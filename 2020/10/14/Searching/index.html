<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dejavi-19.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="SearchingBFS 广度优先搜索一层一层地进行遍历，每层遍历都是以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。 需要注意的是，遍历过的节点不能再次被遍历。 123456789101112第一层：- 0 -&gt; &amp;#123;6,2,1,5&amp;#125;第二层：- 6 -&gt; &amp;#123;4&amp;#125;- 2 -&gt; &amp;#123;&amp;#125;- 1 -&gt; &amp;#123">
<meta property="og:type" content="article">
<meta property="og:title" content="Searching">
<meta property="og:url" content="https://dejavi-19.github.io/2020/10/14/Searching/index.html">
<meta property="og:site_name" content="Dejavu&#39;s Notebook">
<meta property="og:description" content="SearchingBFS 广度优先搜索一层一层地进行遍历，每层遍历都是以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。 需要注意的是，遍历过的节点不能再次被遍历。 123456789101112第一层：- 0 -&gt; &amp;#123;6,2,1,5&amp;#125;第二层：- 6 -&gt; &amp;#123;4&amp;#125;- 2 -&gt; &amp;#123;&amp;#125;- 1 -&gt; &amp;#123">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://camo.githubusercontent.com/17135f6479126d3322eb4c81746c7b7693f8f34b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39353930333837382d373235622d346564392d626465642d6263346161653037393261392e6a7067">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/02/16/oranges.png">
<meta property="og:image" content="https://leetcode.com/problems/word-ladder/Figures/127/Word_Ladder_1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/08/04/example2_2.png">
<meta property="og:image" content="https://assets.leetcode.com/users/lee215/image_1537671763.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/09/01/maze1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg">
<meta property="og:image" content="https://camo.githubusercontent.com/538ca5bd92ad237cc495cafa937f2e324db4be6eecde13e47b25d80cb827c7b7/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30363762333130632d363837372d343066652d396463662d3130363534653733373438352e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/b8607e2983ed40fa3f5f5cbad4d1467dc58fb63fff6835b9a59a4b3d04f639f3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39633432323932332d313434372d346133622d613465312d3937653636333733383138372e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/5b04d1d080eb7ffc776c17f8f5629dbec00b231b9dd7c2ee1d0cb49fa5bb2a98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37613835653238352d653135322d343131362d623664632d3366616232376261393433372e6a7067">
<meta property="og:image" content="https://leetcode.com/problems/valid-sudoku/Figures/36/36_boxes_2.png">
<meta property="og:image" content="https://leetcode.com/problems/sudoku-solver/Figures/37/37_const3.png">
<meta property="og:image" content="https://leetcode.com/problems/sudoku-solver/Figures/37/37_backtrack2.png">
<meta property="og:image" content="https://leetcode.com/problems/sudoku-solver/Figures/36/36_boxes_2.png">
<meta property="article:published_time" content="2020-10-14T10:01:23.312Z">
<meta property="article:modified_time" content="2021-01-28T04:29:41.656Z">
<meta property="article:author" content="Dejavu">
<meta property="article:tag" content="200">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://camo.githubusercontent.com/17135f6479126d3322eb4c81746c7b7693f8f34b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39353930333837382d373235622d346564392d626465642d6263346161653037393261392e6a7067">

<link rel="canonical" href="https://dejavi-19.github.io/2020/10/14/Searching/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Searching | Dejavu's Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/Dejavu-19" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dejavu's Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Alea iacta est</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首&emsp;&emsp;页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于博主</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标&emsp;&emsp;签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分&emsp;&emsp;类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归&emsp;&emsp;档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/10/14/Searching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Searching
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 19:01:23" itemprop="dateCreated datePublished" datetime="2020-10-14T19:01:23+09:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-28 13:29:41" itemprop="dateModified" datetime="2021-01-28T13:29:41+09:00">2021-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h1><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p><img src="https://camo.githubusercontent.com/17135f6479126d3322eb4c81746c7b7693f8f34b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39353930333837382d373235622d346564392d626465642d6263346161653037393261392e6a7067" alt=""></p>
<p>广度优先搜索一层一层地进行遍历，每层遍历都是以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。</p>
<p>需要注意的是，遍历过的节点不能再次被遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一层：</span><br><span class="line">- <span class="number">0</span> -&gt; &#123;<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">第二层：</span><br><span class="line">- <span class="number">6</span> -&gt; &#123;<span class="number">4</span>&#125;</span><br><span class="line">- <span class="number">2</span> -&gt; &#123;&#125;</span><br><span class="line">- <span class="number">1</span> -&gt; &#123;&#125;</span><br><span class="line">- <span class="number">5</span> -&gt; &#123;<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">第三层：</span><br><span class="line">- <span class="number">4</span> -&gt; &#123;&#125;</span><br><span class="line">- <span class="number">3</span> -&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>每一层遍历的节点都与根节点距离相同。设 di 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 di &lt;= dj。</p>
<p>利用这个结论，可以求解最短路径等 <strong>最优解</strong> 问题：第一次遍历到目的节点，其所经过的路径为最短路径。</p>
<p>应该注意的是，使用 BFS 只能求解无权图的最短路径，无权图是指从一个节点到另一个节点的代价都记为 1。</p>
<p>在程序实现 BFS 时需要考虑以下问题：</p>
<ul>
<li>队列：用来存储每一轮遍历得到的节点；</li>
<li>标记：对于遍历过的节点，应该将它标记，防止重复遍历。</li>
</ul>
<h2 id="547-Number-of-Provinces⭐"><a href="#547-Number-of-Provinces⭐" class="headerlink" title="547. Number of Provinces⭐"></a><a href="https://leetcode.com/problems/number-of-provinces/" target="_blank" rel="noopener">547. Number of Provinces⭐</a></h2><p>There are <code>n</code> cities. Some of them are connected, while some are not. If city <code>a</code> is connected directly with city <code>b</code>, and city <code>b</code> is connected directly with city <code>c</code>, then city <code>a</code> is connected indirectly with city <code>c</code>.</p>
<p>A <strong>province</strong> is a group of directly or indirectly connected cities and no other cities outside of the group.</p>
<p>You are given an <code>n x n</code> matrix <code>isConnected</code> where <code>isConnected[i][j] = 1</code> if the <code>ith</code> city and the <code>jth</code> city are directly connected, and <code>isConnected[i][j] = 0</code> otherwise.</p>
<p>Return <em>the total number of *</em>provinces***.</p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: isConnected = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = isConnected.length;</span><br><span class="line">    <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(i, visited, isConnected);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] visited, <span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//find all connection and mark it has been visited(include itselt)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; isConnected.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            visited[j] = -<span class="number">1</span>;</span><br><span class="line">            dfs(j, visited, isConnected);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[isConnected.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isConnected.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            dfs(i, visited, isConnected);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> city, <span class="keyword">int</span>[] visited, <span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    visited[city] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isConnected.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; isConnected[i][city] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(i, visited, isConnected);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Union Find</li>
<li>This is a typical <code>Union Find</code> problem - a similar problem is <a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="noopener">Graph Valid Tree</a><br>A bit advanced Union Find problems are <a href="https://leetcode.com/problems/number-of-islands-ii/#/description" target="_blank" rel="noopener">Number of Islands II</a> and <a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/#/description" target="_blank" rel="noopener">Number of Connected Components</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = M.length, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] root = <span class="keyword">new</span> <span class="keyword">int</span>[m]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) root[i] = i; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) unionFind(root, i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">if</span> (i == root[i]) cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionFind</span> <span class="params">(<span class="keyword">int</span>[] root, <span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root[v1] != v1) v1 = root[v1]; <span class="comment">//find v1's root</span></span><br><span class="line">    <span class="keyword">while</span> (root[v2] != v2) v2 = root[v2]; <span class="comment">//find v2's root</span></span><br><span class="line">    <span class="keyword">if</span> (root[v1] != root[v2]) root[v2] = v1; <span class="comment">//unite the 2 subtrees </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent, rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">            parent[p] = parent[parent[p]];    <span class="comment">// path compression by halving</span></span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[rootQ] &gt; rank[rootP]) &#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootP] == rank[rootQ]) &#123;</span><br><span class="line">                rank[rootP]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = M.length;</span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) uf.union(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uf.count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Old-version-547-Friend-Circles"><a href="#Old-version-547-Friend-Circles" class="headerlink" title="Old version 547. Friend Circles"></a>Old version 547. Friend Circles</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Explanation:The <span class="number">0</span>th and <span class="number">1</span>st students are direct friends, so they are in a friend circle.</span><br><span class="line">The <span class="number">2</span>nd student himself is in a friend circle. So <span class="keyword">return</span> <span class="number">2</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>题目描述：好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，那么 M[0] [1] 和 M[1] [0] 的值都为 1。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    n = M.length;</span><br><span class="line">    <span class="keyword">int</span> circleNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasVisited[i]) &#123;</span><br><span class="line">            dfs(M, i, hasVisited);</span><br><span class="line">            circleNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> circleNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> i, <span class="keyword">boolean</span>[] hasVisited)</span> </span>&#123;</span><br><span class="line">    hasVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (M[i][k] == <span class="number">1</span> &amp;&amp; !hasVisited[k]) &#123;</span><br><span class="line">            dfs(M, k, hasVisited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rotting-Oranges⭐"><a href="#Rotting-Oranges⭐" class="headerlink" title="Rotting Oranges⭐"></a><a href="https://leetcode.com/problems/rotting-oranges/" target="_blank" rel="noopener">Rotting Oranges⭐</a></h2><p><img src="https://assets.leetcode.com/uploads/2019/02/16/oranges.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>One of the most distinguished code patterns in BFS algorithms is that often we use a <strong><em>queue</em></strong> data structure to keep track of the candidates that we need to visit during the process.</p>
<p>The main algorithm is built around a loop iterating through the queue. At each iteration, we <em>pop</em> out an element from the head of the queue. Then we do some particular process with the popped element. More importantly, we then <em>append</em> neighbors of the popped element into the queue, to keep the BFS process running.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minutes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fresh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = grid.length;</span><br><span class="line">    <span class="keyword">int</span> c = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Put the position of all rotten oranges in queue, count the number of fresh oranges</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) fresh++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//edge case, if count of fresh oranges is zero --&gt; return 0 </span></span><br><span class="line">    <span class="keyword">if</span> (fresh == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//bfs starting from initially rotten oranges</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextR = cur[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nextC = cur[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nextR &lt; <span class="number">0</span> || nextR &gt;= r || nextC &lt; <span class="number">0</span> || nextC &gt;= c || grid[nextR][nextC] != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//mark the orange at (x , y) as rotten</span></span><br><span class="line">                grid[nextR][nextC] = <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//decrease the count of fresh oranges by 1</span></span><br><span class="line">                fresh--;</span><br><span class="line">                <span class="comment">//put the new rotten orange at (x , y) in queue</span></span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nextR, nextC&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        minutes++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//node result is minute - 1</span></span><br><span class="line">    <span class="keyword">return</span> fresh == <span class="number">0</span> ? minutes - <span class="number">1</span> : -<span class="number">1</span>;  <span class="comment">//last step do not increase minutes so -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="127-Word-Ladder⭐💜"><a href="#127-Word-Ladder⭐💜" class="headerlink" title="127. Word Ladder⭐💜"></a><a href="https://leetcode.com/problems/word-ladder/description/" target="_blank" rel="noopener">127. Word Ladder⭐💜</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = <span class="string">"hit"</span>,</span><br><span class="line">endWord = <span class="string">"cog"</span>,</span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is <span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span>,</span><br><span class="line"><span class="keyword">return</span> its length <span class="number">5</span>.</span><br><span class="line">    </span><br><span class="line">Input:</span><br><span class="line">beginWord = <span class="string">"hit"</span></span><br><span class="line">endWord = <span class="string">"cog"</span></span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Explanation: The endWord <span class="string">"cog"</span> is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>

<p><img src="https://leetcode.com/problems/word-ladder/Figures/127/Word_Ladder_1.png" alt=""></p>
<p>题目描述：找出一条从 beginWord 到 endWord 的最短路径，每次移动规定为改变一个字符，并且改变之后的字符串必须在 wordList 中。</p>
<h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>思路：BFS（广度优先搜索）因为只要找最短的可能，所以每次只找下一层的所有可能，再一层层递进，直到 找到。和广度优先遍历类似，使用一个 Set 缓存下一层可能的词，然后到下一层逐一试。</p>
</li>
<li><p>Time Complexity: O<em>(</em>M^2×N), where Mis the length of each word and N is the total number of words in the input word list.</p>
<p>pace Complexity: O<em>(</em>M^2×N).</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginWord.equals(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">1</span>;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(beginWord);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] current = queue.poll().toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; current.length; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> pre = current[j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                    current[j] = c;</span><br><span class="line">                    <span class="comment">//char[] -&gt; Stirng : use new String(chars) | String.valueOf(chars)</span></span><br><span class="line">                    String next = <span class="keyword">new</span> String(current);</span><br><span class="line">                    <span class="comment">//when the changed word contained in the wordlist</span></span><br><span class="line">                    <span class="keyword">if</span> (set.contains(next)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (next.equals(endWord)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> steps + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        set.remove(next);</span><br><span class="line">                        queue.add(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//undo the change for next position character</span></span><br><span class="line">                current[j] = pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-126-Word-Ladder-II⭐"><a href="#Unsolved-126-Word-Ladder-II⭐" class="headerlink" title="Unsolved 126. Word Ladder II⭐"></a><a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank" rel="noopener">Unsolved 126. Word Ladder II⭐</a></h3><h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>The basic idea is:</p>
<p>1). Use BFS to find the shortest distance between start and end, tracing the distance of crossing nodes from start node to end node, and store node’s next level neighbors to HashMap;</p>
<p>2). Use DFS to output paths with the same distance as the shortest distance from distance HashMap: compare if the distance of the next level node equals the distance of the current node + 1.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, List&lt;String&gt; wordList) &#123;</span><br><span class="line">    HashSet&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;String&gt;(wordList);</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();         </span><br><span class="line">    HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt;();<span class="comment">// Neighbors for every node</span></span><br><span class="line">    HashMap&lt;String, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();<span class="comment">// Distance of every node from the start node</span></span><br><span class="line">    ArrayList&lt;String&gt; solution = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    dict.add(start);          </span><br><span class="line">    bfs(start, end, dict, nodeNeighbors, distance);                 </span><br><span class="line">    dfs(start, end, dict, nodeNeighbors, distance, solution, res);   </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS: Trace every node's distance from the start node (level by level).</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String start, </span></span></span><br><span class="line"><span class="function"><span class="params">                 String end, </span></span></span><br><span class="line"><span class="function"><span class="params">                 Set&lt;String&gt; dict, </span></span></span><br><span class="line"><span class="function"><span class="params">                 HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors, </span></span></span><br><span class="line"><span class="function"><span class="params">                 HashMap&lt;String, Integer&gt; distance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String str : dict)</span><br><span class="line">        nodeNeighbors.put(str, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    queue.offer(start);</span><br><span class="line">    distance.put(start, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = queue.size();</span><br><span class="line">        <span class="keyword">boolean</span> foundEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> curDistance = distance.get(cur);                </span><br><span class="line">            ArrayList&lt;String&gt; neighbors = getNeighbors(cur, dict);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">                nodeNeighbors.get(cur).add(neighbor);</span><br><span class="line">                <span class="keyword">if</span> (!distance.containsKey(neighbor)) &#123;<span class="comment">// Check if visited</span></span><br><span class="line">                    distance.put(neighbor, curDistance + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (end.equals(neighbor))<span class="comment">// Found the shortest path</span></span><br><span class="line">                        foundEnd = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (foundEnd)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all next level nodes.    </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String node, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">char</span> chs[] = node.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch =<span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chs[i] == ch) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">char</span> old_ch = chs[i];</span><br><span class="line">            chs[i] = ch;</span><br><span class="line">            <span class="keyword">if</span> (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">                res.add(String.valueOf(chs));</span><br><span class="line">            &#125;</span><br><span class="line">            chs[i] = old_ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS: output all paths with the shortest distance.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String cur, String end, Set&lt;String&gt; dict, HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors, HashMap&lt;String, Integer&gt; distance, ArrayList&lt;String&gt; solution, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">    solution.add(cur);</span><br><span class="line">    <span class="keyword">if</span> (end.equals(cur)) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(solution));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String next : nodeNeighbors.get(cur)) &#123;            </span><br><span class="line">            <span class="keyword">if</span> (distance.get(next) == distance.get(cur) + <span class="number">1</span>) &#123;</span><br><span class="line">                dfs(next, end, dict, nodeNeighbors, distance, solution, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;           </span><br><span class="line">    solution.remove(solution.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * High level design: BFS + DFS</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Step 1: use BFS to build graph (adjacency list of each word), as well as calculating distance from beginWord to </span></span><br><span class="line"><span class="comment"> * each node in the graph (should store minimum distance)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Step 2: use DFS to traverse and record path from beginWord to endWord with shortest path. We can use distance map</span></span><br><span class="line"><span class="comment"> * to control every next word. </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (wordList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result: result list to store final return list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph: adjacency list of key - store all neighbors of each word (neighbor means all words in dictionary </span></span><br><span class="line"><span class="comment">     *             that only has one character difference with key)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> distance: distance between beginWord and current key word, used for tracing path when we do DFS</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dict: word dictionary, efficient for searching purpose</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line"></span><br><span class="line">    bfs(beginWord, endWord, dict, graph, distance);</span><br><span class="line">    dfs(result, graph, distance, endWord, beginWord, <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(beginWord)));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String beginWord, String endWord, Set&lt;String&gt; dict, Map&lt;String, Set&lt;String&gt;&gt; graph, Map&lt;String, Integer&gt; distance)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(beginWord);</span><br><span class="line">    distance.put(beginWord, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> reachEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            String curWord = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* try all possible substitution (26 characters) in every position of current word, if newWord exists in dictionary, </span></span><br><span class="line"><span class="comment">               we add it to the adjacency list of curWord */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curWord.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] curWordArr = curWord.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                    curWordArr[j] = c;</span><br><span class="line">                    String newWord = <span class="keyword">new</span> String(curWordArr);</span><br><span class="line">                    <span class="keyword">if</span> (dict.contains(newWord)) &#123;</span><br><span class="line">                        graph.putIfAbsent(curWord, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                        graph.get(curWord).add(newWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// traverse all neighbors of current word, update distance map and queue for next ladder (level)</span></span><br><span class="line">            <span class="comment">// WARNING: DO NOT USE visited set, since it is hard to deal with end word if endWord is visited</span></span><br><span class="line">            <span class="keyword">for</span> (String neighbor : graph.get(curWord)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!distance.containsKey(neighbor)) &#123;</span><br><span class="line">                    distance.put(neighbor, distance.get(curWord) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (neighbor.equals(endWord)) &#123;</span><br><span class="line">                        reachEnd = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        queue.offer(neighbor);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reachEnd) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;String&gt;&gt; result, Map&lt;String, Set&lt;String&gt;&gt; graph, Map&lt;String, Integer&gt; distance,</span></span></span><br><span class="line"><span class="function"><span class="params">                String endWord, String curWord, List&lt;String&gt; tempList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curWord.equals(endWord)) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String nextWord : graph.get(curWord)) &#123;</span><br><span class="line">        <span class="comment">// only if next node is on the minimum path to the endWord, we can traverse it</span></span><br><span class="line">        <span class="keyword">if</span> (distance.get(nextWord) == distance.get(curWord) + <span class="number">1</span>) &#123;</span><br><span class="line">            tempList.add(nextWord);</span><br><span class="line">            dfs(result, graph, distance, endWord, nextWord, tempList);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="675-Cut-Off-Trees-for-Golf-Event⭐"><a href="#675-Cut-Off-Trees-for-Golf-Event⭐" class="headerlink" title="675. Cut Off Trees for Golf Event⭐"></a><a href="https://leetcode.com/problems/cut-off-trees-for-golf-event/" target="_blank" rel="noopener">675. Cut Off Trees for Golf Event⭐</a></h2><p><img src="https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: forest = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: Following the path above allows you to cut off the trees from shortest to tallest in <span class="number">6</span> steps.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: forest = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br><span class="line">Output: -<span class="number">1</span></span><br><span class="line">Explanation: The trees in the bottom row cannot be accessed as the middle row is blocked.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Since we have to cut trees in order of their height, we first put trees (int[] {row, col, height}) into a priority queue and sort by height.</li>
<li>Poll each tree from the queue and use BFS to find out steps needed.</li>
<li>The worst case time complexity could be O(m^2 * n^2) (m = number of rows, n = number of columns) since there are m * n trees and for each BFS worst case time complexity is O(m * n) too.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] dir = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (forest == <span class="keyword">null</span> || forest.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = forest.size(), n = forest.get(<span class="number">0</span>).size();</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (forest.get(i).get(j) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j, forest.get(i).get(j)&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] tree = pq.poll();</span><br><span class="line">        <span class="keyword">int</span> step = minStep(forest, start, tree, m, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (step &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        sum += step;</span><br><span class="line"></span><br><span class="line">        start[<span class="number">0</span>] = tree[<span class="number">0</span>];</span><br><span class="line">        start[<span class="number">1</span>] = tree[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minStep</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] tree, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(start);</span><br><span class="line">    visited[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (curr[<span class="number">0</span>] == tree[<span class="number">0</span>] &amp;&amp; curr[<span class="number">1</span>] == tree[<span class="number">1</span>]) <span class="keyword">return</span> step;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dir) &#123;</span><br><span class="line">                <span class="keyword">int</span> nr = curr[<span class="number">0</span>] + d[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nc = curr[<span class="number">1</span>] + d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nr &gt;= m || nc &lt; <span class="number">0</span> || nc &gt;= n </span><br><span class="line">                    || forest.get(nr).get(nc) == <span class="number">0</span> || visited[nr][nc]) <span class="keyword">continue</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nr, nc&#125;);</span><br><span class="line">                visited[nr][nc] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> tr, <span class="keyword">int</span> tc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R = forest.size(), C = forest.get(<span class="number">0</span>).size();</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr, sc, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line">    seen[sr][sc] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (cur[<span class="number">0</span>] == tr &amp;&amp; cur[<span class="number">1</span>] == tc) <span class="keyword">return</span> cur[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">0</span>; di &lt; <span class="number">4</span>; ++di) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = cur[<span class="number">0</span>] + dr[di];</span><br><span class="line">            <span class="keyword">int</span> c = cur[<span class="number">1</span>] + dc[di];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= r &amp;&amp; r &lt; R &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; C &amp;&amp;</span><br><span class="line">                    !seen[r][c] &amp;&amp; forest.get(r).get(c) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                seen[r][c] = <span class="keyword">true</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c, cur[<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1091-Shortest-Path-in-Binary-Matrix🎂⭐"><a href="#1091-Shortest-Path-in-Binary-Matrix🎂⭐" class="headerlink" title="1091. Shortest Path in Binary Matrix🎂⭐"></a><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">1091. Shortest Path in Binary Matrix🎂⭐</a></h2><p><img src="https://assets.leetcode.com/uploads/2019/08/04/example2_2.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p>In an N by N square grid, each cell is either empty (0) or blocked (1).</p>
<p>A <em>clear path from top-left to bottom-right</em> has length <code>k</code> if and only if it is composed of cells <code>C_1, C_2, ..., C_k</code> such that:</p>
<ul>
<li>Adjacent cells <code>C_i</code> and <code>C_{i+1}</code> are connected 8-directionally (ie., they are different and share an edge or corner)</li>
<li><code>C_1</code> is at location <code>(0, 0)</code> (ie. has value <code>grid[0][0]</code>)</li>
<li><code>C_k</code> is at location <code>(N-1, N-1)</code> (ie. has value <code>grid[N-1][N-1]</code>)</li>
<li>If <code>C_i</code> is located at <code>(r, c)</code>, then <code>grid[r][c]</code> is empty (ie. <code>grid[r][c] == 0</code>).</li>
</ul>
<p>Return the length of the shortest such clear path from top-left to bottom-right. If such a path does not exist, return -1.</p>
<h3 id="Solition1"><a href="#Solition1" class="headerlink" title="Solition1:"></a>Solition1:</h3><ol>
<li>题目描述：0 表示可以经过某个位置，求解从左上角到右下角的最短路径长度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//edge case</span></span><br><span class="line">    <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || grid[m-<span class="number">1</span>][n-<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] pop = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (pop[<span class="number">0</span>] == m-<span class="number">1</span> &amp;&amp; pop[<span class="number">1</span>] == n-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextX = d[<span class="number">0</span>] + pop[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nextY = d[<span class="number">1</span>] + pop[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nextX &gt;= <span class="number">0</span> &amp;&amp; nextX &lt; m &amp;&amp; nextY &gt;= <span class="number">0</span> &amp;&amp; nextY &lt; n &amp;&amp; !visited[nextX][nextY] &amp;&amp; grid[nextX][nextY] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nextX,nextY&#125;);</span><br><span class="line">                    visited[nextX][nextY] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="279-Perfect-Squares✨"><a href="#279-Perfect-Squares✨" class="headerlink" title="279.Perfect Squares✨"></a><a href="https://leetcode.com/problems/perfect-squares/description/" target="_blank" rel="noopener">279.Perfect Squares✨</a></h2><p>For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>
<p><a href="https://leetcode.com/problems/perfect-squares/discuss/71488/Summary-of-4-different-solutions-(BFS-DP-static-DP-and-mathematics)" target="_blank" rel="noopener">Summary of 4 different solutions (BFS, DP, static DP and mathematics)</a></p>
<h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。</p>
<p>要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。</p>
<p>本题也可以用动态规划求解，在之后动态规划部分中会再次出现。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    q.offer(<span class="number">0</span>);</span><br><span class="line">    visited.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i*i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = u+i*i;</span><br><span class="line">                <span class="keyword">if</span>(v == n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(v &gt; n) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(v)) &#123;</span><br><span class="line">                    q.offer(v);</span><br><span class="line">                    visited.add(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：动态规划。寻找 dp[i]最小的可能性，只要寻找 i 减去平方为 j 及以下的所有可能平方数（i-j*j）的可能性+1 中最小的值。O(n2 )</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j*j &lt;= i; ++j)</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i-j*j] + <span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="909-Snakes-and-Ladders🎂✨"><a href="#909-Snakes-and-Ladders🎂✨" class="headerlink" title="909. Snakes and Ladders🎂✨"></a><a href="https://leetcode.com/problems/snakes-and-ladders/" target="_blank" rel="noopener">909. Snakes and Ladders🎂✨</a></h2><p><img src="https://assets.leetcode.com/users/lee215/image_1537671763.png" alt=""></p>
<h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.length;</span><br><span class="line">    <span class="comment">// convert 2D array to 1D to make processing more easier</span></span><br><span class="line">    <span class="keyword">int</span>[] flatten = convert2DTo1D(board);</span><br><span class="line">    <span class="keyword">int</span> targetIdx = n * n - <span class="number">1</span>; <span class="comment">// target index to try to reach</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();  <span class="comment">// queue for BFS</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n * n]; <span class="comment">// keep track of which node has been visited</span></span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>; <span class="comment">// keep track of number of steps (levels) we have gone in BFS</span></span><br><span class="line">    <span class="comment">// add starting node (number 1, index 0) to the queue and start BFS</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = flatten[<span class="number">0</span>] == -<span class="number">1</span> ? <span class="number">0</span> : flatten[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">    queue.offer(start);</span><br><span class="line">    visited[start] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// BFS:</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> currIdx = queue.poll();</span><br><span class="line">            <span class="comment">// in case the current index is the index we are looking for</span></span><br><span class="line">            <span class="comment">// return the number of moves used to get there</span></span><br><span class="line">            <span class="keyword">if</span> (currIdx == targetIdx) <span class="keyword">return</span> steps;</span><br><span class="line">            <span class="comment">// consider all numbers from +1 to +6, note that don't go out of bound</span></span><br><span class="line">            <span class="keyword">int</span> upper = Math.min(targetIdx, currIdx + <span class="number">6</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> nextIdx = currIdx + <span class="number">1</span>; nextIdx &lt;= upper; nextIdx++) &#123;</span><br><span class="line">                <span class="comment">// check if the nextIdx is a snake/ladder</span></span><br><span class="line">                <span class="keyword">int</span> dest = flatten[nextIdx] == -<span class="number">1</span> ? nextIdx : flatten[nextIdx] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// in case the next index is already explored, skip it</span></span><br><span class="line">                <span class="keyword">if</span> (visited[dest]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// add next index into the queue and mark it as visited</span></span><br><span class="line">                queue.offer(dest);</span><br><span class="line">                visited[dest] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] convert2DTo1D(<span class="keyword">int</span>[][] board) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.length;</span><br><span class="line">    <span class="comment">// 1D array whose size is n^2</span></span><br><span class="line">    <span class="keyword">int</span>[] rst = <span class="keyword">new</span> <span class="keyword">int</span>[n * n];</span><br><span class="line">    <span class="keyword">boolean</span> leftToRight = <span class="keyword">true</span>; <span class="comment">// order to traverse columns in each row</span></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start from the bottom row of 2D array, initially going from left to right</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// if we need to read columns from left to right</span></span><br><span class="line">            <span class="keyword">if</span> (leftToRight) &#123;</span><br><span class="line">                rst[idx++] = board[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// if we need to read columns from right to left</span></span><br><span class="line">                rst[idx++] = board[i][n - <span class="number">1</span> - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// after processing each row, switch the order</span></span><br><span class="line">        leftToRight = !leftToRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = board.length;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Integer&gt; dist = <span class="keyword">new</span> HashMap();</span><br><span class="line">    dist.put(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = queue.remove();</span><br><span class="line">        <span class="keyword">if</span> (s == N*N) <span class="keyword">return</span> dist.get(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s2 = s+<span class="number">1</span>; s2 &lt;= Math.min(s+<span class="number">6</span>, N*N); ++s2) &#123;</span><br><span class="line">            <span class="keyword">int</span> rc = get(s2, N);</span><br><span class="line">            <span class="keyword">int</span> r = rc / N, c = rc % N;</span><br><span class="line">            <span class="keyword">int</span> s2Final = board[r][c] == -<span class="number">1</span> ? s2 : board[r][c];</span><br><span class="line">            <span class="keyword">if</span> (!dist.containsKey(s2Final)) &#123;</span><br><span class="line">                dist.put(s2Final, dist.get(s) + <span class="number">1</span>);</span><br><span class="line">                queue.add(s2Final);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Given a square num s, return board coordinates (r, c) as r*N + c</span></span><br><span class="line">    <span class="keyword">int</span> quot = (s-<span class="number">1</span>) / N;</span><br><span class="line">    <span class="keyword">int</span> rem = (s-<span class="number">1</span>) % N;</span><br><span class="line">    <span class="keyword">int</span> row = N - <span class="number">1</span> - quot;</span><br><span class="line">    <span class="keyword">int</span> col = row % <span class="number">2</span> != N % <span class="number">2</span> ? rem : N - <span class="number">1</span> - rem;</span><br><span class="line">    <span class="keyword">return</span> row * N + col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="752-Open-the-Lock✨"><a href="#752-Open-the-Lock✨" class="headerlink" title="752. Open the Lock✨"></a><a href="https://leetcode.com/problems/open-the-lock/" target="_blank" rel="noopener">752. Open the Lock✨</a></h2><h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Breadth-First Search</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(deadends));</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    q.offer(<span class="string">"0000"</span>);</span><br><span class="line">    visited.add(<span class="string">"0000"</span>);</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">            String s = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(deads.contains(s)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(target)) <span class="keyword">return</span> level;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = sb.charAt(i);</span><br><span class="line">                String s1 = sb.substring(<span class="number">0</span>, i) + (c == <span class="string">'9'</span> ? <span class="number">0</span> : c - <span class="string">'0'</span> + <span class="number">1</span>) + sb.substring(i + <span class="number">1</span>);</span><br><span class="line">                String s2 = sb.substring(<span class="number">0</span>, i) + (c == <span class="string">'0'</span> ? <span class="number">9</span> : c - <span class="string">'0'</span> - <span class="number">1</span>) + sb.substring(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(s1) &amp;&amp; !deads.contains(s1)) &#123;</span><br><span class="line">                    q.offer(s1);</span><br><span class="line">                    visited.add(s1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(s2) &amp;&amp; !deads.contains(s2)) &#123;</span><br><span class="line">                    q.offer(s2);</span><br><span class="line">                    visited.add(s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        level ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS</li>
<li>优化：把dead加到visited里</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">plusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (ch[j] == <span class="string">'9'</span>)</span><br><span class="line">        ch[j] = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ch[j] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (ch[j] == <span class="string">'0'</span>)</span><br><span class="line">        ch[j] = <span class="string">'9'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ch[j] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; dead = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String deadend : deadends) &#123;</span><br><span class="line">        dead.add(deadend);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    queue.offer(<span class="string">"0000"</span>);</span><br><span class="line">    visited.add(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            String cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (dead.contains(cur))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.equals(target))</span><br><span class="line">                <span class="keyword">return</span> steps;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(up)) &#123;</span><br><span class="line">                    queue.offer(up);</span><br><span class="line">                    visited.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(down)) &#123;</span><br><span class="line">                    queue.offer(down);</span><br><span class="line">                    visited.add(down);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="490-The-Maze✨"><a href="#490-The-Maze✨" class="headerlink" title="490. The Maze✨"></a><a href="https://leetcode.com/problems/the-maze/" target="_blank" rel="noopener">490. The Maze✨</a></h2><p><img src="https://assets.leetcode.com/uploads/2020/09/01/maze1.png" alt=""></p>
<h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[maze.length][maze[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    Queue &lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList &lt; &gt; ();</span><br><span class="line">    queue.add(start);</span><br><span class="line">    visited[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] s = queue.remove();</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; s[<span class="number">1</span>] == destination[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir: dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = s[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = s[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; maze.length &amp;&amp; y &lt; maze[<span class="number">0</span>].length &amp;&amp; maze[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                x += dir[<span class="number">0</span>];</span><br><span class="line">                y += dir[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!visited[x - dir[<span class="number">0</span>]][y - dir[<span class="number">1</span>]]) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;x - dir[<span class="number">0</span>], y - dir[<span class="number">1</span>]&#125;);</span><br><span class="line">                visited[x - dir[<span class="number">0</span>]][y - dir[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dir = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[maze.length][maze[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">return</span> dfs(maze, visited, start, destination);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span>[] c, <span class="keyword">int</span>[] des)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[c[<span class="number">0</span>]][c[<span class="number">1</span>]]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c[<span class="number">0</span>] == des[<span class="number">0</span>] &amp;&amp; c[<span class="number">1</span>] == des[<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    visited[c[<span class="number">0</span>]][c[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dir) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = c[<span class="number">0</span>] + d[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = c[<span class="number">1</span>] + d[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">0</span> &lt;= x &amp;&amp; x &lt; maze.length &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; maze[<span class="number">0</span>].length &amp;&amp; maze[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">            x += d[<span class="number">0</span>];</span><br><span class="line">            y += d[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        result = result || dfs(maze, visited, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; x - d[<span class="number">0</span>], y - d[<span class="number">1</span>]&#125;, des);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="773-Sliding-Puzzle🎂"><a href="#773-Sliding-Puzzle🎂" class="headerlink" title="773. Sliding Puzzle🎂"></a><a href="https://leetcode.com/problems/sliding-puzzle/" target="_blank" rel="noopener">773. Sliding Puzzle🎂</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> --&gt; <span class="number">0</span> can go to &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> --&gt; <span class="number">0</span> can go to index of &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> --&gt; <span class="number">0</span> can go to &#123;<span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span> <span class="number">5</span> --&gt; <span class="number">0</span> can go to &#123;<span class="number">0</span>,<span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">0</span> <span class="number">5</span> --&gt; <span class="number">0</span> can go to &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">0</span> --&gt; <span class="number">0</span> can go to &#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Algorithm:</p>
<p>Consider each state in the board as a graph node, we just need to find out the min distance between start node and final target node “123450”. </p>
<p>Since it’s a single point to single point questions, Dijkstra is not needed here. We can simply use BFS, and also count the level we passed. Every time we swap 0 position in the String to find the next state. Use a hashTable to store the visited states.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//initail varaibles</span></span><br><span class="line">    <span class="keyword">int</span> rows = board.length;</span><br><span class="line">    <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line">    String goal = <span class="string">"123450"</span>;</span><br><span class="line">    String start = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            start += board[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bfs</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            String s = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (s == start) &#123;</span><br><span class="line">                <span class="keyword">return</span> steps;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pos = s.indexOf(<span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">int</span> x = pos % cols;</span><br><span class="line">            <span class="keyword">int</span> y = pos / cols;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] d : directions) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextX = x + d[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nextY = y + d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nextX &lt; <span class="number">0</span> || nextX &gt;= cols || nextY &lt; <span class="number">0</span> || nextY &gt;= rows) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> nextPos = nextY * cols + nextX;</span><br><span class="line">                String newS = swap(s, pos, nextPos);</span><br><span class="line">                <span class="keyword">if</span> (visited.contains(newS)) <span class="keyword">continue</span>;</span><br><span class="line">                visited.add(newS);</span><br><span class="line">                queue.add(newS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">swap</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">    chars[i] = chars[j];</span><br><span class="line">    chars[j] = temp;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/sliding-puzzle/discuss/113620/JavaPython-3-BFS-clean-codes-w-comment-Time-and-space%3A-O(m-*-n-*-(m-*-n)!)." target="_blank" rel="noopener">Explaination</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] d = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;; <span class="comment">//  relative displacements of neighbors in board.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = board.length, width = height == <span class="number">0</span> ? <span class="number">0</span> : board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// convert board to string - initial state.</span></span><br><span class="line">        String s = Arrays.deepToString(board).replaceAll(<span class="string">"\\[|\\]|,|\\s"</span>, <span class="string">""</span>); <span class="comment">// e.g., [[1,2,3],[4,0,5]] -&gt; "123405"</span></span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(s)); <span class="comment">// add initial state to queue.</span></span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;(q); <span class="comment">// used to avoid duplicates</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> steps = <span class="number">0</span>; !q.isEmpty(); ++steps) &#123; <span class="comment">// Not traverse all states yet?</span></span><br><span class="line">            <span class="comment">// loop used to control search breadth.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sz = q.size(); sz &gt; <span class="number">0</span>; --sz) &#123;</span><br><span class="line">                String str = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (str.equals(<span class="string">"123450"</span>)) &#123; <span class="keyword">return</span> steps; &#125; <span class="comment">// found target.</span></span><br><span class="line">                <span class="keyword">int</span> i = str.indexOf(<span class="string">"0"</span>), x = i / width, y = i % width; <span class="comment">// board[x][y] is '0'.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123; <span class="comment">// traverse all options.</span></span><br><span class="line">                    <span class="keyword">int</span> r = x + d[k], c = y + d[k + <span class="number">1</span>]; <span class="comment">// board[r][c] is the neighbor of '0'.</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; height &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; width) &#123;</span><br><span class="line">                        <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">                        ch[i] = ch[r * width + c]; <span class="comment">// r * width + c is the string index of board[r][c].</span></span><br><span class="line">                        ch[r * width + c] = <span class="string">'0'</span>; <span class="comment">// assign '0' to the neighbor of board[x][y].</span></span><br><span class="line">                        s = String.valueOf(ch);</span><br><span class="line">                        <span class="keyword">if</span> (seen.add(s)) q.offer(s); <span class="comment">// if not duplicate, add s to the queue.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Update 1:</p>
<ol>
<li><strong>distance</strong> in the follows changed to <strong>displacement</strong> to avoid confusion:</li>
<li>see after the code.</li>
</ol>
<p>Convert array to string, e.g., [[1,2,3],[4,0,5]] -&gt; “123405”, hence the corresponding potential swap displacements are: -1, 1, -3, 3. Also note, charAt(2) and charAt(3) are not adjacent in original 2 dimensional int array and therefore are not valid swaps.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] d = &#123; <span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">3</span> &#125;; <span class="comment">// potential swap displacements.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// convert board to string - initial state.</span></span><br><span class="line">      String s = Arrays.deepToString(board).replaceAll(<span class="string">"\\[|\\]|,|\\s"</span>, <span class="string">""</span>);</span><br><span class="line">      Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(s)); <span class="comment">// add initial state to queue.</span></span><br><span class="line">      Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;(q); <span class="comment">// used to avoid duplicates</span></span><br><span class="line">      <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// record the # of rounds of Breadth Search</span></span><br><span class="line">      <span class="keyword">while</span> (!q.isEmpty()) &#123; <span class="comment">// Not traverse all states yet?</span></span><br><span class="line">          <span class="comment">// loop used to control search breadth.</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> sz = q.size(); sz &gt; <span class="number">0</span>; --sz) &#123; </span><br><span class="line">              String str = q.poll();</span><br><span class="line">              <span class="keyword">if</span> (str.equals(<span class="string">"123450"</span>)) &#123; <span class="keyword">return</span> ans; &#125; <span class="comment">// found target.</span></span><br><span class="line">              <span class="keyword">int</span> i = str.indexOf(<span class="string">'0'</span>); <span class="comment">// locate '0'</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123; <span class="comment">// traverse all options.</span></span><br><span class="line">                  <span class="keyword">int</span> j = i + d[k]; <span class="comment">// potential swap index.</span></span><br><span class="line">                  <span class="comment">// conditional used to avoid invalid swaps.</span></span><br><span class="line">                  <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt; <span class="number">5</span> || i == <span class="number">2</span> &amp;&amp; j == <span class="number">3</span> || i == <span class="number">3</span> &amp;&amp; j == <span class="number">2</span>) &#123; <span class="keyword">continue</span>; &#125; </span><br><span class="line">                  <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">                  <span class="comment">// swap ch[i] and ch[j]:  ch[i] = ch[j], ch[j] = '0'. Updated per @caowang888's suggestion. </span></span><br><span class="line">                  ch[i] = ch[j];</span><br><span class="line">                  ch[j] = <span class="string">'0'</span>;</span><br><span class="line">                  s = String.valueOf(ch); <span class="comment">// a new candidate state.</span></span><br><span class="line">                  <span class="keyword">if</span> (seen.add(s)) &#123; q.offer(s); &#125; <span class="comment">//Avoid duplicate.</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ++ans; <span class="comment">// finished a round of Breadth Search, plus 1.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Analysis:</strong><br>There are at most 6! permutation of the 6 numbers: 0~5. For each permustion, cost spaceO(6); String.indexOf() and String.equals() cost time O(6). Therefore, space and time both cost 6 * 6! = 4320.<br>Replace the above <code>6</code> with <code>m * n</code>, we have:</p>
<p><strong>Time &amp; space: O(m * n * (m * n)!)</strong>.</p>
<p>Feel free to let me know if you can find a tighter bound.</p>
<h2 id="Unsolved-913-Cat-and-Mouse🎂"><a href="#Unsolved-913-Cat-and-Mouse🎂" class="headerlink" title="Unsolved 913. Cat and Mouse🎂"></a><a href="https://leetcode.com/problems/cat-and-mouse/" target="_blank" rel="noopener">Unsolved 913. Cat and Mouse🎂</a></h2><h2 id="Unsolved-1345-Jump-Game-IV🎂"><a href="#Unsolved-1345-Jump-Game-IV🎂" class="headerlink" title="Unsolved 1345. Jump Game IV🎂"></a><a href="https://leetcode.com/problems/jump-game-iv/?utm_source=AlgoTogether&utm_campaign=6415681024-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_3&utm_medium=email&utm_term=0_38d4e2e3e2-6415681024-231340480" target="_blank" rel="noopener">Unsolved 1345. Jump Game IV🎂</a></h2><h2 id="Unsolved-1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix🎂"><a href="#Unsolved-1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix🎂" class="headerlink" title="Unsolved 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix🎂"></a><a href="https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/?utm_source=AlgoTogether&utm_campaign=6415681024-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_3&utm_medium=email&utm_term=0_38d4e2e3e2-6415681024-231340480" target="_blank" rel="noopener">Unsolved 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix🎂</a></h2><h2 id="Unsolved-1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination🎂✨"><a href="#Unsolved-1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination🎂✨" class="headerlink" title="Unsolved 1293. Shortest Path in a Grid with Obstacles Elimination🎂✨"></a><a href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/?utm_source=AlgoTogether&utm_campaign=6415681024-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_3&utm_medium=email&utm_term=0_38d4e2e3e2-6415681024-231340480" target="_blank" rel="noopener">Unsolved 1293. Shortest Path in a Grid with Obstacles Elimination🎂✨</a></h2><h2 id="Unsolved-310-Minimum-Height-Trees🎂✨"><a href="#Unsolved-310-Minimum-Height-Trees🎂✨" class="headerlink" title="Unsolved 310. Minimum Height Trees🎂✨"></a><a href="https://leetcode.com/problems/minimum-height-trees/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 310. Minimum Height Trees🎂✨</a></h2><h2 id="Unsolved-864-Shortest-Path-to-Get-All-Keys🎂"><a href="#Unsolved-864-Shortest-Path-to-Get-All-Keys🎂" class="headerlink" title="Unsolved 864. Shortest Path to Get All Keys🎂"></a><a href="https://leetcode.com/problems/shortest-path-to-get-all-keys/" target="_blank" rel="noopener">Unsolved 864. Shortest Path to Get All Keys🎂</a></h2><h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>BFS</p>
</li>
<li><p>find out all keys reachable from stanting</p>
<p>use all keys to open the locks</p>
<p>run more BFS to find out more keys<br>…</p>
<p>regular bfs</p>
<pre><code>visited[x] [y]: if (x. y) is reach before</code></pre><p>this bfs</p>
<pre><code>visited [x] [y] [a] [b] [c] [d] [e] [f] if access (x, y) with some of the keys</code></pre><p>visited [startX] [startY] [0] [0] [0] [1] [0] [0]</p>
<p>if run into key: set the index of the key to 1<br>if run into lock: check if we have the key</p>
<ul>
<li>If yes: unlock it &gt; visited[lockX]CLockT]<br>If no: lock-&gt; can not access<br>visited [x] [y]  [1] [1]  [1] [1] [1] [1]<br>status compression<br>visited [x] [y] [mask]<br>visited[startX] [startY] [0]<br>visited[x] [y] [0b111111]</li>
</ul>
</li>
<li><p>Use Bit to represent the keys.</p>
</li>
<li><p>Use <code>State</code> to represent visited states.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keys, i, j;</span><br><span class="line">    State(<span class="keyword">int</span> keys, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">this</span>.keys = keys;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">        <span class="keyword">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPathAllKeys</span><span class="params">(String[] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = -<span class="number">1</span>, y = -<span class="number">1</span>, m = grid.length, n = grid[<span class="number">0</span>].length(), max = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = grid[i].charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'@'</span>) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">                y = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>) &#123;</span><br><span class="line">                max = Math.max(c - <span class="string">'a'</span> + <span class="number">1</span>, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    State start = <span class="keyword">new</span> State(<span class="number">0</span>, x, y);</span><br><span class="line">    Queue&lt;State&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    visited.add(<span class="number">0</span> + <span class="string">" "</span> + x + <span class="string">" "</span> + y);</span><br><span class="line">    q.offer(start);</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            State cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur.keys == (<span class="number">1</span> &lt;&lt; max) - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cur.i + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> j = cur.j + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> keys = cur.keys;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">char</span> c = grid[i].charAt(j);</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="string">'#'</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>) &#123;</span><br><span class="line">                        keys |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'F'</span> &amp;&amp; ((keys &gt;&gt; (c - <span class="string">'A'</span>)) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(keys + <span class="string">" "</span> + i + <span class="string">" "</span> + j)) &#123;</span><br><span class="line">                        visited.add(keys + <span class="string">" "</span> + i + <span class="string">" "</span> + j);</span><br><span class="line">                        q.offer(<span class="keyword">new</span> State(keys, i, j));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="1192-Critical-Connections-in-a-Network⭐"><a href="#1192-Critical-Connections-in-a-Network⭐" class="headerlink" title="1192. Critical Connections in a Network⭐"></a><a href="https://leetcode.com/problems/critical-connections-in-a-network/" target="_blank" rel="noopener">1192. Critical Connections in a Network⭐</a></h2><h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><a href="https://leetcode.com/problems/critical-connections-in-a-network/discuss/382638/DFS-detailed-explanation-O(orEor)-solution" target="_blank" rel="noopener">Explanation</a></li>
<li>思路：找环，环上任何一条边都不是criticalConnections</li>
<li>如何用O(n)找环：<ul>
<li>DFS前向搜索：每个节点最多走一遍，每走一步记录当前步数</li>
<li>DFS探索返回：返回当前节点（间接）接触到非父节点的最小步数的节点</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; criticalConnections(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(connections);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; c : connections) &#123;</span><br><span class="line">        connect(c.get(<span class="number">0</span>), c.get(<span class="number">1</span>), graph);</span><br><span class="line">        connect(c.get(<span class="number">1</span>), c.get(<span class="number">0</span>), graph);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] steps = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(steps, -<span class="number">2</span>);  <span class="comment">//-2 because when traverse the neighbor check the depth-1(parent depth)</span></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, steps, graph, set);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> depth, <span class="keyword">int</span>[] steps, Map&lt;Integer, List&lt;Integer&gt;&gt; graph, Set&lt;List&lt;Integer&gt;&gt; set)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (steps[node] &gt;= <span class="number">0</span>) <span class="keyword">return</span> steps[node];</span><br><span class="line"></span><br><span class="line">    steps[node] = depth;</span><br><span class="line">    <span class="comment">//record current min depth, if is a leave node no neighbor will return this depth value</span></span><br><span class="line">    <span class="keyword">int</span> minDepthFound = depth;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.get(node)) &#123;</span><br><span class="line">        <span class="comment">//skip the parent</span></span><br><span class="line">        <span class="keyword">if</span> (steps[neighbor] == depth - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//recursive dfs to the neighbor branch to get depth</span></span><br><span class="line">        <span class="keyword">int</span> minDepth = dfs(neighbor, depth + <span class="number">1</span>, steps, graph, set);</span><br><span class="line">        minDepthFound = Math.min(minDepthFound, minDepth);</span><br><span class="line">        <span class="comment">//if the neighbor branch depht &lt;= current depth, cycle exist</span></span><br><span class="line">        <span class="keyword">if</span> (minDepth &lt;= depth) &#123;</span><br><span class="line">            set.remove(Arrays.asList(node, neighbor));</span><br><span class="line">            set.remove(Arrays.asList(neighbor, node));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDepthFound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, Map&lt;Integer, List&lt;Integer&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">    graph.putIfAbsent(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    graph.get(i).add(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/critical-connections-in-a-network/discuss/401340/Clean-Java-Solution-With-Explanation!!!-Great-Question!" target="_blank" rel="noopener">Explanation</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; criticalConnections(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; connection : connections) &#123;</span><br><span class="line">        graph[connection.get(<span class="number">0</span>)].add(connection.get(<span class="number">1</span>));</span><br><span class="line">        graph[connection.get(<span class="number">1</span>)].add(connection.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet&lt;List&lt;Integer&gt;&gt; connectionsSet = <span class="keyword">new</span> HashSet&lt;&gt;(connections);</span><br><span class="line">    <span class="keyword">int</span>[] step = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(step, -<span class="number">2</span>);</span><br><span class="line">    dfs(graph, <span class="number">0</span>, <span class="number">0</span>, step, connectionsSet);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(connectionsSet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="keyword">int</span> node, <span class="keyword">int</span> depth, <span class="keyword">int</span>[] step, HashSet&lt;List&lt;Integer&gt;&gt; connectionsSet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case already visited node. return its depth</span></span><br><span class="line">    <span class="keyword">if</span> (step[node] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> step[node];</span><br><span class="line">    &#125;</span><br><span class="line">    step[node] = depth;</span><br><span class="line">    <span class="keyword">int</span> minDepthFound = depth;</span><br><span class="line">    <span class="keyword">for</span> (Integer neighbor : graph[node]) &#123;</span><br><span class="line">        <span class="comment">// skip parent</span></span><br><span class="line">        <span class="keyword">if</span> (step[neighbor] == depth - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> minDepth = dfs(graph, neighbor, depth + <span class="number">1</span>, step, connectionsSet);</span><br><span class="line">        minDepthFound = Math.min(minDepthFound, minDepth);</span><br><span class="line">        <span class="keyword">if</span> (minDepth &lt;= depth) &#123;</span><br><span class="line">            <span class="comment">// to avoid the sorting just try to remove both combinations. of (x,y) and (y,x)</span></span><br><span class="line">            connectionsSet.remove(Arrays.asList(node, neighbor));</span><br><span class="line">            connectionsSet.remove(Arrays.asList(neighbor, node));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDepthFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We record the timestamp that we visit each node. For each node, we check every neighbor except its parent and return a smallest timestamp in all its neighbors. If this timestamp is strictly less than the node's timestamp, we know that this node is somehow in a cycle. Otherwise, this edge from the parent to this node is a critical connection</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; criticalConnections(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(List&lt;Integer&gt; oneConnection :connections) &#123;</span><br><span class="line">        graph[oneConnection.get(<span class="number">0</span>)].add(oneConnection.get(<span class="number">1</span>));</span><br><span class="line">        graph[oneConnection.get(<span class="number">1</span>)].add(oneConnection.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> timer[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">int</span> []timeStampAtThatNode = <span class="keyword">new</span> <span class="keyword">int</span>[n]; </span><br><span class="line">    criticalConnectionsUtil(graph, -<span class="number">1</span>, <span class="number">0</span>, timer, visited, results, timeStampAtThatNode);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">criticalConnectionsUtil</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="keyword">int</span> parent, <span class="keyword">int</span> node, <span class="keyword">int</span> timer[], <span class="keyword">boolean</span>[] visited, List&lt;List&lt;Integer&gt;&gt; results, <span class="keyword">int</span> []timeStampAtThatNode)</span> </span>&#123;</span><br><span class="line">    visited[node] = <span class="keyword">true</span>;</span><br><span class="line">    timeStampAtThatNode[node] = timer[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">int</span> currentTimeStamp = timeStampAtThatNode[node];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> oneNeighbour : graph[node]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(oneNeighbour == parent) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!visited[oneNeighbour]) criticalConnectionsUtil(graph, node, oneNeighbour, timer, visited, results, timeStampAtThatNode);</span><br><span class="line">        timeStampAtThatNode[node] = Math.min(timeStampAtThatNode[node], timeStampAtThatNode[oneNeighbour]);</span><br><span class="line">        <span class="keyword">if</span>(currentTimeStamp &lt; timeStampAtThatNode[oneNeighbour]) results.add(Arrays.asList(node, oneNeighbour));</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-529-Minesweeper⭐"><a href="#Unsolved-529-Minesweeper⭐" class="headerlink" title="Unsolved 529. Minesweeper⭐"></a><a href="https://leetcode.com/problems/minesweeper/" target="_blank" rel="noopener">Unsolved 529. Minesweeper⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">[[<span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>],</span><br><span class="line"> [<span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>],</span><br><span class="line"> [<span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>],</span><br><span class="line"> [<span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>]]</span><br><span class="line"></span><br><span class="line">Click : [<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line"></span><br><span class="line">[[<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'E'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'M'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>]]</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_1.png" alt=""></p>
<h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>dfs</li>
<li>This is a typical <code>Search</code> problem, either by using <code>DFS</code> or <code>BFS</code>. Search rules:<ol>
<li>If click on a mine (‘<code>M</code>‘), mark it as ‘<code>X</code>‘, stop further search.</li>
<li>If click on an empty cell (‘<code>E</code>‘), depends on how many surrounding mine:<br>2.1 Has surrounding mine(s), mark it with number of surrounding mine(s), stop further search.<br>2.2 No surrounding mine, mark it as ‘<code>B</code>‘, continue search its <code>8</code> neighbors.</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">    <span class="keyword">if</span> (board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span> || click.length != <span class="number">2</span>) <span class="keyword">return</span> board;</span><br><span class="line">    <span class="keyword">int</span> r = click[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> c = click[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (board[r][c] == <span class="string">'M'</span>) &#123;</span><br><span class="line">        board[r][c] = <span class="string">'X'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dfs(board, r, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> board;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= board.length || c &lt; <span class="number">0</span> || c &gt;= board[<span class="number">0</span>].length || board[r][c] != <span class="string">'E'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numOfMine = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = r + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = c + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= board.length || y &lt; <span class="number">0</span> || y &gt;= board[<span class="number">0</span>].length) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] == <span class="string">'M'</span>) numOfMine++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numOfMine &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        board[r][c] = (<span class="keyword">char</span>) (numOfMine + <span class="string">'0'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        board[r][c] = <span class="string">'B'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = c + dir[<span class="number">1</span>];</span><br><span class="line">            dfs(board, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> row = click[<span class="number">0</span>], col = click[<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">'M'</span>) &#123; <span class="comment">// Mine</span></span><br><span class="line">            board[row][col] = <span class="string">'X'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// Empty</span></span><br><span class="line">            <span class="comment">// Get number of mines first.</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> r = row + i, c = col + j;</span><br><span class="line">                    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || c &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (board[r][c] == <span class="string">'M'</span> || board[r][c] == <span class="string">'X'</span>) count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">// If it is not a 'B', stop further DFS.</span></span><br><span class="line">                board[row][col] = (<span class="keyword">char</span>)(count + <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Continue DFS to adjacent cells.</span></span><br><span class="line">                board[row][col] = <span class="string">'B'</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">int</span> r = row + i, c = col + j;</span><br><span class="line">                        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || c &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (board[r][c] == <span class="string">'E'</span>) updateBoard(board, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(click);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cell = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> row = cell[<span class="number">0</span>], col = cell[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == <span class="string">'M'</span>) &#123; <span class="comment">// Mine</span></span><br><span class="line">                board[row][col] = <span class="string">'X'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Empty</span></span><br><span class="line">                <span class="comment">// Get number of mines first.</span></span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">int</span> r = row + i, c = col + j;</span><br><span class="line">                        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || c &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (board[r][c] == <span class="string">'M'</span> || board[r][c] == <span class="string">'X'</span>) count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">// If it is not a 'B', stop further BFS.</span></span><br><span class="line">                    board[row][col] = (<span class="keyword">char</span>)(count + <span class="string">'0'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// Continue BFS to adjacent cells.</span></span><br><span class="line">                    board[row][col] = <span class="string">'B'</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">int</span> r = row + i, c = col + j;</span><br><span class="line">                            <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || c &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">if</span> (board[r][c] == <span class="string">'E'</span>) &#123;</span><br><span class="line">                                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c&#125;);</span><br><span class="line">                                board[r][c] = <span class="string">'B'</span>; <span class="comment">// Avoid to be added again.</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-417-Pacific-Atlantic-Water-Flow🎂⭐💎"><a href="#Unsolved-417-Pacific-Atlantic-Water-Flow🎂⭐💎" class="headerlink" title="Unsolved 417. Pacific Atlantic Water Flow🎂⭐💎"></a><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">Unsolved 417. Pacific Atlantic Water Flow🎂⭐💎</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given the following <span class="number">5</span>x5 matrix:</span><br><span class="line"></span><br><span class="line">  Pacific ~   ~   ~   ~   ~</span><br><span class="line">       ~  <span class="number">1</span>   <span class="number">2</span>   <span class="number">2</span>   <span class="number">3</span>  (<span class="number">5</span>) *</span><br><span class="line">       ~  <span class="number">3</span>   <span class="number">2</span>   <span class="number">3</span>  (<span class="number">4</span>) (<span class="number">4</span>) *</span><br><span class="line">       ~  <span class="number">2</span>   <span class="number">4</span>  (<span class="number">5</span>)  <span class="number">3</span>   <span class="number">1</span>  *</span><br><span class="line">       ~ (<span class="number">6</span>) (<span class="number">7</span>)  <span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>  *</span><br><span class="line">       ~ (<span class="number">5</span>)  <span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">4</span>  *</span><br><span class="line">          *   *   *   *   * Atlantic</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[[<span class="number">0</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">4</span>, <span class="number">0</span>]] (positions with parentheses in above matrix).</span><br></pre></td></tr></table></figure>

<ol>
<li>左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。</li>
<li><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/discuss/90733/Java-BFS-and-DFS-from-Ocean" target="_blank" rel="noopener">Explaination</a></li>
</ol>
<h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>DFS 每一个点需要回溯，会变成n^2。</li>
<li>优化，从边dfs二者，然后取交集，没有回溯变成线性O(n)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="comment">//edge case</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">    m = matrix.length;</span><br><span class="line">    n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] canReachP = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">boolean</span>[][] canReachA = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(i, <span class="number">0</span>, canReachP);</span><br><span class="line">        dfs(i, n - <span class="number">1</span>, canReachA);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, j, canReachP);</span><br><span class="line">        dfs(m - <span class="number">1</span>, j, canReachA);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canReachP[i][j] &amp;&amp; canReachA[i][j]) &#123;</span><br><span class="line">                ans.add(Arrays.asList(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] canReach)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (canReach[i][j]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    canReach[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextR = i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> nextC = j + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextR &lt; <span class="number">0</span> || nextR &gt;= m || nextC &lt; <span class="number">0</span> || nextC &gt;= n || matrix[nextR][nextC] &lt; matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(nextR, nextC, canReach);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="200-Number-of-Islands💜⭐"><a href="#200-Number-of-Islands💜⭐" class="headerlink" title="200. Number of Islands💜⭐"></a><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">200. Number of Islands💜⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br><span class="line"></span><br><span class="line">Output: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>可以将矩阵表示看成一张有向图。</p>
<h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>DFS</p>
</li>
<li><p>Time: O(MN). </p>
<p>Space: O(MN). M is the rows, N is the cols.worst case O(M×N) in case that the grid map is filled with lands where DFS goes by M \times N<em>M</em>×<em>N</em> deep.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(i, j, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] != <span class="string">'1'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mark as visited and go through 4 directions</span></span><br><span class="line">    grid[i][j] = <span class="string">' '</span>;</span><br><span class="line">    dfs(i + <span class="number">1</span>, j, grid);</span><br><span class="line">    dfs(i - <span class="number">1</span>, j, grid);</span><br><span class="line">    dfs(i, j + <span class="number">1</span>, grid);</span><br><span class="line">    dfs(i, j - <span class="number">1</span>, grid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check :</span></span><br><span class="line"><span class="comment">if grid == null || gird.length == 0 return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">DFS</span></span><br><span class="line"><span class="comment">need a dfs helper function</span></span><br><span class="line"><span class="comment">Step1: Travsse the whole grid</span></span><br><span class="line"><span class="comment">Step2: When we encounter a land(1), add max varaible by 1, apply dfs which will tarverse cuurent whole island, and mark it has been traversed</span></span><br><span class="line"><span class="comment">Step3: Continue step2 until finish the traverse the grid, finally return max</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Go through Example :</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  ["1","1","1","1","0"],</span></span><br><span class="line"><span class="comment">  ["1","1","0","1","0"],</span></span><br><span class="line"><span class="comment">  ["1","1","0","0","0"],</span></span><br><span class="line"><span class="comment">  ["0","0","0","0","0"]</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">-&gt;</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  ["-1","-1","-1","-1","0"],</span></span><br><span class="line"><span class="comment">  ["-1","-1","0","-1","0"],</span></span><br><span class="line"><span class="comment">  ["-1","-1","0","0","0"],</span></span><br><span class="line"><span class="comment">  ["0","0","0","0","0"]</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">retrun 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(mn)</span></span><br><span class="line"><span class="comment">Space O(mn)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IslandCountBFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumberOfIslands</span><span class="params">(<span class="keyword">int</span>[][] binaryMatrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (binaryMatrix == <span class="keyword">null</span> || binaryMatrix.length == <span class="number">0</span> || binaryMatrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = binaryMatrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = binaryMatrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binaryMatrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    markIsland(binaryMatrix, m, n, i, j);</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markIsland</span><span class="params">(<span class="keyword">int</span>[][] binaryMatrix, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// store the index in queue</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.remove();</span><br><span class="line">            <span class="keyword">int</span> r = cur[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (binaryMatrix[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                binaryMatrix[r][c] = -<span class="number">1</span>; <span class="comment">// mark as visited</span></span><br><span class="line">                addIfValid(queue, m, n, r - <span class="number">1</span>, c);</span><br><span class="line">                addIfValid(queue, m, n, r + <span class="number">1</span>, c);</span><br><span class="line">                addIfValid(queue, m, n, r, c - <span class="number">1</span>);</span><br><span class="line">                addIfValid(queue, m, n, r, c + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addIfValid</span><span class="params">(Queue&lt;<span class="keyword">int</span>[]&gt; queue, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n) queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] binaryMatrix = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        System.out.println(getNumberOfIslands(binaryMatrix));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="694-Number-of-Distinct-Islands⭐"><a href="#694-Number-of-Distinct-Islands⭐" class="headerlink" title="694. Number of Distinct Islands⭐"></a><a href="https://leetcode.com/problems/number-of-distinct-islands/" target="_blank" rel="noopener">694. Number of Distinct Islands⭐</a></h2><h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Hash By Local Coordinates</li>
<li>Time Complexity: O(R<em>C)*O</em>(<em>R</em>∗<em>C</em>), where R<em>R</em> is the number of rows in the given <code>grid</code>, and C<em>C</em> is the number of columns. We visit every square once.</li>
<li>Space complexity: O(R<em>C)*O</em>(<em>R</em>∗<em>C</em>), the space used by <code>seen</code> to keep track of visited squares, and <code>shapes</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;String&gt; shapes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                dfs(grid, i, j, <span class="number">0</span>, <span class="number">0</span>, sb);</span><br><span class="line">                String shape = sb.toString();</span><br><span class="line">                <span class="keyword">if</span> (!shapes.contains(shape)) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    shapes.add(shape);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> x, <span class="keyword">int</span> y, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    sb.append(<span class="string">""</span> + x + y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> c = j + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= grid.length || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].length || grid[r][c] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(grid, r, c, x + dir[<span class="number">0</span>], y + dir[<span class="number">1</span>], sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Use direction string instead of using number string in set</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                dfs(grid, i, j, sb, <span class="string">"o"</span>); <span class="comment">// origin</span></span><br><span class="line">                grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                set.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, StringBuilder sb, String dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i == grid.length || j &lt; <span class="number">0</span> || j == grid[i].length </span><br><span class="line">       || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    sb.append(dir);</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    dfs(grid, i-<span class="number">1</span>, j, sb, <span class="string">"u"</span>);</span><br><span class="line">    dfs(grid, i+<span class="number">1</span>, j, sb, <span class="string">"d"</span>);</span><br><span class="line">    dfs(grid, i, j-<span class="number">1</span>, sb, <span class="string">"l"</span>);</span><br><span class="line">    dfs(grid, i, j+<span class="number">1</span>, sb, <span class="string">"r"</span>);</span><br><span class="line">    sb.append(<span class="string">"b"</span>); <span class="comment">// back</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Universal-sink⭐⭐"><a href="#Universal-sink⭐⭐" class="headerlink" title="Universal sink⭐⭐"></a>Universal sink⭐⭐</h2><p>Find a universal sink in a directed acyclic graph. </p>
<p>And the universal sink means a vertex that has no edge emanating from it, and all other vertices have an edge towards the sink.</p>
<h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>This is a similar question with Find Celebrity, the goal of this question is to find a node which doesn’t have an arrow towards any other node in a graph.</p>
</li>
<li><p>You can start by checking any node as beginning, in any given “checking”, you have two possibility:</p>
<ol>
<li>For this node, there is an arrow towards other node, in this case, this is not candidate for our goal, then you can move on checking the next node (by following the arrow), and removing current node from candidate list</li>
<li>For this node, there is zero arrow towards other node, in this case, this is a candidate, you can save this candidate and move on checking other node.</li>
</ol>
<p>Once you exhaust all nodes and end up with an empty candidate list, you can draw the conclusion that there is no universal sink, vice versa.</p>
</li>
</ol>
<h3 id="277-Find-the-celebrity⭐⭐"><a href="#277-Find-the-celebrity⭐⭐" class="headerlink" title="277. Find the celebrity⭐⭐"></a><a href="https://leetcode.com/problems/find-the-celebrity/" target="_blank" rel="noopener">277. Find the celebrity⭐⭐</a></h3><h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：所有人都知道 c，而 c 不知道任何人，所以如果 0 是 c，则它不可能知道任何其他人，如果 0 不是 c，则他一定知道 c，以此类推，找到唯一的一个可能是 c 的。然后判断是否符合条件。O(n)</li>
<li>The first pass is to pick out the candidate. If candidate knows i, then switch candidate. The second pass is to check whether the candidate is real.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n) | S O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> candidate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//if candidate is real, he will not know everyone, i is fixed</span></span><br><span class="line">        <span class="keyword">if</span> (knows(candidate, i))</span><br><span class="line">            candidate = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//test it's a valid candidate</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != candidate &amp;&amp; (knows(candidate, i) || !knows(i, candidate)))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-10"><a href="#Solution2-10" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Brute Force</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Relation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nums;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        nums = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isCelebrity(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCelebrity</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (knows(i, j) || !knows(j, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3:"></a>Solution3:</h3><ol>
<li><p>Problem Statement </p>
</li>
<li><p>implement <code>findCelebrity()</code> method to find the celebrity in a party (matrix) using a stack. A celebrity is someone that everyone knows, but he/she doesn’t know anyone at the party.</p>
</li>
<li><p>Where the <em>party</em> is a reference variable storing a 2D matrix, which has stored all the information about acquaintances, <em>numPeople</em> and the number of people present in the party.</p>
<p>In the party matrix, a particular [row][col] stores acquaintance information for row and col. In other words, if [row][col] == 1, then it means row knows col, and if it’s zero, then it means <em>row</em> doesn’t know <em>col</em>. Remember that everyone knows a celebrity, but the celebrity doesn’t know the people at the party.</p>
</li>
<li><pre><code class="java">party = {
          {<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>},
          {<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>},
          {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},
          {<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>},
                }

numPeople = <span class="number">4</span> (Number of rows in party array)   

<span class="number">2</span> (because row Index = <span class="number">2</span> is a celebrity)
&lt;!--￼<span class="number">49</span>--&gt;
</code></pre>
</li>
</ol>
<h2 id="Unsolved-332-Reconstruct-Itinerary🎂⭐"><a href="#Unsolved-332-Reconstruct-Itinerary🎂⭐" class="headerlink" title="Unsolved 332. Reconstruct Itinerary🎂⭐"></a><a href="https://leetcode.com/problems/reconstruct-itinerary/?utm_source=AlgoTogether&utm_campaign=6415681024-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_3&utm_medium=email&utm_term=0_38d4e2e3e2-6415681024-231340480" target="_blank" rel="noopener">Unsolved 332. Reconstruct Itinerary🎂⭐</a></h2><p><a href="https://leetcode.com/problems/reconstruct-itinerary/discuss/78768/Short-Ruby-Python-Java-C%2B%2B" target="_blank" rel="noopener">https://leetcode.com/problems/reconstruct-itinerary/discuss/78768/Short-Ruby-Python-Java-C%2B%2B</a></p>
<p>“Given a list of airline tickets represented by pairs of departure and arrival airports <em><code>[from, to]</code></em>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from <em><code>JFK</code></em>. Thus, the itinerary must begin with <em><code>JFK</code></em>.”</p>
<h3 id="Solution1-19"><a href="#Solution1-19" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：假设没有重复，非常容易，只要建立词典，从 JFK 开始逐一机票使用。</li>
<li>现在是有可能有重复，不过题中还给出了另一个条件：如果有重复，则按到站的字典顺排序。所以这里只有到站是需要排序的。排序问题可以想到优先队列。</li>
<li>有了上述的准备工作，则使用 DFS 找结果，最后把结果存入数组。</li>
<li>Path.addFirst 是因为总是靠近队尾的元素更先到该句（因为是 DFS）。如果有答案，可以证明：重复到站先走哪个都应该可以完成。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, PriorityQueue&lt;String&gt;&gt; map;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; ticket : tickets) &#123;</span><br><span class="line">        map.putIfAbsent(ticket.get(<span class="number">0</span>), <span class="keyword">new</span> PriorityQueue&lt;String&gt;());</span><br><span class="line">        map.get(ticket.get(<span class="number">0</span>)).add(ticket.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="string">"JFK"</span>, path);</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String dep, List&lt;String&gt; path)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;String&gt; heap = map.get(dep);</span><br><span class="line">    <span class="keyword">while</span>(heap != <span class="keyword">null</span> &amp;&amp; !heap.isEmpty()) &#123;</span><br><span class="line">        dfs(heap.poll(), path);</span><br><span class="line">    &#125;</span><br><span class="line">    path.add(<span class="number">0</span>, dep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-11"><a href="#Solution2-11" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String[] ticket : tickets)</span><br><span class="line">        targets.computeIfAbsent(ticket[<span class="number">0</span>], k -&gt; <span class="keyword">new</span> PriorityQueue()).add(ticket[<span class="number">1</span>]);</span><br><span class="line">    visit(<span class="string">"JFK"</span>);</span><br><span class="line">    <span class="keyword">return</span> route;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;String, PriorityQueue&lt;String&gt;&gt; targets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;String&gt; route = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(String airport)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(targets.containsKey(airport) &amp;&amp; !targets.get(airport).isEmpty())</span><br><span class="line">        visit(targets.get(airport).poll());</span><br><span class="line">    route.add(<span class="number">0</span>, airport);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Iterative version:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, PriorityQueue&lt;String&gt;&gt; targets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String[] ticket : tickets)</span><br><span class="line">        targets.computeIfAbsent(ticket[<span class="number">0</span>], k -&gt; <span class="keyword">new</span> PriorityQueue()).add(ticket[<span class="number">1</span>]);</span><br><span class="line">    List&lt;String&gt; route = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(<span class="string">"JFK"</span>);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (targets.containsKey(stack.peek()) &amp;&amp; !targets.get(stack.peek()).isEmpty())</span><br><span class="line">            stack.push(targets.get(stack.peek()).poll());</span><br><span class="line">        route.add(<span class="number">0</span>, stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> route;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-1102-Path-With-Maximum-Minimum-Value⭐"><a href="#Unsolved-1102-Path-With-Maximum-Minimum-Value⭐" class="headerlink" title="Unsolved 1102. Path With Maximum Minimum Value⭐"></a><a href="https://leetcode.com/problems/path-with-maximum-minimum-value/" target="_blank" rel="noopener">Unsolved 1102. Path With Maximum Minimum Value⭐</a></h2><p>“Given a matrix of integers <em><code>A</code></em> with R rows and C columns, find the <strong>maximum</strong> score of a path starting at <em><code>[0,0]</code></em> and ending at <em><code>[R-1,C-1]</code></em>.”</p>
<p><a href="https://leetcode.com/problems/path-with-maximum-minimum-value/" target="_blank" rel="noopener">https://leetcode.com/problems/path-with-maximum-minimum-value/</a></p>
<h2 id="695-Max-Area-of-Island✨"><a href="#695-Max-Area-of-Island✨" class="headerlink" title="695. Max Area of Island✨"></a><a href="https://leetcode.com/problems/max-area-of-island/description/" target="_blank" rel="noopener">695. Max Area of Island✨</a></h2><h3 id="Solution1-20"><a href="#Solution1-20" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Given a non-empty 2D array <code>grid</code> of 0’s and 1’s, an <strong>island</strong> is a group of <code>1</code>‘s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</li>
<li>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">Given the above grid, <span class="keyword">return</span> <span class="number">6</span>. </span><br><span class="line">Note the answer is not <span class="number">11</span>, because the island must be connected <span class="number">4</span>-directionally.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                max = Math.max(max, dfs(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= grid.length || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].length || grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    count += dfs(grid, r+<span class="number">1</span>, c);</span><br><span class="line">    count += dfs(grid, r-<span class="number">1</span>, c);</span><br><span class="line">    count += dfs(grid, r, c+<span class="number">1</span>);</span><br><span class="line">    count += dfs(grid, r, c-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="130-Surrounded-Regions✨"><a href="#130-Surrounded-Regions✨" class="headerlink" title="130.Surrounded Regions✨"></a><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">130.Surrounded Regions✨</a></h2><h3 id="Solution1-21"><a href="#Solution1-21" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：先把不被包围的 0 全部置成特殊字符（这里使用” + “），然后再逐一扫描元素，是’’ + ‘’的置回 0，是 0 的置成 X。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">'O'</span>) dfs(board, i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">'O'</span>) dfs(board, i, n  -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">'O'</span>) dfs(board, <span class="number">0</span>, j);</span><br><span class="line">        <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">'O'</span>) dfs(board, m - <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'A'</span>) &#123;</span><br><span class="line">                board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">'X'</span> || board[i][j] == <span class="string">'A'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    board[i][j] = <span class="string">'A'</span>;</span><br><span class="line">    dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">    dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-12"><a href="#Solution2-12" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Hi. So here is my accepted code using <strong>Union Find</strong> data structure. The idea comes from the observation that if a region is NOT captured, it is connected to the boundry. So if we connect all the ‘O’ nodes on the boundry to a dummy node, and then connect each ‘O’ node to its neighbour ‘O’ nodes, then we can tell directly whether a ‘O’ node is captured by checking whether it is connected to the dummy node.<br>For more about Union Find, the first assignment in the algo1 may help:<br><a href="https://www.coursera.org/course/algs4partI" target="_blank" rel="noopener">https://www.coursera.org/course/algs4partI</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* id;     <span class="comment">// id[i] = parent of i</span></span><br><span class="line">    <span class="keyword">int</span>* rank;  <span class="comment">// rank[i] = rank of subtree rooted at i (cannot be more than 31)</span></span><br><span class="line">    <span class="keyword">int</span> count;    <span class="comment">// number of components</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    UF(<span class="keyword">int</span> N)</span><br><span class="line">    &#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~UF()</span><br><span class="line">    &#123;</span><br><span class="line">        delete [] id;</span><br><span class="line">        delete [] rank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p != id[p]) &#123;</span><br><span class="line">            id[p] = id[id[p]];    <span class="comment">// path compression by halving</span></span><br><span class="line">            p = id[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">bool <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = find(p);</span><br><span class="line">        <span class="keyword">int</span> j = find(q);</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[i] &lt; rank[j]) id[i] = j;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[i] &gt; rank[j]) id[j] = i;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            id[j] = i;</span><br><span class="line">            rank[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)    <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board[<span class="number">0</span>].size();</span><br><span class="line">        UF uf = UF(n*m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i==<span class="number">0</span>||i==n-<span class="number">1</span>||j==<span class="number">0</span>||j==m-<span class="number">1</span>)&amp;&amp;board[i][j]==<span class="string">'O'</span>) <span class="comment">// if a 'O' node is on the boundry, connect it to the dummy node</span></span><br><span class="line">                    uf.connect(i*m+j,n*m);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) <span class="comment">// connect a 'O' node to its neighbour 'O' nodes</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[i-<span class="number">1</span>][j]==<span class="string">'O'</span>)</span><br><span class="line">                        uf.connect(i*m+j,(i-<span class="number">1</span>)*m+j);</span><br><span class="line">                    <span class="keyword">if</span>(board[i+<span class="number">1</span>][j]==<span class="string">'O'</span>)</span><br><span class="line">                        uf.connect(i*m+j,(i+<span class="number">1</span>)*m+j);</span><br><span class="line">                    <span class="keyword">if</span>(board[i][j-<span class="number">1</span>]==<span class="string">'O'</span>)</span><br><span class="line">                        uf.connect(i*m+j,i*m+j-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(board[i][j+<span class="number">1</span>]==<span class="string">'O'</span>)</span><br><span class="line">                        uf.connect(i*m+j,i*m+j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!uf.connected(i*m+j,n*m))&#123; <span class="comment">// if a 'O' node is not connected to the dummy node, it is captured</span></span><br><span class="line">                    board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="130-Surrounded-Regions✨-1"><a href="#130-Surrounded-Regions✨-1" class="headerlink" title="130. Surrounded Regions✨"></a><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. Surrounded Regions✨</a></h2><h3 id="Solution1-22"><a href="#Solution1-22" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：先把不被包围的 0 全部置成特殊字符（这里使用<em>），然后再逐一扫描元素，是</em>的置回 0，是 0 的置成 X。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">'O'</span>)</span><br><span class="line">                dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">'O'</span>)</span><br><span class="line">                dfs(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">'O'</span>)</span><br><span class="line">                dfs(board, <span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">'O'</span>)</span><br><span class="line">                dfs(board, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>)</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'+'</span>)</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == board.length || j &lt; <span class="number">0</span> || j == board[<span class="number">0</span>].length || board[i][j] == <span class="string">'X'</span> || board[i][j] == <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] = <span class="string">'+'</span>;</span><br><span class="line">        dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="403-Frog-Jump✨"><a href="#403-Frog-Jump✨" class="headerlink" title="403. Frog Jump✨"></a><a href="https://leetcode.com/problems/frog-jump/" target="_blank" rel="noopener">403. Frog Jump✨</a></h2><h3 id="Solution1-23"><a href="#Solution1-23" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones[i] &gt; stones[i - <span class="number">1</span>] * <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> lastStone = stones[stones.length - <span class="number">1</span>];  <span class="comment">//taregt</span></span><br><span class="line">    Stack&lt;Integer&gt; positions = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; jump = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    positions.push(<span class="number">0</span>);</span><br><span class="line">    jump.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">        set.add(stone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!positions.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = positions.pop();</span><br><span class="line">        <span class="keyword">int</span> jumpDistance = jump.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = jumpDistance - <span class="number">1</span>; i &lt;= jumpDistance + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current + i == lastStone) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(current + i)) &#123;</span><br><span class="line">                    positions.push(current + i);</span><br><span class="line">                    jump.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="286-Walls-and-Gates✨"><a href="#286-Walls-and-Gates✨" class="headerlink" title="286. Walls and Gates✨"></a><a href="https://leetcode.com/problems/walls-and-gates/" target="_blank" rel="noopener">286. Walls and Gates✨</a></h2><p>Given the 2D grid:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INF  -<span class="number">1</span>  <span class="number">0</span>  INF</span><br><span class="line">INF INF INF  -<span class="number">1</span></span><br><span class="line">INF  -<span class="number">1</span> INF  -<span class="number">1</span></span><br><span class="line">  <span class="number">0</span>  -<span class="number">1</span> INF INF</span><br></pre></td></tr></table></figure>

<p>After running your function, the 2D grid should be:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>  -<span class="number">1</span>   <span class="number">0</span>   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2</span>   <span class="number">1</span>  -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>  -<span class="number">1</span>   <span class="number">2</span>  -<span class="number">1</span></span><br><span class="line"><span class="number">0</span>  -<span class="number">1</span>   <span class="number">3</span>   <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-l"><a href="#Solution1-l" class="headerlink" title="Solution1:l"></a>Solution1:l</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rooms.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rooms[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i, j, <span class="number">0</span>, rooms);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> count, <span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rooms.length || j &lt; <span class="number">0</span> || j &gt;= rooms[i].length || rooms[i][j] &lt; count) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rooms[i][j] = count;</span><br><span class="line">    dfs(i + <span class="number">1</span>, j, count + <span class="number">1</span>, rooms);</span><br><span class="line">    dfs(i - <span class="number">1</span>, j, count + <span class="number">1</span>, rooms);</span><br><span class="line">    dfs(i, j + <span class="number">1</span>, count + <span class="number">1</span>, rooms);</span><br><span class="line">    dfs(i, j - <span class="number">1</span>, count + <span class="number">1</span>, rooms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-13"><a href="#Solution2-13" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rooms.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rooms[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = cur[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = x + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> c = y + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= rooms.length || c &lt; <span class="number">0</span> || c &gt;= rooms[<span class="number">0</span>].length || rooms[r][c] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                rooms[r][c] = rooms[x][y] + <span class="number">1</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="01-Matrix✨"><a href="#01-Matrix✨" class="headerlink" title="01 Matrix✨"></a><a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="noopener">01 Matrix✨</a></h2><h3 id="Solution1-24"><a href="#Solution1-24" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>General idea is <code>BFS</code>. Some small tricks:<ol>
<li>At beginning, set cell value to <code>Integer.MAX_VALUE</code> if it is not <code>0</code>.</li>
<li>If newly calculated distance <code>&gt;=</code> current distance, then we don’t need to explore that cell again.</li>
</ol>
</li>
<li>Time complexity: O(r \cdot c)<em>O</em>(<em>r</em>⋅<em>c</em>).<ul>
<li>Since, the new cells are added to the queue only if their current distance is greater than the calculated distance, cells are not likely to be added multiple times.</li>
</ul>
</li>
<li>Space complexity: O(r \cdot c)<em>O</em>(<em>r</em>⋅<em>c</em>). Additional O(r \cdot c)<em>O</em>(<em>r</em>⋅<em>c</em>) for queue than in Approach #1</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                matrix[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = cur[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> c = cur[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= matrix.length || c &lt; <span class="number">0</span> || c &gt;= matrix[<span class="number">0</span>].length || matrix[r][c] != Integer.MAX_VALUE) <span class="keyword">continue</span>;</span><br><span class="line">                matrix[r][c] = matrix[cur[<span class="number">0</span>]][cur[<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="419-Battleships-in-a-Board💎"><a href="#419-Battleships-in-a-Board💎" class="headerlink" title="419. Battleships in a Board💎"></a><a href="https://leetcode.com/problems/battleships-in-a-board/" target="_blank" rel="noopener">419. Battleships in a Board💎</a></h2><h3 id="Solution1-25"><a href="#Solution1-25" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numBattleships = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'X'</span>) </span><br><span class="line">                numBattleships++;</span><br><span class="line">            dfs(board, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numBattleships;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != <span class="string">'X'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">    dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line">    dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Soltuion2"><a href="#Soltuion2" class="headerlink" title="Soltuion2:"></a>Soltuion2:</h3><ol>
<li><strong>Follow up:</strong><br>Could you do it in <strong>one-pass</strong>, using only <strong>O(1) extra memory</strong> and <strong>without modifying</strong> the value of the board?</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numBattleships = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">'X'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; board[i][j - <span class="number">1</span>] == <span class="string">'X'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            numBattleships++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numBattleships;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="841-Keys-and-Rooms✨"><a href="#841-Keys-and-Rooms✨" class="headerlink" title="841. Keys and Rooms✨"></a><a href="https://leetcode.com/problems/keys-and-rooms/" target="_blank" rel="noopener">841. Keys and Rooms✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[]]</span><br><span class="line">Output: <span class="keyword">true</span></span><br><span class="line">Explanation:  </span><br><span class="line">We start in room <span class="number">0</span>, and pick up key <span class="number">1</span>.</span><br><span class="line">We then go to room <span class="number">1</span>, and pick up key <span class="number">2</span>.</span><br><span class="line">We then go to room <span class="number">2</span>, and pick up key <span class="number">3</span>.</span><br><span class="line">We then go to room <span class="number">3</span>.  Since we were able to go to every room, we <span class="keyword">return</span> <span class="keyword">true</span>.</span><br><span class="line"></span><br><span class="line">Input: [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">0</span>]]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation: We can<span class="string">'t enter the room with number 2.</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-26"><a href="#Solution1-26" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    stack.add(<span class="number">0</span>);</span><br><span class="line">    visited.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; keys = rooms.get(stack.pop());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : keys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(key)) &#123;</span><br><span class="line">                stack.push(key);</span><br><span class="line">                visited.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visited.size() == rooms.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="494-Target-Sum✨"><a href="#494-Target-Sum✨" class="headerlink" title="494. Target Sum✨"></a><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">494. Target Sum✨</a></h2><h3 id="Solution1-27"><a href="#Solution1-27" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>DFS</p>
</li>
<li><p>题目大意：给你一串数字，你可以在每个数字前放置+或-，问有多少种方法可以使得表达式的值等于target。You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p>
<p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p>
</li>
<li><p>Time complexity: O(2^n)</p>
<p>Space complexity: O(n)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; Math.abs(S)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    dfs(nums, <span class="number">0</span>, S);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (start == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="number">0</span>) ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(nums, start + <span class="number">1</span>, S + nums[start]);</span><br><span class="line">    dfs(nums, start + <span class="number">1</span>, S - nums[start]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-Solution2"><a href="#Unsolved-Solution2" class="headerlink" title="Unsolved Solution2:"></a>Unsolved Solution2:</h3><ol>
<li><a href="https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-494-target-sum/" target="_blank" rel="noopener">DP</a></li>
</ol>
<h1 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h1><p>Backtracking（回溯）属于 DFS。</p>
<ul>
<li>普通 DFS 主要用在 <strong><code>可达性问题</code></strong> ，这种问题只需要执行到特点的位置然后返回即可。</li>
<li>而 Backtracking 主要用于求解 <strong><code>排列组合</code></strong> 问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li>
</ul>
<p>因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p>
<ul>
<li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</li>
<li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</li>
</ul>
<h2 id="79-Word-Search⭐"><a href="#79-Word-Search⭐" class="headerlink" title="79. Word Search⭐"></a><a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">79. Word Search⭐</a></h2><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">For example,</span><br><span class="line">Given board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line">word = <span class="string">"ABCCED"</span>, -&gt; returns <span class="keyword">true</span>,</span><br><span class="line">word = <span class="string">"SEE"</span>, -&gt; returns <span class="keyword">true</span>,</span><br><span class="line">word = <span class="string">"ABCB"</span>, -&gt; returns <span class="keyword">false</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-28"><a href="#Solution1-28" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span> || board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>) &amp;&amp; dfs(board, word, <span class="number">0</span>, i, j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> idx, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// if over board or not correct char</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || word.charAt(idx) != board[i][j]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//back tracking mark it to empty space dfs, and then recover</span></span><br><span class="line">    <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">    board[i][j] = <span class="string">' '</span>; <span class="comment">//mark as used</span></span><br><span class="line">    <span class="keyword">boolean</span> found = dfs(board, word, idx+<span class="number">1</span>, i + <span class="number">1</span>, j)</span><br><span class="line">        || dfs(board, word, idx+<span class="number">1</span>, i - <span class="number">1</span>, j)</span><br><span class="line">        || dfs(board, word, idx+<span class="number">1</span>, i, j + <span class="number">1</span>)</span><br><span class="line">        || dfs(board, word, idx+<span class="number">1</span>, i, j - <span class="number">1</span>);</span><br><span class="line">    board[i][j] = temp;  <span class="comment">//recover to previoud char for next round, backtracking </span></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check:</span></span><br><span class="line"><span class="comment">1. If input is empty, just return false</span></span><br><span class="line"><span class="comment">    1) word == null || word.length == 0</span></span><br><span class="line"><span class="comment">    2) board == null || board.length == 0 || board[0].length == 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution:</span></span><br><span class="line"><span class="comment">    Use DFS to solve this problem</span></span><br><span class="line"><span class="comment">    Idea : traverse form top left to bottom right, in each unit we check if it equals to the first character in the taregt string, if same we apply dfs which return a boolean value</span></span><br><span class="line"><span class="comment">    dfs pass in the board, target string, cur idx, if tarversed string == target return true otherwise return false,</span></span><br><span class="line"><span class="comment">    in each dfs we check the char in unit is same to current idx char in target,</span></span><br><span class="line"><span class="comment">    if dfs retrun true we can just return true, said we do have taregt strig in the board</span></span><br><span class="line"><span class="comment">    booelan dfs(board, word, idx, i, j) &#123;</span></span><br><span class="line"><span class="comment">        //base case</span></span><br><span class="line"><span class="comment">        if (idx == word.length) return true;</span></span><br><span class="line"><span class="comment">        //error check</span></span><br><span class="line"><span class="comment">        if (i &lt; 0 || i &gt; board.length || j &lt; 0 || j &gt; board[0].length || word.charAt(idx) != board[i][j]) return false;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        boolean exist = dfs(board, word, idx+1, i + 1, j)</span></span><br><span class="line"><span class="comment">                        || dfs(board, word, idx+1, i - 1, j)</span></span><br><span class="line"><span class="comment">                        || dfs(board, word, idx+1, i, j + 1)</span></span><br><span class="line"><span class="comment">                        || dfs(board, word, idx+1, i, j - 1);</span></span><br><span class="line"><span class="comment">        retrun exist;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">3. Time O(mn)</span></span><br><span class="line"><span class="comment">Space O(mn)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-14"><a href="#Solution2-14" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = board.length;</span><br><span class="line">    n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (backtracking(<span class="number">0</span>, r, c, hasVisited, board, word)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> curLen, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] visited, <span class="keyword">final</span> <span class="keyword">char</span>[][] board, <span class="keyword">final</span> String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curLen == word.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n</span><br><span class="line">            || board[r][c] != word.charAt(curLen) || visited[r][c]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        <span class="keyword">if</span> (backtracking(curLen + <span class="number">1</span>, r + d[<span class="number">0</span>], c + d[<span class="number">1</span>], visited, board, word)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[r][c] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="51-N-Queens✨"><a href="#51-N-Queens✨" class="headerlink" title="51. N-Queens✨"></a><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="noopener">51. N-Queens✨</a></h2><p><img src="https://camo.githubusercontent.com/538ca5bd92ad237cc495cafa937f2e324db4be6eecde13e47b25d80cb827c7b7/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30363762333130632d363837372d343066652d396463662d3130363534653733373438352e6a7067" alt=""></p>
<p>在 n*n 的矩阵中摆放 n 个皇后，并且每个皇后不能在同一行，同一列，同一对角线上，求所有的 n 皇后的解。</p>
<p>一行一行地摆放，在确定一行中的那个皇后应该摆在哪一列时，需要用三个标记数组来确定某一列是否合法，这三个标记数组分别为：列标记数组、45 度对角线标记数组和 135 度对角线标记数组。</p>
<p>45 度对角线标记数组的长度为 2 * n - 1，通过下图可以明确 (r, c) 的位置所在的数组下标为 r + c。</p>
<p><img src="https://camo.githubusercontent.com/b8607e2983ed40fa3f5f5cbad4d1467dc58fb63fff6835b9a59a4b3d04f639f3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39633432323932332d313434372d346133622d613465312d3937653636333733383138372e6a7067" alt=""></p>
<p>135 度对角线标记数组的长度也是 2 * n - 1，(r, c) 的位置所在的数组下标为 n - 1 - (r - c)。</p>
<p><img src="https://camo.githubusercontent.com/5b04d1d080eb7ffc776c17f8f5629dbec00b231b9dd7c2ee1d0cb49fa5bb2a98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37613835653238352d653135322d343131362d623664632d3366616232376261393433372e6a7067" alt=""></p>
<h3 id="Solution1-29"><a href="#Solution1-29" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：回溯法。逐行（逐位）尝试，每次置“Q”后，将其所对应的列（行已经处理了）、两个纵行（row-i+n, n*2-i-row-1）设置为已访问。O((n^2)^2)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; r = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] col = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">boolean</span>[] lr = <span class="keyword">new</span> <span class="keyword">boolean</span>[n * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">boolean</span>[] rl = <span class="keyword">new</span> <span class="keyword">boolean</span>[n * <span class="number">2</span>];</span><br><span class="line">    backtrack(<span class="number">0</span>, n, col, lr, rl, r, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n, <span class="keyword">boolean</span>[] col, <span class="keyword">boolean</span>[] lr, <span class="keyword">boolean</span>[] rl, List&lt;List&lt;String&gt;&gt; r, List&lt;String&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">    	r.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (row == n)</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> lrp = row - i + n;</span><br><span class="line">        <span class="keyword">int</span> rlp = n * <span class="number">2</span> - i - row - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (col[i] || lr[lrp] || rl[rlp])</span><br><span class="line">    	<span class="keyword">continue</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; n; ++i1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == i1) &#123;</span><br><span class="line">            sb.append(<span class="string">"Q"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	sb.append(<span class="string">"."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    l.add(sb.toString());</span><br><span class="line">    col[i] = <span class="keyword">true</span>;</span><br><span class="line">    lr[lrp] = <span class="keyword">true</span>;</span><br><span class="line">    rl[rlp] = <span class="keyword">true</span>;</span><br><span class="line">    backtrack(row + <span class="number">1</span>, n, col, lr, rl, r, l);</span><br><span class="line">    l.remove(l.size() - <span class="number">1</span>);</span><br><span class="line">    col[i] = <span class="keyword">false</span>;</span><br><span class="line">    lr[lrp] = <span class="keyword">false</span>;</span><br><span class="line">    rl[rlp] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        String[][] board = <span class="keyword">new</span> String[n][n];</span><br><span class="line">        <span class="keyword">for</span> (String[] b : board) &#123;</span><br><span class="line">            Arrays.fill(b, <span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String[][] board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base line</span></span><br><span class="line">        <span class="keyword">if</span> (row == board.length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String[] b : board)</span><br><span class="line">                res.add(Arrays.asList(b));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = board[row].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isValid(board, row, col))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            board[row][col] = <span class="string">"Q"</span>;</span><br><span class="line">            backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">            board[row][col] = <span class="string">"."</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line">        <span class="comment">//check the column</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col].equals(<span class="string">"Q"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j].equals(<span class="string">"Q"</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j].equals(<span class="string">"Q"</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Solution2-15"><a href="#Solution2-15" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; solutions;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[][] nQueens;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] colUsed;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] diagonals45Used;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] diagonals135Used;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    solutions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    nQueens = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Arrays.fill(nQueens[i], <span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    colUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    diagonals45Used = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">    diagonals135Used = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    backtracking(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> solutions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : nQueens) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">        &#125;</span><br><span class="line">        solutions.add(list);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">int</span> diagonals45Idx = row + col;</span><br><span class="line">        <span class="keyword">int</span> diagonals135Idx = n - <span class="number">1</span> - (row - col);</span><br><span class="line">        <span class="keyword">if</span> (colUsed[col] || diagonals45Used[diagonals45Idx] || diagonals135Used[diagonals135Idx]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nQueens[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = <span class="keyword">true</span>;</span><br><span class="line">        backtracking(row + <span class="number">1</span>);</span><br><span class="line">        colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = <span class="keyword">false</span>;</span><br><span class="line">        nQueens[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="36-Valid-Sudoku⭐"><a href="#36-Valid-Sudoku⭐" class="headerlink" title="36. Valid Sudoku⭐"></a><a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. Valid Sudoku⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Let us first discuss two questions.</span><br><span class="line"></span><br><span class="line">How to enumerate sub-boxes?</span><br><span class="line">One could use box_index = (row / <span class="number">3</span>) * <span class="number">3</span> + col / <span class="number">3</span> where / is an integer division, row is a row number, and col is a column number.</span><br></pre></td></tr></table></figure>

<p><img src="https://leetcode.com/problems/valid-sudoku/Figures/36/36_boxes_2.png" alt=""></p>
<p>One could just track all values which were already encountered in a hash map <code>value -&gt; count</code>.</p>
<h3 id="Solution1-30"><a href="#Solution1-30" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>brute force</li>
<li>Move along the board.<ul>
<li>Check for each cell value if it was seen already in the current row / column / box :<ul>
<li>Return <code>false</code> if yes.</li>
<li>Keep this value for a further tracking if no.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>true</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// init data</span></span><br><span class="line">    HashSet&lt;Integer&gt;[] rows = <span class="keyword">new</span> HashSet[<span class="number">9</span>];</span><br><span class="line">    HashSet&lt;Integer&gt;[] cols = <span class="keyword">new</span> HashSet[<span class="number">9</span>];</span><br><span class="line">    HashSet&lt;Integer&gt;[] boxes = <span class="keyword">new</span> HashSet[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        rows[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        cols[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        boxes[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// validate a board</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =  <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = (<span class="keyword">int</span>) board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (!rows[i].add(num)</span><br><span class="line">                    || !cols[j].add(num)</span><br><span class="line">                    || ! boxes[(i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>].add(num))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-16"><a href="#Solution2-16" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Collect the set of things we see, encoded as strings. For example:</p>
<ul>
<li><code>&#39;4&#39; in row 7</code> is encoded as <code>&quot;(4)7&quot;</code>.</li>
<li><code>&#39;4&#39; in column 7</code> is encoded as <code>&quot;7(4)&quot;</code>.</li>
<li><code>&#39;4&#39; in the top-right block</code> is encoded as <code>&quot;0(4)2&quot;</code>.</li>
</ul>
<p>Scream <code>false</code> if we ever fail to add something because it was already added (i.e., seen before).</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                String val = <span class="string">"("</span> + board[i][j] + <span class="string">")"</span>;</span><br><span class="line">                <span class="keyword">if</span> (!set.add(i + val) || !set.add(val + j) || !set.add(i/<span class="number">3</span> + val + j/<span class="number">3</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Eroor check</span></span><br><span class="line"><span class="comment">1. " ", null, return false;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">case1: each row has excatly 123456789 element - </span></span><br><span class="line"><span class="comment">case2: each row has excatly 123456789 element</span></span><br><span class="line"><span class="comment">case3: each sub square has excatly 123456789 element</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Traverse until encounter a empty space('.'), we fill this space with potenitial canidiated 1~9,visited array to record wich element has been used or not</span></span><br><span class="line"><span class="comment">potenitial candidate: we need check all the row, col, and sub square corresponding with this position, make sure no dplicate</span></span><br><span class="line"><span class="comment">otherwise did not meet these cases, we try another candidate</span></span><br><span class="line"><span class="comment">each pos we have 9 possible choice</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">when we encount a val in idx of [i, j]</span></span><br><span class="line"><span class="comment">case1(row) -&gt; String =  row(val)</span></span><br><span class="line"><span class="comment">case2(col) -&gt; String = (val)col</span></span><br><span class="line"><span class="comment">case3(sub square) -&gt; String = i/3(val)j/3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="37-Sudoku-Solver💜✨"><a href="#37-Sudoku-Solver💜✨" class="headerlink" title="37. Sudoku Solver💜✨"></a><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. Sudoku Solver💜✨</a></h2><h3 id="Solution0"><a href="#Solution0" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute Force</li>
<li>The first idea is to use brut-force to generate all possible ways to fill the cells with numbers from <code>1</code> to <code>9</code>, and then check them to keep the solution only. That means 9^{81}981 operations to do, where 99 is a number of available digits and 8181 is a number of cells to fill. Hence we’re forced to think further how to optimize.</li>
</ol>
<h3 id="Solution1-31"><a href="#Solution1-31" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Backtracking</p>
</li>
<li><p>There are two programming conceptions here which could help.</p>
<p>The first one is called <em>constrained programming</em>.</p>
</li>
</ol>
<p><img src="https://leetcode.com/problems/sudoku-solver/Figures/37/37_const3.png" alt=""></p>
<p>The second one called <em>backtracking</em>.</p>
<p><img src="https://leetcode.com/problems/sudoku-solver/Figures/37/37_backtrack2.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">How to enumerate sub-boxes</span><br><span class="line">One tip to enumerate sub-boxes: </span><br><span class="line">let us use box_index = (row / <span class="number">3</span>) * <span class="number">3</span> + column / <span class="number">3</span> where / is an integer division.</span><br></pre></td></tr></table></figure>

<p><img src="https://leetcode.com/problems/sudoku-solver/Figures/36/36_boxes_2.png" alt=""></p>
<h3 id="Solution2-17"><a href="#Solution2-17" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：回溯法，每一个未填位置试图填入 1-9 每个数，然后再试下一位置。失败时记得把当前值回置为”.”。</li>
<li>Try 1 through 9 for each cell. The time complexity should be 9 ^ m (m represents the number of blanks to be filled in), since each blank can have 9 choices. Details see comments inside code.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    solve(board);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="comment">//trial. Try 1 through 9</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isValid(board, i, j, c)) &#123;</span><br><span class="line">                        <span class="comment">//Put c for this cell</span></span><br><span class="line">                        board[i][j] = c;</span><br><span class="line">                        <span class="comment">//If it's the solution return true</span></span><br><span class="line">                        <span class="keyword">if</span> (solve(board))</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">else</span>  <span class="comment">//otherwise backtracking</span></span><br><span class="line">                            board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//check row</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][col] != <span class="string">'.'</span> &amp;&amp; board[i][col] == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//check column</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][i] != <span class="string">'.'</span> &amp;&amp; board[row][i] == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//check 3*3 block</span></span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">3</span> * (row / <span class="number">3</span>) + i / <span class="number">3</span>][<span class="number">3</span> * (col / <span class="number">3</span>) + i % <span class="number">3</span>] != <span class="string">'.'</span></span><br><span class="line">            &amp;&amp; board[<span class="number">3</span> * (row / <span class="number">3</span>) + i / <span class="number">3</span>][<span class="number">3</span> * (col / <span class="number">3</span>) + i % <span class="number">3</span>] == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">There are two places can be improved in the isValid() method. See detail below:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Don't need to check whether the a cell in the row, col or region is not dot. Just check these cells are not c is enough. Since c will not be a '.'</span></span><br><span class="line"><span class="comment">Define region start row and region start col variables make the code a bit more readable and reduce 8 times duplicate computing in each call.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> regionRow = <span class="number">3</span> * (row / <span class="number">3</span>);  <span class="comment">//region start row</span></span><br><span class="line">    <span class="keyword">int</span> regionCol = <span class="number">3</span> * (col / <span class="number">3</span>);    <span class="comment">//region start col</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == c) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check row</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][i] == c) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check column</span></span><br><span class="line">        <span class="keyword">if</span> (board[regionRow + i / <span class="number">3</span>][regionCol + i % <span class="number">3</span>] == c) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check 3*3 block</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="778-Swim-in-Rising-Water🎂💎"><a href="#778-Swim-in-Rising-Water🎂💎" class="headerlink" title="778. Swim in Rising Water🎂💎"></a><a href="https://leetcode.com/problems/swim-in-rising-water/" target="_blank" rel="noopener">778. Swim in Rising Water🎂💎</a></h2><h3 id="Solution1-32"><a href="#Solution1-32" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> N = grid.length;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!visited.contains(N*N-<span class="number">1</span>)) &#123;</span><br><span class="line">            visited.clear();</span><br><span class="line">            dfs(grid, <span class="number">0</span>, <span class="number">0</span>, time, visited);</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> time, Set&lt;Integer&gt; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; grid.length - <span class="number">1</span> || j &lt; <span class="number">0</span> || j &gt; grid[<span class="number">0</span>].length - <span class="number">1</span> || grid[i][j] &gt; time || visited.contains(i*grid.length+j)) <span class="keyword">return</span>;</span><br><span class="line">        visited.add(i*grid.length+j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            dfs(grid, i+dir[<span class="number">0</span>], j+dir[<span class="number">1</span>], time, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="733-Flood-Fill✨"><a href="#733-Flood-Fill✨" class="headerlink" title="733. Flood Fill✨"></a><a href="https://leetcode.com/problems/flood-fill/" target="_blank" rel="noopener">733. Flood Fill✨</a></h2><h3 id="Solution1-33"><a href="#Solution1-33" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (image[sr][sc] == newColor) &#123;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fill(image, sr, sc, image[sr][sc], newColor);</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> color, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= image.length || j &lt; <span class="number">0</span> || j &gt;= image[<span class="number">0</span>].length || image[i][j] != color) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    image[i][j] = newColor;</span><br><span class="line">    fill(image, i + <span class="number">1</span>, j, color, newColor);</span><br><span class="line">    fill(image, i - <span class="number">1</span>, j, color, newColor);</span><br><span class="line">    fill(image, i, j + <span class="number">1</span>, color, newColor);</span><br><span class="line">    fill(image, i, j - <span class="number">1</span>, color, newColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1723-Find-Minimum-Time-to-Finish-All-Jobs🎃✨"><a href="#1723-Find-Minimum-Time-to-Finish-All-Jobs🎃✨" class="headerlink" title="1723. Find Minimum Time to Finish All Jobs🎃✨"></a><a href="https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/" target="_blank" rel="noopener">1723. Find Minimum Time to Finish All Jobs🎃✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: jobs = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">3</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: By assigning each person one job, the maximum time is <span class="number">3</span>.</span><br><span class="line"></span><br><span class="line">Input: jobs = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>], k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">11</span></span><br><span class="line">Explanation: Assign the jobs the following way:</span><br><span class="line">Worker <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span> (working time = <span class="number">1</span> + <span class="number">2</span> + <span class="number">8</span> = <span class="number">11</span>)</span><br><span class="line">Worker <span class="number">2</span>: <span class="number">4</span>, <span class="number">7</span> (working time = <span class="number">4</span> + <span class="number">7</span> = <span class="number">11</span>)</span><br><span class="line">The maximum working time is <span class="number">11</span>.</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009817/One-branch-cutting-trick-to-solve-three-LeetCode-questions" target="_blank" rel="noopener">https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009817/One-branch-cutting-trick-to-solve-three-LeetCode-questions</a></p>
<h3 id="Solution1-34"><a href="#Solution1-34" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>prune1: when we have current woker sum of jobs more than the global max, we stop<br>prune2: when we assign a new job to several wokers who has same work load, we only need to pick one, and stop others recursive call.<br>prune3: sort and start from big task then smaller one, we can stop ealier based on prune1</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTimeRequired</span><span class="params">(<span class="keyword">int</span>[] jobs, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(jobs);</span><br><span class="line">    dfs(jobs, jobs.length - <span class="number">1</span>, <span class="keyword">new</span> <span class="keyword">int</span>[k]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] jobs, <span class="keyword">int</span> pos, <span class="keyword">int</span>[] sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        res = Math.min(res, Arrays.stream(sum).max().getAsInt());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Arrays.stream(sum).max().getAsInt() &gt;= res) <span class="keyword">return</span>;           <span class="comment">//prune1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; sum[i] == sum[i - <span class="number">1</span>]) <span class="keyword">continue</span>;                  <span class="comment">//prune2</span></span><br><span class="line">        sum[i] += jobs[pos];</span><br><span class="line">        dfs(jobs, pos - <span class="number">1</span>, sum);</span><br><span class="line">        sum[i] -= jobs[pos];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="827-Making-A-Large-Island💎"><a href="#827-Making-A-Large-Island💎" class="headerlink" title="827. Making A Large Island💎"></a><a href="https://leetcode.com/problems/making-a-large-island/" target="_blank" rel="noopener">827. Making A Large Island💎</a></h2><h3 id="Solution1-35"><a href="#Solution1-35" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="526-Beautiful-Arrangement"><a href="#526-Beautiful-Arrangement" class="headerlink" title="526. Beautiful Arrangement"></a><a href="https://leetcode.com/problems/beautiful-arrangement/" target="_blank" rel="noopener">526. Beautiful Arrangement</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Suppose you have n integers labeled <span class="number">1</span> through n. <span class="function">A permutation of those n integers <span class="title">perm</span> <span class="params">(<span class="number">1</span>-indexed)</span> is considered a beautiful arrangement <span class="keyword">if</span> <span class="keyword">for</span> every <span class="title">i</span> <span class="params">(<span class="number">1</span> &lt;= i &lt;= n)</span>, either of the following is <span class="keyword">true</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1. perm[i] is divisible by i.</span></span><br><span class="line"><span class="function">2. i is divisible by perm[i].</span></span><br><span class="line"><span class="function">Given an integer n, return the number of the beautiful arrangements that you can construct.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Input: n </span>= <span class="number">2</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: </span><br><span class="line">The first beautiful arrangement is [<span class="number">1</span>,<span class="number">2</span>]:</span><br><span class="line">    - perm[<span class="number">1</span>] = <span class="number">1</span> is divisible by i = <span class="number">1</span></span><br><span class="line">    - perm[<span class="number">2</span>] = <span class="number">2</span> is divisible by i = <span class="number">2</span></span><br><span class="line">The second beautiful arrangement is [<span class="number">2</span>,<span class="number">1</span>]:</span><br><span class="line">    - perm[<span class="number">1</span>] = <span class="number">2</span> is divisible by i = <span class="number">1</span></span><br><span class="line">    - i = <span class="number">2</span> is divisible by perm[<span class="number">2</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-36"><a href="#Solution1-36" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] used = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    findArrangement(n, <span class="number">1</span>, used);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findArrangement</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> idx, <span class="keyword">int</span>[] used)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx &gt; n) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i] == <span class="number">0</span> &amp;&amp; (i % idx == <span class="number">0</span> || idx % i == <span class="number">0</span>)) &#123;</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            findArrangement(n, idx+<span class="number">1</span>, used);</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1718-Construct-the-Lexicographically-Largest-Valid-Sequence🎃"><a href="#1718-Construct-the-Lexicographically-Largest-Valid-Sequence🎃" class="headerlink" title="1718. Construct the Lexicographically Largest Valid Sequence🎃"></a><a href="https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/" target="_blank" rel="noopener">1718. Construct the Lexicographically Largest Valid Sequence🎃</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The integer <span class="number">1</span> occurs once in the sequence.</span><br><span class="line">Each integer between <span class="number">2</span> and n occurs twice in the sequence.</span><br><span class="line">For every integer i between <span class="number">2</span> and n, the distance between the two occurrences of i is exactly i.</span><br><span class="line">    </span><br><span class="line">Input: n = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">Explanation: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] is also a valid sequence, but [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>] is the lexicographically largest valid sequence.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-37"><a href="#Solution1-37" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Since ‘n’ ranges between 1 to 20 , we can afford a solution of exponential time complexity.</p>
<ol>
<li>We try to construct our result array by taking the largest number possible at each point.</li>
<li>Except 1 (since its count is 1) whenever we place an integer in a particular position, we also place the second occurence of that integer in our temporary array. This is because in the question it is mentioned that : <em>For every integer i between 2 and n, the distance between the two occurrences of i is exactly i.</em></li>
<li>As soon as we reach a valid solution that follows all the constraints we return ‘true’. This indicates we do not need to continue our search. (This is an important step as otherwise we will get TLE).</li>
<li>Since we start from largest possible number at each step once we reach a valid solution that is our answer.</li>
</ol>
<p><strong>Time Complexity</strong> : Ideally it should be (n!) since we are using backtracking and trying to find out all possible solutions.<br>But because of this constraint : <strong>For every integer i between 2 and n, the distance between the two occurrences of i is exactly i</strong>, the number of permutations under consideration is reducing greatly.<br>Also since we are trying to find out the <strong>lexicographically largest sequence</strong> we stop as soon as we find a valid solution (early stop).</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] constructDistancedSequence(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] ans =  <span class="keyword">new</span> <span class="keyword">int</span>[n*<span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">    getSequence(<span class="number">0</span>, ans, visited, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//return boolean mean can or can not form assign all value to ans ans idx add to ans.length</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getSequence</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] ans, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == ans.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans[idx] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// value already assigned in this position. So go ahead with the next index</span></span><br><span class="line">        <span class="keyword">return</span> getSequence(idx+<span class="number">1</span>, ans, visited, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// start from n to 1 since we need to find out the lexicographically largest sequence</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            ans[idx] = i;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getSequence(idx+<span class="number">1</span>, ans, visited, n)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx + i &lt; ans.length &amp;&amp; ans[idx + i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// assigning the second occurence of i in the desired position(current index + i )</span></span><br><span class="line">                ans[idx + i] = i;</span><br><span class="line">                <span class="comment">// largest possible sequence satisfying the given conditions found</span></span><br><span class="line">                <span class="keyword">if</span> (getSequence(idx+<span class="number">1</span>, ans, visited, n)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                ans[idx + i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            ans[idx] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/200/" rel="tag"># 200</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/12/Princeton%20Algorithms%20week2/" rel="prev" title="Princeton Algorithms week2">
      <i class="fa fa-chevron-left"></i> Princeton Algorithms week2
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/21/Princeton%20Algorithms%20week3/" rel="next" title="Princeton Algorithms week3">
      Princeton Algorithms week3 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Searching"><span class="nav-number">1.</span> <span class="nav-text">Searching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BFS"><span class="nav-number">2.</span> <span class="nav-text">BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#547-Number-of-Provinces⭐"><span class="nav-number">2.1.</span> <span class="nav-text">547. Number of Provinces⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1"><span class="nav-number">2.1.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2"><span class="nav-number">2.1.2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Old-version-547-Friend-Circles"><span class="nav-number">2.1.3.</span> <span class="nav-text">Old version 547. Friend Circles</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-1"><span class="nav-number">2.1.4.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rotting-Oranges⭐"><span class="nav-number">2.2.</span> <span class="nav-text">Rotting Oranges⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-2"><span class="nav-number">2.2.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#127-Word-Ladder⭐💜"><span class="nav-number">2.3.</span> <span class="nav-text">127. Word Ladder⭐💜</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-3"><span class="nav-number">2.3.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsolved-126-Word-Ladder-II⭐"><span class="nav-number">2.3.2.</span> <span class="nav-text">Unsolved 126. Word Ladder II⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-4"><span class="nav-number">2.3.3.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#675-Cut-Off-Trees-for-Golf-Event⭐"><span class="nav-number">2.4.</span> <span class="nav-text">675. Cut Off Trees for Golf Event⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-5"><span class="nav-number">2.4.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1091-Shortest-Path-in-Binary-Matrix🎂⭐"><span class="nav-number">2.5.</span> <span class="nav-text">1091. Shortest Path in Binary Matrix🎂⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solition1"><span class="nav-number">2.5.1.</span> <span class="nav-text">Solition1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#279-Perfect-Squares✨"><span class="nav-number">2.6.</span> <span class="nav-text">279.Perfect Squares✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-6"><span class="nav-number">2.6.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-1"><span class="nav-number">2.6.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#909-Snakes-and-Ladders🎂✨"><span class="nav-number">2.7.</span> <span class="nav-text">909. Snakes and Ladders🎂✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-7"><span class="nav-number">2.7.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-2"><span class="nav-number">2.7.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#752-Open-the-Lock✨"><span class="nav-number">2.8.</span> <span class="nav-text">752. Open the Lock✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-8"><span class="nav-number">2.8.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-3"><span class="nav-number">2.8.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#490-The-Maze✨"><span class="nav-number">2.9.</span> <span class="nav-text">490. The Maze✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-9"><span class="nav-number">2.9.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-4"><span class="nav-number">2.9.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#773-Sliding-Puzzle🎂"><span class="nav-number">2.10.</span> <span class="nav-text">773. Sliding Puzzle🎂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-10"><span class="nav-number">2.10.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-5"><span class="nav-number">2.10.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-913-Cat-and-Mouse🎂"><span class="nav-number">2.11.</span> <span class="nav-text">Unsolved 913. Cat and Mouse🎂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-1345-Jump-Game-IV🎂"><span class="nav-number">2.12.</span> <span class="nav-text">Unsolved 1345. Jump Game IV🎂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix🎂"><span class="nav-number">2.13.</span> <span class="nav-text">Unsolved 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix🎂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination🎂✨"><span class="nav-number">2.14.</span> <span class="nav-text">Unsolved 1293. Shortest Path in a Grid with Obstacles Elimination🎂✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-310-Minimum-Height-Trees🎂✨"><span class="nav-number">2.15.</span> <span class="nav-text">Unsolved 310. Minimum Height Trees🎂✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-864-Shortest-Path-to-Get-All-Keys🎂"><span class="nav-number">2.16.</span> <span class="nav-text">Unsolved 864. Shortest Path to Get All Keys🎂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-11"><span class="nav-number">2.16.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DFS"><span class="nav-number">3.</span> <span class="nav-text">DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1192-Critical-Connections-in-a-Network⭐"><span class="nav-number">3.1.</span> <span class="nav-text">1192. Critical Connections in a Network⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-12"><span class="nav-number">3.1.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-6"><span class="nav-number">3.1.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-529-Minesweeper⭐"><span class="nav-number">3.2.</span> <span class="nav-text">Unsolved 529. Minesweeper⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-13"><span class="nav-number">3.2.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-7"><span class="nav-number">3.2.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-417-Pacific-Atlantic-Water-Flow🎂⭐💎"><span class="nav-number">3.3.</span> <span class="nav-text">Unsolved 417. Pacific Atlantic Water Flow🎂⭐💎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-14"><span class="nav-number">3.3.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#200-Number-of-Islands💜⭐"><span class="nav-number">3.4.</span> <span class="nav-text">200. Number of Islands💜⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-15"><span class="nav-number">3.4.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-8"><span class="nav-number">3.4.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#694-Number-of-Distinct-Islands⭐"><span class="nav-number">3.5.</span> <span class="nav-text">694. Number of Distinct Islands⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-16"><span class="nav-number">3.5.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-9"><span class="nav-number">3.5.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Universal-sink⭐⭐"><span class="nav-number">3.6.</span> <span class="nav-text">Universal sink⭐⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-17"><span class="nav-number">3.6.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#277-Find-the-celebrity⭐⭐"><span class="nav-number">3.6.2.</span> <span class="nav-text">277. Find the celebrity⭐⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-18"><span class="nav-number">3.6.3.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-10"><span class="nav-number">3.6.4.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution3"><span class="nav-number">3.6.5.</span> <span class="nav-text">Solution3:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-332-Reconstruct-Itinerary🎂⭐"><span class="nav-number">3.7.</span> <span class="nav-text">Unsolved 332. Reconstruct Itinerary🎂⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-19"><span class="nav-number">3.7.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-11"><span class="nav-number">3.7.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-1102-Path-With-Maximum-Minimum-Value⭐"><span class="nav-number">3.8.</span> <span class="nav-text">Unsolved 1102. Path With Maximum Minimum Value⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#695-Max-Area-of-Island✨"><span class="nav-number">3.9.</span> <span class="nav-text">695. Max Area of Island✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-20"><span class="nav-number">3.9.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#130-Surrounded-Regions✨"><span class="nav-number">3.10.</span> <span class="nav-text">130.Surrounded Regions✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-21"><span class="nav-number">3.10.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-12"><span class="nav-number">3.10.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#130-Surrounded-Regions✨-1"><span class="nav-number">3.11.</span> <span class="nav-text">130. Surrounded Regions✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-22"><span class="nav-number">3.11.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#403-Frog-Jump✨"><span class="nav-number">3.12.</span> <span class="nav-text">403. Frog Jump✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-23"><span class="nav-number">3.12.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#286-Walls-and-Gates✨"><span class="nav-number">3.13.</span> <span class="nav-text">286. Walls and Gates✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-l"><span class="nav-number">3.13.1.</span> <span class="nav-text">Solution1:l</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-13"><span class="nav-number">3.13.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#01-Matrix✨"><span class="nav-number">3.14.</span> <span class="nav-text">01 Matrix✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-24"><span class="nav-number">3.14.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#419-Battleships-in-a-Board💎"><span class="nav-number">3.15.</span> <span class="nav-text">419. Battleships in a Board💎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-25"><span class="nav-number">3.15.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Soltuion2"><span class="nav-number">3.15.2.</span> <span class="nav-text">Soltuion2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#841-Keys-and-Rooms✨"><span class="nav-number">3.16.</span> <span class="nav-text">841. Keys and Rooms✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-26"><span class="nav-number">3.16.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#494-Target-Sum✨"><span class="nav-number">3.17.</span> <span class="nav-text">494. Target Sum✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-27"><span class="nav-number">3.17.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsolved-Solution2"><span class="nav-number">3.17.2.</span> <span class="nav-text">Unsolved Solution2:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Backtracking"><span class="nav-number">4.</span> <span class="nav-text">Backtracking</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#79-Word-Search⭐"><span class="nav-number">4.1.</span> <span class="nav-text">79. Word Search⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-28"><span class="nav-number">4.1.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-14"><span class="nav-number">4.1.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-N-Queens✨"><span class="nav-number">4.2.</span> <span class="nav-text">51. N-Queens✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-29"><span class="nav-number">4.2.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-15"><span class="nav-number">4.2.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-Valid-Sudoku⭐"><span class="nav-number">4.3.</span> <span class="nav-text">36. Valid Sudoku⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-30"><span class="nav-number">4.3.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-16"><span class="nav-number">4.3.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-Sudoku-Solver💜✨"><span class="nav-number">4.4.</span> <span class="nav-text">37. Sudoku Solver💜✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution0"><span class="nav-number">4.4.1.</span> <span class="nav-text">Solution0:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-31"><span class="nav-number">4.4.2.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-17"><span class="nav-number">4.4.3.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#778-Swim-in-Rising-Water🎂💎"><span class="nav-number">4.5.</span> <span class="nav-text">778. Swim in Rising Water🎂💎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-32"><span class="nav-number">4.5.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#733-Flood-Fill✨"><span class="nav-number">4.6.</span> <span class="nav-text">733. Flood Fill✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-33"><span class="nav-number">4.6.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1723-Find-Minimum-Time-to-Finish-All-Jobs🎃✨"><span class="nav-number">4.7.</span> <span class="nav-text">1723. Find Minimum Time to Finish All Jobs🎃✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-34"><span class="nav-number">4.7.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#827-Making-A-Large-Island💎"><span class="nav-number">4.8.</span> <span class="nav-text">827. Making A Large Island💎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-35"><span class="nav-number">4.8.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#526-Beautiful-Arrangement"><span class="nav-number">4.9.</span> <span class="nav-text">526. Beautiful Arrangement</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-36"><span class="nav-number">4.9.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1718-Construct-the-Lexicographically-Largest-Valid-Sequence🎃"><span class="nav-number">4.10.</span> <span class="nav-text">1718. Construct the Lexicographically Largest Valid Sequence🎃</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-37"><span class="nav-number">4.10.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dejavu"
      src="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
  <p class="site-author-name" itemprop="name">Dejavu</p>
  <div class="site-description" itemprop="description">Stay gold</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Dejavu-19" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Dejavu-19" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/liu.kunling19@gmail.com" title="E-Mail → liu.kunling19@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dejavu</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false});</script></body>
</html>
