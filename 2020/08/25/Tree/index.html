<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dejavi-19.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Binary TreeBranch Sums(AE)⭐Go through the tree and return an array consists of  the branch sums of each branch.  Use DFS, call the recursive function, and keep track of running sum.  First setup an Ar">
<meta property="og:type" content="article">
<meta property="og:title" content="Tree">
<meta property="og:url" content="https://dejavi-19.github.io/2020/08/25/Tree/index.html">
<meta property="og:site_name" content="Dejavu&#39;s Notebook">
<meta property="og:description" content="Binary TreeBranch Sums(AE)⭐Go through the tree and return an array consists of  the branch sums of each branch.  Use DFS, call the recursive function, and keep track of running sum.  First setup an Ar">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_113.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png">
<meta property="og:image" content="https://zxi.mytechroad.com/blog/wp-content/uploads/2018/03/560-ep176.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/04/09/1308_example_1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/08/29/main.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/08/29/updown.jpg">
<meta property="og:image" content="https://assets.leetcode.com/users/images/6fca1ddd-2791-444a-9f94-75b4a49913f9_1601421082.2188914.png">
<meta property="og:image" content="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/Figures/103/103_BFS.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/11/boundary1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/11/boundary2.jpg">
<meta property="og:image" content="https://leetcode.com/problems/boundary-of-binary-tree/Figures/545_Preorder.png">
<meta property="og:image" content="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/Figures/145_transverse.png">
<meta property="og:image" content="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/Figures/297_BST.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/07/01/screen-shot-2019-07-01-at-53836-pm.png">
<meta property="og:image" content="https://leetcode.com/problems/inorder-successor-in-bst-ii/Figures/510/case.png">
<meta property="og:image" content="https://leetcode.com/problems/inorder-successor-in-bst-ii/Figures/510/casenull.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/05/31/1368_1_a2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/05/31/1368_1_b.png">
<meta property="og:image" content="https://leetcode.com/problems/recover-binary-search-tree/Figures/99/iinorde.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/01/25/bst_deletion_case_1.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/01/25/bst_deletion_case_2.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/01/25/bst_deletion_case_3.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/08/17/linked.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/JiawenQi98/PrampPractice/master/Largest%20Smaller%20BST%20Key/example.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/01/30/sample_1_1709.png">
<meta property="og:image" content="https://leetcode.com/problems/design-add-and-search-words-data-structure/Figures/211/trie.png">
<meta property="og:image" content="https://leetcode.com/problems/design-add-and-search-words-data-structure/Figures/211/search2.png">
<meta property="og:image" content="https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/Figures/421/trie.png">
<meta property="og:image" content="https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/Figures/421/max_xor.png">
<meta property="article:published_time" content="2020-08-25T02:15:45.176Z">
<meta property="article:modified_time" content="2021-02-02T07:47:01.421Z">
<meta property="article:author" content="Dejavu">
<meta property="article:tag" content="200">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_113.png">

<link rel="canonical" href="https://dejavi-19.github.io/2020/08/25/Tree/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Tree | Dejavu's Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/Dejavu-19" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dejavu's Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Alea iacta est</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首&emsp;&emsp;页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于博主</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标&emsp;&emsp;签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分&emsp;&emsp;类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归&emsp;&emsp;档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/08/25/Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Tree
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 11:15:45" itemprop="dateCreated datePublished" datetime="2020-08-25T11:15:45+09:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-02 16:47:01" itemprop="dateModified" datetime="2021-02-02T16:47:01+09:00">2021-02-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><h2 id="Branch-Sums-AE-⭐"><a href="#Branch-Sums-AE-⭐" class="headerlink" title="Branch Sums(AE)⭐"></a>Branch Sums(AE)⭐</h2><p>Go through the tree and return an array consists of  the branch sums of each branch.</p>
<ol>
<li><p>Use <strong><code>DFS</code></strong>, call the recursive function, and keep track of running sum.</p>
</li>
<li><p>First setup an ArrayList <strong><code>nums</code></strong> to store the return value, because <strong><code>return is an Array</code></strong></p>
</li>
<li><p>Built a helper method take (tree, runningSum, nums) as parameter, add the target value to nums</p>
</li>
<li><p>while the left &amp; right both are null, we will say we have find the <strong><code>leaf node</code></strong>, the <strong>runningSum at this moment is Branch Sums</strong>, add this value to the sums; if not, we will call the method recursively. A special situation need to note, is that only one child node of current node, to deal with this, add if (node == null) return;</p>
</li>
<li><p>recursive:</p>
<p>O(N) T</p>
<p>O(log N) S</p>
</li>
</ol>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the class of the input root. Do not edit it.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    BinaryTree left;</span><br><span class="line">    BinaryTree right;</span><br><span class="line"></span><br><span class="line">    BinaryTree(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">branchSums</span><span class="params">(BinaryTree root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">    List&lt;Integer&gt; sums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    calculateBranchSums(root, <span class="number">0</span>, sums);</span><br><span class="line">    <span class="keyword">return</span> sums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calculateBranchSums</span><span class="params">(BinaryTree node, <span class="keyword">int</span> runningSum, List&lt;Integer&gt; sums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;  <span class="comment">//base case</span></span><br><span class="line">    runningSum += node.value;  <span class="comment">//keep updating the sum of value in the path</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;  <span class="comment">//if leaf node, add it to the return list</span></span><br><span class="line">        sums.add(runningSum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    calculateBranchSums(node.left, runningSum, sums);  <span class="comment">//going left recursively</span></span><br><span class="line">    calculateBranchSums(node.right, runningSum, sums);  <span class="comment">//going right recursively</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="112-Path-Sum✨"><a href="#112-Path-Sum✨" class="headerlink" title="112. Path Sum✨"></a><a href="https://leetcode.com/problems/path-sum/description/" target="_blank" rel="noopener">112. Path Sum✨</a></h3><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. </p>
<p>For example: Given the below binary tree and sum = 22, return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the below binary tree and sum = <span class="number">22</span>,</span><br><span class="line">              <span class="number">5</span></span><br><span class="line">             / \</span><br><span class="line">            <span class="number">4</span>   <span class="number">8</span></span><br><span class="line">           /   / \</span><br><span class="line">          <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></span><br><span class="line">         /  \      \</span><br><span class="line">        <span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>, as there exist a root-to-leaf path <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">11</span>-&gt;<span class="number">2</span> which sum is <span class="number">22</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：递归求解。</li>
<li>递推条件：左子树为真或右子树为真。</li>
<li>结束条件：途中不断添加当前元素值，如果到叶子结点且和达到目标值，则为真；如果当前元素为空则为假；</li>
<li>Time complexity : we visit each node exactly once, thus the time complexity is \mathcal{O}(N)O(<em>N</em>), where N<em>N</em> is the number of nodes.</li>
<li>Space complexity : in the worst case, the tree is completely unbalanced, <em>e.g.</em> each node has only one child node, the recursion call would occur N<em>N</em> times (the height of the tree), therefore the storage to keep the call stack would be \mathcal{O}(N)O(<em>N</em>). But in the best case (the tree is completely balanced), the height of the tree would be \log(N)log(<em>N</em>). Therefore, the space complexity in this case would be \mathcal{O}(\log(N))O(log(<em>N</em>)).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root, <span class="number">0</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> curSum, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    curSum += root.val;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> curSum == sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, curSum, sum) || hasPathSum(root.right, curSum, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="113-Path-Sum-II🎂✨"><a href="#113-Path-Sum-II🎂✨" class="headerlink" title="113. Path Sum II🎂✨"></a><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. Path Sum II🎂✨</a></h3><p><img src="https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_113.png" alt=""></p>
<h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><ol>
<li>思路：与上题思路一致，只不过过程中通过创建新 List 不断记录新路径。如果存在目标路径，则把该 List 添加到结果中。</li>
<li>Time Complexity: O(N^2) where N<em>N</em> are the number of nodes in a tree. In the worst case, we could have a complete binary tree and if that is the case, then there would be N/2<em>N</em>/2 leafs. For every leaf, we perform a potential O(N)<em>O</em>(<em>N</em>) operation of copying over the <code>pathNodes</code> nodes to a new list to be added to the final <code>pathsList</code>. Hence, the complexity in the worst case could be O(N^2)<em>O</em>(<em>N</em>2).</li>
<li>Space Complexity: O(logN). The space complexity, like many other problems is debatable here. I personally choose <em>not</em> to consider the space occupied by the <code>output</code> in the space complexity. So, all the <code>new</code> lists that we create for the paths are actually a part of the output and hence, don’t count towards the final space complexity. The only <em>additional</em> space that we use is the <code>pathNodes</code> list to keep track of nodes along a branch.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;(); </span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </span><br><span class="line">    pathSum(root, sum, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    cur.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum)&#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pathSum(root.left, sum - root.val, cur, ans);</span><br><span class="line">        pathSum(root.right, sum - root.val, cur, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    findPaths(root, sum, cur, paths);</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPaths</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; paths)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//main recursive</span></span><br><span class="line">    cur.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == root.val) &#123;</span><br><span class="line">        paths.add(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    findPaths(root.left, sum - root.val, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur), paths);</span><br><span class="line">    findPaths(root.right, sum - root.val, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur), paths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="437-Path-Sum-III⭐"><a href="#437-Path-Sum-III⭐" class="headerlink" title="437. Path Sum III⭐"></a><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. Path Sum III⭐</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [<span class="number">10</span>,<span class="number">5</span>,-<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="keyword">null</span>,<span class="number">11</span>,<span class="number">3</span>,-<span class="number">2</span>,<span class="keyword">null</span>,<span class="number">1</span>], sum = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">      <span class="number">10</span></span><br><span class="line">     /  \</span><br><span class="line">    <span class="number">5</span>   -<span class="number">3</span></span><br><span class="line">   / \    \</span><br><span class="line">  <span class="number">3</span>   <span class="number">2</span>   <span class="number">11</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>  -<span class="number">2</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Return <span class="number">3</span>. The paths that sum to <span class="number">8</span> are:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.  <span class="number">5</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">2</span>.  <span class="number">5</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">3</span>. -<span class="number">3</span> -&gt; <span class="number">11</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Recursion</p>
</li>
<li><p>路径不一定以 root 开头，也不一定以 leaf 结尾，但是必须连续。</p>
</li>
<li><p>Typical recursive DFS.</p>
<p>Time complexity: O(n^2)</p>
<p>Space complexity: O(n)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pathSumStartWithRoot</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == sum) ret++;</span><br><span class="line">    ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Running Prefix Sum</li>
<li>Prefix sum is a sum of the current value with all previous elements starting from the beginning of the structure.</li>
<li>So the idea is similar as Two sum, using HashMap to store ( key : the prefix sum, value : how many ways get to this prefix sum) , and whenever reach a node, we check if prefix sum - target exists in hashmap or not, if it does, we added up the ways of prefix sum - target into res.</li>
<li>For instance : in one path we have 1,2,-1,-1,2, then the prefix sum will be: 1, 3, 2, 1, 3, let’s say we want to find target sum is 2, then we will have{2}, {1,2,-1}, {2,-1,-1,2} and {2}ways.</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(h)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, Integer&gt; sums = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    sums.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    traverse(root, <span class="number">0</span>, sum, sums);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> cur, <span class="keyword">int</span> sum, Map&lt;Integer, Integer&gt; sums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    cur += root.val;</span><br><span class="line">    ans += sums.getOrDefault(cur - sum, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    sums.put(cur, sums.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    traverse(root.left, cur, sum, sums);</span><br><span class="line">    traverse(root.right, cur, sum, sums);</span><br><span class="line">    sums.put(cur, sums.get(cur) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; preSum = <span class="keyword">new</span> HashMap();</span><br><span class="line">    preSum.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> helper(root, <span class="number">0</span>, sum, preSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> currSum, <span class="keyword">int</span> target, HashMap&lt;Integer, Integer&gt; preSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currSum += root.val;</span><br><span class="line">    <span class="keyword">int</span> res = preSum.getOrDefault(currSum - target, <span class="number">0</span>);</span><br><span class="line">    preSum.put(currSum, preSum.getOrDefault(currSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    res += helper(root.left, currSum, target, preSum) + helper(root.right, currSum, target, preSum);</span><br><span class="line">    preSum.put(currSum, preSum.get(currSum) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1022-Sum-of-Root-To-Leaf-Binary-Numbers⭐"><a href="#1022-Sum-of-Root-To-Leaf-Binary-Numbers⭐" class="headerlink" title="1022. Sum of Root To Leaf Binary Numbers⭐"></a><a href="https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/" target="_blank" rel="noopener">1022. Sum of Root To Leaf Binary Numbers⭐</a></h2><p><img src="https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">22</span></span><br><span class="line">Explanation: (<span class="number">100</span>) + (<span class="number">101</span>) + (<span class="number">110</span>) + (<span class="number">111</span>) = <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> = <span class="number">22</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    inorder(root, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, String cur)</span> </span>&#123;</span><br><span class="line">    cur = cur + root.val;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ans += Integer.valueOf(cur, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inorder(root.left, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inorder(root.right, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Easily decompose this problem into 2 sub-problem:</p>
<ol>
<li>Find all path from root to leaves. DFS recursion should help do that.</li>
<li>Transform a path from base to base 10.</li>
</ol>
<p>You can do this separately, and it will be a <code>O(N^2)</code> solution.<br>In my solution, I combine them together.</p>
<p>Explanation:</p>
<p>We recursively pass the current value of path to the children.<br>If <code>root == null</code>, no value, return 0.<br>If <code>root != null</code>,<br>we double the value from its parent and add the node’s value,<br>like the process of transforming base 2 to base 10.</p>
<p>In the end of recursion,<br>if <code>root.left == root.right == null</code>,<br>return the current <code>val</code>.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    val = val*<span class="number">2</span> + root.val;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ans += val;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left, val);</span><br><span class="line">    dfs(root.right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Prefix-Sum"><a href="#Prefix-Sum" class="headerlink" title="Prefix Sum"></a>Prefix Sum</h2><h3 id="560-Subarray-Sum-Equals-K✨"><a href="#560-Subarray-Sum-Equals-K✨" class="headerlink" title="560. Subarray Sum Equals K✨"></a><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. Subarray Sum Equals K✨</a></h3><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of continuous subarrays whose sum equals to <code>k</code></em>.</p>
<p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2018/03/560-ep176.png" alt=""></p>
<h3 id="Soluiton0"><a href="#Soluiton0" class="headerlink" title="Soluiton0:"></a>Soluiton0:</h3><ol>
<li>Brute force, O(n^3) O(1)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">            sum += nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">check each sum</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>计算prefix，储存在数组， 然后循环里子数组和是prefix[j] - prefix[i]</li>
<li>Time O(n^2) Space O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j) &#123;</span><br><span class="line">        sum = prefix[j] - prefix[i]; <span class="comment">//O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];  <span class="comment">//0 -&gt; 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        sums[i] = sums[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">//数组长度可以是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) </span><br><span class="line">            <span class="keyword">if</span> (sums[j+<span class="number">1</span>] - sums[i] == k) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>HashTable储存目前为止prefixsum出现过多少次</li>
<li>Time O(n) Space O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//base case, 初始化，0的初始化为1次</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    counts.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="keyword">if</span> (counts.containsKey(sum - k))</span><br><span class="line">            ans += counts.get(sum - k);</span><br><span class="line">        counts.put(sum, counts.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="523-Continuous-Subarray-Sum🎂✨"><a href="#523-Continuous-Subarray-Sum🎂✨" class="headerlink" title="523. Continuous Subarray Sum🎂✨"></a><a href="https://leetcode.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">523. Continuous Subarray Sum🎂✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">23</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>],  k = <span class="number">6</span></span><br><span class="line">Output: True</span><br><span class="line">Explanation: Because [<span class="number">2</span>, <span class="number">4</span>] is a continuous subarray of size <span class="number">2</span> and sums up to <span class="number">6</span>.</span><br><span class="line">    </span><br><span class="line">Input: [<span class="number">23</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>],  k=<span class="number">6</span></span><br><span class="line">Output: True</span><br><span class="line">Explanation: Because [<span class="number">23</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>] is an continuous subarray of size <span class="number">5</span> and sums up to <span class="number">42</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Brute Force</li>
<li>consider every possible subarray of size greater than or equal to 2, find out its sum by iterating over the elements of the subarray, and then we check if the sum obtained is an integer multiple of the given k.</li>
<li>Time complexity : O(n^3)<em>O</em>(<em>n</em>3). Three for loops iterating over the array are used.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant extra space is used.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; start++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt; n; end++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == k || (sum != <span class="number">0</span> &amp;&amp; sum % k == <span class="number">0</span>)) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Better Brute Force(Prefix sum)</li>
<li>Time complexity : O(n^2)<em>O</em>(<em>n</em>2). Two for loops are used for considering every subarray possible.</li>
<li>Space complexity : O(n)<em>O</em>(<em>n</em>). sum<em>s<strong>u</strong>m</em> array of size n<em>n</em> is used.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    sums[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sums[i] = sums[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; start++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start+<span class="number">1</span>; end &lt; n; end++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = sums[end] - sums[start] + nums[start];</span><br><span class="line">            <span class="keyword">if</span> (sum == k || (sum != <span class="number">0</span>) &amp;&amp; (sum % k == <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Prefix sum updated version. Using HashMap</li>
<li>We iterate through the input array exactly once, keeping track of the running sum mod k of the elements in the process. If we find that a running sum value at index j has been previously seen before in some earlier index i in the array, then we know that the sub-array (i,j] contains a desired sum.</li>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). Only one traversal of the array nums<em>n<strong>u</strong>m**s</em> is done.</li>
<li>Space complexity : O(min(n,k))<em>O</em>(<em>m<strong>i</strong>n</em>(<em>n</em>,<em>k</em>)). The HashMap can contain upto min(n,k)<em>m<strong>i</strong>n</em>(<em>n</em>,<em>k</em>) different pairings.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Key point: if we can find any two subarray of prefix sum have same mod value, then their difference MUST be</span></span><br><span class="line"><span class="comment"> * divisible by k. So we can use a map to store mod value of each prefix sum in map, with its index. Then check</span></span><br><span class="line"><span class="comment"> * if map contains the same mod value with size &gt; 2 when we have new mod value in every iteration */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">//hash map store (sum%k, index)</span></span><br><span class="line">    <span class="comment">// corner case: if the very first subarray with first two numbers in array could form the result, we need to </span></span><br><span class="line">    <span class="comment">// put mod value 0 and index -1 to make it as a true case</span></span><br><span class="line">    map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        curSum += nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// corner case: k CANNOT be 0 when we use a number mod k</span></span><br><span class="line">        <span class="keyword">if</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">            curSum = curSum % k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(curSum)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - map.get(curSum) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(curSum, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="724-Find-Pivot-Index"><a href="#724-Find-Pivot-Index" class="headerlink" title="724. Find Pivot Index"></a><a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">724. Find Pivot Index</a></h3><p>Given an array of integers <code>nums</code>, write a method that returns the “pivot” index of this array.</p>
<p>We define the pivot index as the index where the sum of all the numbers to the left of the index is equal to the sum of all the numbers to the right of the index.</p>
<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>
<h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//initial prefix sum array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == sum - left - nums[i]) <span class="keyword">return</span> i;</span><br><span class="line">        left += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Max-Path-Sum-AE-⭐"><a href="#Max-Path-Sum-AE-⭐" class="headerlink" title="Max Path Sum(AE)⭐"></a>Max Path Sum(AE)⭐</h2><p>“Given a <strong>non-empty</strong> binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Only calculate the one brach max path</span><br><span class="line">MPS(T):</span><br><span class="line">	LSB,LS = mps(L);  <span class="comment">//</span></span><br><span class="line">	RSB,RS = mps(R);</span><br><span class="line">	MCSB = max(LSB, RSB);  <span class="comment">//max child sum branch</span></span><br><span class="line">	MSB = max(MCSB + V, V);</span><br><span class="line">	MST = max(MSB, LSB + V + RSB);</span><br><span class="line">	RMPS = max(LS, RS, MST);</span><br><span class="line">    <span class="keyword">return</span> (MSB, RMPS)</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(BinaryTree tree)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; maxSumArray = findMaxSum(tree);</span><br><span class="line">    <span class="keyword">return</span> maxSumArray.get(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findMaxSum</span><span class="params">(BinaryTree tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">0</span>, Integer.MIN_VALUE));</span><br><span class="line">    List&lt;Integer&gt; leftMaxSumArray = findMaxSum(tree.left);</span><br><span class="line">    Integer leftMaxSumAsBranch = leftMaxSumArray.get(<span class="number">0</span>);</span><br><span class="line">    Integer leftMaxPathSum = leftMaxSumArray.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; rightMaxSumArray = findMaxSum(tree.right);</span><br><span class="line">    Integer rightMaxSumAsBranch = rightMaxSumArray.get(<span class="number">0</span>);</span><br><span class="line">    Integer rightMaxPathSum = rightMaxSumArray.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Integer maxChildSumAsBranch = Math.max(leftMaxSumAsBranch, rightMaxSumAsBranch);</span><br><span class="line">    Integer maxSumAsBranch = Math.max(maxChildSumAsBranch + tree.value, tree.value);</span><br><span class="line">    Integer maxSumAsRootNode = Math.max(leftMaxSumAsBranch + tree.value + rightMaxSumAsBranch, maxSumAsBranch);</span><br><span class="line">    <span class="keyword">int</span> maxPathSum = Math.max(leftMaxPathSum, Math.max(rightMaxPathSum, maxSumAsRootNode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(maxSumAsBranch, maxPathSum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="124-Binary-Tree-Maximum-Path-Sum💜⭐"><a href="#124-Binary-Tree-Maximum-Path-Sum💜⭐" class="headerlink" title="124. Binary Tree Maximum Path Sum💜⭐"></a><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. Binary Tree Maximum Path Sum💜⭐</a></h3><h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：遍历时记录每一个点的最值。最值有三种，从左、右子树到当前和从左子树经过当前再到右子树。O(n)</li>
<li>Time complexity: \mathcal{O}(N)O(<em>N</em>), where <code>N</code> is number of nodes, since we visit each node not more than 2 times.</li>
<li>Space complexity: \mathcal{O}(H)O(<em>H</em>), where H<em>H</em> is a tree height, to keep the recursion stack. In the average case of balanced tree, the tree height H = \log N<em>H</em>=log<em>N</em>, in the worst case of skewed tree, H = N<em>H</em>=<em>N</em>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxValue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    maxValue = Integer.MIN_VALUE;</span><br><span class="line">    maxPathDown(root);</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathDown</span><span class="params">(TreeNode node)</span> </span>&#123;  <span class="comment">//single path</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//post order pattern</span></span><br><span class="line">    <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, maxPathDown(node.left));  <span class="comment">//node value can be negative, so compare with 0</span></span><br><span class="line">    <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, maxPathDown(node.right));</span><br><span class="line">    maxValue = Math.max(maxValue, left + right + node.val);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1120-Maximum-Average-Subtree⭐"><a href="#1120-Maximum-Average-Subtree⭐" class="headerlink" title="1120. Maximum Average Subtree⭐"></a><a href="https://leetcode.com/problems/maximum-average-subtree/" target="_blank" rel="noopener">1120. Maximum Average Subtree⭐</a></h3><p><img src="https://assets.leetcode.com/uploads/2019/04/09/1308_example_1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">6.00000</span></span><br><span class="line">Explanation: </span><br><span class="line">For the node with value = <span class="number">5</span> <span class="function">we have an average <span class="title">of</span> <span class="params">(<span class="number">5</span> + <span class="number">6</span> + <span class="number">1</span>)</span> / 3 </span>= <span class="number">4</span>.</span><br><span class="line">For the node with value = <span class="number">6</span> we have an average of <span class="number">6</span> / <span class="number">1</span> = <span class="number">6</span>.</span><br><span class="line">For the node with value = <span class="number">1</span> we have an average of <span class="number">1</span> / <span class="number">1</span> = <span class="number">1</span>.</span><br><span class="line">So the answer is <span class="number">6</span> which is the maximum.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Recursion dfs</li>
<li>Time &amp; space: O(n), n is the <code>#</code> of nodes in the tree.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> ans = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">maximumAverageSubtree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//node[0] = sum of subtree values, node[1] = subtree nodes number</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] dfs(TreeNode root) &#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] left = dfs(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = dfs(root.right);</span><br><span class="line">    <span class="keyword">int</span> sum = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span> + left[<span class="number">1</span>] + right[<span class="number">1</span>];</span><br><span class="line">    ans = Math.max(ans, <span class="number">1.0</span>*sum/count);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sum, count&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">maximumAverageSubtree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] postOrder(TreeNode node) &#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] left = postOrder(node.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = postOrder(node.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    cur[<span class="number">0</span>] = left[<span class="number">0</span>] + right[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    cur[<span class="number">1</span>] = left[<span class="number">1</span>] + right[<span class="number">1</span>] + node.val;</span><br><span class="line">    max = Math.max(max, <span class="number">1.0</span>* cur[<span class="number">1</span>]/cur[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="257-Binary-Tree-Paths✨"><a href="#257-Binary-Tree-Paths✨" class="headerlink" title="257. Binary Tree Paths✨"></a><a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. Binary Tree Paths✨</a></h3><h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="string">"1-&gt;2-&gt;5"</span>, <span class="string">"1-&gt;3"</span>]</span><br><span class="line"></span><br><span class="line">Explanation: All root-to-leaf paths are: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>, <span class="number">1</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<ol>
<li>思路：前序遍历。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//function shell</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//magic recursive function</span></span><br><span class="line">    dfs(root, <span class="string">""</span>, paths);</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, String path, List&lt;String&gt; paths)</span> </span>&#123;</span><br><span class="line">    path += root.val;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        paths.add(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dfs(root.left, path + <span class="string">"-&gt;"</span>, paths);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dfs(root.right, path + <span class="string">"-&gt;"</span>, paths);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>)</span><br><span class="line">        searchBT(root, <span class="string">""</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchBT</span><span class="params">(TreeNode root, String path, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        res.add(path + root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">        searchBT(root.left, path + root.val + <span class="string">"-&gt;"</span>, res);</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">        searchBT(root.right, path + root.val + <span class="string">"-&gt;"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="110-Balanced-Binary-Tree🎂✨"><a href="#110-Balanced-Binary-Tree🎂✨" class="headerlink" title="110. Balanced Binary Tree🎂✨"></a><a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">110. Balanced Binary Tree🎂✨</a></h3><p>Given a binary tree, determine if it is <strong><code>height-balanced</code></strong>. </p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line"><span class="comment">//平衡树左右子树高度差都小于等于 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> balanced = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    maxDepth(root);</span><br><span class="line">    <span class="keyword">return</span> balanced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//post order pattern</span></span><br><span class="line">    <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">    <span class="comment">//check if balanced, update it</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>)</span><br><span class="line">        balanced = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：递归求解。</li>
<li>分别查看左右子树的深度，然后取大者+1 为当前子树的深度。</li>
<li>结束条件：如果有左右子树 的深度差超过 1，则表示不平衡，这时以-1 计，并返回，查子树过程中碰到-1 则返回-1；结点为空返回 0。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lH = height(node.left);</span><br><span class="line">    <span class="keyword">if</span> (lH == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rH = height(node.right);</span><br><span class="line">    <span class="keyword">if</span> (rH == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(lH - rH) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(lH, rH) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binary-Tree-Diameter-AE-⭐"><a href="#Binary-Tree-Diameter-AE-⭐" class="headerlink" title="Binary Tree Diameter(AE)⭐"></a>Binary Tree Diameter(AE)⭐</h2><h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binaryTreeDiameter</span><span class="params">(BinaryTree tree)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">    <span class="keyword">return</span> getTreeInfo(tree).diameter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeInfo <span class="title">getTreeInfo</span><span class="params">(BinaryTree tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeInfo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeInfo leftTreeInfo = getTreeInfo(tree.left);</span><br><span class="line">    TreeInfo rightTreeInfo = getTreeInfo(tree.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height;</span><br><span class="line">    <span class="keyword">int</span> maxDiameterSoFar = Math.max(leftTreeInfo.diameter, rightTreeInfo.diameter);</span><br><span class="line">    <span class="keyword">int</span> currentDiameter = Math.max(longestPathThroughRoot, maxDiameterSoFar);</span><br><span class="line">    <span class="keyword">int</span> currentHeight = <span class="number">1</span> + Math.max(leftTreeInfo.height, rightTreeInfo.height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeInfo(currentDiameter, currentHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> diameter;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeInfo</span><span class="params">(<span class="keyword">int</span> diameter, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.diameter = diameter;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> BinaryTree left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> BinaryTree right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="543-Diameter-of-Binary-Tree⭐"><a href="#543-Diameter-of-Binary-Tree⭐" class="headerlink" title="543. Diameter of Binary Tree⭐"></a><a href="https://leetcode.com/problems/diameter-of-binary-tree/description/" target="_blank" rel="noopener">543. Diameter of Binary Tree⭐</a></h3><p>Given a binary tree, you need to compute the length of the diameter of the tree. </p>
<p>The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. </p>
<p>This path may or may not pass through the root.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">         <span class="number">1</span></span><br><span class="line">        / \</span><br><span class="line">       <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">Return <span class="number">3</span>, which is the length of the path [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] or [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>].</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;  <span class="comment">//single path depth</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftDepth = depth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightDepth = depth(root.right);</span><br><span class="line">    <span class="comment">//update the max value</span></span><br><span class="line">    max = Math.max(max, leftDepth + rightDepth);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Go through expamle:</span></span><br><span class="line"><span class="comment">Edge case:</span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">traverse the tree, or each node recursively call a depth calculated function</span></span><br><span class="line"><span class="comment">in the function:</span></span><br><span class="line"><span class="comment">left = depth(root.left);</span></span><br><span class="line"><span class="comment">right = depth(rot.right);</span></span><br><span class="line"><span class="comment">path = left + right;  //kepp update it</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Node-Depths-AE"><a href="#Node-Depths-AE" class="headerlink" title="Node Depths(AE)"></a>Node Depths(AE)</h2><p>Take in a Binary Tree and returns the sum of its node’s depths. </p>
<p>Recursive approach(clean nicer) &amp;&amp; iterative approach</p>
<ol>
<li><p>f(n, d) = f(left , d+1) + f(right, d+1), base case : left &amp;&amp; right ==null; Using stack to push value and pop, and using runningSum to calculate to value</p>
</li>
<li><p>O(N) T</p>
<p>O(h) S  h is the height of Binary tree, the maximum of number of functions calls on the call stack is the height of tree, if tree is balanced h = log N, if one brunch h = N</p>
<p>eg. </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">//push 1 pop 1</span></span><br><span class="line"><span class="number">32</span> <span class="comment">//pop 1 push 32</span></span><br><span class="line"><span class="number">354</span> <span class="comment">//pop 2 push 54</span></span><br><span class="line"><span class="number">3598</span> <span class="comment">//pop 4 push 98  maximum hight = h = 4</span></span><br><span class="line"><span class="number">359</span> <span class="comment">//pop 8 8 is leaf node, so no push</span></span><br><span class="line"><span class="number">35</span> <span class="comment">//pop 9 same with 8</span></span><br><span class="line"><span class="number">3</span> <span class="comment">//pop 5 same with 8</span></span><br><span class="line"><span class="number">76</span> <span class="comment">//pop 3 push 76</span></span><br><span class="line"><span class="number">7</span> <span class="comment">//pop 6</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nodeDepths</span><span class="params">(BinaryTree root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">    <span class="keyword">return</span> caculateDepth(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">caculateDepth</span><span class="params">(BinaryTree node, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//edge case</span></span><br><span class="line">    <span class="keyword">return</span> depth + caculateDepth(node.left, depth + <span class="number">1</span>) + caculateDepth(node.right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="104-Maximum-Depth-of-Binary-Tree🎂✨"><a href="#104-Maximum-Depth-of-Binary-Tree🎂✨" class="headerlink" title="104. Maximum Depth of Binary Tree🎂✨"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">104. Maximum Depth of Binary Tree🎂✨</a></h3><h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>“Bottom-up” Solution</li>
<li>递归求解</li>
<li>递推方程：左面或右面较大者为解。</li>
<li>结束条件：结点为空，则为当前结点深度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxDepth(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    <span class="comment">//pre-order pattern</span></span><br><span class="line">    <span class="keyword">int</span> left = maxDepth(root.left, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> right = maxDepth(root.right, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> max = Math.max(left, right);  <span class="comment">//update max value</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>“Top-down” Solution</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> answer;		<span class="comment">// don't forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        answer = Math.max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root.left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root.right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. Minimum Depth of Binary Tree</a></h3><h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Recursion DFS思路：递归求解。结束条件：结点为空，深度 0。</li>
<li>分别求解左右子树深度。取较小者+1 即为本结点树的最小深度。</li>
<li>特殊情况，有一子树不存在，则其深度为另一子树深度+1。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;  <span class="comment">//single path</span></span><br><span class="line">        <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS Iteration</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        queue.add(<span class="keyword">new</span> Pair(root, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> current_depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Pair&lt;TreeNode, Integer&gt; current = queue.poll();</span><br><span class="line">        root = current.getKey();</span><br><span class="line">        current_depth = current.getValue();</span><br><span class="line">        <span class="keyword">if</span> ((root.left == <span class="keyword">null</span>) &amp;&amp; (root.right == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> Pair(root.left, current_depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> Pair(root.right, current_depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current_depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode curNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (curNode.left == <span class="keyword">null</span> &amp;&amp; curNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(curNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(curNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="156-Binary-Tree-Upside-Down"><a href="#156-Binary-Tree-Upside-Down" class="headerlink" title="156. Binary Tree Upside Down"></a><a href="https://leetcode.com/problems/binary-tree-upside-down/" target="_blank" rel="noopener">156. Binary Tree Upside Down</a></h2><p><img src="https://assets.leetcode.com/uploads/2020/08/29/main.jpg" alt=""></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/29/updown.jpg" alt=""></p>
<h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>This is not a very intuitive problem for me, I have to spent quite a while drawing figures to understand it. As shown in the figure, 1 shows the original tree, you can think about it as a comb, with 1, 2, 4 form the bone, and 3, 5 as the teeth. All we need to do is flip the teeth direction as shown in figure 2. We will remove the link 1–3, 2–5, and add link 2–3, and 4–5. And node 4 will be the new root.</li>
<li>As the recursive solution, we will keep recurse on the left child and once we are are done, we found the newRoot, which is 4 for this case. At this point, we will need to set the new children for node 2, basically the new left node is 3, and right node is 1. Here is the recursive solution:</li>
</ol>
<p><img src="https://assets.leetcode.com/users/images/6fca1ddd-2791-444a-9f94-75b4a49913f9_1601421082.2188914.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">upsideDownBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode newRoot = upsideDownBinaryTree(root.left);</span><br><span class="line">    root.left.left = root.right;</span><br><span class="line">    root.left.right = root;</span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    root.right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Traverse"><a href="#Traverse" class="headerlink" title="Traverse"></a>Traverse</h1><h2 id="Iterative-In-order-Traversal-AE-⭐"><a href="#Iterative-In-order-Traversal-AE-⭐" class="headerlink" title="Iterative In-order Traversal(AE)⭐"></a>Iterative In-order Traversal(AE)⭐</h2><h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeInOrderTraversal</span><span class="params">(BinaryTree tree, Function&lt;BinaryTree, Void&gt; callback)</span> </span>&#123;</span><br><span class="line">    BinaryTree prevNode = <span class="keyword">null</span>;</span><br><span class="line">    BinaryTree curNode = tree;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        BinaryTree nextNode;</span><br><span class="line">        <span class="keyword">if</span> (prevNode == <span class="keyword">null</span> || prevNode == curNode.parent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nextNode = curNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                callback.apply(curNode);</span><br><span class="line">                nextNode = curNode.right != <span class="keyword">null</span> ? curNode.right : curNode.parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevNode == curNode.left) &#123;</span><br><span class="line">            callback.apply(curNode);</span><br><span class="line">            nextNode = curNode.right != <span class="keyword">null</span> ? curNode.right : curNode.parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextNode = curNode.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        prevNode = curNode;</span><br><span class="line">        curNode = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal</a></h3><h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：中序遍历，不输出结果，存到 List 中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inorder(root, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inorder(root.left, res);</span><br><span class="line">    &#125;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-10"><a href="#Solution2-10" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/45551/Preorder-Inorder-and-Postorder-Iteratively-Summarization" target="_blank" rel="noopener">Iterative solution summarization</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        result.add(node.val);  <span class="comment">// Add after all left children</span></span><br><span class="line">        cur = node.right;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal</a></h3><h3 id="Solution1-19"><a href="#Solution1-19" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preorderTraversal(root, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preorderTraversal(root.left, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preorderTraversal(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; pre = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> pre;</span><br><span class="line">    pre.add(root.val);</span><br><span class="line">    pre.addAll(preorderTraversal(root.left));</span><br><span class="line">    pre.addAll(preorderTraversal(root.right));</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-11"><a href="#Solution2-11" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：使用栈模拟前序遍历，注意先添加右子树，后添加左子树，因为左子树要先弹出。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            result.add(cur.val);  <span class="comment">// Add before going to children</span></span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        cur = node.right;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="145-Binary-Tree-Postorder-Traversal✨"><a href="#145-Binary-Tree-Postorder-Traversal✨" class="headerlink" title="145. Binary Tree Postorder Traversal✨"></a><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. Binary Tree Postorder Traversal✨</a></h3><h3 id="Solution1-20"><a href="#Solution1-20" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postorderTraversal(root, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postorderTraversal(root.left, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postorderTraversal(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-12"><a href="#Solution2-12" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Iterative Preorder Traversal: Tweak the Order of the Output</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">//dfs</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = stack.pop();</span><br><span class="line">        ans.add(<span class="number">0</span>, cur.val);  <span class="comment">//add first</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this method have some problem</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            ans.add(<span class="number">0</span>, cur.val);  <span class="comment">//add at 0 index</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        cur = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="429-N-ary-Tree-Level-Order-Traversal⭐"><a href="#429-N-ary-Tree-Level-Order-Traversal⭐" class="headerlink" title="429. N-ary Tree Level Order Traversal⭐"></a><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N-ary Tree Level Order Traversal⭐</a></h3><h3 id="Solution1-21"><a href="#Solution1-21" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Node cur = queue.poll();</span><br><span class="line">            temp.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.addAll(cur.children);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="589-N-ary-Tree-Preorder-Traversal"><a href="#589-N-ary-Tree-Preorder-Traversal" class="headerlink" title="589. N-ary Tree Preorder Traversal"></a><a href="https://leetcode.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N-ary Tree Preorder Traversal</a></h3><h3 id="Solution1-22"><a href="#Solution1-22" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    preOrder(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root, List&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">    ans.add(root.val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root.children.size(); i++) &#123;</span><br><span class="line">        preOrder(root.children.get(i),ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-13"><a href="#Solution2-13" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        Node cur = stack.pop();</span><br><span class="line">        ans.add(cur.val);</span><br><span class="line">        Collections.reverse(cur.children);  <span class="comment">//reverse children list</span></span><br><span class="line">        <span class="keyword">for</span> (Node n : cur.children) &#123;</span><br><span class="line">            stack.push(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="590-N-ary-Tree-Postorder-Traversal✨"><a href="#590-N-ary-Tree-Postorder-Traversal✨" class="headerlink" title="590. N-ary Tree Postorder Traversal✨"></a><a href="https://leetcode.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N-ary Tree Postorder Traversal✨</a></h3><h3 id="Solution1-23"><a href="#Solution1-23" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    postOrder(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root, List&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root.children.size(); i++) &#123;</span><br><span class="line">        postOrder(root.children.get(i), ans);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-14"><a href="#Solution2-14" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Node node = stack.pollLast();</span><br><span class="line">        output.addFirst(node.val);</span><br><span class="line">        <span class="keyword">for</span> (Node item : node.children) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.add(item);    </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1506-Find-Root-of-N-Ary-Tree"><a href="#1506-Find-Root-of-N-Ary-Tree" class="headerlink" title="1506. Find Root of N-Ary Tree"></a><a href="https://leetcode.com/problems/find-root-of-n-ary-tree/" target="_blank" rel="noopener">1506. Find Root of N-Ary Tree</a></h2><h3 id="Solution1-24"><a href="#Solution1-24" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time: O(n) for first loop, O(n) for 2nd loop - <strong>total O(n) time</strong><br>Space: <strong>O(n) space</strong> for the “seen” set</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findRoot</span><span class="params">(List&lt;Node&gt; tree)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Edge Case</span></span><br><span class="line">	<span class="keyword">if</span> (tree==<span class="keyword">null</span> || tree.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	Set&lt;Node&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For each node in the tree</span></span><br><span class="line">	<span class="keyword">for</span> (Node node : tree)&#123;</span><br><span class="line">		<span class="comment">// For each child of the current node</span></span><br><span class="line">		<span class="keyword">for</span> (Node child : node.children)</span><br><span class="line">			seen.add(child);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For each node in the tree, if node doesn't exist in the set, return it as it's our root</span></span><br><span class="line">	<span class="keyword">for</span> (Node node : tree)</span><br><span class="line">		<span class="keyword">if</span> (!seen.contains(node)) <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-15"><a href="#Solution2-15" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Follow Up: Can you do O(1) space?</li>
<li>nstead of using a “seen” set - we can simply add all the values of the nodes into a Long sum variable, then deduct the children from same variable.<br>For example: [1,null,3,2,4,null,5,6]<br>Our variable as we progress through the nodes would be:<br>sum=0;<br>sum= +1 -3 -2 -4 +3 -5 -6 +2 +4 +5 +6 [=1]</li>
<li>Time: O(n) for first loop, O(n) for 2nd loop - <strong>total O(n) time</strong><br>Space: <strong>O(1) space</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findRoot</span><span class="params">(List&lt;Node&gt; tree)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Edge Case</span></span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="keyword">null</span> || tree.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For each node in the tree</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : tree)&#123;</span><br><span class="line">        <span class="comment">// Add current node value to sum</span></span><br><span class="line">        sum+=node.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For each child - reduce value of child from sum</span></span><br><span class="line">        <span class="keyword">for</span> (Node child : node.children)</span><br><span class="line">            sum-=child.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining value in sum is the only node that doesn't have a parent (meaning isn't a child of any other node) - which is the root.</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : tree)</span><br><span class="line">        <span class="keyword">if</span> (node.val==sum) <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Other-traversal-ways"><a href="#Other-traversal-ways" class="headerlink" title="Other traversal ways"></a>Other traversal ways</h1><h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal🎂💜⭐"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal🎂💜⭐" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal🎂💜⭐"></a><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal" target="_blank" rel="noopener">103. Binary Tree Zigzag Level Order Traversal🎂💜⭐</a></h2><p><img src="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/Figures/103/103_BFS.png" alt=""></p>
<h3 id="Solution1-25"><a href="#Solution1-25" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路 1：利用一个 List 嵌套数组保存每一层的元素，到相应层则把相应层元素存入对应数组。先序遍历则每层 元素都是从左到右的。要成为 ZigZag，只要在双数层上反向插入 List（collection.add(0, curr.val);）即可。 </li>
<li>思路 2：同 102，广度优先，每层新建一个 List，双数层时反射添加（可以利用 LinkedList addFirst() API）。所 有 List 都添加到 sol List 中</li>
<li><strong><code>Collections.reverse(subList)</code></strong></li>
<li><strong><code>LinkedList addFirst()</code></strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    Boolean <span class="keyword">var</span> = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> level = queue.size();</span><br><span class="line">        List&lt;Integer&gt; subList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.peek().left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(queue.peek().left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (queue.peek().right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(queue.peek().right);</span><br><span class="line">            &#125;</span><br><span class="line">            subList.add(queue.poll().val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">var</span>) &#123;</span><br><span class="line">            res.add(subList);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Collections.reverse(subList);</span><br><span class="line">            res.add(subList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> = !<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> level = <span class="keyword">true</span>; <span class="comment">//even root -&gt; 0</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    queue.add(cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        LinkedList&lt;Integer&gt; newList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="comment">//level</span></span><br><span class="line">            <span class="keyword">if</span> (level) &#123;</span><br><span class="line">                newList.add(node.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newList.addFirst(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(newList);</span><br><span class="line">        level = !level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Solution2-16"><a href="#Solution2-16" class="headerlink" title="Solution2:"></a>Solution2:</h3><p>1.DFS method</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    travel(root, res, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode cur, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//zigzag adding value</span></span><br><span class="line">    <span class="keyword">if</span> (res.size() &lt;= level) &#123;  <span class="comment">//if level up, add new list to store value</span></span><br><span class="line">        List&lt;Integer&gt; newLevel = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        res.add(newLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; cur = (LinkedList&lt;Integer&gt;)res.get(level);</span><br><span class="line">    <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        cur.add(cur.val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur.addFirst(cur.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pre-order recursion</span></span><br><span class="line">    travel(cur.left, res, level + <span class="number">1</span>);</span><br><span class="line">    travel(cur.right, res, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="116-Populating-Next-Right-Pointers-in-Each-Node⭐"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node⭐" class="headerlink" title="116. Populating Next Right Pointers in Each Node⭐"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. Populating Next Right Pointers in Each Node⭐</a></h2><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt=""></p>
<h3 id="Solution1-26"><a href="#Solution1-26" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>BFS</li>
<li>Time Complexity: O(N)<em>O</em>(<em>N</em>) since we process each node exactly once. Note that processing a node in this context means popping the node from the queue and then establishing the next pointers.</li>
<li>Space Complexity: O(N)<em>O</em>(<em>N</em>). This is a perfect binary tree which means the last level contains N/2<em>N</em>/2 nodes. The space complexity for breadth first traversal is the space occupied by the queue which is dependent upon the maximum number of nodes in particular level. So, in this case, the space complexity would be O(N)<em>O</em>(<em>N</em>).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Node current = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (i == size - <span class="number">1</span>) current.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> current.next = queue.peek();</span><br><span class="line">            <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(current.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(current.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check:</span></span><br><span class="line"><span class="comment">if root == null, return null</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">BFS with queue</span></span><br><span class="line"><span class="comment">Step1: Create a queue, and add root into it.</span></span><br><span class="line"><span class="comment">Step2: In each level, we calculate the current queue size which is the nums of cuurent number of nodes in this level, apply a for loop </span></span><br><span class="line"><span class="comment">  eg.</span></span><br><span class="line"><span class="comment">  for (int i = 0; i &lt; size; i++) &#123;</span></span><br><span class="line"><span class="comment">        Node cur = queue.poll();</span></span><br><span class="line"><span class="comment">        if (i == size - 1) cu.next = null; last node point to null</span></span><br><span class="line"><span class="comment">        cur.next = queue.peek(); connect the link between neighbor nodes</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"> Step3: return root until queue is empty which mean we finish the tarverse</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">Go through a example:</span></span><br><span class="line"><span class="comment">     1</span></span><br><span class="line"><span class="comment">    / \</span></span><br><span class="line"><span class="comment">   2   3</span></span><br><span class="line"><span class="comment">  / \ / \</span></span><br><span class="line"><span class="comment"> 4  5 6  7</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">[1,2,3,4,5,6,7]</span></span><br><span class="line"><span class="comment">queue: 4,5,6,7</span></span><br><span class="line"><span class="comment">size: 4</span></span><br><span class="line"><span class="comment">ans: 1-&gt; null, 2 -&gt; 3 -&gt; null, 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; null</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(n) number of nodes int the tree</span></span><br><span class="line"><span class="comment">Space O(n) size of queue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-17"><a href="#Solution2-17" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>We start at the root node. Since there are no more nodes to process on the first level or level <code>0</code>, we can establish the next pointers on the next level i.e. level 1. An important thing to remember in this algorithm is that we establish the next pointers for a level N<em>N</em> while we are still on level N-1<em>N</em>−1 and once we are done establishing these new connections, we move on to N<em>N</em> and do the same thing for N+1<em>N</em>+1.</li>
<li>As we just said, when we go over the nodes of a particular level, their next pointers are already established. This is what helps get rid of the queue data structure from the previous approach and helps save space. To start on a particular level, we just need the <code>leftmost</code> node. From there on out, its just a linked list traversal.</li>
<li>Time Complexity: O(N) since we process each node exactly once.</li>
<li>Space Complexity: O(1) since we don’t make use of any additional data structure for traversing nodes on a particular level like the previous approach does.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start with the root node. There are no next pointers</span></span><br><span class="line">    <span class="comment">// that need to be set up on the first level</span></span><br><span class="line">    Node leftmost = root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once we reach the final level, we are done</span></span><br><span class="line">    <span class="keyword">while</span> (leftmost.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate the "linked list" starting from the head</span></span><br><span class="line">        <span class="comment">// node and using the next pointers, establish the </span></span><br><span class="line">        <span class="comment">// corresponding links for the next level</span></span><br><span class="line">        Node head = leftmost;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// CONNECTION 1</span></span><br><span class="line">            head.left.next = head.right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// CONNECTION 2</span></span><br><span class="line">            <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                head.right.next = head.next.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Progress along the list (nodes on the current level)</span></span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move onto the next level</span></span><br><span class="line">        leftmost = leftmost.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="117-Populating-Next-Right-Pointers-in-Each-Node-II✨"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II✨" class="headerlink" title="117. Populating Next Right Pointers in Each Node II✨"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. Populating Next Right Pointers in Each Node II✨</a></h2><h3 id="Solution1-27"><a href="#Solution1-27" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>BFS Level Order Traversal</p>
</li>
<li><p>Time Complexity: O(N)<em>O</em>(<em>N</em>) since we process each node exactly once. Note that processing a node in this context means popping the node from the queue and then establishing the next pointers.</p>
</li>
<li><p>Space Complexity: O(N)<em>O</em>(<em>N</em>). This is a perfect binary tree which means the last level contains N/2<em>N</em>/2 nodes. The space complexity for breadth first traversal is the maximum space occupied and the space occupied by the queue is dependent upon the maximum number of nodes in particular level. So, in this case, the space complexity would be O(N)<em>O</em>(<em>N</em>).</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Node cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                cur.next = queue.peek();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-18"><a href="#Solution2-18" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Using previously established next pointers</li>
<li>Time Complexity: O(N)<em>O</em>(<em>N</em>) since we process each node exactly once.</li>
<li>Space Complexity: O(1)<em>O</em>(1) since we don’t make use of any additional data structure for traversing nodes on a particular level like the previous approach does.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Node prev, leftmost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processChild</span><span class="params">(Node childNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (childNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the "prev" pointer is alread set i.e. if we</span></span><br><span class="line">        <span class="comment">// already found atleast one node on the next level,</span></span><br><span class="line">        <span class="comment">// setup its next pointer</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prev.next = childNode;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Else it means this child node is the first node</span></span><br><span class="line">            <span class="comment">// we have encountered on the next level, so, we</span></span><br><span class="line">            <span class="comment">// set the leftmost pointer</span></span><br><span class="line">            <span class="keyword">this</span>.leftmost = childNode;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.prev = childNode; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The root node is the only node on the first level</span></span><br><span class="line">    <span class="comment">// and hence its the leftmost node for that level</span></span><br><span class="line">    <span class="keyword">this</span>.leftmost = root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Variable to keep track of leading node on the "current" level</span></span><br><span class="line">    Node curr = leftmost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We have no idea about the structure of the tree,</span></span><br><span class="line">    <span class="comment">// so, we keep going until we do find the last level.</span></span><br><span class="line">    <span class="comment">// the nodes on the last level won't have any children</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.leftmost != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// "prev" tracks the latest node on the "next" level</span></span><br><span class="line">        <span class="comment">// while "curr" tracks the latest node on the current</span></span><br><span class="line">        <span class="comment">// level.</span></span><br><span class="line">        <span class="keyword">this</span>.prev = <span class="keyword">null</span>;</span><br><span class="line">        curr = <span class="keyword">this</span>.leftmost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We reset this so that we can re-assign it to the leftmost</span></span><br><span class="line">        <span class="comment">// node of the next level. Also, if there isn't one, this</span></span><br><span class="line">        <span class="comment">// would help break us out of the outermost loop.</span></span><br><span class="line">        <span class="keyword">this</span>.leftmost = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate on the nodes in the current level using</span></span><br><span class="line">        <span class="comment">// the next pointers already established.</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process both the children and update the prev</span></span><br><span class="line">            <span class="comment">// and leftmost pointers as necessary.</span></span><br><span class="line">            <span class="keyword">this</span>.processChild(curr.left);</span><br><span class="line">            <span class="keyword">this</span>.processChild(curr.right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Move onto the next node.</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="938-Range-Sum-of-BST✨"><a href="#938-Range-Sum-of-BST✨" class="headerlink" title="938. Range Sum of BST✨"></a><a href="https://leetcode.com/problems/range-sum-of-bst/" target="_blank" rel="noopener">938. Range Sum of BST✨</a></h2><h3 id="Solution1-28"><a href="#Solution1-28" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode current = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (current.val &lt;= high &amp;&amp; current.val &gt;= low) &#123;</span><br><span class="line">                sum += current.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.left != <span class="keyword">null</span> &amp;&amp; current.val &gt; low) &#123;</span><br><span class="line">                queue.add(current.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.right != <span class="keyword">null</span> &amp;&amp; current.val &lt; high) &#123;</span><br><span class="line">                queue.add(current.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="199-Binary-Tree-Right-Side-View✨"><a href="#199-Binary-Tree-Right-Side-View✨" class="headerlink" title="199. Binary Tree Right Side View✨"></a><a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. Binary Tree Right Side View✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">5</span>,<span class="keyword">null</span>,<span class="number">4</span>]</span><br><span class="line">Output: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>            &lt;---</span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;---</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-29"><a href="#Solution1-29" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; visibleValues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> visibleValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode current = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (i == size - <span class="number">1</span>) &#123;</span><br><span class="line">                visibleValues.add(current.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(current.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(current.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visibleValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="102-Binary-Tree-Level-Order-Traversal🎂⭐"><a href="#102-Binary-Tree-Level-Order-Traversal🎂⭐" class="headerlink" title="102. Binary Tree Level Order Traversal🎂⭐"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal🎂⭐</a></h2><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example: Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Thinking-Process："><a href="#Thinking-Process：" class="headerlink" title="Thinking Process："></a>Thinking Process：</h3><p>In order to traverse the binary tree by level, we need use queue to store nodes which are to be expanded. we can expand all nodes at the same level and form one array per level. While expanding the parent nodes,<br>we need generate children nodes from parent nodes, and push them back into the queue. But how do we determine when we reach to the end of each level?</p>
<h3 id="Solution1-BFS-with-Per-level-Queue"><a href="#Solution1-BFS-with-Per-level-Queue" class="headerlink" title="Solution1: BFS with Per-level Queue"></a>Solution1: BFS with Per-level Queue</h3><p>we can enqueue all nodes of the same level into the same queue but use different queues for different levels. We enqueue the root into the level 1 queue. When we dequeue the root we will enqueue its child nodes into level 2 queue. When we dequeue nodes from level 2 queue, we will enqueue their child nodes into level 3 queue. We can optimize this technique and only keep track of two queues — one for the current level we are dequeueing through and one for the next level that we are enqueuing into.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="comment">//errocr check</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        List&lt;Integer&gt; sublist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode cur = queue.poll();</span><br><span class="line">            sublist.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(sublist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check：</span></span><br><span class="line"><span class="comment">if root == null return empty list</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">BFS with a queue</span></span><br><span class="line"><span class="comment">step1: add root to the queue</span></span><br><span class="line"><span class="comment">step2: get the current size of queue, poll and add it to the a temp list, at the same time add current pop node's children to the queue, when cur loop finish say we get the temp list of current level nodes, add it to the ans list, keep doing these until queue is empty</span></span><br><span class="line"><span class="comment">step3: return the queue</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">   / \</span></span><br><span class="line"><span class="comment">  9  20</span></span><br><span class="line"><span class="comment">    /  \</span></span><br><span class="line"><span class="comment">   15   7</span></span><br><span class="line"><span class="comment">queue:  </span></span><br><span class="line"><span class="comment">temp: 15</span></span><br><span class="line"><span class="comment">size: 2</span></span><br><span class="line"><span class="comment">list: [3], [9, 20], [15, 7]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(n) numbe of nodes in the tree</span></span><br><span class="line"><span class="comment">Space O(n) queue.size</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-19"><a href="#Solution2-19" class="headerlink" title="Solution2:"></a>Solution2:</h3><p>recursively DFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    levelHelper(ans, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">levelHelper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt;= ans.size()) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    ans.get(depth).add(root.val);</span><br><span class="line">    levelHelper(ans, root.left, depth + <span class="number">1</span>);</span><br><span class="line">    levelHelper(ans, root.right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="My-Weakness-Bugs"><a href="#My-Weakness-Bugs" class="headerlink" title="My Weakness /Bugs"></a>My Weakness /Bugs</h4><ol>
<li>[Weakness-1] Can’t figure out how to store level information in BFS.</li>
</ol>
<p>This problem is intuitive with DFS. However, some people will start with BFS. Sometimes the interviewer might ask for a BFS solution. Then some people are stuck at not being able to figure out how to identify the level of a node because it’s hard to pass that information around in BFS.</p>
<ol>
<li>[Weakness-2] Can’t figure out…</li>
<li>[Bug-1] Forget to push node into queue while expanding the nodes</li>
<li>[Bug-2] Mistake when …</li>
</ol>
<h3 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637. Average of Levels in Binary Tree"></a><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">637. Average of Levels in Binary Tree</a></h3><h3 id="Solution1-30"><a href="#Solution1-30" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Double&gt; res = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.peek().left != <span class="keyword">null</span>) queue.add(queue.peek().left);</span><br><span class="line">            <span class="keyword">if</span> (queue.peek().right != <span class="keyword">null</span>) queue.add(queue.peek().right);</span><br><span class="line">            sum += queue.poll().val;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(sum / level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="107-Binary-Tree-Level-Order-Traversal-II🎂"><a href="#107-Binary-Tree-Level-Order-Traversal-II🎂" class="headerlink" title="107. Binary Tree Level Order Traversal II🎂"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. Binary Tree Level Order Traversal II🎂</a></h3><h3 id="Solution1-31"><a href="#Solution1-31" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：与 102 题思路相同，只不过这次每次添加新层 List 时总是插入到 0 位置，从而实现倒置。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">//edge case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> levelNum = queue.size();</span><br><span class="line">        List&lt;Integer&gt; sublist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.peek().left != <span class="keyword">null</span>) queue.add(queue.peek().left);</span><br><span class="line">            <span class="keyword">if</span> (queue.peek().right != <span class="keyword">null</span>) queue.add(queue.peek().right);</span><br><span class="line">            sublist.add(queue.poll().val);</span><br><span class="line">        &#125;</span><br><span class="line">        res.addFirst(sublist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-20"><a href="#Solution2-20" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Recursion</p>
</li>
<li><p>The simplest way to solve the problem is to use a recursion. Let’s first ensure that the tree is not empty, and then call recursively the function <code>helper(node, level)</code>, which takes the current node and its level as the arguments.</p>
<p>This function does the following :</p>
<ul>
<li>The output list here is called <code>levels</code>, and hence the current level is just a length of this list <code>len(levels)</code>. Compare the number of a current level <code>len(levels)</code> with a node level <code>level</code>. If you’re still on the previous level - add the new one by adding a new list into <code>levels</code>.</li>
<li>Append the node value to the last list in <code>levels</code>.</li>
<li>Process recursively child nodes if they are not <code>None</code> : <code>helper(node.left / node.right, level + 1)</code>.</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; levels = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// start the current level</span></span><br><span class="line">    <span class="keyword">if</span> (levels.size() == level)</span><br><span class="line">        levels.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fulfil the current level</span></span><br><span class="line">    levels.get(level).add(node.val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process child nodes for the next level</span></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">        helper(node.left, level + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">        helper(node.right, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> levels;</span><br><span class="line">    helper(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> levels;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="652-Find-Duplicate-Subtrees⭐"><a href="#652-Find-Duplicate-Subtrees⭐" class="headerlink" title="652. Find Duplicate Subtrees⭐"></a><a href="https://leetcode.com/problems/find-duplicate-subtrees/" target="_blank" rel="noopener">652. Find Duplicate Subtrees⭐</a></h2><h3 id="Solution1-32"><a href="#Solution1-32" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>perform postorder traversal, serializing and hashing the serials of subtrees in the process. We can recognize a duplicate subtree by its serialization.</p>
</li>
<li><p>Time Complexity: O(N^2)<em>O</em>(<em>N</em>2), where N<em>N</em> is the number of nodes in the tree. We visit each node once, but each creation of <code>serial</code> may take O(N)<em>O</em>(<em>N</em>) work.</p>
</li>
<li><p>Space Complexity: O(N^2)<em>O</em>(<em>N</em>2), the size of <code>count</code>.</p>
</li>
<li><p>We can serialize each subtree. For example, the tree</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>can be represented as the serialization <code>1,2,#,#,3,4,#,#,5,#,#</code>, which is a unique representation of the tree.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    postorder(root, map, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">postorder</span><span class="params">(TreeNode root, Map&lt;String, Integer&gt; map, List&lt;TreeNode&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">    String serial = root.val + <span class="string">","</span> + postorder(root.left, map, ans) + <span class="string">","</span> + postorder(root.right, map, ans);</span><br><span class="line">    map.put(serial, map.getOrDefault(serial, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (map.get(serial) == <span class="number">2</span>) ans.add(root);</span><br><span class="line">    <span class="keyword">return</span> serial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; set = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res, set);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">helper</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; res, Map&lt;String, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    String s = <span class="string">"("</span> + helper(root.left, res, map) + root.val + helper(root.right, res, map) + <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">if</span> (map.getOrDefault(s, <span class="number">0</span>) == <span class="number">1</span>) res.add(root);</span><br><span class="line">    map.put(s, map.getOrDefault(s, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-Solution2"><a href="#Unsolved-Solution2" class="headerlink" title="Unsolved Solution2:"></a>Unsolved Solution2:</h3><ol>
<li>Time Complexity: O(N)<em>O</em>(<em>N</em>), where N<em>N</em> is the number of nodes in the tree. We visit each node once.</li>
<li>Space Complexity: O(N)<em>O</em>(<em>N</em>). Every structure we use is using O(1)<em>O</em>(1) storage per node.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    Map&lt;String, Integer&gt; trees;</span><br><span class="line">    Map&lt;Integer, Integer&gt; count;</span><br><span class="line">    List&lt;TreeNode&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">        trees = <span class="keyword">new</span> HashMap();</span><br><span class="line">        count = <span class="keyword">new</span> HashMap();</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        lookup(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lookup</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        String serial = node.val + <span class="string">","</span> + lookup(node.left) + <span class="string">","</span> + lookup(node.right);</span><br><span class="line">        <span class="keyword">int</span> uid = trees.computeIfAbsent(serial, x-&gt; t++);</span><br><span class="line">        count.put(uid, count.getOrDefault(uid, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (count.get(uid) == <span class="number">2</span>)</span><br><span class="line">            ans.add(node);</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="662-Maximum-Width-of-Binary-Tree✨"><a href="#662-Maximum-Width-of-Binary-Tree✨" class="headerlink" title="662. Maximum Width of Binary Tree✨"></a><a href="https://leetcode.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noopener">662. Maximum Width of Binary Tree✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">           <span class="number">1</span></span><br><span class="line">         /   \</span><br><span class="line">        <span class="number">3</span>     <span class="number">2</span></span><br><span class="line">       / \     \  </span><br><span class="line">      <span class="number">5</span>   <span class="number">3</span>     <span class="number">9</span> </span><br><span class="line"></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: The maximum width existing in the third level with the length <span class="number">4</span> (<span class="number">5</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">9</span>).</span><br><span class="line">    </span><br><span class="line">Input: </span><br><span class="line"></span><br><span class="line">          <span class="number">1</span></span><br><span class="line">         / \</span><br><span class="line">        <span class="number">3</span>   <span class="number">2</span></span><br><span class="line">       /     \  </span><br><span class="line">      <span class="number">5</span>       <span class="number">9</span> </span><br><span class="line">     /         \</span><br><span class="line">    <span class="number">6</span>           <span class="number">7</span></span><br><span class="line">Output: <span class="number">8</span></span><br><span class="line">Explanation:The maximum width existing in the fourth level with the length <span class="number">8</span> (<span class="number">6</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">7</span>).</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-33"><a href="#Solution1-33" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// queue of elements [(node, col_index)]</span></span><br><span class="line">    Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue.add(<span class="keyword">new</span> Pair&lt;&gt;(root, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = queue.peek().getValue();</span><br><span class="line">        <span class="keyword">int</span> right = left;</span><br><span class="line">        <span class="comment">// iterate through the current level</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            TreeNode node = queue.peek().getKey();</span><br><span class="line">            right = queue.poll().getValue();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair&lt;&gt;(node.left, <span class="number">2</span> * right));</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair&lt;&gt;(node.right, <span class="number">2</span> * right + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate the length of the current level,</span></span><br><span class="line">        <span class="comment">//   by comparing the first and last col_index.</span></span><br><span class="line">        max = Math.max(max, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="314-Binary-Tree-Vertical-Order-Traversal✨"><a href="#314-Binary-Tree-Vertical-Order-Traversal✨" class="headerlink" title="314. Binary Tree Vertical Order Traversal✨"></a><a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal" target="_blank" rel="noopener">314. Binary Tree Vertical Order Traversal✨</a></h2><p>Given a binary tree, return the vertical order traversal of its nodes’ values. (ie, from top to bottom, column by column). If two nodes are in the same row and column, the order should be from left to right. Examples: Given binary tree [3,9,20,null,null,15,7],</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> /   \</span><br><span class="line"><span class="number">9</span>    <span class="number">20</span></span><br><span class="line">     / \</span><br><span class="line">    /   \</span><br><span class="line">   <span class="number">15</span>    <span class="number">7</span></span><br><span class="line"><span class="keyword">return</span> its vertical order traversal as:</span><br><span class="line">[ [<span class="number">9</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">15</span>],</span><br><span class="line"> [<span class="number">20</span>],</span><br><span class="line"> [<span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line">Given binary tree [<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>],</span><br><span class="line">      <span class="number">3</span></span><br><span class="line">     / \</span><br><span class="line">    /   \</span><br><span class="line">   <span class="number">9</span>     <span class="number">8</span></span><br><span class="line">  / \   / \</span><br><span class="line"> /   \ /   \</span><br><span class="line"><span class="number">4</span>    <span class="number">0</span> <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="keyword">return</span> its vertical order traversal as:</span><br><span class="line">[ [<span class="number">4</span>],</span><br><span class="line"> [<span class="number">9</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">8</span>],</span><br><span class="line"> [<span class="number">7</span>]]</span><br><span class="line">Given binary tree [<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">5</span>] (<span class="number">0</span><span class="string">'s right child is 2 and 1'</span>s left child is <span class="number">5</span>)</span><br><span class="line">         <span class="number">3</span></span><br><span class="line">        / \</span><br><span class="line">       /   \</span><br><span class="line">      <span class="number">9</span>     <span class="number">8</span></span><br><span class="line">     / \   / \</span><br><span class="line">    /   \ /   \</span><br><span class="line">   <span class="number">4</span>    <span class="number">0</span> <span class="number">1</span>    <span class="number">7</span></span><br><span class="line">  / \</span><br><span class="line"> /   \</span><br><span class="line"> <span class="number">5</span>    <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> its vertical order traversal as:</span><br><span class="line">[ [<span class="number">4</span>],</span><br><span class="line"> [<span class="number">9</span>,<span class="number">5</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">8</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">7</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-34"><a href="#Solution1-34" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：假设根为 0，则左/右结点为-1/1，深度遍历找出最左和最右的范围，建立相应的 List（此时最左边索引 为 0，依次右推，根为-range[0]，最右则为-rang[0]+rang[1]）。再广度优先遍历（自上而下），把每个结点放 入对应的 List。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue1.add(root);</span><br><span class="line">    queue2.add(<span class="number">0</span>);  <span class="comment">//keep track the node col value ex. root - 0, root.left - -1, root.right - 1</span></span><br><span class="line">    <span class="keyword">while</span>(!queue1.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = queue1.poll();</span><br><span class="line">        <span class="keyword">int</span> col = queue2.poll();</span><br><span class="line">        <span class="comment">//if it's a new col, initial a new ArrayList</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(col)) &#123;</span><br><span class="line">            map.put(col, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(col).add(cur.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue1.add(cur.left);</span><br><span class="line">            queue2.add(col - <span class="number">1</span>);</span><br><span class="line">            min = Math.min(min, col - <span class="number">1</span>);  <span class="comment">//keep track the col range</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue1.add(cur.right);</span><br><span class="line">            queue2.add(col + <span class="number">1</span>);</span><br><span class="line">            max = Math.max(max, col + <span class="number">1</span>);  <span class="comment">//keep track the col range</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">        ans.add(map.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-331-Verify-Preorder-Serialization-of-a-Binary-Tree✨"><a href="#Unsolved-331-Verify-Preorder-Serialization-of-a-Binary-Tree✨" class="headerlink" title="Unsolved 331. Verify Preorder Serialization of a Binary Tree✨"></a><a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/" target="_blank" rel="noopener">Unsolved 331. Verify Preorder Serialization of a Binary Tree✨</a></h2><h3 id="Solution1-35"><a href="#Solution1-35" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Iteration</li>
<li>The idea is straightforward : take the nodes one by one from preorder traversal, and compute the number of available slots. If at the end all available slots are used up, the preorder traversal represents the valid serialization.</li>
<li>Initiate the number of available slots: <code>slots = 1</code>.</li>
<li>Split preorder traversal by comma, and iterate over the resulting array. At each step :<ul>
<li>Both a number or a null node take one slot : <code>slots = slot - 1</code>.</li>
<li>If the number of available slots is negative, the preorder traversal is invalid, return False.</li>
<li>Non-empty node <code>node != &#39;#&#39;</code> creates two more available slots: <code>slots = slots + 2</code>.</li>
</ul>
</li>
<li>Preorder traversal is valid if all available slots are used up : return <code>slots == 0</code>.</li>
<li>Time complexity : \mathcal{O}(N)O(<em>N</em>) to iterate over the string of length N.</li>
<li>Space complexity : \mathcal{O}(N)O(<em>N</em>) to keep split array in memory.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// number of available slots</span></span><br><span class="line">    <span class="keyword">int</span> slots = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String node : preorder.split(<span class="string">","</span>)) &#123;</span><br><span class="line">        <span class="comment">// one node takes one slot</span></span><br><span class="line">        --slots;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// no more slots available</span></span><br><span class="line">        <span class="keyword">if</span> (slots &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// non-empty node creates two children slots</span></span><br><span class="line">        <span class="keyword">if</span> (!node.equals(<span class="string">"#"</span>)) slots += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all slots should be used up</span></span><br><span class="line">    <span class="keyword">return</span> slots == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-21"><a href="#Solution2-21" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：利用结点和叶子外#数量关系进行验证。</li>
<li>One pass</li>
<li>Initiate the number of available slots: <code>slots = 1</code>.</li>
<li>Iterate over the string. At each comma :<ul>
<li>Both a number or a null node take one slot : <code>slots = slot - 1</code>.</li>
<li>If the number of available slots is negative, the preorder traversal is invalid, return False.</li>
<li>Non-empty node, detected by non-<code>#</code> character before comma, creates two more available slots: <code>slots = slots + 2</code>.</li>
</ul>
</li>
<li>The last node should be considered separately, since there is no comma after it.</li>
<li>Preorder traversal is valid if all available slots are used up : return <code>slots == 0</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// number of available slots</span></span><br><span class="line">    <span class="keyword">int</span> slots = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = preorder.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.charAt(i) == <span class="string">','</span>) &#123;</span><br><span class="line">            <span class="comment">// one node takes one slot</span></span><br><span class="line">            --slots;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// no more slots available</span></span><br><span class="line">            <span class="keyword">if</span> (slots &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// non-empty node creates two children slots</span></span><br><span class="line">            <span class="keyword">if</span> (preorder.charAt(i - <span class="number">1</span>) != <span class="string">'#'</span>) slots += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the last node</span></span><br><span class="line">    slots = (preorder.charAt(n - <span class="number">1</span>) == <span class="string">'#'</span>) ? slots - <span class="number">1</span> : slots + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// all slots should be used up</span></span><br><span class="line">    <span class="keyword">return</span> slots == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">    String[] nodes = preorder.split(<span class="string">","</span>);</span><br><span class="line">    <span class="keyword">int</span> diff = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!node.equals(<span class="string">"#"</span>))</span><br><span class="line">            diff += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> diff == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-987-Vertical-Order-Traversal-of-a-Binary-Tree✨"><a href="#Unsolved-987-Vertical-Order-Traversal-of-a-Binary-Tree✨" class="headerlink" title="Unsolved 987. Vertical Order Traversal of a Binary Tree✨"></a><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener">Unsolved 987. Vertical Order Traversal of a Binary Tree✨</a></h2><h2 id="545-Boundary-of-Binary-Tree✨"><a href="#545-Boundary-of-Binary-Tree✨" class="headerlink" title="545. Boundary of Binary Tree✨"></a><a href="https://leetcode.com/problems/boundary-of-binary-tree/" target="_blank" rel="noopener">545. Boundary of Binary Tree✨</a></h2><p><img src="https://assets.leetcode.com/uploads/2020/11/11/boundary1.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">Explanation:</span><br><span class="line">The left boundary is the nodes [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].</span><br><span class="line">The right boundary is the nodes [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>].</span><br><span class="line">The leaves are nodes [<span class="number">3</span>,<span class="number">4</span>].</span><br><span class="line">Unioning the sets together gives [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], which is [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>] in counter-clockwise order.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2020/11/11/boundary2.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">Explanation:</span><br><span class="line">The left boundary are node <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>. (<span class="number">4</span> is the left-most node according to definition)</span><br><span class="line">The left boundary is nodes [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>].</span><br><span class="line">The right boundary is nodes [<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>].</span><br><span class="line">The leaves are nodes [<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>].</span><br><span class="line">Unioning the sets together gives [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>], which is [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>] in counter-clockwise order.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       a</span><br><span class="line">    b    c</span><br><span class="line"> d   e   f   g </span><br><span class="line">h i g k l m n o</span><br><span class="line">output: [a, b, c, h, i, k, l, m, n, o, g, c] boundry value list</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-36"><a href="#Solution1-36" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Simple Solution</li>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>) One complete traversal for leaves and two traversals upto depth of binary tree for left and right boundary.</li>
<li>Space complexity : O(n)<em>O</em>(<em>n</em>) res<em>r<strong>e</strong>s</em> and stack<em>s<strong>t</strong>a<strong>c</strong>k</em> is used.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    ans.add(root.val);</span><br><span class="line">    leftBoundry(root.left);</span><br><span class="line">    leaves(root.left);</span><br><span class="line">    leaves(root.right);</span><br><span class="line">    rightBoundry(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftBoundry</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pre order</span></span><br><span class="line">    <span class="comment">//base case | only traverse the boundry, skip the null &amp; leave node</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        leftBoundry(root.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        leftBoundry(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightBoundry</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//post order</span></span><br><span class="line">    <span class="comment">//base case | only traverse the boundry, skip the null &amp; leave node</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rightBoundry(root.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rightBoundry(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.add(root.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    leaves(root.left);</span><br><span class="line">    leaves(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-22"><a href="#Solution2-22" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>PreOrder Traversal</li>
<li>Time complexity : O(n) One complete traversal of the tree is done.</li>
<li>Space complexity : O(n) The recursive stack can grow upto a depth of n. Further, \text{left_boundary, right_boundary and leaves combined together can be of size n.</li>
<li><code>node.left</code> is <code>left bound</code> if <code>node</code> is left bound;<br><code>node.right</code> could also be left bound if <code>node</code> is left bound &amp;&amp; <code>node</code> has no right child;</li>
<li>Same applys for <code>right bound</code>;</li>
<li>if node is <code>left bound</code>, add it <code>before</code> 2 child - pre order;<br>if node is <code>right bound</code>, add it <code>after</code> 2 child - post order;</li>
<li>A <code>leaf node</code> that is neither left or right bound belongs to the bottom line;</li>
</ol>
<p><img src="https://leetcode.com/problems/boundary-of-binary-tree/Figures/545_Preorder.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        getBounds(root.left, res, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        getBounds(root.right, res, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getBounds</span><span class="params">(TreeNode node, List&lt;Integer&gt; res, <span class="keyword">boolean</span> lb, <span class="keyword">boolean</span> rb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (lb) res.add(node.val);</span><br><span class="line">    <span class="keyword">if</span> (!lb &amp;&amp; !rb &amp;&amp; node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) res.add(node.val);</span><br><span class="line">    getBounds(node.left, res, lb, rb &amp;&amp; node.right == <span class="keyword">null</span>);</span><br><span class="line">    getBounds(node.right, res, lb &amp;&amp; node.left == <span class="keyword">null</span>, rb);</span><br><span class="line">    <span class="keyword">if</span> (rb) res.add(node.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="993-Cousins-in-Binary-Tree✨"><a href="#993-Cousins-in-Binary-Tree✨" class="headerlink" title="993. Cousins in Binary Tree✨"></a><a href="https://leetcode.com/problems/cousins-in-binary-tree/" target="_blank" rel="noopener">993. Cousins in Binary Tree✨</a></h2><p>In a binary tree, the root node is at depth <code>0</code>, and children of each depth <code>k</code> node are at depth <code>k+1</code>.</p>
<p>Two nodes of a binary tree are <em>cousins</em> if they have the same depth, but have <strong>different parents</strong>.</p>
<p>We are given the <code>root</code> of a binary tree with unique values, and the values <code>x</code> and <code>y</code> of two different nodes in the tree.</p>
<p>Return <code>true</code> if and only if the nodes corresponding to the values <code>x</code> and <code>y</code> are cousins.</p>
<h3 id="Solution1-37"><a href="#Solution1-37" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCousins</span><span class="params">(TreeNode root, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">boolean</span> isAexist = <span class="keyword">false</span>;		</span><br><span class="line">        <span class="keyword">boolean</span> isBexist = <span class="keyword">false</span>;		</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur.val == A) isAexist = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == B) isBexist = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span> &amp;&amp; cur.right != <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> (cur.left.val == A &amp;&amp; cur.right.val == B) &#123; </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left.val == B &amp;&amp; cur.right.val == A) &#123; </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isAexist &amp;&amp; isBexist)  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="129-Sum-Root-to-Leaf-Numbers✨"><a href="#129-Sum-Root-to-Leaf-Numbers✨" class="headerlink" title="129. Sum Root to Leaf Numbers✨"></a><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. Sum Root to Leaf Numbers✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">Output: <span class="number">25</span></span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path <span class="number">1</span>-&gt;<span class="number">2</span> represents the number <span class="number">12</span>.</span><br><span class="line">The root-to-leaf path <span class="number">1</span>-&gt;<span class="number">3</span> represents the number <span class="number">13</span>.</span><br><span class="line">Therefore, sum = <span class="number">12</span> + <span class="number">13</span> = <span class="number">25</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-38"><a href="#Solution1-38" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    findSum(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    sum = sum * <span class="number">10</span> + root.val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) ans += sum;</span><br><span class="line">    findSum(root.left, sum);</span><br><span class="line">    findSum(root.right, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Unsolved-1161-Maximum-Level-Sum-of-a-Binary-Tree"><a href="#Unsolved-1161-Maximum-Level-Sum-of-a-Binary-Tree" class="headerlink" title="Unsolved 1161. Maximum Level Sum of a Binary Tree"></a><a href="https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/" target="_blank" rel="noopener">Unsolved 1161. Maximum Level Sum of a Binary Tree</a></h2><h2 id="1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree"><a href="#1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree" class="headerlink" title="1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree"></a><a href="https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/" target="_blank" rel="noopener">1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</a></h2><h3 id="Solution1-39"><a href="#Solution1-39" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TreeNode ans;</span><br><span class="line">TreeNode target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TreeNode <span class="title">getTargetCopy</span><span class="params">(<span class="keyword">final</span> TreeNode original, <span class="keyword">final</span> TreeNode cloned, <span class="keyword">final</span> TreeNode target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    inorder(original, cloned);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode o, TreeNode c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(o.left, c.left);</span><br><span class="line">    <span class="keyword">if</span> (o == target) ans = c;</span><br><span class="line">    inorder(o.right, c.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Construct-Binary-Tree"><a href="#Construct-Binary-Tree" class="headerlink" title="Construct Binary Tree"></a>Construct Binary Tree</h1><h2 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal⭐"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal⭐" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal⭐"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. Construct Binary Tree from Preorder and Inorder Traversal⭐</a></h2><p>“Given preorder and inorder traversal of a tree, construct the binary tree.”</p>
<p><img src="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/Figures/145_transverse.png" alt=""></p>
<h3 id="Solution1-40"><a href="#Solution1-40" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>The basic idea is here:<br>Say we have 2 arrays, PRE and IN.<br>Preorder traversing implies that PRE[0] is the root node.<br>Then we can find this PRE[0] in IN, say it’s IN[5].<br>Now we know that IN[5] is root, so we know that IN[0] - IN[4] is on the left side, IN[6] to the end is on the right side.<br>Recursively doing this on subarrays, we can build a tree out of it :)</li>
</ol>
<p>Hope this helps.</p>
<p>Nice solution! One improvement: remember to use <strong>HashMap</strong> to cache the <code>inorder[]</code> position. This can reduce your solution from <code>20ms</code> to <code>5ms</code>.</p>
<p>Here is the my Java solution:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length != inorder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> construcTree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">construcTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, HashMap&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">    <span class="keyword">int</span> idx = map.get(root.val);  <span class="comment">// Index of current root in inorder</span></span><br><span class="line">    <span class="keyword">int</span> leftPart = idx - inStart;</span><br><span class="line">    root.left = construcTree(preorder, preStart + <span class="number">1</span>, preStart + leftPart, inorder, inStart, idx - <span class="number">1</span>, map);</span><br><span class="line">    root.right = construcTree(preorder, preStart + leftPart + <span class="number">1</span>, preEnd, inorder, idx + <span class="number">1</span>, inEnd, map);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//no hash map version</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preorder.length - <span class="number">1</span> || inStart &gt; inEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">    <span class="keyword">int</span> inIndex = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">            inIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.left = helper(preStart + <span class="number">1</span>, inStart, inIndex - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">    root.right = helper(preStart + inIndex - inStart + <span class="number">1</span>, inIndex + <span class="number">1</span>, inEnd, preorder, inorder);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal✨"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal✨" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal✨"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. Construct Binary Tree from Inorder and Postorder Traversal✨</a></h3><h3 id="Solution1-41"><a href="#Solution1-41" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder == <span class="keyword">null</span> || postorder == <span class="keyword">null</span> || inorder.length != postorder.length) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; idxMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        idxMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> constructTree(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>, idxMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd, HashMap&lt;Integer, Integer&gt; idxMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inStart &gt; inEnd || postStart &gt; postEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postEnd]);</span><br><span class="line">    <span class="keyword">int</span> rootIdx = idxMap.get(postorder[postEnd]);</span><br><span class="line">    root.left = constructTree(inorder, inStart, rootIdx - <span class="number">1</span>, postorder, postStart, postStart + rootIdx - inStart - <span class="number">1</span>, idxMap);</span><br><span class="line">    root.right = constructTree(inorder, rootIdx + <span class="number">1</span>, inEnd, postorder, postStart + rootIdx - inStart, postEnd - <span class="number">1</span>, idxMap);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal✨"><a href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal✨" class="headerlink" title="889. Construct Binary Tree from Preorder and Postorder Traversal✨"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" target="_blank" rel="noopener">889. Construct Binary Tree from Preorder and Postorder Traversal✨</a></h3><h3 id="Solution1-42"><a href="#Solution1-42" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] post)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || post == <span class="keyword">null</span> || pre.length != post.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; post.length; i++) &#123;</span><br><span class="line">        map.put(post[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> constructTree(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, post, <span class="number">0</span>, post.length - <span class="number">1</span>, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span>[] post, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd, HashMap&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd || postStart &gt; postEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[preStart]);</span><br><span class="line">    <span class="keyword">if</span> (preStart &lt; preEnd) &#123;</span><br><span class="line">        <span class="comment">//idx is the length of left subtree array</span></span><br><span class="line">        <span class="keyword">int</span> idx = map.get(pre[preStart + <span class="number">1</span>]) - postStart;</span><br><span class="line">        root.left = constructTree(pre, preStart + <span class="number">1</span>, preStart + <span class="number">1</span> + idx, post, postStart, postStart + idx, map);</span><br><span class="line">        root.right = constructTree(pre,  preStart + <span class="number">1</span> + idx + <span class="number">1</span>, preEnd, post, postStart + idx + <span class="number">1</span>, postEnd - <span class="number">1</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="572-Subtree-of-Another-Tree⭐"><a href="#572-Subtree-of-Another-Tree⭐" class="headerlink" title="572. Subtree of Another Tree⭐"></a><a href="https://leetcode.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572. Subtree of Another Tree⭐</a></h2><p><strong>Example 1:</strong><br>Given tree s:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>Given tree t:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">4</span> </span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>Return <strong>true</strong>, because t has the same structure and node values with a subtree of s.</p>
<h3 id="Solution1-43"><a href="#Solution1-43" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time complexity : O(mn). In worst case(skewed tree) <code>traverse</code> function takes O(m<em>n)*O</em>(<em>m</em>∗<em>n</em>) time.</li>
<li>Space complexity : O(n). The depth of the recursion tree can go upto n<em>n</em>. n<em>n</em> refers to the number of nodes in s<em>s</em>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//edge case</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//baseline</span></span><br><span class="line">    <span class="keyword">if</span> (isSameTree(s, t)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//pre-order pattern, check left || right</span></span><br><span class="line">    <span class="keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//current operation</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span> || s.val != t.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//pre-order pattern, check left || right</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(s.left, t.left) &amp;&amp; isSameTree(s.right, t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="297-Serialize-and-Deserialize-Binary-Tree⭐"><a href="#297-Serialize-and-Deserialize-Binary-Tree⭐" class="headerlink" title="297. Serialize and Deserialize Binary Tree⭐"></a><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. Serialize and Deserialize Binary Tree⭐</a></h2><p><img src="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/Figures/297_BST.png" alt=""></p>
<h3 id="Solution1-44"><a href="#Solution1-44" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：先序遍历存入数组输出，每到叶结点添加#以区分。恢复时也使用先序遍历，如果遇到#则说明上个结点 为叶子结点。O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pre order travserse</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"#"</span>).append(<span class="string">","</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(root.val).append(<span class="string">","</span>);</span><br><span class="line">            serialize(root.left, sb);</span><br><span class="line">            serialize(root.right, sb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data.split(<span class="string">","</span>)));</span><br><span class="line">        <span class="keyword">return</span> deserialize(q);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(Queue&lt;String&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        String s = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">"#"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//pre order pattern</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(s));</span><br><span class="line">        root.left = deserialize(q);</span><br><span class="line">        root.right = deserialize(q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="449-Serialize-and-Deserialize-BST⭐"><a href="#449-Serialize-and-Deserialize-BST⭐" class="headerlink" title="449.Serialize and Deserialize BST⭐"></a><a href="https://leetcode.com/problems/serialize-and-deserialize-bst/" target="_blank" rel="noopener">449.Serialize and Deserialize BST⭐</a></h3><p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong>. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.</p>
<p><strong>The encoded string should be as compact as possible.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    serialize(root, sb);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    sb.append(root.val).append(<span class="string">","</span>);</span><br><span class="line">    serialize(root.left, sb);</span><br><span class="line">    serialize(root.right, sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data.split(<span class="string">","</span>)));</span><br><span class="line">    <span class="keyword">return</span> deserialize(queue, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(Queue&lt;String&gt; queue, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//check valid candidate</span></span><br><span class="line">    String str = queue.peek();</span><br><span class="line">    <span class="keyword">int</span> val = Integer.parseInt(str);</span><br><span class="line">    <span class="keyword">if</span> (val &lt; min || val &gt; max) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//pre order pattern</span></span><br><span class="line">    queue.poll();</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    root.left = deserialize(queue, min, val);</span><br><span class="line">    root.right = deserialize(queue, val, max);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="100-Same-Tree⭐"><a href="#100-Same-Tree⭐" class="headerlink" title="100. Same Tree⭐"></a><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">100. Same Tree⭐</a></h2><p>Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<h3 id="Solution1-45"><a href="#Solution1-45" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：递归求解。每次判断当前结点是否相等：当前两结点都为空则结果为真；某一为空或元素值不同则为 假。逐一判断左、右子树是否相等。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-23"><a href="#Solution2-23" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>iteration</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(p);</span><br><span class="line">    queue.add(q);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode first = queue.poll();</span><br><span class="line">        TreeNode second = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> &amp;&amp; second == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first == <span class="keyword">null</span> || second == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first.val != second.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(first.left);</span><br><span class="line">        queue.add(second.left);</span><br><span class="line">        queue.add(first.right);</span><br><span class="line">        queue.add(second.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="617-Merge-Two-Binary-Trees✨"><a href="#617-Merge-Two-Binary-Trees✨" class="headerlink" title="617. Merge Two Binary Trees✨"></a><a href="https://leetcode.com/problems/merge-two-binary-trees/description/" target="_blank" rel="noopener">617. Merge Two Binary Trees✨</a></h3><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>
<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">       Tree <span class="number">1</span>                     Tree <span class="number">2</span></span><br><span class="line">          <span class="number">1</span>                         <span class="number">2</span></span><br><span class="line">         / \                       / \</span><br><span class="line">        <span class="number">3</span>   <span class="number">2</span>                     <span class="number">1</span>   <span class="number">3</span></span><br><span class="line">       /                           \   \</span><br><span class="line">      <span class="number">5</span>                             <span class="number">4</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">         <span class="number">3</span></span><br><span class="line">        / \</span><br><span class="line">       <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">      / \   \</span><br><span class="line">     <span class="number">5</span>   <span class="number">4</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-46"><a href="#Solution1-46" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Method 1: Recursive Solution</span></span><br><span class="line"><span class="comment">// Time: O(n)</span></span><br><span class="line"><span class="comment">// Space: O(height)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">    <span class="comment">//pre order</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">    root.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">    root.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-24"><a href="#Solution2-24" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Method 2: Iterative BFS</span></span><br><span class="line"><span class="comment">// Time: O(n)</span></span><br><span class="line"><span class="comment">// Space: O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    <span class="comment">// use array in the queue to manipulate at the same time</span></span><br><span class="line">    Queue&lt;TreeNode[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(<span class="keyword">new</span> TreeNode[]&#123;t1,t2&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode[] nodes = queue.poll();</span><br><span class="line">        <span class="comment">// merge 2 into 1 when it is not null</span></span><br><span class="line">        <span class="keyword">if</span> (nodes[<span class="number">1</span>]  == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// nodes[0] must not be null</span></span><br><span class="line">        nodes[<span class="number">0</span>].val += nodes[<span class="number">1</span>].val;</span><br><span class="line">        <span class="comment">// make sure nodes[0] will be null</span></span><br><span class="line">        <span class="keyword">if</span> (nodes[<span class="number">0</span>].left == <span class="keyword">null</span>)</span><br><span class="line">            nodes[<span class="number">0</span>].left = nodes[<span class="number">1</span>].left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            queue.offer(<span class="keyword">new</span> TreeNode[]&#123;nodes[<span class="number">0</span>].left, nodes[<span class="number">1</span>].left&#125;);</span><br><span class="line">        <span class="keyword">if</span> (nodes[<span class="number">0</span>].right == <span class="keyword">null</span>)</span><br><span class="line">            nodes[<span class="number">0</span>].right = nodes[<span class="number">1</span>].right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            queue.offer(<span class="keyword">new</span> TreeNode[]&#123;nodes[<span class="number">0</span>].right, nodes[<span class="number">1</span>].right&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="101-Symmetric-Tree⭐"><a href="#101-Symmetric-Tree⭐" class="headerlink" title="101.Symmetric Tree⭐"></a><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">101.Symmetric Tree⭐</a></h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-47"><a href="#Solution1-47" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路 1：符合条件的树的特点：中心对称两侧结点相等，递归对比即得解。</li>
<li>结束条件：对应结点都为空，则为真；对应结点有一个为空或值不相当，则为假。推导方程：左（右）结点的左、右（右、左）孩子应该和右 （左）结点的右、左（左、右）孩子相等。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSymmertric(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmertric</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//current operation</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left == right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pre-order pattern, check left || right</span></span><br><span class="line">    <span class="keyword">return</span> isSymmertric(left.left, right.right) &amp;&amp; isSymmertric(left.right, right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-25"><a href="#Solution2-25" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路 2：与思路 1 一致，用队列模拟递归。这里有一个观察是：需要比较的对象总是成对出现，并且后面需要 比较的对和当前对都有关系，即左左对右右，左右对右左。</li>
<li>iteratively</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode t1 = queue.poll();</span><br><span class="line">        TreeNode t2 = queue.poll();</span><br><span class="line">        <span class="comment">//current operation</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        queue.add(t1.left);</span><br><span class="line">        queue.add(t2.right);</span><br><span class="line">        queue.add(t1.right);</span><br><span class="line">        queue.add(t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root.left);</span><br><span class="line">    stack.push(root.right);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        TreeNode n1 = stack.pop(), n2 = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span> &amp;&amp; n2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span> || n2 == <span class="keyword">null</span> || n1.val != n2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.push(n1.left);</span><br><span class="line">        stack.push(n2.right);</span><br><span class="line">        stack.push(n1.right);</span><br><span class="line">        stack.push(n2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-261-Graph-Valid-Tree⭐"><a href="#Unsolved-261-Graph-Valid-Tree⭐" class="headerlink" title="Unsolved 261. Graph Valid Tree⭐"></a><a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="noopener">Unsolved 261. Graph Valid Tree⭐</a></h2><p>“Given <em><code>n</code></em> nodes labeled from <em><code>0</code></em> to <em><code>n-1</code></em> and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.” </p>
<p><a href="https://leetcode.com/problems/graph-valid-tree/discuss/69018/AC-Java-Union-Find-solution" target="_blank" rel="noopener">https://leetcode.com/problems/graph-valid-tree/discuss/69018/AC-Java-Union-Find-solution</a></p>
<h2 id="Flatten-Binary-Tree-AE"><a href="#Flatten-Binary-Tree-AE" class="headerlink" title="Flatten Binary Tree(AE)"></a>Flatten Binary Tree(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">         <span class="number">1</span></span><br><span class="line">        / \</span><br><span class="line">      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     / \   /  </span><br><span class="line">    <span class="number">4</span>   <span class="number">5</span> <span class="number">6</span>    </span><br><span class="line">       / \</span><br><span class="line">      <span class="number">7</span>   <span class="number">8</span></span><br><span class="line">method1:inorder traverse tree and save value into a list </span><br><span class="line">O(n) time | O(n) space</span><br><span class="line">[<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>]  </span><br><span class="line">    </span><br><span class="line">method2:can you <span class="keyword">do</span> better? optimize the space -&gt; <span class="function">recursive call stack <span class="title">O</span><span class="params">(d)</span></span></span><br><span class="line"><span class="function">find the formula to find left node and right node of the current node</span></span><br><span class="line"><span class="function">[4,2,7,5,8,1,6,3] </span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">7 is rightMost node in right subtree of 2</span></span><br><span class="line"><span class="function">    8 1 6</span></span><br><span class="line"><span class="function">8 is leftMost node in left subtree of 1</span></span><br><span class="line"><span class="function">6 is rightMost node in right subtree of 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-48"><a href="#Solution1-48" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTree <span class="title">flattenBinaryTree</span><span class="params">(BinaryTree root)</span> </span>&#123;</span><br><span class="line">    List&lt;BinaryTree&gt; inorderNodes = getNodesInOrder(root, <span class="keyword">new</span> ArrayList&lt;BinaryTree&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorderNodes.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//make leftNode point to the rightNode with right pointer</span></span><br><span class="line">        <span class="comment">//make rightNode point to the leftNode with left pointer</span></span><br><span class="line">        BinaryTree leftNode = inorderNodes.get(i);</span><br><span class="line">        BinaryTree rightNode = inorderNodes.get(i + <span class="number">1</span>);</span><br><span class="line">        leftNode.right = rightNode;</span><br><span class="line">        rightNode.left = leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inorderNodes.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in order traverse</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;BinaryTree&gt; <span class="title">getNodesInOrder</span><span class="params">(BinaryTree tree, List&lt;BinaryTree&gt; array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getNodesInOrder(tree.left, array);</span><br><span class="line">        array.add(tree);</span><br><span class="line">        getNodesInOrder(tree.right, array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-Solution2-1"><a href="#Unsolved-Solution2-1" class="headerlink" title="Unsolved Solution2:"></a>Unsolved Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTree <span class="title">flattenBinaryTree</span><span class="params">(BinaryTree root)</span> </span>&#123;</span><br><span class="line">    BinaryTree leftMost = flattenTree(root)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> leftMost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTree[] flattenTree(BinaryTree node) &#123;</span><br><span class="line">    BinaryTree leftMost;</span><br><span class="line">    BinaryTree rightMost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//find leftMost node</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        leftMost = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        BinaryTree[] leftAndRightMostNodes = flattenTree(node.left);</span><br><span class="line">        connectNodes(leftAndRightMostNodes[<span class="number">1</span>], node);  <span class="comment">//update the pointer</span></span><br><span class="line">        leftMost = leftAndRightMostNodes[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//find rightMost node</span></span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        rightMost = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        BinaryTree[] leftAndRightMostNodes = flattenTree(node.right);</span><br><span class="line">        connectNodes(node, leftAndRightMostNodes[<span class="number">0</span>]);</span><br><span class="line">        rightMost = leftAndRightMostNodes[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BinaryTree[]&#123;leftMost, rightMost&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connectNodes</span><span class="params">(BinaryTree left, BinaryTree right)</span> </span>&#123;</span><br><span class="line">    left.right = right;</span><br><span class="line">    right.left = left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="114-Flatten-Binary-Tree-to-Linked-List🎂✨"><a href="#114-Flatten-Binary-Tree-to-Linked-List🎂✨" class="headerlink" title="114. Flatten Binary Tree to Linked List🎂✨"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. Flatten Binary Tree to Linked List🎂✨</a></h3><h3 id="Solution1-49"><a href="#Solution1-49" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>Great solution of the <code>post order traversal</code> in <code>(right, left, root)</code> order!<br>Basically, the traversing order after flattening is <code>pre order traversal</code> in <code>(root, left, right)</code>, like</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line">        </span><br><span class="line"> -&gt;</span><br><span class="line">        </span><br><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>If we traverse the flattened tree in the reverse way, we would notice that <code>[6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1]</code> is in <code>(right, left, root)</code> order of the original tree. So the reverse order after flattening is <code>post order traversal</code> in <code>(right, left, root)</code> order like <code>[6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1]</code>.</p>
<p>The idea is to traverse the original tree in this order by</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and then set each node’s right pointer as the previous one in <code>[6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1]</code>, as such the right pointer behaves similar to a link in the flattened tree(though technically, it’s still a right child reference from the tree data structure’s perspective) and set the left child as null before the end of one recursion by</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//post order right -&gt; left -&gt; root</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line"></span><br><span class="line">    root.right = prev;  <span class="comment">//set cur.right to previous saved nodes</span></span><br><span class="line">    root.left = <span class="keyword">null</span>;  <span class="comment">//eliminate the left part</span></span><br><span class="line">    prev = root;  <span class="comment">//update the prev pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-26"><a href="#Solution2-26" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路 1（略）：如提示，其实就是（可以用队列或递归）按先序遍历把树改成结点间仅有右子树的树。 </li>
<li>思路 2：先序遍历就是所需要的顺序，所以在先序的过程中，保留上一结点位置信息(pre)，总是让上一位置的元素左结点为空，右结点为下一结点（即当前结点）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pre order</span></span><br><span class="line">TreeNode pre = <span class="keyword">null</span>;  <span class="comment">//use pre to track previous node</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    TreeNode left = root.left;</span><br><span class="line">    TreeNode right = root.right;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pre.left = <span class="keyword">null</span>;</span><br><span class="line">        pre.right = root;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root;</span><br><span class="line">    flatten(left);</span><br><span class="line">    flatten(right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Invert-Binary-Tree-AE-💜✨"><a href="#Invert-Binary-Tree-AE-💜✨" class="headerlink" title="Invert Binary Tree(AE)💜✨"></a>Invert Binary Tree(AE)💜✨</h2><ol>
<li>Give a binary tree, every node has value and one or two children</li>
<li>BFS, traverse the tree and swap every node in same level</li>
<li>time O(N) space O(N) queue, every leaf node in the tree</li>
</ol>
<h3 id="Solution1-50"><a href="#Solution1-50" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>BFS, Iteration invert with queue</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(n) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invertBinaryTree</span><span class="params">(BinaryTree tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;<span class="comment">//edge case input is []</span></span><br><span class="line">    ArrayDeque&lt;BinaryTree&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;BinaryTree&gt;();  <span class="comment">//declare ArrayDueue varaible</span></span><br><span class="line">    queue.addLast(tree);  <span class="comment">//hold the root node, then start BFS traverse</span></span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        BinaryTree current = queue.pollFirst();  <span class="comment">//current is the first ele in the queue, when something in the queue we look at our node and see if it's a null node, if is we skip it otherwise we swap it's left and right nodes, and append them in the queue intil it's become empty</span></span><br><span class="line">        swapLeftAndRight(current);</span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.addLast(current.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.addLast(current.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swapLeftAndRight</span><span class="params">(BinaryTree tree)</span> </span>&#123;</span><br><span class="line">    BinaryTree left = tree.left;</span><br><span class="line">    tree.left = tree.right;</span><br><span class="line">    tree.right = left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> BinaryTree left;</span><br><span class="line">    <span class="keyword">public</span> BinaryTree right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-27"><a href="#Solution2-27" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>recursion</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(d) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invertBinaryTree</span><span class="params">(BinaryTree tree)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pre order pattern</span></span><br><span class="line">    swapLeftAndRight(tree);  <span class="comment">//passing in our current node</span></span><br><span class="line">    invertBinaryTree(tree.left);  <span class="comment">//recursive function to lefy and right</span></span><br><span class="line">    invertBinaryTree(tree.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swapLeftAndRight</span><span class="params">(BinaryTree tree)</span> </span>&#123;</span><br><span class="line">    BinaryTree left = tree.left;</span><br><span class="line">    tree.left = tree.right;</span><br><span class="line">    tree.right = left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> BinaryTree left;</span><br><span class="line">    <span class="keyword">public</span> BinaryTree right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="226-Invert-Binary-Tree✨"><a href="#226-Invert-Binary-Tree✨" class="headerlink" title="226. Invert Binary Tree✨"></a><a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">226. Invert Binary Tree✨</a></h3><p>Trivia: This problem was inspired by this original <a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank" rel="noopener">tweet</a> by <a href="https://twitter.com/mxcl" target="_blank" rel="noopener">Max Howell</a>: </p>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</p>
<ol>
<li>思路，DFS, 递归求解，左右互换。</li>
</ol>
<h3 id="Solution1-51"><a href="#Solution1-51" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">//swap operation</span></span><br><span class="line">    swap(root);</span><br><span class="line">    <span class="comment">//pre-order traverse pattern</span></span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-28"><a href="#Solution2-28" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode left = root.left;</span><br><span class="line">    root.left = invertTree(root.right);</span><br><span class="line">    root.right = invertTree(left);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree⭐"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree⭐" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree⭐"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. Lowest Common Ancestor of a Binary Tree⭐</a></h2><h3 id="Solution1-52"><a href="#Solution1-52" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>recursion</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case, if root is p|q return this node</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//check left, right sub tree contains p|q or not</span></span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if both left, right not contains p,q</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    <span class="comment">//if both left, right contains p or q</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;  </span><br><span class="line">    <span class="comment">//if one of them contains p and q</span></span><br><span class="line">    <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if both p and q exist in Tree rooted at root, then return their LCA</span></span><br><span class="line"><span class="comment">if neither p and q exist in Tree rooted at root, then return null</span></span><br><span class="line"><span class="comment">if only one of p or q (NOT both of them), exists in Tree rooted at root, return it</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-29"><a href="#Solution2-29" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Start from the root node and traverse the tree.</li>
<li>Until we find <code>p</code> and <code>q</code> both, keep storing the parent pointers in a dictionary.</li>
<li>Once we have found both <code>p</code> and <code>q</code>, we get all the ancestors for <code>p</code> using the parent dictionary and add to a set called <code>ancestors</code>.</li>
<li>Similarly, we traverse through ancestors for node <code>q</code>. If the ancestor is present in the ancestors set for <code>p</code>, this means this is the first ancestor common between <code>p</code> and <code>q</code> (while traversing upwards) and hence this is the LCA node.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Stack for tree traversal</span></span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap for parent pointers</span></span><br><span class="line">    Map&lt;TreeNode, TreeNode&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    parent.put(root, <span class="keyword">null</span>);</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate until we find both the nodes p and q</span></span><br><span class="line">    <span class="keyword">while</span> (!parent.containsKey(p) || !parent.containsKey(q)) &#123;</span><br><span class="line"></span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While traversing the tree, keep saving the parent pointers.</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.put(node.left, node);</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.put(node.right, node);</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ancestors set() for node p.</span></span><br><span class="line">    Set&lt;TreeNode&gt; ancestors = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process all ancestors for node p using parent pointers.</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ancestors.add(p);</span><br><span class="line">        p = parent.get(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The first ancestor of q which appears in</span></span><br><span class="line">    <span class="comment">// p's ancestor set() is their lowest common ancestor.</span></span><br><span class="line">    <span class="keyword">while</span> (!ancestors.contains(q))</span><br><span class="line">        q = parent.get(q);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-307-Range-Sum-Query-Mutable🎂"><a href="#Unsolved-307-Range-Sum-Query-Mutable🎂" class="headerlink" title="Unsolved 307. Range Sum Query - Mutable🎂"></a><a href="https://leetcode.com/problems/range-sum-query-mutable/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 307. Range Sum Query - Mutable🎂</a></h2><h2 id="Unsolved-865-Smallest-Subtree-with-all-the-Deepest-Nodes"><a href="#Unsolved-865-Smallest-Subtree-with-all-the-Deepest-Nodes" class="headerlink" title="Unsolved 865. Smallest Subtree with all the Deepest Nodes"></a><a href="https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/" target="_blank" rel="noopener">Unsolved 865. Smallest Subtree with all the Deepest Nodes</a></h2><h3 id="Solution1-53"><a href="#Solution1-53" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>In the first phase, we use a depth first search <code>dfs</code> to annotate our nodes.</p>
<p>In the second phase, we also use a depth first search <code>answer(node)</code>, returning the answer for the subtree at that <code>node</code>, and using the rules above to build our answer from the answers of the children of <code>node</code>.</p>
<p>Note that in this approach, the <code>answer</code> function returns answers that have the deepest nodes of the <em>entire</em> tree, not just the subtree being considered.</p>
</li>
<li><p>Time Complexity: O(N)<em>O</em>(<em>N</em>), where N<em>N</em> is the number of nodes in the tree.</p>
</li>
<li><p>Space Complexity: O(N)<em>O</em>(<em>N</em>).</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;TreeNode, Integer&gt; depth;</span><br><span class="line"><span class="keyword">int</span> max_depth;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">subtreeWithAllDeepest</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    depth = <span class="keyword">new</span> HashMap();</span><br><span class="line">    depth.put(<span class="keyword">null</span>, -<span class="number">1</span>);</span><br><span class="line">    dfs(root, <span class="keyword">null</span>);</span><br><span class="line">    max_depth = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer d: depth.values())</span><br><span class="line">        max_depth = Math.max(max_depth, d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, TreeNode parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        depth.put(node, depth.get(parent) + <span class="number">1</span>);</span><br><span class="line">        dfs(node.left, node);</span><br><span class="line">        dfs(node.right, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">answer</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span> || depth.get(node) == max_depth)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    TreeNode L = answer(node.left),</span><br><span class="line">    R = answer(node.right);</span><br><span class="line">    <span class="keyword">if</span> (L != <span class="keyword">null</span> &amp;&amp; R != <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">if</span> (L != <span class="keyword">null</span>) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span> (R != <span class="keyword">null</span>) <span class="keyword">return</span> R;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.util.Pair;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The question is unclear. For example, if we did not have nodes 7 and 4, the answer would</span></span><br><span class="line"><span class="comment"> * be TreeNode(3). If we did not have node 4, the answer would be TreeNode(7) and not</span></span><br><span class="line"><span class="comment"> * TreeNode(2). Similarly, if we did not have 7, the answer would be TreeNode(4) and not</span></span><br><span class="line"><span class="comment"> * TreeNode(2).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Intuitively, we should be traversing from the children to the parent and calculate the</span></span><br><span class="line"><span class="comment"> * height from bottom. So the null nodes would have height 0. The leaf nodes would have the</span></span><br><span class="line"><span class="comment"> * height 1 and the root would have the max height.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * At each node, we keep a pair&lt;height_of_node_from_bottom, node&gt;. At a given node, if we</span></span><br><span class="line"><span class="comment"> * realize that the leftHeight == rightHeight, it means we have found the deepest subtree</span></span><br><span class="line"><span class="comment"> * rooted at node. If leftHeight &gt; rightHeight, it means the deepest subtree must be rooted</span></span><br><span class="line"><span class="comment"> * at left child. If rightHeight &gt; leftHeight, it means the deepest subtree must be rooted</span></span><br><span class="line"><span class="comment"> * at right child.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Which traversal allows us to traverse from bottom-up? Postorder! So we use it in the code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">subtreeWithAllDeepest</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> height(root).getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Pair&lt;Integer, TreeNode&gt; <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    Pair&lt;Integer, TreeNode&gt; left = height(root.left);</span><br><span class="line">    Pair&lt;Integer, TreeNode&gt; right = height(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftHeight = left.getKey();</span><br><span class="line">    <span class="keyword">int</span> rightHeight = right.getKey();</span><br><span class="line">    <span class="keyword">if</span> (leftHeight == rightHeight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(leftHeight + <span class="number">1</span>, root);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftHeight &lt; rightHeight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(rightHeight + <span class="number">1</span>, right.getValue());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(leftHeight + <span class="number">1</span>, left.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="298-Binary-Tree-Longest-Consecutive-Sequence"><a href="#298-Binary-Tree-Longest-Consecutive-Sequence" class="headerlink" title="298. Binary Tree Longest Consecutive Sequence"></a><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/" target="_blank" rel="noopener">298. Binary Tree Longest Consecutive Sequence</a></h2><h3 id="Solution1-54"><a href="#Solution1-54" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    findLongest(root, <span class="number">0</span>, root.val);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLongest</span><span class="params">(TreeNode root, <span class="keyword">int</span> count, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, count);</span><br><span class="line">    findLongest(root.left, count, root.val + <span class="number">1</span>);</span><br><span class="line">    findLongest(root.right, count, root.val + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    findLongest(root, <span class="number">0</span>, <span class="number">0</span>, max);</span><br><span class="line">    <span class="keyword">return</span> max[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLongest</span><span class="params">(TreeNode root, <span class="keyword">int</span> count, <span class="keyword">int</span> target, <span class="keyword">int</span>[] max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val == target) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    max[<span class="number">0</span>] = Math.max(max[<span class="number">0</span>], count);</span><br><span class="line">    findLongest(root.left, count, root.val + <span class="number">1</span>, max);</span><br><span class="line">    findLongest(root.right, count, root.val + <span class="number">1</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1110-Delete-Nodes-And-Return-Forest✨"><a href="#1110-Delete-Nodes-And-Return-Forest✨" class="headerlink" title="1110. Delete Nodes And Return Forest✨"></a><a href="https://leetcode.com/problems/delete-nodes-and-return-forest/" target="_blank" rel="noopener">1110. Delete Nodes And Return Forest✨</a></h2><p><img src="https://assets.leetcode.com/uploads/2019/07/01/screen-shot-2019-07-01-at-53836-pm.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], to_delete = [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">null</span>,<span class="number">4</span>],[<span class="number">6</span>],[<span class="number">7</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-55"><a href="#Solution1-55" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">delNodes</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] to_delete)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : to_delete) &#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    removeNode(root, set, ans);</span><br><span class="line">    <span class="keyword">if</span> (!set.contains(root.val)) &#123;</span><br><span class="line">        ans.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">removeNode</span><span class="params">(TreeNode root, HashSet&lt;Integer&gt; set, List&lt;TreeNode&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//go from bottom up, post order traverse</span></span><br><span class="line">    root.left = removeNode(root.left, set, ans);</span><br><span class="line">    root.right = removeNode(root.right, set, ans);</span><br><span class="line">    <span class="comment">//if current node need to delete</span></span><br><span class="line">    <span class="keyword">if</span> (set.contains(root.val)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans.add(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans.add(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">//return to the above recursive calls</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="250-Count-Univalue-Subtrees💎"><a href="#250-Count-Univalue-Subtrees💎" class="headerlink" title="250. Count Univalue Subtrees💎"></a><a href="https://leetcode.com/problems/count-univalue-subtrees/" target="_blank" rel="noopener">250. Count Univalue Subtrees💎</a></h2><h3 id="Solution1-56"><a href="#Solution1-56" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Depth First Search</li>
<li>Given a node in our tree, we know that it is a univalue subtree if it meets one of the following criteria:<ol>
<li>The node has no children (base case)</li>
<li>All of the node’s children are univalue subtrees, and the node and its children all have the same value</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countUnivalSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (isUnival(root)) <span class="keyword">return</span> countUnivalSubtrees(root.left) + countUnivalSubtrees(root.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> countUnivalSubtrees(root.left) + countUnivalSubtrees(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnival</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left.val != root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.right.val != root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isUnival(root.left) &amp;&amp; isUnival(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countUnivalSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    isUnival(root);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnival</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case - if the node has no children this is a univalue subtree</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check if all of the node's children are univalue subtrees and if they have the same value</span></span><br><span class="line">    <span class="comment">// also recursively call is_uni for children</span></span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        valid = isUnival(root.left) &amp;&amp; root.left.val == root.val &amp;&amp; valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        valid = isUnival(root.right) &amp;&amp; root.right.val == root.val &amp;&amp; valid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return if a univalue tree exists here and increment if it does</span></span><br><span class="line">    <span class="keyword">if</span> (!valid) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="965-Univalued-Binary-Tree"><a href="#965-Univalued-Binary-Tree" class="headerlink" title="965. Univalued Binary Tree"></a><a href="https://leetcode.com/problems/univalued-binary-tree/" target="_blank" rel="noopener">965. Univalued Binary Tree</a></h2><h3 id="Solution1-57"><a href="#Solution1-57" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> val = root.val;</span><br><span class="line">    <span class="keyword">return</span> isUnivalTree(root, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val != val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isUnivalTree(root.left, val) &amp;&amp; isUnivalTree(root.right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="687-Longest-Univalue-Path✨"><a href="#687-Longest-Univalue-Path✨" class="headerlink" title="687. Longest Univalue Path✨"></a><a href="https://leetcode.com/problems/longest-univalue-path/" target="_blank" rel="noopener">687. Longest Univalue Path✨</a></h2><h3 id="Solution1-58"><a href="#Solution1-58" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a><a href="https://leetcode.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. Sum of Left Leaves</a></h2><h3 id="Solution1-59"><a href="#Solution1-59" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Recursive DFS method. </li>
<li>For given node we check whether its left child is a leaf. If it is the case, we add its value to answer, otherwise recursively call method on left child. For right child we call method only if it has at least one nonnull child.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root.left.val + sumOfLeftLeaves(root.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//if root.left is leave node operate</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sum += root.left.val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">//pre-order pattern</span></span><br><span class="line">        sum += sumOfLeftLeaves(root.left);  <span class="comment">//recursive call the method to left subtree</span></span><br><span class="line">    &#125;</span><br><span class="line">    sum += sumOfLeftLeaves(root.right);  <span class="comment">//recursive call the method to right subtree</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-30"><a href="#Solution2-30" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><strong>Iterative method.</strong> </li>
<li>Here for each node in the tree we check whether its left child is a leaf. </li>
<li>If it is true, we add its value to answer, otherwise add left child to the stack to process it later. For right child we add it to stack only if it is not a leaf.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left.left == <span class="keyword">null</span> &amp;&amp; node.left.right == <span class="keyword">null</span>)</span><br><span class="line">                ans += node.left.val;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;  <span class="comment">//if right subtree have children push it into stack</span></span><br><span class="line">            <span class="keyword">if</span> (node.right.left != <span class="keyword">null</span> || node.right.right != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h1><h2 id="BST-Traversal-AE-⭐"><a href="#BST-Traversal-AE-⭐" class="headerlink" title="BST Traversal(AE)⭐"></a>BST Traversal(AE)⭐</h2><h3 id="Solution1-60"><a href="#Solution1-60" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Traversal of a binary search tree, <strong><code>in-order, pre-order, post-order</code></strong> technique</li>
<li>Time O(N) Space O(N/d)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inOrderTraverse</span><span class="params">(BST tree, List&lt;Integer&gt; array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//write your code here</span></span><br><span class="line">    <span class="keyword">if</span> (tree.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inOrderTraverse(tree.left, array);</span><br><span class="line">    &#125;</span><br><span class="line">    array.append(tree.value);</span><br><span class="line">    <span class="keyword">if</span> (tree.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inOrderTraverse(tree.right, array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preOrderTraverse</span><span class="params">(BST tree, List&lt;Integer&gt; array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//write your code here</span></span><br><span class="line">    array.add(tree.value);</span><br><span class="line">    <span class="keyword">if</span> (tree.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preOrderTraverse(tree.left, array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preOrderTraverse(tree.right, array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">postOrderTraverse</span><span class="params">(BST tree, List&lt;Integer&gt; array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//write your code here</span></span><br><span class="line">    <span class="keyword">if</span> (tree.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postOrderTraverse(tree.left, array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postOrderTraverse(tree.right, array);</span><br><span class="line">    &#125;</span><br><span class="line">    array.add(tree.value);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> BST left;</span><br><span class="line">    <span class="keyword">public</span> BST right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Find-Successor-AE-⭐"><a href="#Find-Successor-AE-⭐" class="headerlink" title="Find Successor(AE)⭐"></a>Find Successor(AE)⭐</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	  <span class="number">1</span></span><br><span class="line">     /  \</span><br><span class="line">    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">   / \ </span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">6</span></span><br><span class="line">input : <span class="number">5</span></span><br><span class="line">output : <span class="number">1</span></span><br><span class="line"><span class="number">6</span>-&gt;<span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-61"><a href="#Solution1-61" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Inorder traverse save value in an array&lt; Node &gt; .</li>
<li>Traverse array, if current node == target, &amp;&amp; index not array.size() - 1, return array.get(i+1)</li>
<li>else return null.</li>
<li>Time O(n)</li>
<li>Space O(n)</li>
</ol>
<h3 id="Solution2-31"><a href="#Solution2-31" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>If has right branch, find getLeftmostChild in left subtree</li>
<li>else return getRightmostParent</li>
<li>Time O(h)</li>
<li>Space O(1)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BinaryTree <span class="title">findSuccessor</span><span class="params">(BinaryTree tree, BinaryTree node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getLeftmostChild(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getRightmostParent(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTree <span class="title">getLeftmostChild</span><span class="params">(BinaryTree node)</span> </span>&#123;</span><br><span class="line">    BinaryTree cur = node;</span><br><span class="line">    <span class="keyword">while</span>(cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTree <span class="title">getRightmostParent</span><span class="params">(BinaryTree node)</span> </span>&#123;</span><br><span class="line">    BinaryTree cur = node;</span><br><span class="line">    <span class="keyword">while</span>(cur.parent != <span class="keyword">null</span> &amp;&amp; cur.parent.right == cur) &#123;</span><br><span class="line">        cur = cur.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="285-Inorder-Successor-in-BST⭐"><a href="#285-Inorder-Successor-in-BST⭐" class="headerlink" title="285. Inorder Successor in BST⭐"></a><a href="https://leetcode.com/problems/inorder-successor-in-bst/" target="_blank" rel="noopener">285. Inorder Successor in BST⭐</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">iterative in-order traverse</span><br><span class="line">	  <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    /   \</span><br><span class="line">   <span class="number">3</span>     <span class="number">7</span></span><br><span class="line">  / \   / \</span><br><span class="line"> /   \ /   \</span><br><span class="line"><span class="number">2</span>    <span class="number">4</span> <span class="number">6</span>    <span class="number">8</span></span><br><span class="line">Given <span class="number">5</span> -&gt; <span class="number">6</span></span><br><span class="line">Gived <span class="number">6</span> -&gt; <span class="number">7</span></span><br><span class="line">Gived <span class="number">8</span> -&gt; none</span><br><span class="line"><span class="comment">//think about the edge case</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-62"><a href="#Solution1-62" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Here it’s better to choose the iterative traversal in order to optimise the performance and minimize the space at the same time. Iterative inorder traversal is simple: go left till you can, and then one step right. Repeat till the end of nodes in the tree.</li>
<li>If the node has a right child, go one step right and then left till you can. Return the successor.</li>
<li>Otherwise, implement iterative inorder traversal. While there are still nodes in the tree or in the stack:<ul>
<li>Go left till you can, adding nodes in stack.</li>
<li>Pop out the last node. If its predecessor is equal to <code>p</code>, return that last node. Otherwise, save that node to be the predecessor in the next turn of the loop.</li>
<li>Go one step right.</li>
</ul>
</li>
<li>If we’re here that means the successor doesn’t exit. Return null.</li>
<li>Time complexity : O(H) in the best case, O(N) in the worst case</li>
<li>Space complexity : \mathcal{O}(1)O(1) in the best case, when node <code>p</code> has a right child. Otherwise, up to \mathcal{O}(H)O(<em>H</em>) to keep the stack.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the successor is somewhere lower in the right subtree</span></span><br><span class="line">    <span class="comment">// successor: one step right and then left till you can</span></span><br><span class="line">    <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p = p.right;</span><br><span class="line">        <span class="keyword">while</span>(p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the successor is somewhere upper in the tree</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// inorder traversal : left -&gt; node -&gt; right</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. go left till you can</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. all logic around the node</span></span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="comment">// if the previous node was equal to p</span></span><br><span class="line">        <span class="comment">// then the current node is its successor</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.val == p.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="comment">// 3. go one step right</span></span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// there is no successor</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-32"><a href="#Solution2-32" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Here is a much simpler solution to the problem. The idea is pretty straight forward.<br>We start from the root, utilizing the property of BST:</p>
<ul>
<li>If current node’s value is less than or equal to p’s value, we know our answer must be in the right subtree.</li>
<li>If current node’s value is greater than p’s value, current node is a candidate. Go to its left subtree to see if we can find a smaller one.</li>
<li>If we reach <code>null</code>, our search is over, just return the candidate.</li>
</ul>
</li>
<li><p>The time complexity should be <code>O(h)</code> where h is the depth of the result node. <code>succ</code> is a pointer that keeps the possible successor. Whenever you go left the current root is the new possible successor, otherwise the it remains the same.</p>
<p>Only in a balanced BST <code>O(h) = O(log n)</code>. In the worst case <code>h</code> can be as large as <code>n</code>.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    TreeNode candidate = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &gt; p.val) &#123;</span><br><span class="line">            candidate = cur;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// cur.val &lt;= p.val</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="510-Inorder-Successor-in-BST-II⭐"><a href="#510-Inorder-Successor-in-BST-II⭐" class="headerlink" title="510. Inorder Successor in BST II⭐"></a><a href="https://leetcode.com/problems/inorder-successor-in-bst-ii/" target="_blank" rel="noopener">510. Inorder Successor in BST II⭐</a></h3><p><img src="https://leetcode.com/problems/inorder-successor-in-bst-ii/Figures/510/case.png" alt=""></p>
<p><img src="https://leetcode.com/problems/inorder-successor-in-bst-ii/Figures/510/casenull.png" alt=""></p>
<h3 id="Solution1-63"><a href="#Solution1-63" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>If the node has a right child, and hence its successor is somewhere lower in the tree. Go to the right once and then as many times to the left as you could. Return the node you end up with.</li>
<li>Node has no right child, and hence its successor is somewhere upper in the tree. Go up till the node that is <em>left</em> child of its parent. The answer is the parent.</li>
<li>Time complexity : \mathcal{O}(H)O(<em>H</em>), where H<em>H</em> is the height of the tree. That means \mathcal{O}(\log N)O(log<em>N</em>) in the average case, and \mathcal{O}(N)O(<em>N</em>) in the worst case, where N<em>N</em> is the number of nodes in the tree.</li>
<li>Space complexity : \mathcal{O}(1)O(1), since no additional space is allocated during the calculation.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">inorderSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the successor is somewhere lower in the right subtree</span></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">        <span class="keyword">while</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// the successor is somewhere upper in the tree</span></span><br><span class="line">        Node cur = node;</span><br><span class="line">        <span class="keyword">while</span>(cur.parent != <span class="keyword">null</span> &amp;&amp; cur.parent.right == cur) &#123;</span><br><span class="line">            cur = cur.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1214-Two-Sum-BSTs⭐"><a href="#1214-Two-Sum-BSTs⭐" class="headerlink" title="1214.Two Sum BSTs⭐"></a><a href="https://leetcode.com/problems/two-sum-bsts/" target="_blank" rel="noopener">1214.Two Sum BSTs⭐</a></h3><p>Given two binary search trees, return <code>True</code> if and only if there is a node in the first tree and a node in the second tree whose values sum up to a given integer <code>target</code>.</p>
<p><img src="https://assets.leetcode.com/uploads/2019/05/31/1368_1_a2.png" alt=""></p>
<p><img src="https://assets.leetcode.com/uploads/2019/05/31/1368_1_b.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root1 = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>], root2 = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>], target = <span class="number">5</span></span><br><span class="line">Output: <span class="keyword">true</span></span><br><span class="line">Explanation: <span class="number">2</span> and <span class="number">3</span> sum up to <span class="number">5</span>.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root1 = [<span class="number">0</span>,-<span class="number">10</span>,<span class="number">10</span>], root2 = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">2</span>], target = <span class="number">18</span></span><br><span class="line">Output: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-64"><a href="#Solution1-64" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">twoSumBSTs</span><span class="params">(TreeNode root1, TreeNode root2, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = root1.val + root2.val;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> twoSumBSTs(root1.right, root2, target) || twoSumBSTs(root1, root2.right, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> twoSumBSTs(root1.left, root2, target) || twoSumBSTs(root1, root2.left, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-33"><a href="#Solution2-33" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Traverse root 1 from smallest value to node to largest.<br>Traverse root 2 from largest value node to smallest.<br>Sum up the corresponding node’s value : If sum == target return true<br>If target &gt; sum,<br>then move to the <strong>inorder successor</strong> of the current node of root1,<br>else<br>move to the <strong>inorder predecessor</strong> of the current node of root2.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">twoSumBSTs</span><span class="params">(TreeNode root1, TreeNode root2, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if either of the tree is empty</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack 'stack1' used for the inorde traversal of root 1</span></span><br><span class="line">    <span class="comment">// stack 'stack2' used for the reverse inorder traversal of root 2</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode t1, t2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// LeftMost Node.</span></span><br><span class="line">        <span class="keyword">while</span> (root1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(root1);</span><br><span class="line">            root1 = root1.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RighMost Node.</span></span><br><span class="line">        <span class="keyword">while</span> (root2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack2.push(root2);</span><br><span class="line">            root2 = root2.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If either is empty then break.</span></span><br><span class="line">        <span class="keyword">if</span> (stack1.empty() || stack2.empty())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        t1 = stack1.peek();</span><br><span class="line">        t2 = stack2.peek();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the sum of the node's is equal to 'target'</span></span><br><span class="line">        <span class="keyword">if</span> ((t1.val + t2.val) == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// move to next possible node in the inorder traversal of root 1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((t1.val + t2.val) &lt; target) &#123;</span><br><span class="line">            stack1.pop();</span><br><span class="line">            root1 = t1.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// move to next possible node in the reverse inorder traversal of root 2</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            stack2.pop();</span><br><span class="line">            root2 = t2.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="653-Two-Sum-IV-Input-is-a-BST⭐"><a href="#653-Two-Sum-IV-Input-is-a-BST⭐" class="headerlink" title="653. Two Sum IV - Input is a BST⭐"></a><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">653. Two Sum IV - Input is a BST⭐</a></h3><h3 id="Solution1-65"><a href="#Solution1-65" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    preorder(root, set, k);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, Set&lt;Integer&gt; set, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (set.contains(k - root.val)) ans = <span class="keyword">true</span>;</span><br><span class="line">    set.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preorder(root.left, set, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preorder(root.right, set, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="99-Recover-Binary-Search-Tree✨"><a href="#99-Recover-Binary-Search-Tree✨" class="headerlink" title="99. Recover Binary Search Tree✨"></a><a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">99. Recover Binary Search Tree✨</a></h3><p><img src="https://leetcode.com/problems/recover-binary-search-tree/Figures/99/iinorde.png" alt=""></p>
<h3 id="Solution1-66"><a href="#Solution1-66" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：中序遍历。右子树中的结点（root）一定大于当前结点（preElement），找到两个不符合二叉搜索树的 元素，并将其置换。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">TreeNode first = <span class="keyword">null</span>;</span><br><span class="line">TreeNode second = <span class="keyword">null</span>;</span><br><span class="line">TreeNode prev = <span class="keyword">new</span> TreeNode(Integer.MIN_VALUE);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    inorder(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = first.val;</span><br><span class="line">    first.val = second.val;</span><br><span class="line">    second.val = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root.left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(first == <span class="keyword">null</span> &amp;&amp; prev.val &gt; root.val) &#123;</span><br><span class="line">        first = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(first != <span class="keyword">null</span> &amp;&amp; prev.val &gt; root.val) &#123;</span><br><span class="line">        second = root;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = root;</span><br><span class="line"></span><br><span class="line">    inorder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-34"><a href="#Solution2-34" class="headerlink" title="Solution2:"></a>Solution2:</h3><p>This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here.</p>
<p>Let’s start by writing the in order traversal:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// Do some business</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So when we need to print the node values in order, we insert System.out.println(root.val) in the place of “Do some business”.</p>
<p>What is the business we are doing here?<br>We need to find the first and second elements that are not in order right?</p>
<p>How do we find these two elements? For example, we have the following tree that is printed as in order traversal:</p>
<p>6, 3, 4, 5, 2</p>
<p>We compare each node with its next one and we can find out that 6 is the first element to swap because 6 &gt; 3 and 2 is the second element to swap because 2 &lt; 5.</p>
<p>Really, what we are comparing is the current node and its previous node in the “in order traversal”.</p>
<p>Let us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the “do some business” logic as finding the two elements. See the code below:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode firstElement = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode secondElement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized</span></span><br><span class="line">    TreeNode prevElement = <span class="keyword">new</span> TreeNode(Integer.MIN_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In order traversal to find the two elements</span></span><br><span class="line">        traverse(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Swap the values of the two nodes</span></span><br><span class="line">        <span class="keyword">int</span> temp = firstElement.val;</span><br><span class="line">        firstElement.val = secondElement.val;</span><br><span class="line">        secondElement.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        traverse(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start of "do some business", </span></span><br><span class="line">        <span class="comment">// If first element has not been found, assign it to prevElement (refer to 6 in the example above)</span></span><br><span class="line">        <span class="keyword">if</span> (firstElement == <span class="keyword">null</span> &amp;&amp; prevElement.val &gt;= root.val) &#123;</span><br><span class="line">            firstElement = prevElement;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If first element is found, assign the second element to the root (refer to 2 in the example above)</span></span><br><span class="line">        <span class="keyword">if</span> (firstElement != <span class="keyword">null</span> &amp;&amp; prevElement.val &gt;= root.val) &#123;</span><br><span class="line">            secondElement = root;</span><br><span class="line">        &#125;        </span><br><span class="line">        prevElement = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// End of "do some business"</span></span><br><span class="line"></span><br><span class="line">        traverse(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="897-Increasing-Order-Search-Tree✨"><a href="#897-Increasing-Order-Search-Tree✨" class="headerlink" title="897. Increasing Order Search Tree✨"></a><a href="https://leetcode.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener">897. Increasing Order Search Tree✨</a></h3><h3 id="Solution1-67"><a href="#Solution1-67" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>In-Order Traversal</li>
<li>Time Complexity: O(N)<em>O</em>(<em>N</em>), where N<em>N</em> is the number of nodes in the given tree.</li>
<li>Space Complexity: O(N)<em>O</em>(<em>N</em>), the size of the answer.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; vals = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    inorder(root, vals);</span><br><span class="line">    TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>), cur = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: vals) &#123;</span><br><span class="line">        cur.right = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; vals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(node.left, vals);</span><br><span class="line">    vals.add(node.val);</span><br><span class="line">    inorder(node.right, vals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-35"><a href="#Solution2-35" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Traversal with Relinking</li>
<li>Time Complexity: O(N)<em>O</em>(<em>N</em>), where N<em>N</em> is the number of nodes in the given tree.</li>
<li>Space Complexity: O(H)<em>O</em>(<em>H</em>) in <em>additional</em> space complexity, where H<em>H</em> is the height of the given tree, and the size of the implicit call stack in our in-order traversal.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TreeNode cur;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    cur = ans;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">return</span> ans.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(node.left);</span><br><span class="line">    node.left = <span class="keyword">null</span>;</span><br><span class="line">    cur.right = node;</span><br><span class="line">    cur = node;</span><br><span class="line">    inorder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="173-Binary-Search-Tree-Iterator✨"><a href="#173-Binary-Search-Tree-Iterator✨" class="headerlink" title="173. Binary Search Tree Iterator✨"></a><a href="https://leetcode.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">173. Binary Search Tree Iterator✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Essentially, an iterator can be used to iterate over any container object. For our purpose, the container object is a binary search tree. If such an iterator is defined, then the traversal logic can be abstracted out and we can simply make use of the iterator to process the elements in a certain order.</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. new_iterator = BSTIterator(root);</span><br><span class="line"><span class="number">2</span>. <span class="keyword">while</span> (new_iterator.hasNext())</span><br><span class="line"><span class="number">3</span>.     process(new_iterator.next());</span><br><span class="line"></span><br><span class="line">In computer programming, an iterator is an object that enables a programmer to traverse a container, particularly lists. This is the Wikipedia definition of an iterator.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-68"><a href="#Solution1-68" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Inorder traverse</p>
</li>
<li><p>Time complexity :</p>
</li>
</ol>
<p>   O(N) is the time taken by the constructor for the iterator. The problem statement only asks us to analyze the complexity of the two functions, however, when implementing a class, it’s important to also note the time it takes to initialize a new object of the class and in this case it would be linear in terms of the number of nodes in the BST. In addition to the space occupied by the new array we initialized, the recursion stack for the inorder traversal also occupies space but that is limited to O(h) where h is the height of the tree.</p>
<ul>
<li><code>next()</code> would take O(1)<em>O</em>(1)</li>
<li><code>hasNext()</code> would take O(1)<em>O</em>(1)</li>
</ul>
<ol start="3">
<li>Space complexity : O(N)<em>O</em>(<em>N</em>) since we create a new array to contain all the nodes of the BST. This doesn’t comply with the requirement specified in the problem statement that the maximum space complexity of either of the functions should be O(h)<em>O</em>(<em>h</em>) where h<em>h</em> is the height of the tree and for a well balanced BST, the height is usually logN<em>l<strong>o</strong>g**N</em>. So, we get great time complexities but we had to compromise on the space. Note that the new array is used for both the function calls and hence the space complexity for both the calls is O(N)<em>O</em>(<em>N</em>).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodeSoted;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        nodeSoted = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        inorder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        nodeSoted.add(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nodeSoted.get(idx++);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idx &lt; nodeSoted.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-36"><a href="#Solution2-36" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：二叉搜索树特点：左孩子总是较小，右孩子总是较大，所以每次要到最远的左结点，缓存到Stack中， 如果弹出当前元素，则将对应右结点及相应的左枝缓存入Stack中（这个枝上的结点值仍然小于其祖结点）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;TreeNode&gt; stack;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        <span class="comment">// Traversal cur node's right branch</span></span><br><span class="line">        TreeNode cur = node.right;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="230-Kth-Smallest-Element-in-a-BST✨"><a href="#230-Kth-Smallest-Element-in-a-BST✨" class="headerlink" title="230. Kth Smallest Element in a BST✨"></a><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. Kth Smallest Element in a BST✨</a></h3><h3 id="Solution1-69"><a href="#Solution1-69" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Iterative In-order traverse</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="comment">//decrease k until we find the kth node</span></span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-37"><a href="#Solution2-37" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inorder(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans.get(k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root.left, ans);</span><br><span class="line">    ans.add(root.val);</span><br><span class="line">    inorder(root.right, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree✨"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree✨" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree✨"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. Lowest Common Ancestor of a Binary Search Tree✨</a></h3><h3 id="Solution1-70"><a href="#Solution1-70" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if p, q both in left subtree</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="comment">//if p, q both in right subtree</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//if p, q in left and right seperated</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-38"><a href="#Solution2-38" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：根据二叉树特点，共同祖先必然大于其一，小于另一。不断根据与其中 1 结点的大小关系，从根部一 直到找到符合条件的共同祖先。</li>
<li>Just walk down from the whole tree’s root as long as both p and q are in the same subtree (meaning their values are both smaller or both larger than root’s). This walks straight from the root to the LCA, not looking at the rest of the tree, so it’s pretty much as fast as it gets. A few ways to do it:<strong>Iterative, O(1) space</strong></li>
<li>in case of overflow, I’d do <code>(root.val - (long)p.val) * (root.val - (long)q.val)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((root.val - p.val) * (root.val - q.val) &gt; <span class="number">0</span>)</span><br><span class="line">        root = p.val &lt; root.val ? root.left : root.right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BST-Construction-AE-⭐"><a href="#BST-Construction-AE-⭐" class="headerlink" title="BST Construction(AE)⭐"></a>BST Construction(AE)⭐</h2><ol>
<li>Every node in BST has to satisfy an additional property called the BST property. A node’s value must be strictly greater than all of the values of the nodes to it’s  left. And the value of a node must less or equal to all of the nodes to its right.</li>
<li>Insertion, searching, deletion</li>
<li>Average Time O(logn) Space O(logn)  Worst Time O(N) Space O(N) recursion will call stack use space</li>
</ol>
<h3 id="Solution1-71"><a href="#Solution1-71" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Average O(long(n)) time | O(1) space</span></span><br><span class="line"><span class="comment">//Worst O(n) time | O(1) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BST <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    BST currentNode = <span class="keyword">this</span>;  <span class="comment">//declare a current node, initialize it to be self</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; currentNode.value) &#123;  <span class="comment">//do comparsion, when value is less, explore to the left subtree</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode.left == <span class="keyword">null</span>) &#123;  <span class="comment">//if the left position is empty insert the value</span></span><br><span class="line">                BST newNode = <span class="keyword">new</span> BST(value);  <span class="comment">//declare the newNode varaible</span></span><br><span class="line">                currentNode.left = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//if not empty, continue traverse the left part</span></span><br><span class="line">                currentNode = currentNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//do comparsion, when value is greater or equal, explore to the right subtree</span></span><br><span class="line">            <span class="keyword">if</span> (curentNode.right == <span class="keyword">null</span>) &#123;  <span class="comment">//if the right position is empty insert the value</span></span><br><span class="line">                BST newNode = <span class="keyword">new</span> BST(value);</span><br><span class="line">                currentNode.right = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//if not empty, continue traverse the right part</span></span><br><span class="line">                currentNode = currentNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Average O(long(n)) time | O(1) space</span></span><br><span class="line"><span class="comment">//Worst O(n) time | O(1) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    BST currentNode = <span class="keyword">this</span>;  <span class="comment">//declare a current node, initialize it to be self</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;  <span class="comment">//base line if it is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; currentNode.value) &#123;  <span class="comment">//compare the value, if less go left</span></span><br><span class="line">            currentNode = currentNode.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; currentNode.value) &#123;  <span class="comment">//if greater</span></span><br><span class="line">            currentNode = currentNode.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//value = cur.value, we find the value</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BST <span class="title">remove</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    remove(value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> value, BST parentNode)</span> </span>&#123;</span><br><span class="line">    BST currentNode = <span class="keyword">this</span>;  <span class="comment">//declare a current node, initialize it to be self</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; currentNode.value) &#123;  <span class="comment">//if the value try to remove less than the current value</span></span><br><span class="line">            parentNode = currentNode;  <span class="comment">//keep track the parent node</span></span><br><span class="line">            currentNode = currentNode.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; currentNode.value) &#123;</span><br><span class="line">            parentNode = currentNode;</span><br><span class="line">            currentNode = currentNode.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//find the node to remove</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode.left != <span class="keyword">null</span> &amp;&amp; currentNode.right != <span class="keyword">null</span>) &#123;  <span class="comment">//toRemove node have two children node</span></span><br><span class="line">                currentNode.value = currentNode.right.getMinValue();</span><br><span class="line">                <span class="comment">//set currentNode.value = smallest value of right subtree</span></span><br><span class="line">                currentNode.right.remove(currentNode.value, currentNode);  <span class="comment">//remove smallest value of right subtree</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parentNode == <span class="keyword">null</span>) &#123;  <span class="comment">//root node is toRemove</span></span><br><span class="line">                <span class="keyword">if</span> (currentNode.left != <span class="keyword">null</span>) &#123;  <span class="comment">//only have left branch</span></span><br><span class="line">                    currentNode.value = currentNode.left.value;</span><br><span class="line">                    currentNode.right = current.left.right;</span><br><span class="line">                    currentNode.left = current.left.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.right != <span class="keyword">null</span>) &#123;  <span class="comment">//only have right branch</span></span><br><span class="line">                    currentNode.value = currentNode.right.value;</span><br><span class="line">                    currentNode.right = current.right.right;</span><br><span class="line">                    currentNode.left = current.right.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//this is a single-node tree; do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parentNode.left == currentNode) &#123;  <span class="comment">//node inside BST is toRemove, note this time node is still only has one branch</span></span><br><span class="line">                parentNode.left = currentNode.left != <span class="keyword">null</span> ? currentNode.left : currentNode.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parentNode.right == currentNode) &#123;</span><br><span class="line">                parentNode.right = currentNode.left != <span class="keyword">null</span> ? currentNode.left : currentNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.getMinValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-39"><a href="#Solution2-39" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> BST left;</span><br><span class="line">        <span class="keyword">public</span> BST right;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> BST <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    BST newBST = <span class="keyword">new</span> BST(value);</span><br><span class="line">                    left = newBST;</span><br><span class="line">    			&#125; <span class="keyword">else</span> &#123;  <span class="comment">//when still have left subtree to explore, do a recursion</span></span><br><span class="line">    				left.insert(value);</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			<span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">    				BST newBST = <span class="keyword">new</span> BST(value);</span><br><span class="line">    				right = newBST;</span><br><span class="line">    			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    				right.insert(value);</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write your code here.</span></span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">    			<span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">    				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    				<span class="keyword">return</span> left.contains(value);</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">    			<span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">    				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    				<span class="keyword">return</span> right.contains(value);</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> BST <span class="title">remove</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write your code here.</span></span><br><span class="line">            <span class="comment">// Do not edit the return statement of this method.</span></span><br><span class="line">            remove(value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> value, BST parent)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">    			<span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    				left.remove(value, <span class="keyword">this</span>);</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">    			<span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    				right.remove(value, <span class="keyword">this</span>);</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			<span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;  <span class="comment">//if node have two children</span></span><br><span class="line">    				<span class="keyword">this</span>.value = right.getMinValue();</span><br><span class="line">    				right.remove(<span class="keyword">this</span>.value, <span class="keyword">this</span>);</span><br><span class="line">    			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;  <span class="comment">//if node if root node</span></span><br><span class="line">    				<span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;  <span class="comment">//if node only have left children</span></span><br><span class="line">    					<span class="keyword">this</span>.value = left.value;</span><br><span class="line">    					right = left.right;</span><br><span class="line">    					left = left.left;</span><br><span class="line">    				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;  <span class="comment">//if node only have right children</span></span><br><span class="line">    					<span class="keyword">this</span>.value = right.value;</span><br><span class="line">    					left = right.left;</span><br><span class="line">    					right = right.right;</span><br><span class="line">    				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    				    <span class="comment">// This is a dingle-node tree; have no children, do nothing</span></span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.left == <span class="keyword">this</span>) &#123;</span><br><span class="line">    				parent.left = left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right == <span class="keyword">this</span>) &#123;</span><br><span class="line">    				parent.right = left != <span class="keyword">null</span>? left : right;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			<span class="keyword">return</span> left.getMinValue();</span><br><span class="line">    		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="700-Search-in-a-Binary-Search-Tree"><a href="#700-Search-in-a-Binary-Search-Tree" class="headerlink" title="700. Search in a Binary Search Tree"></a><a href="https://leetcode.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. Search in a Binary Search Tree</a></h3><h3 id="Solution1-72"><a href="#Solution1-72" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchBST(root.left, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchBST(root.right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-40"><a href="#Solution2-40" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="701-Insert-into-a-Binary-Search-Tree✨"><a href="#701-Insert-into-a-Binary-Search-Tree✨" class="headerlink" title="701. Insert into a Binary Search Tree✨"></a><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. Insert into a Binary Search Tree✨</a></h3><h3 id="Solution1-73"><a href="#Solution1-73" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">        root.left = insertIntoBST(root.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.right = insertIntoBST(root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-41"><a href="#Solution2-41" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; cur.val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur.left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="450-Delete-Node-in-a-BST"><a href="#450-Delete-Node-in-a-BST" class="headerlink" title="450. Delete Node in a BST"></a><a href="https://leetcode.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. Delete Node in a BST</a></h3><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/01/25/bst_deletion_case_1.png" alt=""></p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/01/25/bst_deletion_case_2.png" alt=""></p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/01/25/bst_deletion_case_3.png" alt=""></p>
<h3 id="Solution1-74"><a href="#Solution1-74" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete from the right subtree</span></span><br><span class="line">    <span class="keyword">if</span> (key &gt; root.val) root.right = deleteNode(root.right, key);</span><br><span class="line">    <span class="comment">// delete from the left subtree</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root.val) root.left = deleteNode(root.left, key);</span><br><span class="line">    <span class="comment">// delete the current node</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// the node is a leaf</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// the node is not a leaf and has a right child</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.val = successor(root);</span><br><span class="line">            root.right = deleteNode(root.right, root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the node is not a leaf, has no right child, and has a left child    </span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            root.val = predecessor(root);</span><br><span class="line">            root.left = deleteNode(root.left, root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//One step right and then always left</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">    <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) root = root.left;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//One step left and then always right</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">predecessor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">    <span class="keyword">while</span> (root.right != <span class="keyword">null</span>) root = root.right;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="109-Convert-Sorted-List-to-Binary-Search-Tree⭐"><a href="#109-Convert-Sorted-List-to-Binary-Search-Tree⭐" class="headerlink" title="109.  Convert Sorted List to Binary Search Tree⭐"></a><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109.  Convert Sorted List to Binary Search Tree⭐</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [-<span class="number">10</span>,-<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">Output: [<span class="number">0</span>,-<span class="number">3</span>,<span class="number">9</span>,-<span class="number">10</span>,<span class="keyword">null</span>,<span class="number">5</span>]</span><br><span class="line">Explanation: One possible answer is [<span class="number">0</span>,-<span class="number">3</span>,<span class="number">9</span>,-<span class="number">10</span>,<span class="keyword">null</span>,<span class="number">5</span>], which represents the shown height balanced BST.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2020/08/17/linked.jpg" alt=""></p>
<h3 id="Solution1-75"><a href="#Solution1-75" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Recursion + Conversion to Array</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        array.add(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> constructBST(array, <span class="number">0</span>, array.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructBST</span><span class="params">(List&lt;Integer&gt; array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(array.get(mid));</span><br><span class="line">    root.left = constructBST(array, left, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = constructBST(array, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1,2,3,6,8,9,10]</span></span><br><span class="line"><span class="comment">     6</span></span><br><span class="line"><span class="comment">    / \</span></span><br><span class="line"><span class="comment">   2   9</span></span><br><span class="line"><span class="comment">  / \ / \</span></span><br><span class="line"><span class="comment"> 1  3 8  10</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">Error check:</span></span><br><span class="line"><span class="comment">list -&gt; BST</span></span><br><span class="line"><span class="comment">if head == null return null</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">recursively helper function, take head, and tail of list as reference</span></span><br><span class="line"><span class="comment">Step1: fast slow pointer,find the mid node in the list, take it as root node, </span></span><br><span class="line"><span class="comment">Step2: recursive call to apply root.left = helper(head, mid), root.right = helper(mid, tail);</span></span><br><span class="line"><span class="comment">Step3 : return root node</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution2:</span></span><br><span class="line"><span class="comment">convert list to array, creat a arraylist, put all listnode val into it</span></span><br><span class="line"><span class="comment">recursively helper function, take start index and last element index as reference</span></span><br><span class="line"><span class="comment">Step1,2,3 basically same with solution1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-42"><a href="#Solution2-42" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>details tricky</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> convertBST(head, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(ListNode head, ListNode tail)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快慢指针寻找mid node</span></span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast != tail &amp;&amp; fast.next != tail) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">    root.left = convertBST(head, slow);</span><br><span class="line">    root.right = convertBST(slow.next, tail);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="108-Convert-Sorted-Array-to-Binary-Search-Tree✨"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree✨" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree✨"></a><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. Convert Sorted Array to Binary Search Tree✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted array: [-<span class="number">10</span>,-<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>],</span><br><span class="line"></span><br><span class="line">One possible answer is: [<span class="number">0</span>,-<span class="number">3</span>,<span class="number">9</span>,-<span class="number">10</span>,<span class="keyword">null</span>,<span class="number">5</span>], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      <span class="number">0</span></span><br><span class="line">     / \</span><br><span class="line">   -<span class="number">3</span>   <span class="number">9</span></span><br><span class="line">   /   /</span><br><span class="line"> -<span class="number">10</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-76"><a href="#Solution1-76" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Preorder Traversal: Always Choose Left Middle Node as a Root</p>
</li>
<li><p>Implement helper function <code>helper(left, right)</code>, which constructs BST from nums elements between indexes <code>left</code> and <code>right</code>:</p>
<ul>
<li>If left &gt; right, then there is no elements available for that subtree. Return None.</li>
<li>Pick left middle element: <code>p = (left + right) // 2</code>.</li>
<li>Initiate the root: <code>root = TreeNode(nums[p])</code>.</li>
<li>Compute recursively left and right subtrees: <code>root.left = helper(left, p - 1)</code>, <code>root.right = helper(p + 1, right)</code>.</li>
</ul>
<p>Return <code>helper(0, len(nums) - 1)</code>.</p>
</li>
<li><p>Time complexity: \mathcal{O}(N)O(<em>N</em>) since we visit each node exactly once.</p>
</li>
<li><p>Space complexity: \mathcal{O}(N)O(<em>N</em>). \mathcal{O}(N)O(<em>N</em>) to keep the output, and \mathcal{O}(\log N)O(log<em>N</em>) for the recursion stack.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> constructBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root.left = constructBST(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = constructBST(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Find-Closest-Value-in-BST-AE-✨"><a href="#Find-Closest-Value-in-BST-AE-✨" class="headerlink" title="Find Closest Value in BST(AE)✨"></a>Find Closest Value in BST(AE)✨</h2><h3 id="270-Closest-Binary-Search-Tree-Value"><a href="#270-Closest-Binary-Search-Tree-Value" class="headerlink" title="270. Closest Binary Search Tree Value"></a><a href="https://leetcode.com/problems/closest-binary-search-tree-value/" target="_blank" rel="noopener">270. Closest Binary Search Tree Value</a></h3><p>Prerequisite to this problem is familiar with <a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener">BST</a></p>
<ol>
<li><p>The idea is first, <strong><code>declare a variable closest infinity, traverse the tree and continually update it</code></strong>.</p>
</li>
<li><p><strong><code>Write a helper method taken the closest value as parameter, keep track the closest value.</code></strong> If we do it recursively, base case is reach the bottom of the tree. </p>
</li>
<li><p><strong><code>Compute the the absolute difference between the current value we are at &amp; target value</code></strong> , if it is smaller than the the absolute difference between the closest  &amp; target value , update the closest.</p>
</li>
<li><p>We can <strong><code>take advantage of BST property</code></strong> by comparing the two values. If the target if greater than the current value we are at, the left of current node must smaller than it, so than the difference between them must greater than current node between target value. So we don’t have to explore them, we can literally eliminate half the BST subtree that we have to cover.</p>
</li>
<li><p>Same to the right, if current value is greater than target value, then for sure, all value on the right must away from target value when compare with current value.</p>
</li>
<li><p>Add an optimal: if the absolute difference is 0, we can just stop there, return the current value immediately</p>
</li>
<li><p>recursively:</p>
<p>O(log n)T  Avg</p>
<p>O(D)S using frame call stack, D is depth</p>
<p>worst case scenario :</p>
<p>O(N) T, tree only have one brunch</p>
<p>O(N)</p>
<p>iteratively : won’t using call stack</p>
<p>O(1) S</p>
</li>
</ol>
<h3 id="Solution1-77"><a href="#Solution1-77" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>recursively algorithm</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findClosestValueInBst</span><span class="params">(BST tree, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(tree, target, tree.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helperMethod</span><span class="params">(BST tree, <span class="keyword">int</span> target, <span class="keyword">int</span> closest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(target - closest) &gt; Math.abs(target - tree.value)) &#123;  <span class="comment">//update the closest</span></span><br><span class="line">        closest = tree.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; tree.value &amp;&amp; tree.left != <span class="keyword">null</span>) &#123;  <span class="comment">//going left recursively</span></span><br><span class="line">        <span class="keyword">return</span> helperMethod(tree.left, target, closest);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; tree.value &amp;&amp; tree.right != <span class="keyword">null</span>) &#123;  <span class="comment">//going right recursively</span></span><br><span class="line">        <span class="keyword">return</span> helperMethod(tree.right, target, closest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-43"><a href="#Solution2-43" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Using a while loop, and cur to iterate traverse</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iteratively algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findClosestValueInBst</span><span class="params">(BST tree, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(tree, target, tree.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helperMethod</span><span class="params">(BST tree, <span class="keyword">int</span> target, <span class="keyword">int</span> closest)</span> </span>&#123;</span><br><span class="line">    BST cur = tree;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(target - closest) &gt; Math.abs(target - cur.value)) &#123;</span><br><span class="line">            closest = cur.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; cur.value) &#123;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; cur.value) &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> closest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Largest-Smaller-BST-Key💜"><a href="#Largest-Smaller-BST-Key💜" class="headerlink" title="Largest Smaller BST Key💜"></a>Largest Smaller BST Key💜</h3><h3 id="Solution1-78"><a href="#Solution1-78" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Given a root of a Binary Search Tree (BST) and a number <code>num</code>, implement an efficient function <code>findLargestSmallerKey</code> that finds the largest key in the tree that is smaller than <code>num</code>. If such a number doesn’t exist, return -1. Assume that all keys in the tree are nonnegative.</p>
</li>
<li><p>For <code>num = 17</code> and the binary search tree below:</p>
<p><img src="https://raw.githubusercontent.com/JiawenQi98/PrampPractice/master/Largest%20Smaller%20BST%20Key/example.png" alt=""></p>
<p>Your function would return: <code>14</code> since it’s the largest key in the tree that is still smaller than <code>17</code>.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargestSmallerBSTKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        Node parent;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> key) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findLargestSmallerKey</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// your code goes here</span></span><br><span class="line">            <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">            Node cur = root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.key &lt; num) &#123;</span><br><span class="line">                    result = cur.key;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.left;   <span class="comment">//res shoult strictly small than num, so if cur.key &gt; num, go through left subtree and find the smaller value</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * inserts a new node with the given key in the correct place in the tree</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1) if the tree is empty, create the root</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.root = <span class="keyword">new</span> Node(key);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2) otherwise, create a node with the key and traverse down the tree to find where to insert the new node</span></span><br><span class="line">            Node currentNode = <span class="keyword">this</span>.root;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(key);</span><br><span class="line">            <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (key &lt; currentNode.key) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentNode.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        currentNode.left = newNode;</span><br><span class="line">                        newNode.parent = currentNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        currentNode = currentNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        currentNode.right = newNode;</span><br><span class="line">                        newNode.parent = currentNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        currentNode = currentNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        bst.insert(<span class="number">20</span>);</span><br><span class="line">        bst.insert(<span class="number">9</span>);</span><br><span class="line">        bst.insert(<span class="number">25</span>);</span><br><span class="line">        bst.insert(<span class="number">5</span>);</span><br><span class="line">        bst.insert(<span class="number">12</span>);</span><br><span class="line">        bst.insert(<span class="number">11</span>);</span><br><span class="line">        bst.insert(<span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = bst.findLargestSmallerKey(<span class="number">17</span>);</span><br><span class="line">        System.out.println(<span class="string">"Largest smaller number of 17 is: "</span> + result);</span><br><span class="line">        result = bst.findLargestSmallerKey(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"Largest smaller number of 4 is: "</span> + result);</span><br><span class="line">        result = bst.findLargestSmallerKey(<span class="number">26</span>);</span><br><span class="line">        System.out.println(<span class="string">"Largest smaller number of 26 is: "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Validate-BST-AE-⭐"><a href="#Validate-BST-AE-⭐" class="headerlink" title="Validate BST(AE)⭐"></a>Validate BST(AE)⭐</h2><ol>
<li>The question want to <strong><code>determine weather or not this data stature is actually a BST</code></strong>.</li>
<li>The value in left subtree less than current node’s value, and keep updating when traversal</li>
<li>Time O(N) Space O(d) d : depth of the tree</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateBst</span><span class="params">(BST tree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//write your code here</span></span><br><span class="line">        <span class="keyword">return</span> validateBst(tree, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateBst</span><span class="params">(BST tree, <span class="keyword">int</span> minValue, <span class="keyword">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree.value &lt; minValue || tree.value &gt;= maxValue) &#123;  <span class="comment">//base line,-inf &lt;= node.value &lt; 10</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree.left != <span class="keyword">null</span> &amp;&amp; !validateBst(tree.left, minValue, tree.value) &#123;  <span class="comment">//left subtree should be strictly less than the tree.value</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree.right != <span class="keyword">null</span> &amp;&amp; !validateBst(tree.right, tree.value, maxValue) &#123;  <span class="comment">//if go to the right, it should be greater or equal to our current value</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> BST left;</span><br><span class="line">        <span class="keyword">public</span> BST right;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="98-Validate-Binary-Search-Tree⭐"><a href="#98-Validate-Binary-Search-Tree⭐" class="headerlink" title="98. Validate Binary Search Tree⭐"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. Validate Binary Search Tree⭐</a></h3><p>Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: </p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Input: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="keyword">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Input: [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation: The root node<span class="string">'s value is 5 but its right child'</span>s value is <span class="number">4</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-79"><a href="#Solution1-79" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：根据二叉搜索树的条件，递归查找不符合条件的，如有则不是，遍历完成没有则是。O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValid(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValid(root.left, min, root) &amp;&amp; isValid(root.right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(TreeNode root, Long min, Long max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//check valid BST</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; min || root.val &gt; max) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValid(root.left, min, root.val) &amp;&amp; isValid(root.right, root.val, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Feedback don't forget mention the iterative way</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check:</span></span><br><span class="line"><span class="comment">1. if root == null return true;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">    Idea:</span></span><br><span class="line"><span class="comment">    Traverse from root to all the children node, recursively call a method to check if current node fit the BST properity</span></span><br><span class="line"><span class="comment">    because left child lees than parent &amp;&amp; right child greater than parent</span></span><br><span class="line"><span class="comment">    eg. boolean isValid(root, min, max)</span></span><br><span class="line"><span class="comment">    apply to each child : isValid(leftChild, min, root.val) &amp;&amp; isValid(rightChild, root.val. max);</span></span><br><span class="line"><span class="comment">    if all the node fit the BST proprity we can say it's a valid BST otherwise not a valid BST</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(n) n reprent the node number in the tree</span></span><br><span class="line"><span class="comment">Space O(n) call the stack</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-44"><a href="#Solution2-44" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/validate-binary-search-tree/discuss/32112/Learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-(Java-Solution)" target="_blank" rel="noopener">Learn one iterative inorder traversal, apply it to multiple tree questions (Java Solution)</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; root.val &lt;= pre.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1373-Maximum-Sum-BST-in-Binary-Tree✨"><a href="#1373-Maximum-Sum-BST-in-Binary-Tree✨" class="headerlink" title="1373. Maximum Sum BST in Binary Tree✨"></a><a href="https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/" target="_blank" rel="noopener">1373. Maximum Sum BST in Binary Tree✨</a></h2><p><img src="https://assets.leetcode.com/uploads/2020/01/30/sample_1_1709.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">Output: <span class="number">20</span></span><br><span class="line">Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to <span class="number">3</span>.</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s/RST4Cujs0V0yiwRyu1fxCQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/RST4Cujs0V0yiwRyu1fxCQ</a></p>
<h3 id="Solution0"><a href="#Solution0" class="headerlink" title="Solution0:"></a>Solution0:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、首先我想知道以我为根的这棵树是不是 BST，所以我肯定得知道左右子树是不是合法的 BST。因为如果这俩儿子有一个不是 BST，以我为根的这棵树肯定不会是 BST 的，对吧。</span><br><span class="line"><span class="number">2</span>、如果左右子树都是合法的 BST，我得瞅瞅左右子树加上自己还是不是合法的 BST 了。因为按照 BST 的定义，当前节点的值应该大于左子树的最大值，小于右子树的最小值，否则就破坏了 BST 的性质。</span><br><span class="line"><span class="number">3</span>、因为题目要计算最大的节点之和，如果左右子树加上我自己还是一棵合法的 BST，也就是说以我为根的整棵树是一棵 BST，那我需要知道我们这棵 BST 的所有节点值之和是多少，方便和别的 BST 子树争个高下，对吧。</span><br><span class="line"></span><br><span class="line">根据以上三点，站在当前节点的视角，需要知道以下具体信息：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、左右子树是否是 BST。</span><br><span class="line"><span class="number">2</span>、左子树的最大值和右子树的最小值。</span><br><span class="line"><span class="number">3</span>、左右子树的节点值之和。</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 全局变量，记录最终结果</span></span><br><span class="line"><span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 遍历二叉树 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 前序遍历位置 *******/</span></span><br><span class="line">    <span class="comment">// 判断左右子树是不是 BST</span></span><br><span class="line">    <span class="keyword">if</span> (!isBST(root.left) || !isBST(root.right)) &#123;</span><br><span class="line">        goto next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算左子树的最大值和右子树的最小值</span></span><br><span class="line">    <span class="keyword">int</span> leftMax = findMax(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMin = findMin(root.right);</span><br><span class="line">    <span class="comment">// 判断以 root 节点为根的树是不是 BST</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= leftMax || root.val &gt;= rightMin) &#123;</span><br><span class="line">        goto next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果条件都符合，计算当前 BST 的节点之和</span></span><br><span class="line">    <span class="keyword">int</span> leftSum = findSum(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightSum = findSum(root.right);</span><br><span class="line">    <span class="keyword">int</span> rootSum = leftSum + rightSum + root.val;</span><br><span class="line">    <span class="comment">// 计算 BST 节点的最大和</span></span><br><span class="line">    <span class="keyword">this</span>.maxSum = Math.max(maxSum, rootSum);</span><br><span class="line">    <span class="comment">/**************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归左右子树</span></span><br><span class="line">    next:</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算以 root 为根的二叉树的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(TreeNode root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算以 root 为根的二叉树的最小值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(TreeNode root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算以 root 为根的二叉树的节点和 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSum</span><span class="params">(TreeNode root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断以 root 为根的二叉树是否是 BST */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(TreeNode root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这几个辅助函数都是递归函数，都要遍历输入的二叉树，外加traverse函数本身的递归，可以说是递归上加递归，所以这个解法的复杂度是非常高的。</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-80"><a href="#Solution1-80" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>postorder traverse</p>
</li>
<li><p><code>traverse(root)</code>返回一个大小为 4 的 int 数组，我们暂且称它为<code>res</code>，其中：</p>
<p><code>res[0]</code>记录以<code>root</code>为根的二叉树是否是 BST，若为 1 则说明是 BST，若为 0 则说明不是 BST；</p>
<p><code>res[1]</code>记录以<code>root</code>为根的二叉树所有节点中的最小值；</p>
<p><code>res[2]</code>记录以<code>root</code>为根的二叉树所有节点中的最大值；</p>
<p><code>res[3]</code>记录以<code>root</code>为根的二叉树所有节点值之和。</p>
<p>其实这就是把之前分析中说到的几个值放到了<code>res</code>数组中，<strong>最重要的是，我们要试图通过<code>left</code>和<code>right</code>正确推导出<code>res</code>数组</strong>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] traverse(TreeNode root) &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算左右子树</span></span><br><span class="line">    <span class="keyword">int</span>[] left = traverse(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = traverse(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******* 后序遍历位置 *******/</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 这个 if 在判断以 root 为根的二叉树是不是 BST</span></span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 以 root 为根的二叉树是 BST</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算以 root 为根的这棵 BST 的最小值</span></span><br><span class="line">        res[<span class="number">1</span>] = Math.min(left[<span class="number">1</span>], root.val);</span><br><span class="line">        <span class="comment">// 计算以 root 为根的这棵 BST 的最大值</span></span><br><span class="line">        res[<span class="number">2</span>] = Math.max(right[<span class="number">2</span>], root.val);</span><br><span class="line">        <span class="comment">// 计算以 root 为根的这棵 BST 所有节点之和</span></span><br><span class="line">        res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">        <span class="comment">// 更新全局变量</span></span><br><span class="line">        maxSum = Math.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 以 root 为根的二叉树不是 BST</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 其他的值都没必要计算了，因为用不到</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    postOrder(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] postOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] left = postOrder(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = postOrder(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">//if is BST</span></span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>]) &#123;</span><br><span class="line">        cur[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        cur[<span class="number">1</span>] = Math.min(left[<span class="number">1</span>], root.val);</span><br><span class="line">        cur[<span class="number">2</span>] = Math.max(right[<span class="number">2</span>], root.val);</span><br><span class="line">        cur[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">        maxSum = Math.max(maxSum, cur[<span class="number">3</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//not BST</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check:</span></span><br><span class="line"><span class="comment">if input is empty/ null -&gt; return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Situation : find the maxSum of a valid BST in a binary tree</span></span><br><span class="line"><span class="comment">1.we need to know current tree is a valid BST or not?</span></span><br><span class="line"><span class="comment">    tranlate it to sub problem -&gt; </span></span><br><span class="line"><span class="comment">    is left subtree a BST &amp;&amp; right BST a BST</span></span><br><span class="line"><span class="comment">    if root.val &gt; left.max &amp;&amp; root.val &lt; right.min</span></span><br><span class="line"><span class="comment">    if BST, cur.sum = left.sum + right.sum, update the larger one in maxSum and cur.sum</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1: brute force</span></span><br><span class="line"><span class="comment">Step1: set a globa varaible, then tarverse form root, (base case root == null, retrun)</span></span><br><span class="line"><span class="comment">Step2: we check as folowed:</span></span><br><span class="line"><span class="comment">    isBST(root.left), isBST(root.right), </span></span><br><span class="line"><span class="comment">    root.val &gt; findMax(root.left) &amp;&amp; root.val &lt; findMin(right)</span></span><br><span class="line"><span class="comment">    curSum = findSum(root.left) + findSum(root.right) + root.val;</span></span><br><span class="line"><span class="comment">    if (current is BST) maxSum = Math.max(maxSum, curSum)</span></span><br><span class="line"><span class="comment">Step3: return maxSum;</span></span><br><span class="line"><span class="comment">basically we need isBST(), findMax(), findMin(), findSum() several functions, which is really expensive</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Optimized:</span></span><br><span class="line"><span class="comment">postOrder traverse, and use array to record the current status value int[] res = int[4] as return</span></span><br><span class="line"><span class="comment">res[0] -&gt; 1 means BST, 0 means not BST</span></span><br><span class="line"><span class="comment">res[1] -&gt; minValue in current subtree</span></span><br><span class="line"><span class="comment">res[2] -&gt; maxValue in current subtree</span></span><br><span class="line"><span class="comment">res[3] -&gt; sum of current subtree</span></span><br><span class="line"><span class="comment">Step2 become:</span></span><br><span class="line"><span class="comment">    if (left[0] == 1 &amp;&amp; right[0] == 1)</span></span><br><span class="line"><span class="comment">    root.val &gt; left[2] &amp;&amp; root.val &lt; right[1]</span></span><br><span class="line"><span class="comment">    cur[3] = left[3] + right[3] + root.val</span></span><br><span class="line"><span class="comment">    maxSum = Math.max(maxSum, cur[3]);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Go through expamle: vasualize</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(n)</span></span><br><span class="line"><span class="comment">Space O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="Min-Height-BST-AE"><a href="#Min-Height-BST-AE" class="headerlink" title="Min Height BST(AE)"></a>Min Height BST(AE)</h2><ol>
<li>Given a sorted array of distinct integers and construct a binary search tree and return the root of that BST. At the same time minimize the height of BST. minimal height</li>
<li>BST property : for any node in the BST, any node to its left has to have a value strictly smaller than that node. And then any node to its right has to have a value strictly greater than or equal to that node</li>
</ol>
<h3 id="Solution1-81"><a href="#Solution1-81" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n log n) time | O(n) space (because we construct a n node bst)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BST <span class="title">minHeightBst</span><span class="params">(List&lt;Integer&gt; array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//write your code here</span></span><br><span class="line">        <span class="keyword">return</span> constructMinHeightBst(array, <span class="keyword">null</span>, <span class="number">0</span>, array.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BST <span class="title">constructMinHeightBst</span><span class="params">(List&lt;Integer&gt; array, BST bst, <span class="keyword">int</span> startIdx, <span class="keyword">int</span> endIdx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIdx &gt; endIdx) <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">//base line</span></span><br><span class="line">        <span class="keyword">int</span> midIdx = (startIdx + endIdx) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> valueToAdd = array.get(midIdx);</span><br><span class="line">        <span class="keyword">if</span> (bst == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bst = <span class="keyword">new</span> BST(valueToAdd);  <span class="comment">//create a root node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bst.insert(valueToAdd);</span><br><span class="line">        &#125;</span><br><span class="line">        constrcutMinHeightBst(array, bst, startIdx, midIdx - <span class="number">1</span>);  <span class="comment">//recursively call the function make sure everytime take a number in the middle so that the depth of BST is minimum</span></span><br><span class="line">        constrcutMinHeightBst(array, bst, midIdx + <span class="number">1</span>, endIdx);</span><br><span class="line">        <span class="keyword">return</span> bst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> BST left;</span><br><span class="line">        <span class="keyword">public</span> BST right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            lefy = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    left = <span class="keyword">new</span> BST(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left.insert(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    right = <span class="keyword">new</span> BST(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right.insert(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-45"><a href="#Solution2-45" class="headerlink" title="Solution2:"></a>Solution2:</h3><p>Iteratively</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time (because every insertion is constant time) | O(n) space</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BST <span class="title">minHeightBst</span><span class="params">(List&lt;Integer&gt; array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//write your code here</span></span><br><span class="line">        <span class="keyword">return</span> constructMinHeightBst(array, <span class="keyword">null</span>, <span class="number">0</span>, array.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BST <span class="title">constructMinHeightBst</span><span class="params">(List&lt;Integer&gt; array, BST bst, <span class="keyword">int</span> startIdx, <span class="keyword">int</span> endIdx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIdx &gt; endIdx) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> midIdx = (startIdx + endIdx)/<span class="number">2</span>;</span><br><span class="line">        BST newBstNode = <span class="keyword">new</span> BST(array.get(midIdx));</span><br><span class="line">        <span class="keyword">if</span> (bst == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bst = newBstNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (array.get(midIdx) &lt; bst.value) &#123;  <span class="comment">//insert manually, bascally same logic with Solution1</span></span><br><span class="line">                bst.left = newBstNode;</span><br><span class="line">                bst = bst.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bst.right = newBstNode;</span><br><span class="line">                bst = bst.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        constructMinHeightBst(array, bst, startIdx, midIdx - <span class="number">1</span>);</span><br><span class="line">        constructMinHeightBst(array, bst, midIdx + <span class="number">1</span>, endIdx);</span><br><span class="line">        <span class="keyword">return</span> bst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> BST left;</span><br><span class="line">        <span class="keyword">public</span> BST right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            lefy = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    left = <span class="keyword">new</span> BST(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left.insert(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    right = <span class="keyword">new</span> BST(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right.insert(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3:"></a>Solution3:</h3><p>Recursively</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(n) space</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BST <span class="title">minHeightBst</span><span class="params">(List&lt;Integer&gt; array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//write your code here</span></span><br><span class="line">        <span class="keyword">return</span> constructMinHeightBst(array, <span class="number">0</span>, array.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BST <span class="title">constructMinHeightBst</span><span class="params">(List&lt;Integer&gt; array, <span class="keyword">int</span> startIdx, <span class="keyword">int</span> endIdx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIdx &gt; endIdx) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> midIdx = (startIdx + endIdx) / <span class="number">2</span>;</span><br><span class="line">        BST bst = <span class="keyword">new</span> BST(array.get(midIdx));</span><br><span class="line">        bst.left = constructMinHeight(array, startIdx, midIdx - <span class="number">1</span>);</span><br><span class="line">        bst.right = constructMinHeight(array, midIdx + <span class="number">1</span>, endIdx);</span><br><span class="line">        <span class="keyword">return</span> bst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> BST left;</span><br><span class="line">        <span class="keyword">public</span> BST right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            lefy = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    left = <span class="keyword">new</span> BST(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left.insert(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    right = <span class="keyword">new</span> BST(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right.insert(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Same-BSTs-AE"><a href="#Unsolved-Same-BSTs-AE" class="headerlink" title="Unsolved Same BSTs(AE)"></a>Unsolved Same BSTs(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">sameBsts</span><span class="params">(List&lt;Integer&gt; arrayOne, List&lt;Integer&gt; arrayTwo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arrayOne.size() != arrayTwo.size()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (arrayOne.size() == <span class="number">0</span> &amp;&amp; arrayTwo.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (arrayOne.get(<span class="number">0</span>)intValue() != arrayTwo.get(<span class="number">0</span>).intValue()) retrun <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; leftOne = getSmaller(arrayOne);</span><br><span class="line">    List&lt;Integer&gt; leftTwo = getSmaller(arrayTwo);</span><br><span class="line">    List&lt;Integer&gt; rightOne =  getBiggerOrEqual(arrayOne);</span><br><span class="line">    List&lt;Integer&gt; rightTwo = getBiggerOrEqual(arratTwo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sameBsts(leftOne, leftTwo) &amp;&amp; sameBsts(rightOne, rightTwo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getSmaller</span><span class="params">(List&lt;Integer&gt; array)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; samller = <span class="keyword">new</span> ArrayLisy&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.get(i).intValue() &lt; array.get(<span class="number">0</span>).intValue()) &#123;</span><br><span class="line">            sammer.add(array.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smaller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getBiggerOrEqual</span><span class="params">(List&lt;Integer&gt; array)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; biggerOrEqual = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.size(; i++)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.get(i).intValue() &gt;= array.get(<span class="number">0</span>).intValue()) &#123;</span><br><span class="line">            biggerOrEqual.add(array.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> biggerOrEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-1038-Binary-Search-Tree-to-Greater-Sum-Tree"><a href="#Unsolved-1038-Binary-Search-Tree-to-Greater-Sum-Tree" class="headerlink" title="Unsolved 1038. Binary Search Tree to Greater Sum Tree"></a><a href="https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 1038. Binary Search Tree to Greater Sum Tree</a></h2><h3 id="Solution1-82"><a href="#Solution1-82" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterative </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstToGst</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        cur.val += sum;</span><br><span class="line">        sum = cur.val;</span><br><span class="line">        cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-46"><a href="#Solution2-46" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstToGst</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    bstToGstHelper(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bstToGstHelper</span> <span class="params">(TreeNode root, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum =  root.val + bstToGstHelper(root.right, s);</span><br><span class="line">    root.val = sum  + s;</span><br><span class="line">    sum += bstToGstHelper(root.left, root.val);</span><br><span class="line">    <span class="keyword">return</span> sum;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="220-Contains-Duplicate-III"><a href="#220-Contains-Duplicate-III" class="headerlink" title="220. Contains Duplicate III"></a><a href="https://leetcode.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. Contains Duplicate III</a></h2><h3 id="Solution1-83"><a href="#Solution1-83" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">        Long floor = set.floor((<span class="keyword">long</span>) nums[i]);</span><br><span class="line">        Long ceiling = set.ceiling((<span class="keyword">long</span>) nums[i]);</span><br><span class="line">        <span class="keyword">if</span> ((floor != <span class="keyword">null</span> &amp;&amp; nums[i] - floor &lt;= t ) ||</span><br><span class="line">            (ceiling != <span class="keyword">null</span> &amp;&amp; ceiling - nums[i] &lt;= t)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add((<span class="keyword">long</span>) nums[i++]);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) &#123;</span><br><span class="line">            set.remove((<span class="keyword">long</span>) nums[i - k - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><h2 id="Suffix-Trie-Construction-AE"><a href="#Suffix-Trie-Construction-AE" class="headerlink" title="Suffix Trie Construction(AE)"></a>Suffix Trie Construction(AE)</h2><ol>
<li>Write SuffixTrie class support create the trie from a string and searching for strings in the trie</li>
</ol>
<h3 id="Solution1-84"><a href="#Solution1-84" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, TrieNode&gt; children = <span class="keyword">new</span> HashMap&lt;Character, TrieNode&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SuffixTrie</span> </span>&#123;</span><br><span class="line">        TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="keyword">char</span> endSymbol = <span class="string">'*'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SuffixTrie</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">            populateSuffixTrieFrom(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateSuffixTrieFrom</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i) &#123;</span><br><span class="line">                insertSubstringStartingAt(i, str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">publci <span class="keyword">void</span> <span class="title">insertSubstringStartingAt</span><span class="params">(<span class="keyword">int</span> i, String str)</span> </span>&#123;</span><br><span class="line">            TrieNode node = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str.length; ++j) &#123;</span><br><span class="line">                <span class="keyword">char</span> letter = str.charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (!node.children.containsKey(letter)) &#123;</span><br><span class="line">                    TrieNode newNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                    node.childrenput(letter, newNode);</span><br><span class="line">                &#125;</span><br><span class="line">                ndoe = node.children.get(letter);</span><br><span class="line">            &#125;</span><br><span class="line">            node.children.put(endSymbol, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">            TrieNode node = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">char</span> letter = str.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (!node.children.containsKey(letter)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.children.get(letter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.children.containsKey(endSymbol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="208-Implement-Trie-Prefix-Tree-✨"><a href="#208-Implement-Trie-Prefix-Tree-✨" class="headerlink" title="208. Implement Trie (Prefix Tree)✨"></a><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. Implement Trie (Prefix Tree)✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(<span class="string">"apple"</span>);</span><br><span class="line">trie.search(<span class="string">"apple"</span>);   <span class="comment">// returns true</span></span><br><span class="line">trie.search(<span class="string">"app"</span>);     <span class="comment">// returns false</span></span><br><span class="line">trie.startsWith(<span class="string">"app"</span>); <span class="comment">// returns true</span></span><br><span class="line">trie.insert(<span class="string">"app"</span>);   </span><br><span class="line">trie.search(<span class="string">"app"</span>);     <span class="comment">// returns true</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-85"><a href="#Solution1-85" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time complexity : O(m)</li>
<li>Space complexity : O(1)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            node = node.children[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            node = node.children[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-47"><a href="#Solution2-47" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// R links to node children</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode[] links;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        links = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> links[ch -<span class="string">'a'</span>] != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> links[ch -<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> ch, TrieNode node)</span> </span>&#123;</span><br><span class="line">        links[ch -<span class="string">'a'</span>] = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> currentChar = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.containsKey(currentChar)) &#123;</span><br><span class="line">                node.put(currentChar, <span class="keyword">new</span> TrieNode());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.get(currentChar);</span><br><span class="line">        &#125;</span><br><span class="line">        node.setEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// search a prefix or whole key in trie and</span></span><br><span class="line">    <span class="comment">// returns the node where search ends</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchPrefix</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> curLetter = word.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (node.containsKey(curLetter)) &#123;</span><br><span class="line">               node = node.get(curLetter);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">       TrieNode node = searchPrefix(word);</span><br><span class="line">       <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = searchPrefix(prefix);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-211-Design-Add-and-Search-Words-Data-Structure⭐"><a href="#Unsolved-211-Design-Add-and-Search-Words-Data-Structure⭐" class="headerlink" title="Unsolved 211. Design Add and Search Words Data Structure⭐"></a><a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/" target="_blank" rel="noopener">Unsolved 211. Design Add and Search Words Data Structure⭐</a></h2><p><img src="https://leetcode.com/problems/design-add-and-search-words-data-structure/Figures/211/trie.png" alt=""></p>
<p><img src="https://leetcode.com/problems/design-add-and-search-words-data-structure/Figures/211/search2.png" alt=""></p>
<p>There are two main types of trie interview questions:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="noopener">Standard Trie</a>. Design a structure to dynamically add and search strings, for example<ul>
<li><a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/solution/" target="_blank" rel="noopener">Add and Search Word</a>.</li>
<li><a href="https://leetcode.com/articles/word-search-ii" target="_blank" rel="noopener">Word Search II</a>.</li>
<li><a href="https://leetcode.com/articles/design-search-autocomplete-system/" target="_blank" rel="noopener">Design Search Autocomplete System</a>.</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Trie#Bitwise_tries" target="_blank" rel="noopener">Bitwise Trie</a>. Design a structure to dynamically add <em>binary</em> strings and compute maximum/minimum XOR/AND/etc, for example<ul>
<li><a href="https://leetcode.com/articles/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener">Maximum XOR of Two Number in an Array</a>.</li>
</ul>
</li>
</ul>
<h3 id="Solution1-86"><a href="#Solution1-86" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Trie</li>
<li>Time complexity: \mathcal{O}(M)O(<em>M</em>), where M<em>M</em> is the key length. At each step, we either examine or create a node in the trie. That takes only M<em>M</em> operations.</li>
<li>Space complexity: \mathcal{O}(M)O(<em>M</em>). In the worst-case newly inserted key doesn’t share a prefix with the keys already inserted in the trie. We have to add M<em>M</em> new nodes, which takes \mathcal{O}(M)O(<em>M</em>) space.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a word into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the data structure. A word could</span></span><br><span class="line">    <span class="comment">// contain the dot character '.' to represent any one letter.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match(word.toCharArray(), <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> k, TrieNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == chs.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.isWord;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chs[k] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node.children.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.children[i] != <span class="keyword">null</span> &amp;&amp; match(chs, k + <span class="number">1</span>, node.children[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.children[chs[k] - <span class="string">'a'</span>] != <span class="keyword">null</span> &amp;&amp; match(chs, k + <span class="number">1</span>, node.children[chs[k] - <span class="string">'a'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-642-Design-Search-Autocomplete-System🎂✨"><a href="#Unsolved-642-Design-Search-Autocomplete-System🎂✨" class="headerlink" title="Unsolved 642. Design Search Autocomplete System🎂✨"></a><a href="https://leetcode.com/problems/design-search-autocomplete-system/" target="_blank" rel="noopener">Unsolved 642. Design Search Autocomplete System🎂✨</a></h2><p> Maximum XOR of Two Numbers in an Array</p>
<p><img src="https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/Figures/421/trie.png" alt=""></p>
<p><img src="https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/Figures/421/max_xor.png" alt=""></p>
<h3 id="Solution1-87"><a href="#Solution1-87" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    Trie[] children;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> Trie[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Init Trie.</span></span><br><span class="line">    Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">        Trie curNode = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">int</span> curBit = (num &gt;&gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(curNode.children[curBit] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                curNode.children[curBit] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.children[curBit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">        Trie curNode = root;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">int</span> curBit = (num &gt;&gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(curNode.children[curBit ^ <span class="number">1</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                curSum += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                curNode = curNode.children[curBit ^ <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                curNode = curNode.children[curBit];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(curSum, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-48"><a href="#Solution2-48" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            mask = mask | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                set.add(num &amp; mask);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = max | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> prefix : set)&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(tmp ^ prefix)) &#123;</span><br><span class="line">                    max = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Data-Structures-for-Coding-Interviews-in-Java"><a href="#Data-Structures-for-Coding-Interviews-in-Java" class="headerlink" title="Data Structures for Coding Interviews in Java"></a>Data Structures for Coding Interviews in Java</h1><h2 id="Challenge-1-Find-the-Minimum-Value-in-a-Binary-Search-Tree"><a href="#Challenge-1-Find-the-Minimum-Value-in-a-Binary-Search-Tree" class="headerlink" title="Challenge 1: Find the Minimum Value in a Binary Search Tree"></a>Challenge 1: Find the Minimum Value in a Binary Search Tree</h2><h3 id="Solution1-88"><a href="#Solution1-88" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Iterative</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In Binary Search Tree, all values in current node's left subtree are smaller </span></span><br><span class="line">    <span class="comment">// than the current node's value.</span></span><br><span class="line">    <span class="comment">// So keep traversing (in order) towards left till you reach leaf node, and then return leaf node's value</span></span><br><span class="line">    <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-49"><a href="#Solution2-49" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Recursive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// So keep traversing (in order) towards left till you reach leaf node,</span></span><br><span class="line">    <span class="comment">//and then return leaf node's value</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> findMin(root.left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-2-Find-kth-Maximum-Value-in-a-Binary-Search-Tree"><a href="#Challenge-2-Find-kth-Maximum-Value-in-a-Binary-Search-Tree" class="headerlink" title="Challenge 2: Find kth Maximum Value in a Binary Search Tree"></a>Challenge 2: Find kth Maximum Value in a Binary Search Tree</h2><h2 id="Challenge-3-Find-Ancestors-of-Given-Node-in-Binary-Search-Tree"><a href="#Challenge-3-Find-Ancestors-of-Given-Node-in-Binary-Search-Tree" class="headerlink" title="Challenge 3: Find Ancestors of Given Node in Binary Search Tree"></a>Challenge 3: Find Ancestors of Given Node in Binary Search Tree</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IterativeAncesstors</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">	<span class="comment">// Iterative Function to print all ancestors of a given key </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findAncestors</span><span class="params">(Node root, <span class="keyword">int</span> k)</span> </span>&#123; </span><br><span class="line">		String result = <span class="string">""</span>; </span><br><span class="line">		Node tempNode = root; </span><br><span class="line">		<span class="keyword">while</span>(tempNode != <span class="keyword">null</span> &amp;&amp; tempNode.getData() != k)&#123; </span><br><span class="line">			result = result + tempNode.getData() + <span class="string">","</span>; </span><br><span class="line">			<span class="keyword">if</span>(k &lt;= tempNode.getData())&#123; </span><br><span class="line">				tempNode = tempNode.getLeftChild(); </span><br><span class="line">			&#125; <span class="keyword">else</span>&#123; </span><br><span class="line">				tempNode = tempNode.getRightChild(); </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(tempNode == <span class="keyword">null</span>)&#123; </span><br><span class="line">			<span class="keyword">return</span> <span class="string">""</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> result; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Driver code </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; 		</span><br><span class="line">		binarySearchTree tree = <span class="keyword">new</span> binarySearchTree(); 		</span><br><span class="line">		<span class="comment">/* Construct a binary tree like this</span></span><br><span class="line"><span class="comment">				6</span></span><br><span class="line"><span class="comment">			   / \</span></span><br><span class="line"><span class="comment">			  4   9</span></span><br><span class="line"><span class="comment">			 / \  |  \</span></span><br><span class="line"><span class="comment">			2	5 8	  12</span></span><br><span class="line"><span class="comment">					  / \</span></span><br><span class="line"><span class="comment">					 10  14 </span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		tree.add(<span class="number">6</span>); </span><br><span class="line">		tree.add(<span class="number">4</span>); </span><br><span class="line">		tree.add(<span class="number">9</span>); </span><br><span class="line">		tree.add(<span class="number">2</span>); </span><br><span class="line">		tree.add(<span class="number">5</span>); </span><br><span class="line">		tree.add(<span class="number">8</span>); </span><br><span class="line">		tree.add(<span class="number">8</span>); </span><br><span class="line">		tree.add(<span class="number">12</span>); </span><br><span class="line">		tree.add(<span class="number">10</span>); </span><br><span class="line">		tree.add(<span class="number">14</span>); </span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> key = <span class="number">10</span>; </span><br><span class="line">		System.out.print(key + <span class="string">" --&gt; "</span>);</span><br><span class="line">		System.out.print(findAncestors(tree.getRoot(), key)); </span><br><span class="line"></span><br><span class="line">		System.out.println();</span><br><span class="line">		key = <span class="number">5</span>; </span><br><span class="line">		System.out.print(key + <span class="string">" --&gt; "</span>);</span><br><span class="line">		System.out.print(findAncestors(tree.getRoot(), key)); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-4-Find-the-Height-of-a-Binary-Search-Tree"><a href="#Challenge-4-Find-the-Height-of-a-Binary-Search-Tree" class="headerlink" title="Challenge 4: Find the Height of a Binary Search Tree"></a>Challenge 4: Find the Height of a Binary Search Tree</h2><h2 id="Challenge-5-Find-Nodes-at-“k”-Distance-from-the-Root"><a href="#Challenge-5-Find-Nodes-at-“k”-Distance-from-the-Root" class="headerlink" title="Challenge 5: Find Nodes at “k” Distance from the Root"></a>Challenge 5: Find Nodes at “k” Distance from the Root</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findKNodes</span><span class="params">(Node root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder(); <span class="comment">//StringBuilder is immutable</span></span><br><span class="line">    result = findK(root, k, result);</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Helper recursive function to traverse tree and append all the nodes at k distance into result StringBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">findK</span><span class="params">(Node root, <span class="keyword">int</span> k, StringBuilder result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        result.append(root.getData() + <span class="string">","</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        findK(root.getLeftChild(), k - <span class="number">1</span>, result);</span><br><span class="line">        findK(root.getRightChild(), k - <span class="number">1</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Trie-1"><a href="#Trie-1" class="headerlink" title="Trie"></a>Trie</h2><h2 id="Challenge-1-Total-Number-of-Words-in-a-Trie"><a href="#Challenge-1-Total-Number-of-Words-in-a-Trie" class="headerlink" title="Challenge 1: Total Number of Words in a Trie"></a>Challenge 1: Total Number of Words in a Trie</h2><ol>
<li>Since the array under each node is traversed and checked for children, the worst-case running time is O(d^h)<em>O</em>(<em>d**h</em>), where d<em>d</em> is the size of the alphabet (26 for English), and h<em>h</em> is the length of the longest word in the dictionary. Note that d<em>d</em> is constant, but h<em>h</em> is not. So, this is an exponential function.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalWords</span><span class="params">(TrieNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//base case, Leaf denotes end of a word</span></span><br><span class="line">    <span class="keyword">if</span> (root.isWord)</span><br><span class="line">        result++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dfs to children</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (root.children[i] != <span class="keyword">null</span>)</span><br><span class="line">            result += totalWords(root.children[i]);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-2-Find-All-of-the-Words-in-a-Trie"><a href="#Challenge-2-Find-All-of-the-Words-in-a-Trie" class="headerlink" title="Challenge 2: Find All of the Words in a Trie"></a>Challenge 2: Find All of the Words in a Trie</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String keys[] = &#123;<span class="string">"the"</span>, <span class="string">"a"</span>, <span class="string">"there"</span>, <span class="string">"answer"</span>, <span class="string">"any"</span>,</span><br><span class="line">                     <span class="string">"by"</span>, <span class="string">"bye"</span>, <span class="string">"their"</span>,<span class="string">"abc"</span>&#125;;</span><br><span class="line"></span><br><span class="line">Output: <span class="string">"a"</span>, <span class="string">"abc"</span>,<span class="string">"answer"</span>,<span class="string">"any"</span>,<span class="string">"by"</span>,<span class="string">"bye"</span>,<span class="string">"the"</span>,<span class="string">"their"</span>,<span class="string">"there"</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-89"><a href="#Solution1-89" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>The <code>findWords(root)</code> function contains a <code>result</code> ArrayList which will contain all the words in the trie. <code>word</code> is a character array in which node characters are added one by one to keep track of all the alphabets in the same recursive call.</p>
<p><code>getWords()</code> is our recursive function which begins from the root and traverses every node. Whenever a node is the end of a word, <code>temp</code>(containing the character array) is converted into a string and inserted into <code>result</code>.</p>
<p>Since <code>word</code> cannot be reset before recording every new word, we simply update the values at each index using <code>level</code>.</p>
</li>
<li><p>As the algorithm traverses all the nodes, its run time is O(n)<em>O</em>(<em>n</em>) where <strong>n</strong> is the number of nodes in the trie.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">findWords</span><span class="params">(TrieNode root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">//chars to record the valid trienode</span></span><br><span class="line">    <span class="keyword">char</span>[] chararr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">    getWords(root, result, <span class="number">0</span>, chararr);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Recursive Function to generate all words</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getWords</span><span class="params">(TrieNode root, ArrayList&lt;String&gt; result, <span class="keyword">int</span> level, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Leaf denotes end of a word</span></span><br><span class="line">    <span class="keyword">if</span> (root.isWord) &#123;</span><br><span class="line">        <span class="comment">//current word is stored till the 'level' in the character array</span></span><br><span class="line">        String temp = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; level; x++) &#123;</span><br><span class="line">            temp += Character.toString(str[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.children[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//for each valid child, so add that index to the character array</span></span><br><span class="line">            str[level] = (<span class="keyword">char</span>)(i + <span class="string">'a'</span>);</span><br><span class="line">            getWords(root.children[i], result, level + <span class="number">1</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-3-Sort-the-Elements-of-an-Array-using-a-Trie"><a href="#Challenge-3-Sort-the-Elements-of-an-Array-using-a-Trie" class="headerlink" title="Challenge 3: Sort the Elements of an Array using a Trie"></a>Challenge 3: Sort the Elements of an Array using a Trie</h2><ol>
<li><p>Pre-Order Traversal </p>
</li>
<li><p>This exercise is very similar to <strong>Challenge 2</strong>, except the fact that you have to create the trie yourself.</p>
<p>Since the <code>children</code> array for each node stores alphabets in alphabetical order, the tree itself is ordered from top to bottom. All we need to do is make a pre-order traversal (think of <code>a</code> as the left most child and <code>z</code> as the right most child) and store the words in a list just like we did in the previous challenge.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">sortArray</span><span class="params">(String[] arr)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">//Creating Trie and Inserting words from array</span></span><br><span class="line">    Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length ; x++)</span><br><span class="line">        trie.insert(arr[x]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] char_arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">    getWords(trie.getRoot(), result, <span class="number">0</span>, char_arr);  </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Recursive Function to generate all words in alphabetic order</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getWords</span><span class="params">(TrieNode root, ArrayList&lt;String&gt; result, <span class="keyword">int</span> level, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Leaf denotes end of a word</span></span><br><span class="line">    <span class="keyword">if</span> (root.isEndWord) &#123;</span><br><span class="line">        <span class="comment">//current word is stored till the 'level' in the character array</span></span><br><span class="line">        String temp = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; level; x++) &#123;</span><br><span class="line">            temp += Character.toString(str[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.children[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Non-null child, so add that index to the character array</span></span><br><span class="line">            str[level] = (<span class="keyword">char</span>)(i + <span class="string">'a'</span>);</span><br><span class="line">            getWords(root.children[i], result, level + <span class="number">1</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-4-Word-Formation-from-a-Given-Dictionary-using-a-Trie"><a href="#Challenge-4-Word-Formation-from-a-Given-Dictionary-using-a-Trie" class="headerlink" title="Challenge 4: Word Formation from a Given Dictionary using a Trie"></a>Challenge 4: Word Formation from a Given Dictionary using a Trie</h2><p>It returns <code>true</code> if the given word can be generated by combining two words from the given dictionary; otherwise, it returns <code>false</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String dict[] = &#123;<span class="string">"the"</span> ,<span class="string">"hello"</span>, <span class="string">"there"</span>, <span class="string">"answer"</span>, <span class="string">"any"</span>, <span class="string">"Dragon"</span>, </span><br><span class="line">                 <span class="string">"world"</span>, <span class="string">"their"</span>, <span class="string">"inc"</span>&#125;;</span><br><span class="line">String word = <span class="string">"helloworld"</span></span><br><span class="line"></span><br><span class="line">Output: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-90"><a href="#Solution1-90" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>We perform the insert operation <strong>m</strong> times for a dictionary of size <strong>m</strong>. After that, the search operation runs on the <code>word</code> in the sequence:</li>
<li>If the length of the longest word in the dictionary is <strong>h</strong>, then the time taken for trie construction is O(m \times h)<em>O</em>(<em>m</em>×<em>h</em>). Let the length of the word being searched be <strong>n</strong>. Then, the lookup phase takes O(n)<em>O</em>(<em>n</em>). So, overall, the given solution is O(mh + n)<em>O</em>(<em>m**h</em>+<em>n</em>) or O( \text{max}(mh, n) )<em>O</em>(max(<em>m**h</em>,<em>n</em>)). We could argue that in some applications, the trie is constructed only once, and then many many lookups are performed. So, the cost of trie creation is amortized over all the lookups. In that case, the complexity reduces to O(n)<em>O</em>(<em>n</em>).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFormationPossible</span><span class="params">(String[] dict,String word)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//err check</span></span><br><span class="line">    <span class="keyword">if</span> (word.length() &lt; <span class="number">2</span> || dict.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create Trie and insert dictionary elements in it</span></span><br><span class="line">    Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dict.length; i++) &#123;</span><br><span class="line">        trie.insert(dict[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="comment">//Slice the word into two strings in each iteration</span></span><br><span class="line">        String first = word.substring(<span class="number">0</span>, i);</span><br><span class="line">        String second = word.substring(i, word.length());</span><br><span class="line">        <span class="comment">//If both substrings are present in the trie, the condition is fulfilled</span></span><br><span class="line">        <span class="keyword">if</span> (trie.search(first) &amp;&amp; trie.search(second)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// Input dict (use only 'a' through 'z' and lower case)</span></span><br><span class="line">    String dict[] = &#123;<span class="string">"the"</span>, <span class="string">"hello"</span>, <span class="string">"there"</span>, <span class="string">"answer"</span>,<span class="string">"any"</span>, <span class="string">"dragon"</span>, <span class="string">"world"</span>, <span class="string">"their"</span>,  <span class="string">"inc"</span>&#125;;</span><br><span class="line">    Trie t = <span class="keyword">new</span> Trie();</span><br><span class="line">    System.out.println(<span class="string">"Keys: "</span>+ Arrays.toString(dict));</span><br><span class="line">    <span class="keyword">if</span> (isFormationPossible(dict, <span class="string">"helloworld"</span>))</span><br><span class="line">        System.out.println(<span class="string">"true"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">"false"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/200/" rel="tag"># 200</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/24/AWS2/" rel="prev" title="AWS Day02">
      <i class="fa fa-chevron-left"></i> AWS Day02
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/25/AWS3/" rel="next" title="AWS Day03">
      AWS Day03 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Binary-Tree"><span class="nav-number">1.</span> <span class="nav-text">Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Branch-Sums-AE-⭐"><span class="nav-number">1.1.</span> <span class="nav-text">Branch Sums(AE)⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#112-Path-Sum✨"><span class="nav-number">1.1.1.</span> <span class="nav-text">112. Path Sum✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1"><span class="nav-number">1.1.2.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2"><span class="nav-number">1.1.3.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113-Path-Sum-II🎂✨"><span class="nav-number">1.1.4.</span> <span class="nav-text">113. Path Sum II🎂✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1："><span class="nav-number">1.1.5.</span> <span class="nav-text">Solution1：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-1"><span class="nav-number">1.1.6.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#437-Path-Sum-III⭐"><span class="nav-number">1.1.7.</span> <span class="nav-text">437. Path Sum III⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-1"><span class="nav-number">1.1.8.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-2"><span class="nav-number">1.1.9.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1022-Sum-of-Root-To-Leaf-Binary-Numbers⭐"><span class="nav-number">1.2.</span> <span class="nav-text">1022. Sum of Root To Leaf Binary Numbers⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-2"><span class="nav-number">1.2.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-3"><span class="nav-number">1.2.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Prefix-Sum"><span class="nav-number">1.3.</span> <span class="nav-text">Prefix Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#560-Subarray-Sum-Equals-K✨"><span class="nav-number">1.3.1.</span> <span class="nav-text">560. Subarray Sum Equals K✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Soluiton0"><span class="nav-number">1.3.2.</span> <span class="nav-text">Soluiton0:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-3"><span class="nav-number">1.3.3.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-4"><span class="nav-number">1.3.4.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#523-Continuous-Subarray-Sum🎂✨"><span class="nav-number">1.3.5.</span> <span class="nav-text">523. Continuous Subarray Sum🎂✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-4"><span class="nav-number">1.3.6.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-5"><span class="nav-number">1.3.7.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-5"><span class="nav-number">1.3.8.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#724-Find-Pivot-Index"><span class="nav-number">1.3.9.</span> <span class="nav-text">724. Find Pivot Index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-6"><span class="nav-number">1.3.10.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Max-Path-Sum-AE-⭐"><span class="nav-number">1.4.</span> <span class="nav-text">Max Path Sum(AE)⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-7"><span class="nav-number">1.4.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#124-Binary-Tree-Maximum-Path-Sum💜⭐"><span class="nav-number">1.4.2.</span> <span class="nav-text">124. Binary Tree Maximum Path Sum💜⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-8"><span class="nav-number">1.4.3.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1120-Maximum-Average-Subtree⭐"><span class="nav-number">1.4.4.</span> <span class="nav-text">1120. Maximum Average Subtree⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-9"><span class="nav-number">1.4.5.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#257-Binary-Tree-Paths✨"><span class="nav-number">1.4.6.</span> <span class="nav-text">257. Binary Tree Paths✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-10"><span class="nav-number">1.4.7.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-Balanced-Binary-Tree🎂✨"><span class="nav-number">1.4.8.</span> <span class="nav-text">110. Balanced Binary Tree🎂✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-11"><span class="nav-number">1.4.9.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-6"><span class="nav-number">1.4.10.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Tree-Diameter-AE-⭐"><span class="nav-number">1.5.</span> <span class="nav-text">Binary Tree Diameter(AE)⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-12"><span class="nav-number">1.5.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#543-Diameter-of-Binary-Tree⭐"><span class="nav-number">1.5.2.</span> <span class="nav-text">543. Diameter of Binary Tree⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-13"><span class="nav-number">1.5.3.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-Depths-AE"><span class="nav-number">1.6.</span> <span class="nav-text">Node Depths(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-7"><span class="nav-number">1.6.1.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree🎂✨"><span class="nav-number">1.6.2.</span> <span class="nav-text">104. Maximum Depth of Binary Tree🎂✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-14"><span class="nav-number">1.6.3.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-8"><span class="nav-number">1.6.4.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-Minimum-Depth-of-Binary-Tree"><span class="nav-number">1.6.5.</span> <span class="nav-text">111. Minimum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-15"><span class="nav-number">1.6.6.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-9"><span class="nav-number">1.6.7.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#156-Binary-Tree-Upside-Down"><span class="nav-number">1.7.</span> <span class="nav-text">156. Binary Tree Upside Down</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-16"><span class="nav-number">1.7.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Traverse"><span class="nav-number">2.</span> <span class="nav-text">Traverse</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterative-In-order-Traversal-AE-⭐"><span class="nav-number">2.1.</span> <span class="nav-text">Iterative In-order Traversal(AE)⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-17"><span class="nav-number">2.1.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-Binary-Tree-Inorder-Traversal"><span class="nav-number">2.1.2.</span> <span class="nav-text">94. Binary Tree Inorder Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-18"><span class="nav-number">2.1.3.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-10"><span class="nav-number">2.1.4.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#144-Binary-Tree-Preorder-Traversal"><span class="nav-number">2.1.5.</span> <span class="nav-text">144. Binary Tree Preorder Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-19"><span class="nav-number">2.1.6.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-11"><span class="nav-number">2.1.7.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#145-Binary-Tree-Postorder-Traversal✨"><span class="nav-number">2.1.8.</span> <span class="nav-text">145. Binary Tree Postorder Traversal✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-20"><span class="nav-number">2.1.9.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-12"><span class="nav-number">2.1.10.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#429-N-ary-Tree-Level-Order-Traversal⭐"><span class="nav-number">2.1.11.</span> <span class="nav-text">429. N-ary Tree Level Order Traversal⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-21"><span class="nav-number">2.1.12.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#589-N-ary-Tree-Preorder-Traversal"><span class="nav-number">2.1.13.</span> <span class="nav-text">589. N-ary Tree Preorder Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-22"><span class="nav-number">2.1.14.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-13"><span class="nav-number">2.1.15.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#590-N-ary-Tree-Postorder-Traversal✨"><span class="nav-number">2.1.16.</span> <span class="nav-text">590. N-ary Tree Postorder Traversal✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-23"><span class="nav-number">2.1.17.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-14"><span class="nav-number">2.1.18.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1506-Find-Root-of-N-Ary-Tree"><span class="nav-number">2.2.</span> <span class="nav-text">1506. Find Root of N-Ary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-24"><span class="nav-number">2.2.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-15"><span class="nav-number">2.2.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Other-traversal-ways"><span class="nav-number">3.</span> <span class="nav-text">Other traversal ways</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#103-Binary-Tree-Zigzag-Level-Order-Traversal🎂💜⭐"><span class="nav-number">3.1.</span> <span class="nav-text">103. Binary Tree Zigzag Level Order Traversal🎂💜⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-25"><span class="nav-number">3.1.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-16"><span class="nav-number">3.1.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#116-Populating-Next-Right-Pointers-in-Each-Node⭐"><span class="nav-number">3.2.</span> <span class="nav-text">116. Populating Next Right Pointers in Each Node⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-26"><span class="nav-number">3.2.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-17"><span class="nav-number">3.2.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#117-Populating-Next-Right-Pointers-in-Each-Node-II✨"><span class="nav-number">3.3.</span> <span class="nav-text">117. Populating Next Right Pointers in Each Node II✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-27"><span class="nav-number">3.3.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-18"><span class="nav-number">3.3.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#938-Range-Sum-of-BST✨"><span class="nav-number">3.4.</span> <span class="nav-text">938. Range Sum of BST✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-28"><span class="nav-number">3.4.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#199-Binary-Tree-Right-Side-View✨"><span class="nav-number">3.5.</span> <span class="nav-text">199. Binary Tree Right Side View✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-29"><span class="nav-number">3.5.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102-Binary-Tree-Level-Order-Traversal🎂⭐"><span class="nav-number">3.6.</span> <span class="nav-text">102. Binary Tree Level Order Traversal🎂⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thinking-Process："><span class="nav-number">3.6.1.</span> <span class="nav-text">Thinking Process：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-BFS-with-Per-level-Queue"><span class="nav-number">3.6.2.</span> <span class="nav-text">Solution1: BFS with Per-level Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-19"><span class="nav-number">3.6.3.</span> <span class="nav-text">Solution2:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#My-Weakness-Bugs"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">My Weakness &#x2F;Bugs</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#637-Average-of-Levels-in-Binary-Tree"><span class="nav-number">3.6.4.</span> <span class="nav-text">637. Average of Levels in Binary Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-30"><span class="nav-number">3.6.5.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#107-Binary-Tree-Level-Order-Traversal-II🎂"><span class="nav-number">3.6.6.</span> <span class="nav-text">107. Binary Tree Level Order Traversal II🎂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-31"><span class="nav-number">3.6.7.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-20"><span class="nav-number">3.6.8.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#652-Find-Duplicate-Subtrees⭐"><span class="nav-number">3.7.</span> <span class="nav-text">652. Find Duplicate Subtrees⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-32"><span class="nav-number">3.7.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsolved-Solution2"><span class="nav-number">3.7.2.</span> <span class="nav-text">Unsolved Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#662-Maximum-Width-of-Binary-Tree✨"><span class="nav-number">3.8.</span> <span class="nav-text">662. Maximum Width of Binary Tree✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-33"><span class="nav-number">3.8.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#314-Binary-Tree-Vertical-Order-Traversal✨"><span class="nav-number">3.9.</span> <span class="nav-text">314. Binary Tree Vertical Order Traversal✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-34"><span class="nav-number">3.9.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-331-Verify-Preorder-Serialization-of-a-Binary-Tree✨"><span class="nav-number">3.10.</span> <span class="nav-text">Unsolved 331. Verify Preorder Serialization of a Binary Tree✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-35"><span class="nav-number">3.10.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-21"><span class="nav-number">3.10.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-987-Vertical-Order-Traversal-of-a-Binary-Tree✨"><span class="nav-number">3.11.</span> <span class="nav-text">Unsolved 987. Vertical Order Traversal of a Binary Tree✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#545-Boundary-of-Binary-Tree✨"><span class="nav-number">3.12.</span> <span class="nav-text">545. Boundary of Binary Tree✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-36"><span class="nav-number">3.12.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-22"><span class="nav-number">3.12.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#993-Cousins-in-Binary-Tree✨"><span class="nav-number">3.13.</span> <span class="nav-text">993. Cousins in Binary Tree✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-37"><span class="nav-number">3.13.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#129-Sum-Root-to-Leaf-Numbers✨"><span class="nav-number">3.14.</span> <span class="nav-text">129. Sum Root to Leaf Numbers✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-38"><span class="nav-number">3.14.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-1161-Maximum-Level-Sum-of-a-Binary-Tree"><span class="nav-number">3.15.</span> <span class="nav-text">Unsolved 1161. Maximum Level Sum of a Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree"><span class="nav-number">3.16.</span> <span class="nav-text">1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-39"><span class="nav-number">3.16.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Construct-Binary-Tree"><span class="nav-number">4.</span> <span class="nav-text">Construct Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal⭐"><span class="nav-number">4.1.</span> <span class="nav-text">105. Construct Binary Tree from Preorder and Inorder Traversal⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-40"><span class="nav-number">4.1.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal✨"><span class="nav-number">4.1.2.</span> <span class="nav-text">106. Construct Binary Tree from Inorder and Postorder Traversal✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-41"><span class="nav-number">4.1.3.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal✨"><span class="nav-number">4.1.4.</span> <span class="nav-text">889. Construct Binary Tree from Preorder and Postorder Traversal✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-42"><span class="nav-number">4.1.5.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#572-Subtree-of-Another-Tree⭐"><span class="nav-number">4.2.</span> <span class="nav-text">572. Subtree of Another Tree⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-43"><span class="nav-number">4.2.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#297-Serialize-and-Deserialize-Binary-Tree⭐"><span class="nav-number">4.3.</span> <span class="nav-text">297. Serialize and Deserialize Binary Tree⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-44"><span class="nav-number">4.3.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#449-Serialize-and-Deserialize-BST⭐"><span class="nav-number">4.3.2.</span> <span class="nav-text">449.Serialize and Deserialize BST⭐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100-Same-Tree⭐"><span class="nav-number">4.4.</span> <span class="nav-text">100. Same Tree⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-45"><span class="nav-number">4.4.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-23"><span class="nav-number">4.4.2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#617-Merge-Two-Binary-Trees✨"><span class="nav-number">4.4.3.</span> <span class="nav-text">617. Merge Two Binary Trees✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-46"><span class="nav-number">4.4.4.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-24"><span class="nav-number">4.4.5.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101-Symmetric-Tree⭐"><span class="nav-number">4.4.6.</span> <span class="nav-text">101.Symmetric Tree⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-47"><span class="nav-number">4.4.7.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-25"><span class="nav-number">4.4.8.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-261-Graph-Valid-Tree⭐"><span class="nav-number">4.5.</span> <span class="nav-text">Unsolved 261. Graph Valid Tree⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flatten-Binary-Tree-AE"><span class="nav-number">4.6.</span> <span class="nav-text">Flatten Binary Tree(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-48"><span class="nav-number">4.6.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsolved-Solution2-1"><span class="nav-number">4.6.2.</span> <span class="nav-text">Unsolved Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#114-Flatten-Binary-Tree-to-Linked-List🎂✨"><span class="nav-number">4.6.3.</span> <span class="nav-text">114. Flatten Binary Tree to Linked List🎂✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-49"><span class="nav-number">4.6.4.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-26"><span class="nav-number">4.6.5.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Invert-Binary-Tree-AE-💜✨"><span class="nav-number">4.7.</span> <span class="nav-text">Invert Binary Tree(AE)💜✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-50"><span class="nav-number">4.7.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-27"><span class="nav-number">4.7.2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#226-Invert-Binary-Tree✨"><span class="nav-number">4.7.3.</span> <span class="nav-text">226. Invert Binary Tree✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-51"><span class="nav-number">4.7.4.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-28"><span class="nav-number">4.7.5.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree⭐"><span class="nav-number">4.8.</span> <span class="nav-text">236. Lowest Common Ancestor of a Binary Tree⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-52"><span class="nav-number">4.8.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-29"><span class="nav-number">4.8.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-307-Range-Sum-Query-Mutable🎂"><span class="nav-number">4.9.</span> <span class="nav-text">Unsolved 307. Range Sum Query - Mutable🎂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-865-Smallest-Subtree-with-all-the-Deepest-Nodes"><span class="nav-number">4.10.</span> <span class="nav-text">Unsolved 865. Smallest Subtree with all the Deepest Nodes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-53"><span class="nav-number">4.10.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#298-Binary-Tree-Longest-Consecutive-Sequence"><span class="nav-number">4.11.</span> <span class="nav-text">298. Binary Tree Longest Consecutive Sequence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-54"><span class="nav-number">4.11.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1110-Delete-Nodes-And-Return-Forest✨"><span class="nav-number">4.12.</span> <span class="nav-text">1110. Delete Nodes And Return Forest✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-55"><span class="nav-number">4.12.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#250-Count-Univalue-Subtrees💎"><span class="nav-number">4.13.</span> <span class="nav-text">250. Count Univalue Subtrees💎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-56"><span class="nav-number">4.13.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#965-Univalued-Binary-Tree"><span class="nav-number">4.14.</span> <span class="nav-text">965. Univalued Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-57"><span class="nav-number">4.14.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#687-Longest-Univalue-Path✨"><span class="nav-number">4.15.</span> <span class="nav-text">687. Longest Univalue Path✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-58"><span class="nav-number">4.15.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#404-Sum-of-Left-Leaves"><span class="nav-number">4.16.</span> <span class="nav-text">404. Sum of Left Leaves</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-59"><span class="nav-number">4.16.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-30"><span class="nav-number">4.16.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BST"><span class="nav-number">5.</span> <span class="nav-text">BST</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BST-Traversal-AE-⭐"><span class="nav-number">5.1.</span> <span class="nav-text">BST Traversal(AE)⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-60"><span class="nav-number">5.1.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Find-Successor-AE-⭐"><span class="nav-number">5.2.</span> <span class="nav-text">Find Successor(AE)⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-61"><span class="nav-number">5.2.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-31"><span class="nav-number">5.2.2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#285-Inorder-Successor-in-BST⭐"><span class="nav-number">5.2.3.</span> <span class="nav-text">285. Inorder Successor in BST⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-62"><span class="nav-number">5.2.4.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-32"><span class="nav-number">5.2.5.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#510-Inorder-Successor-in-BST-II⭐"><span class="nav-number">5.2.6.</span> <span class="nav-text">510. Inorder Successor in BST II⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-63"><span class="nav-number">5.2.7.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1214-Two-Sum-BSTs⭐"><span class="nav-number">5.2.8.</span> <span class="nav-text">1214.Two Sum BSTs⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-64"><span class="nav-number">5.2.9.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-33"><span class="nav-number">5.2.10.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#653-Two-Sum-IV-Input-is-a-BST⭐"><span class="nav-number">5.2.11.</span> <span class="nav-text">653. Two Sum IV - Input is a BST⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-65"><span class="nav-number">5.2.12.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#99-Recover-Binary-Search-Tree✨"><span class="nav-number">5.2.13.</span> <span class="nav-text">99. Recover Binary Search Tree✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-66"><span class="nav-number">5.2.14.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-34"><span class="nav-number">5.2.15.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#897-Increasing-Order-Search-Tree✨"><span class="nav-number">5.2.16.</span> <span class="nav-text">897. Increasing Order Search Tree✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-67"><span class="nav-number">5.2.17.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-35"><span class="nav-number">5.2.18.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#173-Binary-Search-Tree-Iterator✨"><span class="nav-number">5.2.19.</span> <span class="nav-text">173. Binary Search Tree Iterator✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-68"><span class="nav-number">5.2.20.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-36"><span class="nav-number">5.2.21.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#230-Kth-Smallest-Element-in-a-BST✨"><span class="nav-number">5.2.22.</span> <span class="nav-text">230. Kth Smallest Element in a BST✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-69"><span class="nav-number">5.2.23.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-37"><span class="nav-number">5.2.24.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree✨"><span class="nav-number">5.2.25.</span> <span class="nav-text">235. Lowest Common Ancestor of a Binary Search Tree✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-70"><span class="nav-number">5.2.26.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-38"><span class="nav-number">5.2.27.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BST-Construction-AE-⭐"><span class="nav-number">5.3.</span> <span class="nav-text">BST Construction(AE)⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-71"><span class="nav-number">5.3.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-39"><span class="nav-number">5.3.2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#700-Search-in-a-Binary-Search-Tree"><span class="nav-number">5.3.3.</span> <span class="nav-text">700. Search in a Binary Search Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-72"><span class="nav-number">5.3.4.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-40"><span class="nav-number">5.3.5.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#701-Insert-into-a-Binary-Search-Tree✨"><span class="nav-number">5.3.6.</span> <span class="nav-text">701. Insert into a Binary Search Tree✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-73"><span class="nav-number">5.3.7.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-41"><span class="nav-number">5.3.8.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#450-Delete-Node-in-a-BST"><span class="nav-number">5.3.9.</span> <span class="nav-text">450. Delete Node in a BST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-74"><span class="nav-number">5.3.10.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#109-Convert-Sorted-List-to-Binary-Search-Tree⭐"><span class="nav-number">5.3.11.</span> <span class="nav-text">109.  Convert Sorted List to Binary Search Tree⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-75"><span class="nav-number">5.3.12.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-42"><span class="nav-number">5.3.13.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108-Convert-Sorted-Array-to-Binary-Search-Tree✨"><span class="nav-number">5.3.14.</span> <span class="nav-text">108. Convert Sorted Array to Binary Search Tree✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-76"><span class="nav-number">5.3.15.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Find-Closest-Value-in-BST-AE-✨"><span class="nav-number">5.4.</span> <span class="nav-text">Find Closest Value in BST(AE)✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#270-Closest-Binary-Search-Tree-Value"><span class="nav-number">5.4.1.</span> <span class="nav-text">270. Closest Binary Search Tree Value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-77"><span class="nav-number">5.4.2.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-43"><span class="nav-number">5.4.3.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Largest-Smaller-BST-Key💜"><span class="nav-number">5.4.4.</span> <span class="nav-text">Largest Smaller BST Key💜</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-78"><span class="nav-number">5.4.5.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Validate-BST-AE-⭐"><span class="nav-number">5.5.</span> <span class="nav-text">Validate BST(AE)⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#98-Validate-Binary-Search-Tree⭐"><span class="nav-number">5.5.1.</span> <span class="nav-text">98. Validate Binary Search Tree⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-79"><span class="nav-number">5.5.2.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-44"><span class="nav-number">5.5.3.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1373-Maximum-Sum-BST-in-Binary-Tree✨"><span class="nav-number">5.6.</span> <span class="nav-text">1373. Maximum Sum BST in Binary Tree✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution0"><span class="nav-number">5.6.1.</span> <span class="nav-text">Solution0:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-80"><span class="nav-number">5.6.2.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Min-Height-BST-AE"><span class="nav-number">5.7.</span> <span class="nav-text">Min Height BST(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-81"><span class="nav-number">5.7.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-45"><span class="nav-number">5.7.2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution3"><span class="nav-number">5.7.3.</span> <span class="nav-text">Solution3:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-Same-BSTs-AE"><span class="nav-number">5.8.</span> <span class="nav-text">Unsolved Same BSTs(AE)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-1038-Binary-Search-Tree-to-Greater-Sum-Tree"><span class="nav-number">5.9.</span> <span class="nav-text">Unsolved 1038. Binary Search Tree to Greater Sum Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-82"><span class="nav-number">5.9.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-46"><span class="nav-number">5.9.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#220-Contains-Duplicate-III"><span class="nav-number">5.10.</span> <span class="nav-text">220. Contains Duplicate III</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-83"><span class="nav-number">5.10.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Trie"><span class="nav-number">6.</span> <span class="nav-text">Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Suffix-Trie-Construction-AE"><span class="nav-number">6.1.</span> <span class="nav-text">Suffix Trie Construction(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-84"><span class="nav-number">6.1.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#208-Implement-Trie-Prefix-Tree-✨"><span class="nav-number">6.2.</span> <span class="nav-text">208. Implement Trie (Prefix Tree)✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-85"><span class="nav-number">6.2.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-47"><span class="nav-number">6.2.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-211-Design-Add-and-Search-Words-Data-Structure⭐"><span class="nav-number">6.3.</span> <span class="nav-text">Unsolved 211. Design Add and Search Words Data Structure⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-86"><span class="nav-number">6.3.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-642-Design-Search-Autocomplete-System🎂✨"><span class="nav-number">6.4.</span> <span class="nav-text">Unsolved 642. Design Search Autocomplete System🎂✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-87"><span class="nav-number">6.4.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-48"><span class="nav-number">6.4.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Data-Structures-for-Coding-Interviews-in-Java"><span class="nav-number">7.</span> <span class="nav-text">Data Structures for Coding Interviews in Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-1-Find-the-Minimum-Value-in-a-Binary-Search-Tree"><span class="nav-number">7.1.</span> <span class="nav-text">Challenge 1: Find the Minimum Value in a Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-88"><span class="nav-number">7.1.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-49"><span class="nav-number">7.1.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-2-Find-kth-Maximum-Value-in-a-Binary-Search-Tree"><span class="nav-number">7.2.</span> <span class="nav-text">Challenge 2: Find kth Maximum Value in a Binary Search Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-3-Find-Ancestors-of-Given-Node-in-Binary-Search-Tree"><span class="nav-number">7.3.</span> <span class="nav-text">Challenge 3: Find Ancestors of Given Node in Binary Search Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-4-Find-the-Height-of-a-Binary-Search-Tree"><span class="nav-number">7.4.</span> <span class="nav-text">Challenge 4: Find the Height of a Binary Search Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-5-Find-Nodes-at-“k”-Distance-from-the-Root"><span class="nav-number">7.5.</span> <span class="nav-text">Challenge 5: Find Nodes at “k” Distance from the Root</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trie-1"><span class="nav-number">7.6.</span> <span class="nav-text">Trie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-1-Total-Number-of-Words-in-a-Trie"><span class="nav-number">7.7.</span> <span class="nav-text">Challenge 1: Total Number of Words in a Trie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-2-Find-All-of-the-Words-in-a-Trie"><span class="nav-number">7.8.</span> <span class="nav-text">Challenge 2: Find All of the Words in a Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-89"><span class="nav-number">7.8.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-3-Sort-the-Elements-of-an-Array-using-a-Trie"><span class="nav-number">7.9.</span> <span class="nav-text">Challenge 3: Sort the Elements of an Array using a Trie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-4-Word-Formation-from-a-Given-Dictionary-using-a-Trie"><span class="nav-number">7.10.</span> <span class="nav-text">Challenge 4: Word Formation from a Given Dictionary using a Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-90"><span class="nav-number">7.10.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dejavu"
      src="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
  <p class="site-author-name" itemprop="name">Dejavu</p>
  <div class="site-description" itemprop="description">Stay gold</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Dejavu-19" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Dejavu-19" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/liu.kunling19@gmail.com" title="E-Mail → liu.kunling19@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dejavu</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false});</script></body>
</html>
