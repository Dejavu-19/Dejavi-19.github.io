<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dejavi-19.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Unsolved 932. Beautiful ArrayüíéËä±Ëä±ÈÖ± https:&#x2F;&#x2F;leetcode-cn.com&#x2F;circle&#x2F;article&#x2F;2Xxlw3&#x2F; https:&#x2F;&#x2F;zxi.mytechroad.com&#x2F;blog&#x2F;dynamic-programming&#x2F;leetcode-dp-summary&#x2F; https:&#x2F;&#x2F;leetcode.com&#x2F;discuss&#x2F;general-discussi">
<meta property="og:type" content="article">
<meta property="og:title" content="Dynamic Programming">
<meta property="og:url" content="https://dejavi-19.github.io/2020/09/17/Dynamic%20Programming/index.html">
<meta property="og:site_name" content="Dejavu&#39;s Notebook">
<meta property="og:description" content="Unsolved 932. Beautiful ArrayüíéËä±Ëä±ÈÖ± https:&#x2F;&#x2F;leetcode-cn.com&#x2F;circle&#x2F;article&#x2F;2Xxlw3&#x2F; https:&#x2F;&#x2F;zxi.mytechroad.com&#x2F;blog&#x2F;dynamic-programming&#x2F;leetcode-dp-summary&#x2F; https:&#x2F;&#x2F;leetcode.com&#x2F;discuss&#x2F;general-discussi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/01/16/untitled.png">
<meta property="og:image" content="https://zxi.mytechroad.com/blog/wp-content/uploads/2020/01/56F9A2C8-3F83-4C84-880B-F7551A06029D-1024x580.jpeg">
<meta property="og:image" content="https://assets.leetcode.com/users/leetcode/image_1573111823.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/JiawenQi98/PrampPractice/master/Number%20of%20Paths/example.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png">
<meta property="article:published_time" content="2020-09-17T04:16:45.004Z">
<meta property="article:modified_time" content="2021-04-21T14:03:12.833Z">
<meta property="article:author" content="Dejavu">
<meta property="article:tag" content="200">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode.com/uploads/2020/01/16/untitled.png">

<link rel="canonical" href="https://dejavi-19.github.io/2020/09/17/Dynamic%20Programming/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Dynamic Programming | Dejavu's Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/Dejavu-19" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="ÂàáÊç¢ÂØºËà™Ê†è">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dejavu's Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Alea iacta est</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>È¶ñ&emsp;&emsp;È°µ</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>ÂÖ≥‰∫éÂçö‰∏ª</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Ê†á&emsp;&emsp;Á≠æ</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>ÂàÜ&emsp;&emsp;Á±ª</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>ÂΩí&emsp;&emsp;Ê°£</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/17/Dynamic%20Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dynamic Programming
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">ÂèëË°®‰∫é</span>

              <time title="ÂàõÂª∫Êó∂Èó¥Ôºö2020-09-17 13:16:45" itemprop="dateCreated datePublished" datetime="2020-09-17T13:16:45+09:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Êõ¥Êñ∞‰∫é</span>
                <time title="‰øÆÊîπÊó∂Èó¥Ôºö2021-04-21 23:03:12" itemprop="dateModified" datetime="2021-04-21T23:03:12+09:00">2021-04-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">ÂàÜÁ±ª‰∫é</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="Unsolved-932-Beautiful-Arrayüíé"><a href="#Unsolved-932-Beautiful-Arrayüíé" class="headerlink" title="Unsolved 932. Beautiful Arrayüíé"></a><a href="https://leetcode.com/problems/beautiful-array/" target="_blank" rel="noopener">Unsolved 932. Beautiful Arrayüíé</a></h3><p>Ëä±Ëä±ÈÖ±</p>
<p><a href="https://leetcode-cn.com/circle/article/2Xxlw3/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/2Xxlw3/</a></p>
<p><a href="https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-dp-summary/" target="_blank" rel="noopener">https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-dp-summary/</a></p>
<p><a href="https://leetcode.com/discuss/general-discussion/592146/dynamic-programming-summary/513130" target="_blank" rel="noopener">https://leetcode.com/discuss/general-discussion/592146/dynamic-programming-summary/513130</a></p>
<h2 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a><a href="https://leetcode.com/problems/triangle/" target="_blank" rel="noopener">120. Triangle</a></h2><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> col;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        row = triangle.size();</span><br><span class="line">        col = triangle.get(row - <span class="number">1</span>).size();</span><br><span class="line">        Integer[][] memo = <span class="keyword">new</span> Integer[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, memo, triangle);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, Integer[][] memo, List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (r == row - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> triangle.get(row - <span class="number">1</span>).get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (memo[r][c] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(dfs(r+<span class="number">1</span>, c, memo, triangle), dfs(r+<span class="number">1</span>, c+<span class="number">1</span>, memo, triangle));</span><br><span class="line">            memo[r][c] = triangle.get(r).get(c) + min;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> memo[r][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="474-Ones-and-Zeroes"><a href="#474-Ones-and-Zeroes" class="headerlink" title="474. Ones and Zeroes"></a><a href="https://leetcode.com/problems/ones-and-zeroes/solution/" target="_blank" rel="noopener">474. Ones and Zeroes</a></h2><h3 id="Solution1-Brute-Force-Time-Limit-Exceeded"><a href="#Solution1-Brute-Force-Time-Limit-Exceeded" class="headerlink" title="Solution1: Brute Force [Time Limit Exceeded]"></a>Solution1: Brute Force [Time Limit Exceeded]</h3><p>In the brute force approach we will consider every subset of strs<em>s<strong>t</strong>r**s</em> array and count the total number of zeroes and ones in that subset. The subset with zeroes less than equal to m<em>m</em> and ones less than equal to n<em>n</em> will be considered as the valid subsets. The maximum length subset among all valid subsets will be our required subset.</p>
<p>Obviously, there are 2^n2<em>n</em> subsets possible for the list of length n<em>n</em> and here we are using int(32 bits) for iterating every subset. So this method will not work for the list having length greater than 32.</p>
<ul>
<li>Time complexity : O(2^l<em>x)*O</em>(2<em>l</em>‚àó<em>x</em>). 2^l2<em>l</em> possible subsets, where l<em>l</em> is the length of the list strs<em>s<strong>t</strong>r**s</em> and x<em>x</em> is the average string length.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant Space required.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; strs.length); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> zeroes = <span class="number">0</span>, ones = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] count = countzeroesones(strs[j]);</span><br><span class="line">                    zeroes += count[<span class="number">0</span>];</span><br><span class="line">                    ones += count[<span class="number">1</span>];</span><br><span class="line">                    len++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (zeroes &lt;= m &amp;&amp; ones &lt;= n)</span><br><span class="line">                maxlen = Math.max(maxlen, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countzeroesones(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            c[s.charAt(i)-<span class="string">'0'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ul>
<li>Time complexity : O(l<em>m</em>n)<em>O</em>(<em>l</em>‚àó<em>m</em>‚àó<em>n</em>). memo<em>m<strong>e</strong>m**o</em> array of size l<em>m</em>n<em>l</em>‚àó<em>m</em>‚àó<em>n</em> is filled, where l<em>l</em> is the length of strs<em>s<strong>t</strong>r**s</em>, m<em>m</em> and n<em>n</em> are the number of zeroes and ones respectively.</li>
<li>Space complexity : O(l<em>m</em>n)<em>O</em>(<em>l</em>‚àó<em>m</em>‚àó<em>n</em>). 3D array memo<em>m<strong>e</strong>m**o</em> is used.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[strs.length][m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> calculate(strs, <span class="number">0</span>, m, n, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String[] strs, <span class="keyword">int</span> i, <span class="keyword">int</span> zeroes, <span class="keyword">int</span> ones, <span class="keyword">int</span>[][][] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == strs.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][zeroes][ones] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i][zeroes][ones];</span><br><span class="line">        <span class="keyword">int</span>[] count = countzeroesones(strs[i]);</span><br><span class="line">        <span class="keyword">int</span> taken = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (zeroes - count[<span class="number">0</span>] &gt;= <span class="number">0</span> &amp;&amp; ones - count[<span class="number">1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">            taken = calculate(strs, i + <span class="number">1</span>, zeroes - count[<span class="number">0</span>], ones - count[<span class="number">1</span>], memo) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> not_taken = calculate(strs, i + <span class="number">1</span>, zeroes, ones, memo);</span><br><span class="line">        memo[i][zeroes][ones] = Math.max(taken, not_taken);</span><br><span class="line">        <span class="keyword">return</span> memo[i][zeroes][ones];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countzeroesones(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            c[s.charAt(i)-<span class="string">'0'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="üåïUnsolved-1262-Greatest-Sum-Divisible-by-Three-Shopee"><a href="#üåïUnsolved-1262-Greatest-Sum-Divisible-by-Three-Shopee" class="headerlink" title="üåïUnsolved 1262. Greatest Sum Divisible by Three(Shopee)"></a><a href="https://leetcode.com/problems/greatest-sum-divisible-by-three/" target="_blank" rel="noopener">üåïUnsolved 1262. Greatest Sum Divisible by Three(Shopee)</a></h2><h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><p><a href="https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/431077/JavaC%2B%2BPython-One-Pass-O(1)-space" target="_blank" rel="noopener">https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/431077/JavaC%2B%2BPython-One-Pass-O(1)-space</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//init: dp[i] = max sum such that the remainder == i when sum / 3 </span></span><br><span class="line">    <span class="comment">//dp[0]=0: max sum such that the remainder == 0 when 0 / 3 is 0</span></span><br><span class="line">    <span class="comment">//dp[1]=-Inf: max sum such that the remainder == 1 when 0 / 3 does not exist</span></span><br><span class="line">    <span class="comment">//dp[2]=-Inf: max sum such that the remainder == 2 when 0 / 3 does not exist</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, Integer.MIN_VALUE, Integer.MIN_VALUE&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//dp transition</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> remainder=<span class="number">0</span>; remainder&lt;<span class="number">3</span>; remainder++)&#123;</span><br><span class="line">            <span class="comment">//updating each remainder for current "num"</span></span><br><span class="line">            temp[(num+remainder)%<span class="number">3</span>] = Math.max(dp[(num+remainder)%<span class="number">3</span>], dp[remainder]+num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//rotating array</span></span><br><span class="line">        dp = temp; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return: max sum such that the remainder == 0 when sum / 3 </span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåï10-Regular-Expression-Matching‚≠ê"><a href="#üåï10-Regular-Expression-Matching‚≠ê" class="headerlink" title="üåï10. Regular Expression Matching‚≠ê"></a><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">üåï10. Regular Expression Matching‚≠ê</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    Boolean[][] dp = <span class="keyword">new</span> Boolean[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> decode(<span class="number">0</span>, <span class="number">0</span>, s, p, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String s, String p, Boolean[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> ans;</span><br><span class="line">        <span class="comment">//Â¶ÇÊûúpattern‰∏≠jÂ∑≤ÈÅçÂéÜÂÆåÔºå jÊó†ÂØπÂ∫îÁöÑcharÂ≠òÂú®Êó∂</span></span><br><span class="line">        <span class="keyword">if</span> (j == p.length()) &#123;</span><br><span class="line">            ans = (i == s.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//jÂØπÂ∫îÁöÑcharÂ≠òÂú®Êó∂</span></span><br><span class="line">            <span class="comment">//first match style 'a'-'z'&lt;-&gt;'.', Êù°‰ª∂jÂØπÂ∫îÁöÑcharÂ≠òÂú®,‰∏îc1 == c2 || c2 == '.'</span></span><br><span class="line">            <span class="keyword">boolean</span> first_match = (i &lt; s.length() &amp;&amp; (s.charAt(i) == p.charAt(j) || (p.charAt(j) == <span class="string">'.'</span>) ));</span><br><span class="line">            <span class="comment">//second match style 'ccccc' &lt;-&gt; 'c*', *ÂèØ‰ª•‰∏∫0Ôºå Ê∂àÈô§Ââç‰∏Ä‰∏™c</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="comment">//* == 0 || * != 0</span></span><br><span class="line">                ans = (decode(i, j + <span class="number">2</span>, s, p, dp)) || first_match &amp;&amp; decode(i + <span class="number">1</span>, j, s, p, dp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = first_match &amp;&amp; decode(i + <span class="number">1</span>, j + <span class="number">1</span>, s, p, dp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="376-Wiggle-Subsequence‚û∞"><a href="#376-Wiggle-Subsequence‚û∞" class="headerlink" title="376. Wiggle Subsequence‚û∞"></a><a href="https://leetcode.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. Wiggle Subsequence‚û∞</a></h2><h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>For every position in the array, there are only three possible statuses for it.</p>
<ul>
<li>up position, it means nums[i] &gt; nums[i-1]</li>
<li>down position, it means nums[i] &lt; nums[i-1]</li>
<li>equals to position, nums[i] == nums[i-1]</li>
</ul>
<p>So we can use two arrays up[] and down[] to record <em>the max wiggle sequence length so far</em> at index <strong><em>i</em></strong>.<br>If nums[i] &gt; nums[i-1], that means it wiggles up. the element before it must be a down position. so up[i] = down[i-1] + 1; down[i] keeps the same with before.<br>If nums[i] &lt; nums[i-1], that means it wiggles down. the element before it must be a up position. so down[i] = up[i-1] + 1; up[i] keeps the same with before.<br>If nums[i] == nums[i-1], that means it will not change anything becasue it didn‚Äôt wiggle at all. so both down[i] and up[i] keep the same.</p>
<p>In fact, we can reduce the space complexity to O(1), but current way is more easy to understanding.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( nums.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">    up[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums[i] &gt; nums[i-<span class="number">1</span>] )&#123;</span><br><span class="line">            up[i] = down[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[i] &lt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">            down[i] = up[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">            up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(down[nums.length-<span class="number">1</span>],up[nums.length-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Short version</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> down = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            up = down + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            down = up + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåï1359-Count-All-Valid-Pickup-and-Delivery-Options"><a href="#üåï1359-Count-All-Valid-Pickup-and-Delivery-Options" class="headerlink" title="üåï1359. Count All Valid Pickup and Delivery Options"></a><a href="https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/" target="_blank" rel="noopener">üåï1359. Count All Valid Pickup and Delivery Options</a></h2><h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOrders</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span>[] d : dp) Arrays.fill(d, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.toIntExact(dfs(n, <span class="number">0</span>, dp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pick, <span class="keyword">int</span> delivery, <span class="keyword">long</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (pick == <span class="number">0</span> &amp;&amp; delivery == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[pick][delivery] == -<span class="number">1</span>) &#123;</span><br><span class="line">            dp[pick][delivery] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (pick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[pick][delivery] += pick * dfs(pick - <span class="number">1</span>, delivery + <span class="number">1</span>, dp); </span><br><span class="line">                dp[pick][delivery] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (delivery &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[pick][delivery] += delivery * dfs(pick, delivery - <span class="number">1</span>, dp) % mod;</span><br><span class="line">                dp[pick][delivery] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[pick][delivery];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><p><a href="https://zhuanlan.zhihu.com/p/91582909" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91582909</a></p>
<h2 id="üåïUnsolved-1335-Minimum-Difficulty-of-a-Job-Schedule‚≠ê"><a href="#üåïUnsolved-1335-Minimum-Difficulty-of-a-Job-Schedule‚≠ê" class="headerlink" title="üåïUnsolved 1335. Minimum Difficulty of a Job Schedule‚≠ê"></a><a href="https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/" target="_blank" rel="noopener">üåïUnsolved 1335. Minimum Difficulty of a Job Schedule‚≠ê</a></h2><p><img src="https://assets.leetcode.com/uploads/2020/01/16/untitled.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: jobDifficulty &#x3D; [6,5,4,3,2,1], d &#x3D; 2</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: First day you can finish the first 5 jobs, total difficulty &#x3D; 6.</span><br><span class="line">Second day you can finish the last job, total difficulty &#x3D; 1.</span><br><span class="line">The difficulty of the schedule &#x3D; 6 + 1 &#x3D; 7</span><br></pre></td></tr></table></figure>

<p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2020/01/56F9A2C8-3F83-4C84-880B-F7551A06029D-1024x580.jpeg" alt=""></p>
<h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Solution 1: Top-down DP with cache</p>
</li>
<li><p><code>dfs</code> help find the the minimum difficulty<br>if start work at <code>i</code>th job with <code>d</code> days left.</p>
<p>If <code>d = 1</code>, only one day left, we have to do all jobs,<br>return the maximum difficulty of jobs.</p>
<p>Time complexity <code>O(nnd)</code><br>Space complexity <code>O(nd)</code></p>
</li>
</ol>
<p><a href="https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/963963/Java-Top-down-and-bottom-up-DP-monotonic-stack-time-O(nd)-space-O(nd)-with-detailed-explanation" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/963963/Java-Top-down-and-bottom-up-DP-monotonic-stack-time-O(nd)-space-O(nd)-with-detailed-explanation</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer[][] memo;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] maxSoFar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="keyword">int</span>[] jobDifficulty, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (jobDifficulty == <span class="keyword">null</span> || jobDifficulty.length &lt; d || d &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = jobDifficulty.length;</span><br><span class="line">    memo = <span class="keyword">new</span> Integer[d + <span class="number">1</span>][n];</span><br><span class="line"></span><br><span class="line">    maxSoFar = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    maxSoFar[<span class="number">0</span>] = jobDifficulty[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        maxSoFar[i] = Math.max(maxSoFar[i - <span class="number">1</span>], jobDifficulty[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(jobDifficulty, d, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return min difficulty if dividing A[0..j] to i days</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; j + <span class="number">1</span>) &#123; <span class="comment">// more days than tasks</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxSoFar[j];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (memo[i][j] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memo[i][j] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxK2J = A[j]; <span class="comment">// max(A[k+1..j])</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = j - <span class="number">1</span>; k &gt;= i - <span class="number">2</span>; k--) &#123; <span class="comment">// assume second last subarray ends at A[k]</span></span><br><span class="line">        maxK2J = Math.max(maxK2J, A[k + <span class="number">1</span>]);</span><br><span class="line">        memo[i][j] = Math.min(memo[i][j], maxK2J + dfs(A, i - <span class="number">1</span>, k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/490316/JavaC%2B%2BPython3-DP-O(nd)-Solution" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/490316/JavaC%2B%2BPython3-DP-O(nd)-Solution</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="keyword">int</span>[] jobDifficulty, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = jobDifficulty.length;</span><br><span class="line">    <span class="keyword">if</span>(N &lt; D) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[N][D + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] row : memo) Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(D, <span class="number">0</span>, jobDifficulty, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> len, <span class="keyword">int</span>[] jobDifficulty, <span class="keyword">int</span>[][] memo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = jobDifficulty.length;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span> &amp;&amp; len == N) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span> || len == N) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(memo[len][d] != -<span class="number">1</span>) <span class="keyword">return</span> memo[len][d];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curMax = jobDifficulty[len];</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> schedule = len; schedule &lt; N; ++schedule)&#123;</span><br><span class="line">        curMax = Math.max(curMax, jobDifficulty[schedule]);</span><br><span class="line">        <span class="keyword">int</span> temp = dfs(d - <span class="number">1</span>, schedule + <span class="number">1</span>, jobDifficulty, memo);</span><br><span class="line">        <span class="keyword">if</span>(temp != Integer.MAX_VALUE)</span><br><span class="line">            min = Math.min(min, temp + curMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[len][d] = min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>dp<a href="#">i</a> := min difficulties to schedule jobs 1~i in k days.</p>
<p>Schedule 1 ~ j in k ‚Äì 1 days and schedule j + 1 ~ i in 1 day.</p>
<p>Init: dp[0] [0] = 0 Transition: dp<a href="#">i</a> := min(dp[j] [k -1] + max(jobs[j + 1 ~ i]), k ‚Äì 1 &lt;= j &lt; i Answer: dp[n] [d]</p>
<p>Time complexity: O(n^2*d) Space complexity: O(n)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="keyword">int</span>[] jobDifficulty, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">int</span> n = jobDifficulty.length;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; d) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][d+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] a : dp) &#123;</span><br><span class="line">        Arrays.fill(a, Integer.MAX_VALUE/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= d; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxDifficulty = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= k-<span class="number">1</span>; j--) &#123;</span><br><span class="line">                maxDifficulty = Math.max(maxDifficulty, jobDifficulty[j]);</span><br><span class="line">                dp[i][k] = Math.min(dp[i][k], dp[j][k-<span class="number">1</span>] + maxDifficulty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][d];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Solution1: DP</span></span><br><span class="line"><span class="comment">dp[i][k] = minimum jod difficulty to schedule first i jobs in k days</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">initial: dp[0][0] = 0;, dp[*][*] = Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Transition:</span></span><br><span class="line"><span class="comment">d[i][k] = min&#123;dp[j][k-1] + max(jobs[j+1 ~ i])&#125;;</span></span><br><span class="line"><span class="comment">k-1 &lt;= j &lt; i;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Answer: dp[n][d];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(n^2k)</span></span><br><span class="line"><span class="comment">Space O(nk)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="üåïUnsolved-72-Edit-Distance‚ú®"><a href="#üåïUnsolved-72-Edit-Distance‚ú®" class="headerlink" title="üåïUnsolved 72. Edit Distance‚ú®"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">üåïUnsolved 72. Edit Distance‚ú®</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">main</span><span class="params">(lines)</span>:</span></span><br><span class="line"><span class="function">    # „Åì„ÅÆ„Ç≥„Éº„Éâ„ÅØÊ®ôÊ∫ñÂÖ•Âäõ„Å®Ê®ôÊ∫ñÂá∫Âäõ„ÇíÁî®„ÅÑ„Åü„Çµ„É≥„Éó„É´„Ç≥„Éº„Éâ„Åß„Åô„ÄÇ</span></span><br><span class="line"><span class="function">    # „Åì„ÅÆ„Ç≥„Éº„Éâ„ÅØÂ•Ω„Åç„Å™„Çà„ÅÜ„Å´Á∑®ÈõÜ„ÉªÂâäÈô§„Åó„Å¶„ÇÇ„Çâ„Å£„Å¶Êßã„ÅÑ„Åæ„Åõ„Çì„ÄÇ</span></span><br><span class="line"><span class="function">    # ---</span></span><br><span class="line"><span class="function">    # This is a sample code to use stdin and stdout.</span></span><br><span class="line"><span class="function">    # Edit and remove <span class="keyword">this</span> code as you like.</span></span><br><span class="line"><span class="function">    <span class="keyword">try</span>:</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> not lines: </span></span><br><span class="line"><span class="function">            <span class="title">print</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        elif <span class="title">len</span><span class="params">(lines)</span> !</span>=<span class="number">1</span>: </span><br><span class="line">            print(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            word_pair = lines[<span class="number">0</span>].split(<span class="string">" "</span>)</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(word_pair)</span> </span>== <span class="number">1</span>: </span><br><span class="line">                print(len(word_pair[<span class="number">0</span>]))</span><br><span class="line">            <span class="function">elif <span class="title">len</span><span class="params">(word_pair)</span> &gt; 2: </span></span><br><span class="line"><span class="function">                <span class="title">exit</span><span class="params">(<span class="number">100</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">else</span>:</span></span><br><span class="line"><span class="function">                word1, word2 </span>= word_pair</span><br><span class="line">                <span class="keyword">if</span> not word1.isalnum() or not word2.isalnum(): exit(<span class="number">100</span>)</span><br><span class="line">                ans = minDistance(word1, word2)</span><br><span class="line">                print(ans)</span><br><span class="line">    except:</span><br><span class="line">        exit(<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function">def <span class="title">minDistance</span><span class="params">(word1: str, word2: str)</span>:</span></span><br><span class="line"><span class="function">        m </span>= len(word1)</span><br><span class="line">        n = len(word2)</span><br><span class="line">        <span class="keyword">if</span> n * m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> n + m</span><br><span class="line">        res = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="function"><span class="keyword">for</span> _ in <span class="title">range</span><span class="params">(n+<span class="number">1</span>)</span>]</span></span><br><span class="line"><span class="function">        <span class="keyword">for</span> i in <span class="title">range</span><span class="params">(n+<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">            res[i][0] </span>= i</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">for</span> j in <span class="title">range</span><span class="params">(m+<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">            res[0][j] </span>= j</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">1</span>, n+<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">            <span class="keyword">for</span> j in <span class="title">range</span><span class="params">(<span class="number">1</span>, m+<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">                <span class="keyword">if</span> word1[j-1] !</span>= word2[i-<span class="number">1</span>]:</span><br><span class="line">                    res[i][j] = <span class="number">1</span> + min(res[i-<span class="number">1</span>][j], res[i][j-<span class="number">1</span>], res[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res[i][j] = <span class="number">1</span> + min(res[i-<span class="number">1</span>][j], res[i][j-<span class="number">1</span>], res[i-<span class="number">1</span>][j-<span class="number">1</span>]-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res[n][m]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lines = []</span><br><span class="line">    <span class="keyword">for</span> l in sys.stdin:</span><br><span class="line">        lines.append(l.rstrip(<span class="string">'\r\n'</span>))</span><br><span class="line">    main(lines)</span><br></pre></td></tr></table></figure>



<h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>Top down dfs + memo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.length();</span><br><span class="line">    <span class="keyword">int</span> n = word2.length();</span><br><span class="line">    Integer[][] memo = <span class="keyword">new</span> Integer[m][n];</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, word1, word2, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String word1, String word2, Integer[][] memo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == word1.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> word2.length() - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == word2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> word1.length() - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memo[i][j] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//same character no need to operation</span></span><br><span class="line">        <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(i + <span class="number">1</span>, j + <span class="number">1</span>, word1, word2, memo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> insert = <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, word1, word2, memo);</span><br><span class="line">        <span class="keyword">int</span> remove = <span class="number">1</span> + dfs(i, j + <span class="number">1</span>, word1, word2, memo);</span><br><span class="line">        <span class="keyword">int</span> replace = <span class="number">1</span> + dfs(i + <span class="number">1</span>, j + <span class="number">1</span>, word1, word2, memo);</span><br><span class="line"></span><br><span class="line">        memo[i][j] = Math.min(insert, Math.min(remove, replace));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="üåï53-Maximum-Subarray‚ú®"><a href="#üåï53-Maximum-Subarray‚ú®" class="headerlink" title="üåï53. Maximum Subarray‚ú®"></a><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">üåï53. Maximum Subarray‚ú®</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Find the contiguous subarray within an <span class="title">array</span> <span class="params">(containing at least one number)</span> which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum </span>= <span class="number">6</span>.</span><br><span class="line"></span><br><span class="line">Input: nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] has the largest sum = <span class="number">6</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>ÊÄùË∑Ø 1ÔºöÁ±ª‰ººËÇ°Á•®È¢òÁõÆÔºåÈÄê‰∏ÄÊ±ÇÂíåÔºåÂ¶ÇÊûúÂ∞è‰∫é 0 ÂàôÂÜç‰ªé 0 ÂºÄÂßã„ÄÇO(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[i];</span><br><span class="line">        sum += cur;</span><br><span class="line">        max = Math.max(max, sum);</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/maximum-subarray/discuss/20193/DP-solution-and-some-thoughts" target="_blank" rel="noopener">ÊÄùË∑Ø</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> currSum = nums[<span class="number">0</span>], maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        currSum = Math.max(nums[i], currSum + nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum, currSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        curSum = Math.max(nums[i], curSum + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (curSum &gt; max) &#123;</span><br><span class="line">            max = curSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//dp[i] means the maximum subarray ending with A[i];</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåï91-Decode-Ways‚ú®üé∂"><a href="#üåï91-Decode-Ways‚ú®üé∂" class="headerlink" title="üåï91. Decode Ways‚ú®üé∂"></a><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">üåï91. Decode Ways‚ú®üé∂</a></h2><h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Integer[] dp = <span class="keyword">new</span> Integer[s.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> recursiveWithMemo(<span class="number">0</span>, s, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursiveWithMemo</span><span class="params">(<span class="keyword">int</span> idx, String s, Integer[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case,order matter edgecase input "0"</span></span><br><span class="line">    <span class="comment">// If you reach the end of the string</span></span><br><span class="line">    <span class="comment">// Return 1 for success.</span></span><br><span class="line">    <span class="keyword">if</span> (idx == s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the string starts with a zero, it can't be decoded</span></span><br><span class="line">    <span class="keyword">if</span> (s.charAt(idx) == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> oneChar = recursiveWithMemo(idx + <span class="number">1</span>, s, dp);</span><br><span class="line">        <span class="keyword">int</span> twoChar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(s.substring(idx, idx + <span class="number">2</span>)) &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            twoChar = recursiveWithMemo(idx + <span class="number">2</span>, s, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx] = oneChar + twoChar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation" target="_blank" rel="noopener">explanation</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//""</span></span><br><span class="line">    dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> oneDigits = Integer.valueOf(s.substring(i - <span class="number">1</span>, i));</span><br><span class="line">        <span class="keyword">int</span> twoDigits = Integer.valueOf(s.substring(i - <span class="number">2</span>, i));</span><br><span class="line">        <span class="keyword">if</span> (oneDigits &gt;= <span class="number">1</span> &amp;&amp; oneDigits &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">            dp[i] += dp[i-<span class="number">1</span>];  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (twoDigits &gt;= <span class="number">10</span> &amp;&amp; twoDigits &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="221-Maximal-Square‚≠ê"><a href="#221-Maximal-Square‚≠ê" class="headerlink" title="221. Maximal Square‚≠ê"></a><a href="https://leetcode.com/problems/maximal-square/" target="_blank" rel="noopener">221. Maximal Square‚≠ê</a></h2><p><img src="https://assets.leetcode.com/users/leetcode/image_1573111823.png" alt=""></p>
<h3 id="Solution0"><a href="#Solution0" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute force</li>
<li>Time complexity : O\big((mn)^2\big)<em>O</em>((<em>m**n</em>)2). In worst case, we need to traverse the complete matrix for every 1.</li>
<li>Space complexity : O(1)<em>O</em>(1). No extra space is used.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxsqlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> sqlen = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">while</span> (sqlen + i &lt; rows &amp;&amp; sqlen + j &lt; cols &amp;&amp; flag) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= sqlen + j; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + sqlen][k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            flag = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= sqlen + i; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[k][j + sqlen] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            flag = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (flag)</span><br><span class="line">                        sqlen++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (maxsqlen &lt; sqlen) &#123;</span><br><span class="line">                    maxsqlen = sqlen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><code>dp[i][j]</code> represents the length of the square which lower right corner is located at <code>(i, j)</code>.<br>If the value of this cell is also <code>1</code>, then the length of the square is the <strong>minimum</strong> of: the one above, its left, and diagonal up-left value +1. Because if one side is short or missing, it will not form a square.</li>
<li>Time complexity : O(mn)<em>O</em>(<em>m**n</em>). Single pass.</li>
<li>Space complexity : O(mn)<em>O</em>(<em>m**n</em>). Another matrix of same size is used for dp.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length; </span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> edge = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n+<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]), dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                edge = Math.max(edge, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edge * edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1155-Number-of-Dice-Rolls-With-Target-Sum‚≠ê"><a href="#1155-Number-of-Dice-Rolls-With-Target-Sum‚≠ê" class="headerlink" title="1155. Number of Dice Rolls With Target Sum‚≠ê"></a><a href="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/" target="_blank" rel="noopener">1155. Number of Dice Rolls With Target Sum‚≠ê</a></h2><h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>dfs + memorization</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> MOD = <span class="number">1000000000</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span> || target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    String s = d + <span class="string">"|"</span> + target;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &gt;= i) &#123;</span><br><span class="line">            res = (res + numRollsToTarget(d - <span class="number">1</span>, f, target - i)) % MOD;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>dp</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[d + <span class="number">1</span>][target + <span class="number">1</span>]; </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//how many possibility can i dices sum up to j;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; i * f) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;         <span class="comment">//If j is larger than largest possible sum of i dices, there is no possible ways.        </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                      <span class="comment">//watch out below condition, or NPE</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f &amp;&amp; k &lt;= j ; k++) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j - k]) % MOD; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[d][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="139-Word-Break‚≠êüé∂"><a href="#139-Word-Break‚≠êüé∂" class="headerlink" title="139. Word Break‚≠êüé∂"></a><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">139. Word Break‚≠êüé∂</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ÈÄíÂΩíÊ±ÇËß£ÔºåÂàíÂàÜleft, right substring</span><br><span class="line">check <span class="keyword">if</span> dic contains right, recursively apply function to left</span><br><span class="line">wordbreak(<span class="string">"leetcode"</span>) = </span><br><span class="line">wordbreak(<span class="string">""</span>) &amp;&amp; inDict(<span class="string">"leetcode"</span>)</span><br><span class="line">|| wordbreak(<span class="string">"l"</span>) &amp;&amp; inDict(<span class="string">"eetcode"</span>)</span><br><span class="line">|| wordbreak(<span class="string">"le"</span>) &amp;&amp; inDict(<span class="string">"etcode"</span>)</span><br><span class="line">|| wordbreak(<span class="string">"lee"</span>) &amp;&amp; inDict(<span class="string">"tcode"</span>)</span><br><span class="line">|| wordbreak(<span class="string">"leet"</span>) &amp;&amp; inDict(<span class="string">"code"</span>) ‚úî</span><br><span class="line">|| wordbreak(<span class="string">"lettc"</span>) &amp;&amp; inDict(<span class="string">"leetcode"</span>)</span><br><span class="line"></span><br><span class="line">wordbreak(<span class="string">"leet"</span>) =</span><br><span class="line">||wordbreak(<span class="string">""</span>) &amp;&amp; inDict(<span class="string">"leet"</span>)‚úî</span><br><span class="line">||wordbreak(<span class="string">"l"</span>) &amp;&amp; inDict(<span class="string">"eet"</span>)</span><br><span class="line">||wordbreak(<span class="string">"le"</span>) &amp;&amp; inDict(<span class="string">"et"</span>)</span><br><span class="line">||wordbreak(<span class="string">"lee"</span>) &amp;&amp; inDict(<span class="string">"t"</span>)</span><br><span class="line">||wordbreak(<span class="string">"leet"</span>) &amp;&amp; inDict(<span class="string">""</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Boolean[] dp = <span class="keyword">new</span> Boolean[s.length()];</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    <span class="keyword">return</span> findPartition(<span class="number">0</span>, s, set, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findPartition</span><span class="params">(<span class="keyword">int</span> idx, String s, Set&lt;String&gt; set, Boolean[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == s.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> canSplit = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            String sub = s.substring(idx, i);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(sub) &amp;&amp; findPartition(i, s, set, dp)) &#123;</span><br><span class="line">                canSplit = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx] = canSplit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">    Map&lt;String, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> wordBreak(s, map, dict);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, Map&lt;String, Boolean&gt; map, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//in memory directly return</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//base case, if s is valid word memorie it and return</span></span><br><span class="line">    <span class="keyword">if</span> (dict.contains(s)) &#123;</span><br><span class="line">        map.put(s, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//divie the string to left right two part, in all possibilities</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        String left = s.substring(<span class="number">0</span>, i);</span><br><span class="line">        String right = s.substring(i);</span><br><span class="line">        <span class="keyword">if</span> (dict.contains(right) &amp;&amp; wordBreak(left, map, dict)) &#123;</span><br><span class="line">            map.put(s, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>ÊÄùË∑Ø 1ÔºöÂä®ÊÄÅËßÑÂàíÔºåÊØèÊ¨°ÈÉΩÂà©Áî®Â∑≤Â§ÑÁêÜÈÉ®ÂàÜÂèØÂàÜ‰ø°ÊÅØÁúãÂà∞ÂΩìÂâç‰ΩçÁΩÆÊòØÂê¶ÂèØÂàÜÔºåÂ¶ÇÊûúÂèØÂàÜÁΩÆ True„ÄÇO(n2k)</p>
</li>
<li><p>f[i] stands for whether subarray(0, i) can be segmented into words from the dictionary. So f[0] means whether subarray(0, 0) (which is an empty string) can be segmented, and of course the answer is yes.</p>
<p>The default value for boolean array is false. Therefore we need to set f[0] to be true.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-140-Word-Break-II‚≠ê"><a href="#Unsolved-140-Word-Break-II‚≠ê" class="headerlink" title="Unsolved 140. Word Break II‚≠ê"></a><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">Unsolved 140. Word Break II‚≠ê</a></h2><h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>ÊÄùË∑Ø 1ÔºöDFS+ÂõûÊ∫ØÔºåÊØèÊ¨°ËØïÁî®ËØçÂÖ∏‰∏≠ÊØè‰∏Ä‰∏™ËØç‰Ωú‰∏∫‰∏ã‰∏ÄÊÆµÂºÄÂßãÁöÑ‰∏ÄÁßçÂèØËÉΩ„ÄÇOÔºàn^2kÔºâ„ÄÇ</li>
<li>Using DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">    Set&lt;String&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    <span class="keyword">return</span> wordBreak(s, map, words);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, HashMap&lt;String,List&lt;String&gt;&gt; map, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//in memory</span></span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//base case, a whole string is a word</span></span><br><span class="line">    <span class="keyword">if</span>(wordDict.contains(s)) &#123;</span><br><span class="line">        res.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; s.length() ; i++) &#123;</span><br><span class="line">        String left = s.substring(<span class="number">0</span> , i);</span><br><span class="line">        String right = s.substring(i);</span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(right)) &#123;</span><br><span class="line">            List&lt;String&gt; temp = wordBreak(left, map, wordDict);</span><br><span class="line">            <span class="keyword">if</span>(temp.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; temp.size() ; j++) &#123;</span><br><span class="line">                    res.add(temp.get(j) + <span class="string">" "</span> + right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s , res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    <span class="keyword">return</span> dfs(s, words, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">dfs</span><span class="params">(String s, Set&lt;String&gt; words, Map&lt;String, List&lt;String&gt;&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.startsWith(word)) &#123;</span><br><span class="line">            List&lt;String&gt; sublist = dfs(s.substring(word.length()), words, map);</span><br><span class="line">            <span class="keyword">for</span> (String sub : sublist) &#123;</span><br><span class="line">                res.add(word + (sub.isEmpty() ? <span class="string">""</span> : <span class="string">" "</span>) + sub);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>ÊÄùË∑Ø 2Ôºö‰∏éÊÄùË∑Ø 1 Á±ª‰ººÔºå‰∏çÊòØËØçÂéªÂåπÈÖçÂ≠óÁ¨¶‰∏≤ÔºåËÄåÊòØÂ≠óÁ¨¶‰∏≤ÂÖàÂàáÂàÜÔºåÂÜçÁúãÂàÜÂá∫Êù•ÁöÑÈÉ®ÂàÜÊòØ‰∏çÊòØÂú®ËØçÂÖ∏‰∏≠„ÄÇ</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE, max = <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">        set.add(word);</span><br><span class="line">        <span class="keyword">int</span> curLen = word.length();</span><br><span class="line">        min = (curLen &lt; min) ? curLen : min;</span><br><span class="line">        max = (curLen &gt; max) ? curLen : max;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] invalid = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()]; <span class="comment">// invalid[i]: [i:] is unbreakable</span></span><br><span class="line">    seperate(s, result, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, set, invalid, min, max);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">seperate</span><span class="params">(String s, List&lt;String&gt; res, StringBuilder tmp, <span class="keyword">int</span> index, HashSet&lt;String&gt; set, <span class="keyword">boolean</span>[] invalid, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">        res.add(tmp.toString().trim());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> breakable = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> prelen = tmp.length();</span><br><span class="line">    <span class="keyword">int</span> rightbound = Math.min(s.length(), index + max);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = index + min; end &lt;= rightbound; end++) &#123;</span><br><span class="line">        <span class="keyword">int</span> curLen = end - index;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; s.length() &amp;&amp; invalid[end])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        String cur = s.substring(index, end);</span><br><span class="line">        <span class="keyword">if</span> (set.contains(cur)) &#123;</span><br><span class="line">            tmp.append(<span class="string">" "</span>).append(cur);</span><br><span class="line">            breakable |= seperate(s, res, tmp, end, set, invalid, min, max);</span><br><span class="line">            tmp.setLength(prelen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    invalid[index] = !breakable;</span><br><span class="line">    <span class="keyword">return</span> breakable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-472-Concatenated-Words‚≠ê"><a href="#Unsolved-472-Concatenated-Words‚≠ê" class="headerlink" title="Unsolved 472. Concatenated Words‚≠ê"></a><a href="https://leetcode.com/problems/concatenated-words/" target="_blank" rel="noopener">Unsolved 472. Concatenated Words‚≠ê</a></h2><p><a href="https://leetcode.com/problems/concatenated-words/discuss/95652/Java-DP-Solution" target="_blank" rel="noopener">https://leetcode.com/problems/concatenated-words/discuss/95652/Java-DP-Solution</a></p>
<p><a href="https://leetcode.com/problems/concatenated-words/discuss/541520/Java-DFS-%2B-Memoization-Clean-code" target="_blank" rel="noopener">https://leetcode.com/problems/concatenated-words/discuss/541520/Java-DFS-%2B-Memoization-Clean-code</a></p>
<p><a href="https://leetcode.com/problems/concatenated-words/discuss/348972/Java-Common-template-Word-Break-I-Word-Break-II-Concatenated-Words" target="_blank" rel="noopener">https://leetcode.com/problems/concatenated-words/discuss/348972/Java-Common-template-Word-Break-I-Word-Break-II-Concatenated-Words</a></p>
<h2 id="64-Minimum-Path-Sum‚≠ê"><a href="#64-Minimum-Path-Sum‚≠ê" class="headerlink" title="64. Minimum Path Sum‚≠ê"></a><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. Minimum Path Sum‚≠ê</a></h2><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[ [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>] ]</span><br><span class="line">Output: <span class="number">7</span></span><br><span class="line">Explanation: Because the path <span class="number">1</span>‚Üí<span class="number">3</span>‚Üí<span class="number">1</span>‚Üí<span class="number">1</span>‚Üí<span class="number">1</span> minimizes the sum.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>ÊÄùË∑ØÔºöÂä®ÊÄÅËßÑÂàí„ÄÇËæπÁïå‰∏äÂè™ËÉΩÁõ¥Êé•Âä†‰∏ä‰∏Ä‰ΩçÁΩÆÊï∞ÂÄºÂà∞ÂΩìÂâç‰ΩçÁΩÆÔºåÈùûËæπÁïåÁöÑÂàôÂèñ‰∏äË°åÊàñÂàó‰∏≠ËæÉÂ∞èÁöÑÂä†Âà∞ÂΩìÂâçÊï∞ÂÄº‰∏≠ÔºåÊúÄÁªà‰ΩçÁΩÆÊï∞ÂÄºÂç≥ÊúÄÂ∞è„ÄÇ</li>
<li>minimizes, ‰ºòÂåñÈóÆÈ¢òÁªèÂ∏∏ÊòØÂä®ÊÄÅËßÑÂàí</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//initial</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//tarverse</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n; ++j) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[[1,3,1],</span></span><br><span class="line"><span class="comment">[1,5,1],</span></span><br><span class="line"><span class="comment">[4,2,1]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Error check :</span></span><br><span class="line"><span class="comment">if input is empty or null. return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">1. First another matrix to store the path sum</span></span><br><span class="line"><span class="comment">   eg. matrix[i][j] = currnet smallest path sum from start point to current pos</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">2. Initial the boundary conditions</span></span><br><span class="line"><span class="comment">    eg. in first row like a prefix sum calculate the all the element value from start point to here: in first col, same with row</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. Traverse from [1,1] position, keep update the cur matrix value</span></span><br><span class="line"><span class="comment">    since we want minimizes the value, we will peek the smaller one from top, or left unit, and add this value with cur num value</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    [1,4,5]</span></span><br><span class="line"><span class="comment">    [2,2+5 = 7, 6]</span></span><br><span class="line"><span class="comment">    [6,8, 7]</span></span><br><span class="line"><span class="comment">4. return matrix[i][j], end point matrix path sum value</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(mn)</span></span><br><span class="line"><span class="comment">Space O(mn)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="121-Best-Time-to-Buy-and-Sell-Stock‚≠ê"><a href="#121-Best-Time-to-Buy-and-Sell-Stock‚≠ê" class="headerlink" title="121. Best Time to Buy and Sell Stock‚≠ê"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock‚≠ê</a></h2><h3 id="Most-consistent-ways-of-dealing-with-the-series-of-stock-problems"><a href="#Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" class="headerlink" title="Most consistent ways of dealing with the series of stock problems"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">Most consistent ways of dealing with the series of stock problems</a></h3><p><a href="https://mp.weixin.qq.com/s/61CU8PcT2z4Po7cVdwTprg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/61CU8PcT2z4Po7cVdwTprg</a></p>
<h3 id="Solution0-1"><a href="#Solution0-1" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute Force</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(N^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">            <span class="keyword">if</span> (profit &gt; maxprofit)</span><br><span class="line">                maxprofit = profit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>One Pass</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">            minprice = prices[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">            maxprofit = prices[i] - minprice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check:</span></span><br><span class="line"><span class="comment">1. If price == null || price.length == 0 return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">Brute force:</span></span><br><span class="line"><span class="comment">Apply double for loop, eg.</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; prices.length; i++) &#123;</span></span><br><span class="line"><span class="comment">    for (int j = i + 1; j &lt; prices.length; j++) &#123;</span></span><br><span class="line"><span class="comment">        if (prices[j] - prices[i] &gt; max) &#123;</span></span><br><span class="line"><span class="comment">            max = prices[j] - prices[i];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Time O(n^2)</span></span><br><span class="line"><span class="comment">Spcae: O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution2:</span></span><br><span class="line"><span class="comment">maxProfit</span></span><br><span class="line"><span class="comment">we want buy the stock in min price and sold it at max prices in the future</span></span><br><span class="line"><span class="comment">we can tarck the current min price, travrse the prices, say </span></span><br><span class="line"><span class="comment">if (current price - Curmin &gt; maxProfit) &#123;</span></span><br><span class="line"><span class="comment">    maxProfit = current price - Curmin;</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">curmin = Math.min(curMin, price) //keep updating min price we have seen</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Go through example: [7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">day: </span></span><br><span class="line"><span class="comment">price: 1</span></span><br><span class="line"><span class="comment">min: 1</span></span><br><span class="line"><span class="comment">profit: </span></span><br><span class="line"><span class="comment">max: </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(n)</span></span><br><span class="line"><span class="comment">Space O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II‚ú®"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II‚ú®" class="headerlink" title="122. Best Time to Buy and Sell Stock II‚ú®"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II‚ú®</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">7</span></span><br><span class="line">Explanation: Buy on day <span class="number">2</span> (price = <span class="number">1</span>) and sell on day <span class="number">3</span> (price = <span class="number">5</span>), profit = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span>.</span><br><span class="line">             Then buy on day <span class="number">4</span> (price = <span class="number">3</span>) and sell on day <span class="number">5</span> (price = <span class="number">6</span>), profit = <span class="number">6</span>-<span class="number">3</span> = <span class="number">3</span>.</span><br><span class="line">    </span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Buy on day <span class="number">1</span> (price = <span class="number">1</span>) and sell on day <span class="number">5</span> (price = <span class="number">5</span>), profit = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span>.</span><br><span class="line">             Note that you cannot buy on day <span class="number">1</span>, buy on day <span class="number">2</span> and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//but that day higer the previous day tehn sell next day</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i + <span class="number">1</span>] &gt; prices[i]) &#123; </span><br><span class="line">            profit += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def compare(a, b):</span><br><span class="line">        if abs(a) &lt; abs(b): return -1</span><br><span class="line">        if abs(a) &gt; abs(b): return 1</span><br><span class="line">        if a &lt; b: return -1</span><br><span class="line">        if a &gt; b: return 1</span><br><span class="line">        return 0</span><br><span class="line"></span><br><span class="line">    arr.sort(cmp &#x3D; compare)</span><br><span class="line">    return arr</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-123-Best-Time-to-Buy-and-Sell-Stock-III‚ú®"><a href="#Unsolved-123-Best-Time-to-Buy-and-Sell-Stock-III‚ú®" class="headerlink" title="Unsolved 123. Best Time to Buy and Sell Stock III‚ú®"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">Unsolved 123. Best Time to Buy and Sell Stock III‚ú®</a></h2><h2 id="Unsolved-188-Best-Time-to-Buy-and-Sell-Stock-IV‚ú®"><a href="#Unsolved-188-Best-Time-to-Buy-and-Sell-Stock-IV‚ú®" class="headerlink" title="Unsolved 188. Best Time to Buy and Sell Stock IV‚ú®"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">Unsolved 188. Best Time to Buy and Sell Stock IV‚ú®</a></h2><h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>ÊÄùË∑ØÔºöÂêå 122 Âíå 123 È¢ò„ÄÇÂ¶ÇÊûúÊ¨°Êï∞‰∏çÂ∞è‰∫éÂ§©Êï∞‰∏ÄÂçäÔºåÂàôÂèØ‰ªªÊÑèÂ§öÊ¨°‰∫§ÊòìÔºåÂè™Ë¶Å‰∏äÊ∂®Â∞±ËÆ°ÂÖ•Âç≥‰∏∫ÊúÄÂ§ßÊî∂Áõä„ÄÇÂ¶Ç ÊûúÊ¨°Êï∞‰∏çÂà∞Â§©Êï∞‰∏ÄÂçäÔºå‰∫åÁª¥Âä®ÊÄÅËßÑ„ÄÇO(kn)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> maxCum(prices);</span><br><span class="line">    <span class="keyword">int</span>[] balance = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(balance, Integer.MIN_VALUE);</span><br><span class="line">    <span class="keyword">int</span>[] profit = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            balance[j] = Math.max(profit[j - <span class="number">1</span>] - price, balance[j]);</span><br><span class="line">            profit[j] = Math.max(balance[j] + price, profit[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCum</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (prices[i + <span class="number">1</span>] &gt; prices[i])</span><br><span class="line">            ans += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i, j] represents the max profit up until prices[j] using at most i transactions. </span></span><br><span class="line"><span class="comment"> * dp[i, j] = max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]) &#123; jj in range of [0, j-1] &#125;</span></span><br><span class="line"><span class="comment"> *          = max(dp[i, j-1], prices[j] + max(dp[i-1, jj] - prices[jj]))</span></span><br><span class="line"><span class="comment"> * dp[0, j] = 0; 0 transactions makes 0 profit</span></span><br><span class="line"><span class="comment"> * dp[i, 0] = 0; if there is only one price data point you can't make any transaction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = prices.length;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//if k &gt;= n/2, then you can make maximum number of transactions.</span></span><br><span class="line">	<span class="keyword">if</span> (k &gt;=  n/<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> maxPro = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (prices[i] &gt; prices[i-<span class="number">1</span>])</span><br><span class="line">				maxPro += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maxPro;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">    	<span class="keyword">int</span> localMax = dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    		dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>],  prices[j] + localMax);</span><br><span class="line">    		localMax = Math.max(localMax, dp[i-<span class="number">1</span>][j] - prices[j]);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3:"></a>Solution3:</h3><ol>
<li>The general idea is DP, while I had to add a ‚ÄúquickSolve‚Äù function to tackle some corner cases to avoid TLE. DP: t(i,j) is the max profit for up to i transactions by time j (0&lt;=i&lt;=K, 0&lt;=j&lt;=T).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= len / <span class="number">2</span>) <span class="keyword">return</span> quickSolve(prices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] t = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>][len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmpMax =  -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            t[i][j] = Math.max(t[i][j - <span class="number">1</span>], prices[j] + tmpMax);</span><br><span class="line">            tmpMax =  Math.max(tmpMax, t[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t[k][len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSolve</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length, profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        <span class="comment">// as long as there is a price gap, we gain a profit.</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Unsolved-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Unsolved 309. Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">Unsolved 309. Best Time to Buy and Sell Stock with Cooldown</a></h2><h2 id="Unsolved-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Feeüåï"><a href="#Unsolved-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Feeüåï" class="headerlink" title="Unsolved 714. Best Time to Buy and Sell Stock with Transaction Feeüåï"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">Unsolved 714. Best Time to Buy and Sell Stock with Transaction Feeüåï</a></h2><h3 id="Top-down-dp"><a href="#Top-down-dp" class="headerlink" title="Top down dp"></a>Top down dp</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[prices.length + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, prices, <span class="number">0</span>, dp, fee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] prices, <span class="keyword">int</span> hasStock, Integer[][] dp, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (prices.length == <span class="number">0</span> || idx &gt;= prices.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][hasStock] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (hasStock == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> buyCur = dfs(idx + <span class="number">1</span>, prices, <span class="number">1</span>, dp, fee) - prices[idx];</span><br><span class="line">            max = Math.max(max, buyCur);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> soldCur = dfs(idx + <span class="number">1</span>, prices, <span class="number">0</span>, dp, fee) + prices[idx] - fee;</span><br><span class="line">            max = Math.max(max, soldCur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> noOperation = dfs(idx + <span class="number">1</span>, prices, hasStock, dp, fee);</span><br><span class="line">        max = Math.max(max, noOperation);</span><br><span class="line">        dp[idx][hasStock] = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][hasStock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. Maximum Product Subarray</a></h2><h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="Max-Subset-Sum-No-Adjacent-AE-‚ú®"><a href="#Max-Subset-Sum-No-Adjacent-AE-‚ú®" class="headerlink" title="Max Subset Sum No Adjacent(AE)‚ú®"></a>Max Subset Sum No Adjacent(AE)‚ú®</h2><ol>
<li><p>Given a no negative integer array</p>
</li>
<li><p>Built an array same length with the input array, maxSums array to storing the greatest number with no adjacent numbers</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">14</span>]  <span class="comment">//input array</span></span><br><span class="line"></span><br><span class="line">[<span class="number">7</span>, <span class="number">10</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">28</span>, <span class="number">33</span>]   <span class="comment">//maxSums </span></span><br><span class="line"><span class="comment">//33 = 19 + 14</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>formula: <strong><code>maxSums[i]</code></strong> = max(<strong><code>maxSums[i - 1]</code></strong>, <strong><code>maxSums[i - 2] + array[i]</code></strong>)</p>
</li>
<li><p>time O(N), space O(N), because we build an array in length N</p>
</li>
</ol>
<h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(n) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubsetSumNoAdjacent</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;  <span class="comment">//edge case1 need take care of, the array is empty</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array.length = <span class="number">1</span>) &#123;  <span class="comment">//edge case2, the array only have one value</span></span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] maxSums = array.clone();  <span class="comment">//copy the main array, fix first 2 element,because maxSums[0] = array[0]</span></span><br><span class="line">    maxSums[<span class="number">1</span>] = Math.max(array[<span class="number">0</span>], array[<span class="number">1</span>]);  <span class="comment">//set the second value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//start traversal and apply the foluma</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">        maxSums[i] = Math.max(maxSums[i - <span class="number">1</span>], maxSums[i - <span class="number">2</span>] + array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSums[array.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Like nth Fib, sliding window</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">14</span>]  <span class="comment">//input array</span></span><br><span class="line"></span><br><span class="line">first &amp; second</span><br><span class="line">[<span class="number">7</span>, <span class="number">10</span>], <span class="number">19</span>, <span class="number">19</span>, <span class="number">28</span>, <span class="number">33</span></span><br><span class="line"><span class="number">7</span>, [<span class="number">10</span>, <span class="number">19</span>], <span class="number">19</span>, <span class="number">28</span>, <span class="number">33</span></span><br><span class="line"><span class="number">7</span>, <span class="number">10</span>, [<span class="number">19</span>, <span class="number">19</span>], <span class="number">28</span>, <span class="number">33</span></span><br><span class="line"><span class="number">7</span>, <span class="number">10</span>, <span class="number">19</span>, [<span class="number">19</span>, <span class="number">28</span>], <span class="number">33</span></span><br><span class="line"><span class="number">7</span>, <span class="number">10</span>, <span class="number">19</span>, <span class="number">19</span>, [<span class="number">28</span>, <span class="number">33</span>]   <span class="comment">//maxSums</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(1) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubsetSumNoAdjacent</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = array[<span class="number">0</span>];  <span class="comment">//create two varaible to store value rather than array in order to save space complexity, represent maxSums[i - 2], in the begining is array[0]</span></span><br><span class="line">    <span class="keyword">int</span> second = Math.max(array[<span class="number">0</span>], array[<span class="number">1</span>]);  <span class="comment">//represent maxSums[i - 1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = Math.max(second, first + array[i]);  <span class="comment">//create varaible to represent maxSums[i - 1]</span></span><br><span class="line">        first = second;</span><br><span class="line">        second = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="198-House-Robber‚ú®üé∂"><a href="#198-House-Robber‚ú®üé∂" class="headerlink" title="198.House Robber‚ú®üé∂"></a><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198.House Robber‚ú®üé∂</a></h3><h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Time complexity : O(n). Assume that n<em>n</em> is the number of houses, the time complexity is O(n)<em>O</em>(<em>n</em>).</li>
<li>Space complexity : O(1).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prevMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : num) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = currMax;</span><br><span class="line">        currMax = Math.max(prevMax + x, currMax);</span><br><span class="line">        prevMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = Math.max(first + nums[i], second);</span><br><span class="line">        first = second;</span><br><span class="line">        second = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213.House Robber II"></a><a href="https://leetcode.com/problems/house-robber-ii/" target="_blank" rel="noopener">213.House Robber II</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regard ayyay[<span class="number">0</span>] and array[array.length - <span class="number">1</span>] as adjacent houses</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-19"><a href="#Solution1-19" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>ÊÄùË∑ØÔºö‰∏éÁ¨¨ 198 È¢òÊÄùË∑Ø‰∏ÄËá¥ÔºåÂè™‰∏çËøáË¶Å‰ªé 0 Âà∞ n-1Ôºå1 Âà∞ n ‰∏≠ÂèñËæÉÂ§ßÁöÑ„ÄÇÂõ†‰∏∫ n Âíå 0 Áõ∏ÈÇª„ÄÇ</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>), rob(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, preMax = <span class="number">0</span>, noRob, rob;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[i];</span><br><span class="line">        rob = preMax + cur;</span><br><span class="line">        noRob = max;</span><br><span class="line">        max = Math.max(rob, noRob);</span><br><span class="line">        preMax = noRob;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Number-Of-Ways-To-Make-Change-AE"><a href="#Number-Of-Ways-To-Make-Change-AE" class="headerlink" title="Number Of Ways To Make Change(AE)"></a>Number Of Ways To Make Change(AE)</h2><ol>
<li><p>Given an integer to represents a target amount of money, and an array input represent the coin denominations</p>
</li>
<li><p>Dynamic programming</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">10</span> [<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>]  <span class="number">4</span> ways (<span class="number">1</span>x10$, <span class="number">2</span>x5$, <span class="number">1</span>x5$+<span class="number">5</span>x1$, <span class="number">10</span>x1$);</span><br><span class="line">ways-&gt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">$   -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">initals:only <span class="number">1</span> way to change <span class="number">0</span>$ which is use <span class="number">0</span> coins, base <span class="keyword">case</span></span><br><span class="line">    </span><br><span class="line">amount &gt;= <span class="number">1</span>$ coin: </span><br><span class="line">ways-&gt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">$   -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">way[<span class="number">1</span>] += way[<span class="number">1</span> - <span class="number">1</span>]</span><br><span class="line">way[<span class="number">2</span>] += way[<span class="number">2</span> - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">amount &gt;= <span class="number">5</span>$ coin: </span><br><span class="line">ways-&gt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">$   -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">way[<span class="number">5</span>] += way[<span class="number">5</span> - <span class="number">5</span>] </span><br><span class="line">way[<span class="number">10</span>] += way[<span class="number">10</span> - <span class="number">5</span>]</span><br><span class="line">    </span><br><span class="line">amount &gt;= <span class="number">10</span>$ coin: </span><br><span class="line">ways-&gt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">$   -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">way[<span class="number">10</span>] += way[<span class="number">10</span> - <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>if denom &lt;= amount: ways[amount] += ways[amount -denom];</p>
</li>
</ol>
<h3 id="Solution1-20"><a href="#Solution1-20" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(nd) d is denoms | O(n) space n is target amount</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfWayToMakeChange</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] denoms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ways = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//base line, only one way to change 0 $</span></span><br><span class="line">    ways[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> denom : denoms) &#123;  <span class="comment">//denoms : 1, 5, 10 ,25</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> amount = <span class="number">1</span>; amount &lt; n + <span class="number">1</span>; ++amount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (denom &lt;= amount) &#123;</span><br><span class="line">                ways[amount] += ways[amount - denom];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="518-Coin-Change-2"><a href="#518-Coin-Change-2" class="headerlink" title="518. Coin Change 2"></a><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">518. Coin Change 2</a></h3><h3 id="Solution1-21"><a href="#Solution1-21" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><strong>Algorithm</strong><ul>
<li>Initiate number of combinations array with the base case ‚Äúno coins‚Äù: <code>dp[0] = 1</code>, and all the rest = 0.</li>
<li>Loop over all coins:<ul>
<li>For each coin, loop over all amounts from 0 to <code>amount</code>:<ul>
<li>For each amount x, compute the number of combinations: <code>dp[x] += dp[x - coin]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>dp[amount]</code>.</li>
</ul>
</li>
<li>Time complexity: \mathcal{O}(N \times \textrm{amount})O(<em>N</em>√óamount), where N is a length of coins array.</li>
<li>Space complexity: \mathcal{O}(\textrm{amount})O(amount) to keep dp array.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coin &lt;= i) &#123;</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>This is a classic knapsack problem. </p>
<p><code>dp[i][j]</code> : the number of combinations to make up amount <code>j</code> by using the first <code>i</code> types of coins<br><code>State transition</code>:</p>
<ol>
<li>not using the <code>i</code>th coin, only using the first <code>i-1</code> coins to make up amount <code>j</code>, then we have <code>dp[i-1][j]</code> ways.</li>
<li>using the <code>i</code>th coin, since we can use unlimited same coin, we need to know how many ways to make up amount <code>j - coins[i-1]</code> by using first <code>i</code> coins(including <code>i</code>th), which is <code>dp[i][j-coins[i-1]]</code></li>
</ol>
</li>
<li><p><strong><code>Initialization:dp[i][0] = 1</code></strong></p>
</li>
<li><pre><code class="java">different ways
amount-&gt; <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span>
types
<span class="number">0</span>        <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>   <span class="number">1</span> 
<span class="number">1</span>(<span class="number">1</span>$)    <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>   <span class="number">1</span> 
<span class="number">2</span>(<span class="number">5</span>$)    <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>   <span class="number">3</span>
<span class="number">3</span>(<span class="number">10</span>$)   <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>   <span class="number">4</span>

dp[<span class="number">2</span>][<span class="number">5</span>] = dp[<span class="number">1</span>][<span class="number">5</span>] + dp[<span class="number">2</span>][<span class="number">5</span> - <span class="number">5</span>] = <span class="number">2</span>
formula:dp[i][j] = dp[i-<span class="number">1</span>][j] + (j &gt;= coins[i-<span class="number">1</span>] ? dp[i][j-coins[i-<span class="number">1</span>]] : <span class="number">0</span>)
&lt;!--Ôøº<span class="number">54</span>--&gt;
</code></pre>
</li>
</ol>
<p>Now we can see that <code>dp[i][j]</code> only rely on <code>dp[i-1][j]</code> and <code>dp[i][j-coins[i]]</code>, then we can optimize the space by only using one-dimension array.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> denom : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (denom &lt;= i) &#123;</span><br><span class="line">                dp[i] += dp[i - denom];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Levenshtein-Distance-AE-‚≠ê"><a href="#Levenshtein-Distance-AE-‚≠ê" class="headerlink" title="Levenshtein Distance(AE)‚≠ê"></a>Levenshtein Distance(AE)‚≠ê</h2><ol>
<li><p>Return the minimum of edit operations to turn string1 to string2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"abc"</span></span><br><span class="line">str2 = <span class="string">"yabd"</span></span><br><span class="line">insert <span class="string">'y'</span> -&gt; yabc</span><br><span class="line">substitude <span class="string">'d'</span> -&gt; yabd</span><br><span class="line"><span class="number">2</span> operations</span><br><span class="line">   <span class="string">""</span> y a b d  -&gt; row mean <span class="string">""</span>„ÄÅ<span class="string">"y"</span>„ÄÅ<span class="string">"ya"</span>„ÄÅ<span class="string">"yab"</span>„ÄÅ<span class="string">"yabd"</span></span><br><span class="line"><span class="string">""</span> <span class="number">0</span>  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">a  <span class="number">1</span>  <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">b  <span class="number">2</span>  <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">c  <span class="number">3</span>  <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">formula: </span><br><span class="line"><span class="keyword">if</span> str1[r] == str2[c]</span><br><span class="line">    E[r] [c] = E[r - <span class="number">1</span>] [c - <span class="number">1</span>], diagonally equal</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	E[r] [c] = <span class="number">1</span> + min(E[r] [c - <span class="number">1</span>], E[r - <span class="number">1</span>] [c], E[r - <span class="number">1</span>] [c - <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>time O(nm) | space O(nm) -&gt; O(min(n, m)) space</p>
</li>
</ol>
<h3 id="Solution1-22"><a href="#Solution1-22" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">levenshteinDistance</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] edits = <span class="keyword">new</span> <span class="keyword">int</span>[str2.length() + <span class="number">1</span>][str1.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//initial the base line</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str2.length() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str1.length() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            edits[i][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        edits[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//start traversal and apply the formula</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str2.length() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; str1.length() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str2.charAt(i - <span class="number">1</span>) == str1.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                edits[i][j] = edits[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                edits[i][j] = <span class="number">1</span> + Math.min(edits[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(edits[i - <span class="number">1</span>][j], edits[i][j - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edits[str2.length()][str1.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-10"><a href="#Solution2-10" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">levenshteinDistance</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    String small = str1.length() &lt; str2.length()? str1 : str2;</span><br><span class="line">    String big = str1.length() &gt;= str2.length()? str1 : str2;</span><br><span class="line">    <span class="keyword">int</span>[] evenEdits = <span class="keyword">new</span> <span class="keyword">int</span>[small.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] oddEdits = <span class="keyword">new</span> <span class="keyword">int</span>[small.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; small.length() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        evenEdits[j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] currentEdits;</span><br><span class="line">    <span class="keyword">int</span>[] previousEdits;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; big.length() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            currentEdits = oddEdits;</span><br><span class="line">            previousEdits = evenEdits;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentEdits = evenEdits;</span><br><span class="line">            previousEdits = oddEdits;</span><br><span class="line">        &#125;</span><br><span class="line">        currentEdits[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; small.length() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (big.charAt(j - <span class="number">1</span>) == small.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                currentEdits[j] = previousEdits[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentEdits[j] = <span class="number">1</span> + Math.min(previousEdits[j - <span class="number">1</span>], Math.min(previousEdits[j], currentEdits[j - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> big.length() % <span class="number">2</span> == <span class="number">0</span> ? evenEdits[small.length()] : oddEdits[small.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-583-Delete-Operation-for-Two-Strings"><a href="#Unsolved-583-Delete-Operation-for-Two-Strings" class="headerlink" title="Unsolved 583. Delete Operation for Two Strings"></a><a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">Unsolved 583. Delete Operation for Two Strings</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"sea"</span>, <span class="string">"eat"</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: You need one step to make <span class="string">"sea"</span> to <span class="string">"ea"</span> and another step to make <span class="string">"eat"</span> to <span class="string">"ea"</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-23"><a href="#Solution1-23" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="Unsolved-Max-Sum-Increasing-Subsequence-AE"><a href="#Unsolved-Max-Sum-Increasing-Subsequence-AE" class="headerlink" title="Unsolved Max Sum Increasing Subsequence(AE)"></a>Unsolved Max Sum Increasing Subsequence(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array [<span class="number">8</span>,   <span class="number">12</span>, <span class="number">2</span>,   <span class="number">3</span>,      <span class="number">15</span>, <span class="number">5</span> , <span class="number">7</span>]</span><br><span class="line">sums  [<span class="number">8</span>, <span class="number">8</span>+<span class="number">12</span>, <span class="number">2</span>, <span class="number">2</span>+<span class="number">3</span>, <span class="number">8</span>+<span class="number">12</span>+<span class="number">15</span>,  ]</span><br><span class="line">	  [<span class="number">8</span>, <span class="number">20</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">35</span>, ]</span><br><span class="line">sequ  [none,<span class="number">0</span>,none, <span class="number">2</span>, <span class="number">1</span>] (track the index)</span><br><span class="line">    </span><br><span class="line">formula:</span><br><span class="line">currentSum = array[i] (ex. i = <span class="number">5</span>)</span><br><span class="line">otherSum = array[j] <span class="number">0</span> =&lt; j &lt; i</span><br><span class="line">    <span class="keyword">if</span> otherSum &lt; currentSum and sums[j] + currentSum &gt;=  sums[i]</span><br><span class="line">        update sums</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-24"><a href="#Solution1-24" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Space O(n) Time O(n^2)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; maxSumIncreasingSubsequence(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] sequences = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    Arrays.fill(sequences, Integer.MIN_VALUE);</span><br><span class="line">    <span class="keyword">int</span>[] sums = array.clone();</span><br><span class="line">    <span class="keyword">int</span> maxSumIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> currentNum = array[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> otherNum = array[j];</span><br><span class="line">            <span class="keyword">if</span> (otherNum &lt; currentNum &amp;&amp; sums[j] + currentNum &gt;= sums[i]) &#123;</span><br><span class="line">                sums[i] = sums[j] + currentNum;</span><br><span class="line">                sequences[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sums[i] &gt;= sums[maxSumIdx]) &#123;</span><br><span class="line">            maxSumIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildSequence(array, sequences, maxSumIdx, sums[maxSumIdx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; buildSequence(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] sequences, <span class="keyword">int</span> currentIdx, <span class="keyword">int</span> sums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; sequence = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    sequence.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    sequence.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    sequence.get(<span class="number">0</span>).add(sums);</span><br><span class="line">    <span class="keyword">while</span> (currentIdx != Integer.MIN_VALUE) &#123;</span><br><span class="line">        sequence.get(<span class="number">1</span>).add(<span class="number">0</span>, array[currentIdx]);</span><br><span class="line">        currentIdx = sequences[currentIdx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Longest-Common-Subsequence-AE-‚ú®"><a href="#Unsolved-Longest-Common-Subsequence-AE-‚ú®" class="headerlink" title="Unsolved Longest Common Subsequence(AE)‚ú®"></a>Unsolved Longest Common Subsequence(AE)‚ú®</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Str1:ZXVVYZW</span><br><span class="line">Str2:XKYKZPW</span><br><span class="line">   <span class="string">""</span>   X   K   Y   K   Z   P   W</span><br><span class="line"><span class="string">""</span> <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span></span><br><span class="line">Z  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>   Z   Z   Z</span><br><span class="line">X  <span class="string">""</span>   X   X   X   X   X   X   X</span><br><span class="line">V  <span class="string">""</span>   X   X   X   X   X   X   X</span><br><span class="line">V  <span class="string">""</span>   X   X   X   X   X   X   X</span><br><span class="line">Y  <span class="string">""</span>   X   X  XY  XY  XY  XY  XY</span><br><span class="line">Z  <span class="string">""</span>   X   X  XY  XY XYZ XYZ XYZ</span><br><span class="line">W  <span class="string">""</span>   X   X  XY  XY XYZ XYZ XYZW</span><br><span class="line">in pos[<span class="number">1</span>,<span class="number">1</span>] compare <span class="string">"Z"</span>,<span class="string">"X"</span> </span><br><span class="line">    last letter is not same so remove one become <span class="string">""</span>,<span class="string">"X"</span> or <span class="string">"Z"</span>,<span class="string">""</span> correspond to pos[<span class="number">0</span>,<span class="number">1</span>] pos[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">in pos[<span class="number">1</span>,<span class="number">2</span>] compare <span class="string">"Z"</span>,<span class="string">"XK"</span> <span class="comment">//same flow</span></span><br><span class="line">    last letter is not same so remove one become <span class="string">""</span>,<span class="string">"XK"</span> or <span class="string">"Z"</span>,<span class="string">"X"</span> correspond to pos[<span class="number">0</span>,<span class="number">2</span>] pos[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">in pos[<span class="number">1</span>,<span class="number">5</span>] compare <span class="string">"Z"</span>,<span class="string">"XKYKZ"</span></span><br><span class="line">    last letter is same, we remove last letter and add it to LCS, which is diagram pos[<span class="number">0</span>, <span class="number">4</span>] = <span class="string">""</span></span><br><span class="line">in pos[<span class="number">1</span>,<span class="number">6</span>] compare <span class="string">"Z"</span>,<span class="string">"XKYKZP"</span></span><br><span class="line">    last letter is not same, so remove one become <span class="string">""</span>,<span class="string">"XKYKZP"</span> or <span class="string">"Z"</span>,<span class="string">"XKYKZP"</span></span><br><span class="line">in pos[<span class="number">5</span>,<span class="number">3</span>] compare <span class="string">"ZXVVY"</span>,<span class="string">"XKY"</span></span><br><span class="line">    last letter is same, we remove last letter and add it to LCS, which is diagram pos[<span class="number">4</span>, <span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line">in pos[<span class="number">6</span>,<span class="number">3</span>] compare <span class="string">"ZXVVYZ"</span>,<span class="string">"XKY"</span></span><br><span class="line">    last letter is not same so remove one become <span class="string">"ZXVVY"</span>,<span class="string">"XKY"</span> or <span class="string">"ZXVVYZ"</span>,<span class="string">"XK"</span> correspond to pos[<span class="number">5</span>,<span class="number">3</span>] = <span class="string">"XY"</span> pos[<span class="number">6</span>,<span class="number">2</span>] = <span class="string">"X"</span>, take longer one</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-25"><a href="#Solution1-25" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>O(NM*min(N, M)) time, O(NM *min(N, M)) space </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Character&gt; <span class="title">longestCommonSubsequence</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;List&lt;Character&gt;&gt;&gt; lcs = <span class="keyword">new</span> ArrayList&lt;List&lt;List&lt;Character&gt;&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str2.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        lcs.add(<span class="keyword">new</span> ArrayList&lt;List&lt;Character&gt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str1.length() + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            lcs.get(i).add(<span class="keyword">new</span> ArrayList&lt;Character&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str2.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; str1.length() + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str2.charAt(i - <span class="number">1</span>) == str1.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">            	List&lt;Character&gt; copy = <span class="keyword">new</span> ArrayList&lt;Character&gt;(lcs.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>));</span><br><span class="line">	            lcs.get(i).set(j, copy);</span><br><span class="line">    	        lcs.get(i).get(j).add(str2.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lcs.get(i - <span class="number">1</span>).get(j).size() &gt; lcs.get(i).get(j - <span class="number">1</span>).size()) &#123;</span><br><span class="line">                    lcs.get(i).set(j, lcs.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lcs.get(i).set(j, lcs.get(i).get(j - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lcs.get(str2.length()).get(str1.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1143-Longest-Common-Subsequence‚ú®"><a href="#1143-Longest-Common-Subsequence‚ú®" class="headerlink" title="1143. Longest Common Subsequence‚ú®"></a><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. Longest Common Subsequence‚ú®</a></h3><h3 id="Solution1-26"><a href="#Solution1-26" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="Knapsack-Problem-AE"><a href="#Knapsack-Problem-AE" class="headerlink" title="Knapsack Problem(AE)"></a>Knapsack Problem(AE)</h2><h3 id="Solution1-27"><a href="#Solution1-27" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">first index represent the value</span><br><span class="line">second index represent the weight</span><br><span class="line">maximizing the value and the weight did not exceed the knapsack capacity</span><br><span class="line">build a <span class="number">2</span>D array</span><br><span class="line">capacity: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">[]        <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>  <span class="number">1</span></span><br><span class="line">[<span class="number">4</span>,<span class="number">3</span>]     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span>  <span class="number">5</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>]     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span>  <span class="number">9</span></span><br><span class="line">[<span class="number">6</span>,<span class="number">7</span>]     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> w &lt;= j</span><br><span class="line">	values[i][j] = Math.max(values[i - <span class="number">1</span>][j], value[i - <span class="number">1</span>][j - w] + v)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	values[i][j] = values[i - <span class="number">1</span>][j]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; knapsackProblem(<span class="keyword">int</span>[][] items, <span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] knapsackValues = <span class="keyword">new</span> <span class="keyword">int</span>[items.length + <span class="number">1</span>][capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; items.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> currentWeight = items[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> currentValue = items[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; capacity + <span class="number">1</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentWeight &gt; c) &#123;</span><br><span class="line">                knapsackValues[i][c] = knapsackValues[i - <span class="number">1</span>][c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                knapsackValues[i][c] = Math.max(knapsackValues[i - <span class="number">1</span>][c], knapsackValues[i - <span class="number">1</span>][c - currentWeight] + currentValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getKnapsackItems(knapsackValues, items, knapsackValues[items.length][capacity]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getKnapsackItems(<span class="keyword">int</span>[][] knapsackValues, <span class="keyword">int</span>[][] items, <span class="keyword">int</span> weight) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; sequence = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; totalWeight = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    totalWeight.add(weight);</span><br><span class="line">    sequence.add(totalWeight);</span><br><span class="line">    sequence.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">int</span> i = knapsackValues.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = knapsackValues[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (knapsackValues[i][c] == knapsackValues[i - <span class="number">1</span>][c]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence.get(<span class="number">1</span>).add(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">            c -= items[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Disk-Stacking-AE"><a href="#Disk-Stacking-AE" class="headerlink" title="Disk Stacking(AE)"></a>Disk Stacking(AE)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[2,2,1], [2,1,2],[3,2,3],[2,3,4],[4,4,5],[2,2,8]]</span><br><span class="line">width, depth, height</span><br><span class="line">sort by height</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-28"><a href="#Solution1-28" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer[]&gt; diskStacking(List&lt;Integer[]&gt; disks) &#123;</span><br><span class="line">    disks.sort((disk1, disk2) -&gt; disk1[<span class="number">2</span>].compareTo(disk[<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[disk.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disks.size(); i++) &#123;</span><br><span class="line">        heights[i] = disks.get(i)[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] sequences = <span class="keyword">new</span> <span class="keyword">int</span>[disks.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; disk.size(); i++) &#123;</span><br><span class="line">        Integer[] currentDisk = disks.get(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            Integer[] otehrDisk = disk.get(j);</span><br><span class="line">            <span class="keyword">if</span> (areValidDimensions(otherDisk, currentDisk)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (heights[i] &lt;= currentDisk[<span class="number">2</span>] + heights[j]) &#123;</span><br><span class="line">                    heights[i] = currentDIsk[<span class="number">2</span>] + heights[j];</span><br><span class="line">                    sequences[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heights[i] &gt;= heights[maxHeightIdx]) &#123;</span><br><span class="line">            maxHeightIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildSequence(disks, sequences, maxHeightIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="‚úÖNumber-of-Pathsüíú"><a href="#‚úÖNumber-of-Pathsüíú" class="headerlink" title="‚úÖNumber of Pathsüíú"></a><a href="https://github.com/JiawenQi98/PrampPractice/tree/master/Number%20of%20Paths" target="_blank" rel="noopener">‚úÖNumber of Pathsüíú</a></h2><p><img src="https://raw.githubusercontent.com/JiawenQi98/PrampPractice/master/Number%20of%20Paths/example.png" alt=""></p>
<ol>
<li><p>If you are already at the destination, there is obviously only one possible path to the destination, so we set the value for the destination to <code>1</code> (this would be the base case in your recursive version):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          Ôºü</span><br><span class="line">        ? ?</span><br><span class="line">      ? ? ?</span><br><span class="line">    ? ? ? ?</span><br><span class="line">  ? ? ? ? ?</span><br><span class="line"><span class="number">1</span> ? ? ? ? ?</span><br></pre></td></tr></table></figure>

<p>Since every value in the lookup table is the sum of the value above it and the value to its right, we can first fill up the rightmost column from top to bottom (since the values in the rightmost column have no value to their right, every value in this column is identical to the value above it):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">1</span></span><br><span class="line">        ? <span class="number">1</span></span><br><span class="line">      ? ? <span class="number">1</span></span><br><span class="line">    ? ? ? <span class="number">1</span></span><br><span class="line">  ? ? ? ? <span class="number">1</span></span><br><span class="line">? ? ? ? ? <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Now we fill up the next rightmost column in the same way. The upmost element has no value above it, so it is identical to the value to its right.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">1</span></span><br><span class="line">        <span class="number">1</span> <span class="number">1</span></span><br><span class="line">      ? <span class="number">2</span> <span class="number">1</span></span><br><span class="line">    ? ? <span class="number">3</span> <span class="number">1</span></span><br><span class="line">  ? ? ? <span class="number">4</span> <span class="number">1</span></span><br><span class="line">? ? ? ? <span class="number">5</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Repeat this for all the other columns until you have the final lookup table:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">            ? ‚Üê destination</span><br><span class="line">          ? ?</span><br><span class="line">        ? ? ?</span><br><span class="line">      ? ? ? ?</span><br><span class="line">    ? ? ? ? ?</span><br><span class="line">  ? ? ? ? ? ?</span><br><span class="line">  ‚Üë</span><br><span class="line">start</span><br><span class="line">                <span class="number">1</span></span><br><span class="line">             <span class="number">1</span>  <span class="number">1</span></span><br><span class="line">          <span class="number">2</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">       <span class="number">5</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">1</span></span><br><span class="line">   <span class="number">14</span> <span class="number">14</span>  <span class="number">9</span>  <span class="number">4</span>  <span class="number">1</span></span><br><span class="line"><span class="number">42</span> <span class="number">42</span> <span class="number">28</span> <span class="number">14</span>  <span class="number">5</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">calculate how many ways form current position to destination</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];     </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        dp[i][j] += dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOfPaths</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DP method: Time O(n^2), Space O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numOfPathsToDest</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">40</span>;</span><br><span class="line">        System.out.println(<span class="string">"Number of ways of n = "</span> + n1 + <span class="string">" is: "</span>+ numOfPathsToDest(n1));</span><br><span class="line">        System.out.println(<span class="string">"Number of ways of n = "</span> + n2 + <span class="string">" is: "</span>+ numOfPathsToDest(n2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62.Unique Paths"></a><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">62.Unique Paths</a></h3><p>A robot is located at the top-left corner of a m x n grid (marked ‚ÄòStart‚Äô in the diagram below). </p>
<p>The robot can <strong>only move either down or right</strong> at any point in time. </p>
<p>The robot is trying to reach the bottom-right corner of the grid (marked ‚ÄòFinish‚Äô in the diagram below). How many possible unique paths are there?</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt=""></p>
<p>Above is a 3 x 7 grid. How many possible unique paths are there? Note: m and n will be at most 100.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of <span class="number">3</span> ways to reach the bottom-right corner:</span><br><span class="line"><span class="number">1</span>. Right -&gt; Down -&gt; Down</span><br><span class="line"><span class="number">2</span>. Down -&gt; Down -&gt; Right</span><br><span class="line"><span class="number">3</span>. Down -&gt; Right -&gt; Down</span><br><span class="line">    </span><br><span class="line">Input: m = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">Output: <span class="number">28</span></span><br><span class="line">    </span><br><span class="line">formula dp[i] [j] = dp[i - <span class="number">1</span>] [j] + dp[i] [j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-29"><a href="#Solution1-29" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>ÊÄùË∑ØÔºöÂä®ÊÄÅËßÑÂàíÔºåÂ¶ÇÊûúÊ≤øÊüêËæπËµ∞ÂàôÂè™Êúâ‰∏ÄÁßçÂèØËÉΩÔºàÂàùÂßãÂåñÔºâÔºåÁÑ∂ÂêéÂÜÖ‰æßÈÄê 1 Ê∑ªÂä†ÂèØËÉΩÊÄßÔºåÂΩìÂâçÂèØËÉΩÊÄßÊòØ‰∏ä‰∏Ä Ë°åÂíå‰∏ä‰∏ÄÂàóÁõ∏Â∫î‰ΩçÁΩÆÁöÑÂíå„ÄÇ</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        table[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        table[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; m; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">1</span>; column &lt; n; column++) &#123;</span><br><span class="line">            table[row][column] = table[row - <span class="number">1</span>][column] + table[row][column - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. Unique Paths II</a></h3><p>Follow up for ‚ÄúUnique Paths‚Äù: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example, There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[ [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] ]</span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation:</span><br><span class="line">There is one obstacle in the middle of the <span class="number">3</span>x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line"><span class="number">1</span>. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line"><span class="number">2</span>. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure>

<p>The total number of unique paths is 2.</p>
<h3 id="Sulution1"><a href="#Sulution1" class="headerlink" title="Sulution1:"></a>Sulution1:</h3><ol>
<li>ÊÄùË∑ØÔºöÂä®ÊÄÅËßÑÂàí„ÄÇ‰∏é‰∏äÈ¢òËß£Ê≥ïÁ±ª‰ººÔºåÂ§ö‰∏ÄÁÇπÁ¢∞ÈöúÁ¢çÁΩÆÈõ∂„ÄÇ</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">//initial start point</span></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//initial upper boarder base line</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//initial left boarder base line</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//start traversal and apply the formula</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UnsolvedSolution2"><a href="#UnsolvedSolution2" class="headerlink" title="UnsolvedSolution2:"></a>UnsolvedSolution2:</h3><ol>
<li><a href="https://leetcode.com/problems/unique-paths-ii/discuss/23250/Short-JAVA-solution" target="_blank" rel="noopener">ÊÄùË∑Ø</a></li>
<li>More explanation:<br>This is a typical 2D DP problem, we can store value in 2D DP array, but since we only need to use value at dp[i - 1][j] and dp[i][j - 1] to update dp[i][j], we don‚Äôt need to store the whole 2D table, but instead store value in an 1D array, and update data by using dp[j] = dp[j] + dp[j - 1], (where here dp[j] corresponding to the dp[i - 1][j]) and dp[j - 1] corresponding to the dp[i][j - 1] in the 2D array)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> width = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[width];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] row : obstacleGrid) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[j] == <span class="number">1</span>)</span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[width - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="70-Climbing-Stairs‚ú®"><a href="#70-Climbing-Stairs‚ú®" class="headerlink" title="70. Climbing Stairs‚ú®"></a><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing Stairs‚ú®</a></h2><h3 id="Solution1-30"><a href="#Solution1-30" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Basically it‚Äôs a fibonacci.</p>
<p>Base cases:<br>if n &lt;= 0, then the number of ways should be zero.<br>if n == 1, then there is only way to climb the stair.<br>if n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time.</p>
</li>
<li><p>The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points <code>[n-1]</code> and <code>[n-2]</code> respectively, denoted as <code>n1</code> and <code>n2</code> , then the total ways to get to the point <code>[n]</code> is <code>n1 + n2</code>. Because from the <code>[n-1]</code> point, we can take one single step to reach <code>[n]</code>. And from the <code>[n-2]</code> point, we could take two steps to get there.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base cases</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] ways = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    ways[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    ways[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ways[i] = ways[i - <span class="number">1</span>] + ways[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-11"><a href="#Solution2-11" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>sliding windows</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] steps = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = steps[<span class="number">0</span>] + steps[<span class="number">1</span>];</span><br><span class="line">        steps[<span class="number">0</span>] = steps[<span class="number">1</span>];</span><br><span class="line">        steps[<span class="number">1</span>] = cur;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = first + second;</span><br><span class="line">        first = second;</span><br><span class="line">        second = cur;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">1</span> ? second : first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-1659-Maximize-Grid-Happiness"><a href="#Unsolved-1659-Maximize-Grid-Happiness" class="headerlink" title="Unsolved 1659. Maximize Grid Happiness"></a><a href="https://leetcode.com/problems/maximize-grid-happiness/" target="_blank" rel="noopener">Unsolved 1659. Maximize Grid Happiness</a></h2><h2 id="1621-Number-of-Sets-of-K-Non-Overlapping-Line-SegmentsüéÉ"><a href="#1621-Number-of-Sets-of-K-Non-Overlapping-Line-SegmentsüéÉ" class="headerlink" title="1621. Number of Sets of K Non-Overlapping Line SegmentsüéÉ"></a><a href="https://leetcode.com/contest/biweekly-contest-37/problems/number-of-sets-of-k-non-overlapping-line-segments/" target="_blank" rel="noopener">1621. Number of Sets of K Non-Overlapping Line SegmentsüéÉ</a></h2><h2 id="Solution1-31"><a href="#Solution1-31" class="headerlink" title="Solution1:"></a>Solution1:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Integer[][][] memo;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSets</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.memo = <span class="keyword">new</span> Integer[n+<span class="number">1</span>][k+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp(<span class="number">0</span>, k, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k, <span class="keyword">int</span> isStart)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memo[i][k][isStart] != <span class="keyword">null</span>) <span class="keyword">return</span> memo[i][k][isStart];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// Found a way to draw k valid segments</span></span><br><span class="line">    <span class="keyword">if</span> (i == n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Reach end of points</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = dp(i+<span class="number">1</span>, k, isStart); <span class="comment">// Skip ith point</span></span><br><span class="line">    <span class="keyword">if</span> (isStart == <span class="number">1</span>)</span><br><span class="line">        ans += dp(i+<span class="number">1</span>, k, <span class="number">0</span>); <span class="comment">// Take ith point as start</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans += dp(i, k-<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// Take ith point as end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[i][k][isStart] = ans % <span class="number">1_000_000_007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåï343-Integer-Breaküé∂"><a href="#üåï343-Integer-Breaküé∂" class="headerlink" title="üåï343. Integer Breaküé∂"></a><a href="https://leetcode.com/problems/integer-break/" target="_blank" rel="noopener">üåï343. Integer Breaküé∂</a></h2><h3 id="Solution1-32"><a href="#Solution1-32" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Integer[] dp = <span class="keyword">new</span> Integer[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> findMaxValue(n, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxValue</span><span class="params">(<span class="keyword">int</span> n, Integer[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[n] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> curMax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            curMax = Math.max(curMax, i * findMaxValue(n - i, dp));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n] = curMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="516-Unsolved-Longest-Palindromic-Subsequence"><a href="#516-Unsolved-Longest-Palindromic-Subsequence" class="headerlink" title="516. Unsolved Longest Palindromic Subsequence"></a><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. Unsolved Longest Palindromic Subsequence</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]`: the longest palindromic subsequence<span class="string">'s length of substring(i, j), here i, j represent left, right indexes in the string</span></span><br><span class="line"><span class="string">`State transition`:</span></span><br><span class="line"><span class="string">`dp[i][j] = dp[i+1][j-1] + 2` if s.charAt(i) == s.charAt(j)</span></span><br><span class="line"><span class="string">otherwise, `dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])`</span></span><br><span class="line"><span class="string">`Initialization`: `dp[i][i] = 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-33"><a href="#Solution1-33" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()][s.length()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][s.length()-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="486-Predict-the-Winner"><a href="#486-Predict-the-Winner" class="headerlink" title="486. Predict the Winner"></a><a href="https://leetcode.com/problems/predict-the-winner/" target="_blank" rel="noopener">486. Predict the Winner</a></h2><h3 id="Solution1-34"><a href="#Solution1-34" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="Unsolved-787-Cheapest-Flights-Within-K-StopsüéÇ"><a href="#Unsolved-787-Cheapest-Flights-Within-K-StopsüéÇ" class="headerlink" title="Unsolved 787. Cheapest Flights Within K StopsüéÇ"></a><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 787. Cheapest Flights Within K StopsüéÇ</a></h2><h2 id="Unsolved-1373-Maximum-Sum-BST-in-Binary-TreeüéÇ‚ú®"><a href="#Unsolved-1373-Maximum-Sum-BST-in-Binary-TreeüéÇ‚ú®" class="headerlink" title="Unsolved 1373. Maximum Sum BST in Binary TreeüéÇ‚ú®"></a><a href="https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 1373. Maximum Sum BST in Binary TreeüéÇ‚ú®</a></h2><h2 id="Unsolved-44-Wildcard-MatchingüéÇ‚ú®üé∂"><a href="#Unsolved-44-Wildcard-MatchingüéÇ‚ú®üé∂" class="headerlink" title="Unsolved 44. Wildcard MatchingüéÇ‚ú®üé∂"></a><a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">Unsolved 44. Wildcard MatchingüéÇ‚ú®üé∂</a></h2><h3 id="Solution1-35"><a href="#Solution1-35" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>ÊÄùË∑ØÔºöÂä®ÊÄÅËßÑÂàí„ÄÇÊé®ÁêÜÊù°‰ª∂ÔºöÂ¶ÇÊûú p ÊòØ<em>ÔºåÂàô‰∏é p Êàñ s ‰∏ä‰∏Ä‰ΩçÁΩÆÁªìÊûúÁõ∏ÂêåÔºõÂ¶ÇÊûú‰∏çÊòØ</em>ÔºåÂàôÁúãÂΩìÂâçÂ≠óÁ¨¶ÊòØÂê¶ match„ÄÇ</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != <span class="string">'*'</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                &amp;&amp; (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>)</span><br><span class="line">                    || p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-12"><a href="#Solution2-12" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>The basic idea is to have one pointer for the string and one pointer for the pattern. This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step.</li>
<li><a href="https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution" target="_blank" rel="noopener">explanation</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">comparison</span><span class="params">(String str, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, p = <span class="number">0</span>, match = <span class="number">0</span>, starIdx = -<span class="number">1</span>;            </span><br><span class="line">    <span class="keyword">while</span> (s &lt; str.length())&#123;</span><br><span class="line">        <span class="comment">// advancing both pointers</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; pattern.length()  &amp;&amp; (pattern.charAt(p) == <span class="string">'?'</span> || str.charAt(s) == pattern.charAt(p)))&#123;</span><br><span class="line">            s++;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// * found, only advancing pattern pointer</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            starIdx = p;</span><br><span class="line">            match = s;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// last pattern pointer was *, advancing string pointer</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (starIdx != -<span class="number">1</span>)&#123;</span><br><span class="line">            p = starIdx + <span class="number">1</span>;</span><br><span class="line">            match++;</span><br><span class="line">            s = match;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//current pattern pointer is not star, last patter pointer was not *</span></span><br><span class="line">        <span class="comment">//characters do not match</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//check for remaining characters in pattern</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == <span class="string">'*'</span>)</span><br><span class="line">        p++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p == pattern.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="256-Paint-House"><a href="#256-Paint-House" class="headerlink" title="256. Paint House"></a><a href="https://leetcode.com/problems/paint-house/" target="_blank" rel="noopener">256. Paint House</a></h2><h3 id="Solution1-36"><a href="#Solution1-36" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">        costs[i][<span class="number">0</span>] += Math.min(costs[i - <span class="number">1</span>][<span class="number">1</span>], costs[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        costs[i][<span class="number">1</span>] += Math.min(costs[i - <span class="number">1</span>][<span class="number">0</span>], costs[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        costs[i][<span class="number">2</span>] += Math.min(costs[i - <span class="number">1</span>][<span class="number">0</span>], costs[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = Math.min(costs[costs.length - <span class="number">1</span>][<span class="number">0</span>], costs[costs.length - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    min = Math.min(min, costs[costs.length - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-464-Can-I-WinüéÇ"><a href="#Unsolved-464-Can-I-WinüéÇ" class="headerlink" title="Unsolved 464. Can I WinüéÇ"></a><a href="https://leetcode.com/problems/can-i-win/" target="_blank" rel="noopener">Unsolved 464. Can I WinüéÇ</a></h2><h3 id="Solution1-37"><a href="#Solution1-37" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><a href="https://leetcode.com/problems/can-i-win/discuss/95277/Java-solution-using-HashMap-with-detailed-explanation" target="_blank" rel="noopener">explanation</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (desiredTotal&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxChoosableInteger*(maxChoosableInteger+<span class="number">1</span>)/<span class="number">2</span>&lt;desiredTotal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> canIWin(desiredTotal, <span class="keyword">new</span> <span class="keyword">int</span>[maxChoosableInteger], <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">int</span>[] state, HashMap&lt;String, Boolean&gt; hashMap)</span> </span>&#123;</span><br><span class="line">    String curr=Arrays.toString(state);</span><br><span class="line">    <span class="keyword">if</span> (hashMap.containsKey(curr)) <span class="keyword">return</span> hashMap.get(curr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;state.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state[i]==<span class="number">0</span>) &#123;</span><br><span class="line">            state[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (total&lt;=i+<span class="number">1</span> || !canIWin(total-(i+<span class="number">1</span>), state, hashMap)) &#123;</span><br><span class="line">                hashMap.put(curr, <span class="keyword">true</span>);</span><br><span class="line">                state[i]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            state[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hashMap.put(curr, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1664-Ways-to-Make-a-Fair-Array"><a href="#1664-Ways-to-Make-a-Fair-Array" class="headerlink" title="1664. Ways to Make a Fair Array"></a><a href="https://leetcode.com/problems/ways-to-make-a-fair-array/" target="_blank" rel="noopener">1664. Ways to Make a Fair Array</a></h2><h3 id="Solution1-38"><a href="#Solution1-38" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Explanation</p>
<p>We will split the array into two parts, <code>left</code> and <code>right</code>.<br>Firstly we count the sum to an array <code>right</code>,<br>where <code>right[0] = A[0] + A[2] +...</code><br>and <code>right[1] = A[1] + A[3] +...</code></p>
<p>Now we iterates the whole array <code>A</code>, and try to split at each <code>A[i]</code>.<br>When move one element from <code>right</code> to <code>left</code>,<br>we reduce the sum in <code>right</code>,<br>check the if it‚Äôs fair,<br>then increse the sum in <code>left</code>.</p>
<p>Complexity</p>
<p>Time <code>O(N)</code><br>Space <code>O(1)</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToMakeFair</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sumEven = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sumOdd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) sumEven += nums[i];</span><br><span class="line">        <span class="keyword">else</span> sumOdd += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curEven = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curOdd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEven + sumOdd - curOdd == curOdd + sumEven - curEven - nums[i]) count++;</span><br><span class="line">            curEven += nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEven + sumOdd - curOdd - nums[i] == curOdd + sumEven - curEven) count++;</span><br><span class="line">            curOdd += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåïUnsolved-410-Split-Array-Largest-SumüéÇ‚ú®üé∂"><a href="#üåïUnsolved-410-Split-Array-Largest-SumüéÇ‚ú®üé∂" class="headerlink" title="üåïUnsolved 410. Split Array Largest SumüéÇ‚ú®üé∂"></a><a href="https://leetcode.com/problems/split-array-largest-sum/?utm_source=AlgoTogether&utm_campaign=dc64242af2-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_2&utm_medium=email&utm_term=0_38d4e2e3e2-dc64242af2-231340480" target="_blank" rel="noopener">üåïUnsolved 410. Split Array Largest SumüéÇ‚ú®üé∂</a></h2><p>Given an array <code>nums</code> which consists of non-negative integers and an integer <code>m</code>, you can split the array into <code>m</code> non-empty continuous subarrays.</p>
<p>Write an algorithm to minimize the largest sum among these <code>m</code> subarrays.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">8</span>], m = <span class="number">2</span></span><br><span class="line">Output: <span class="number">18</span></span><br><span class="line">Explanation:</span><br><span class="line">There are four ways to split nums into two subarrays.</span><br><span class="line">The best way is to split it into [<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>] and [<span class="number">10</span>,<span class="number">8</span>],</span><br><span class="line">where the largest sum among the two subarrays is only <span class="number">18</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-39"><a href="#Solution1-39" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><a href="https://leetcode.com/problems/split-array-largest-sum/discuss/89817/Clear-Explanation%3A-8ms-Binary-Search-Java" target="_blank" rel="noopener">Explaination</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[nums.length + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    preSum[nums.length - <span class="number">1</span>] = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        preSum[i] = preSum[i + <span class="number">1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findMin(<span class="number">0</span>, nums, preSum, m, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] preSum, <span class="keyword">int</span> m, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case, m == 1, will be sum of remain array</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> preSum[idx];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dp[idx][m] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//Ê≥®ÊÑè i &lt;= nums.length - m, Ë¶ÅÁïôm - 1‰∏™ÁªôÂêéÈù¢Â≠êÊï∞ÁªÑËøõË°åÂàÜÈÖç</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; nums.length - m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            left += nums[i];</span><br><span class="line">            <span class="keyword">int</span> right = findMin(i + <span class="number">1</span>, nums, preSum, m - <span class="number">1</span>, dp);</span><br><span class="line">            <span class="comment">//minimize the largest sum among subarrays</span></span><br><span class="line">            min = Math.min(min, Math.max(left, right));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx][m] = min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Grokking-Dynamic-Programming-Patterns-for-Coding-Interviews"><a href="#Grokking-Dynamic-Programming-Patterns-for-Coding-Interviews" class="headerlink" title="Grokking Dynamic Programming Patterns for Coding Interviews"></a>Grokking Dynamic Programming Patterns for Coding Interviews</h1><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="Nth-Fib"><a href="#Nth-Fib" class="headerlink" title="Nth Fib"></a>Nth Fib</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CalculateFibonacci(n-<span class="number">1</span>) + CalculateFibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-with-Memoization"><a href="#Top-down-with-Memoization" class="headerlink" title="Top-down with Memoization"></a>Top-down with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> memoize[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> CalculateFibonacciRecursive(memoize, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacciRecursive</span><span class="params">(<span class="keyword">int</span>[] memoize, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have already solved this subproblem, simply return the result from the cache</span></span><br><span class="line">    <span class="keyword">if</span>(memoize[n] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> memoize[n];</span><br><span class="line"></span><br><span class="line">    memoize[n] = CalculateFibonacciRecursive(memoize, n-<span class="number">1</span>) + CalculateFibonacciRecursive(memoize, n-<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memoize[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-with-Tabulation"><a href="#Bottom-up-with-Tabulation" class="headerlink" title="Bottom-up with Tabulation"></a>Bottom-up with Tabulation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base cases</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pattern-1-0-1-Knapsack"><a href="#Pattern-1-0-1-Knapsack" class="headerlink" title="Pattern 1: 0/1 Knapsack"></a>Pattern 1: 0/1 Knapsack</h1><h2 id="üåï0-1-Knapsack‚ú®"><a href="#üåï0-1-Knapsack‚ú®" class="headerlink" title="üåï0/1 Knapsack‚ú®"></a>üåï0/1 Knapsack‚ú®</h2><h3 id="brute-force-solution"><a href="#brute-force-solution" class="headerlink" title="brute-force solution"></a>brute-force solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n) recursion tree</span></span><br><span class="line"><span class="comment">//Space O(n) call stack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after choosing the element at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the weight of the element at currentIndex exceeds the capacity, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( weights[currentIndex] &lt;= capacity ) &#123;</span><br><span class="line">        profit1 = profits[currentIndex] + knapsackRecursive(profits, weights, capacity - weights[currentIndex], currentIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the element at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> profit2 = knapsackRecursive(profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(profit1, profit2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization"><a href="#Top-down-Dynamic-Programming-with-Memoization" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(N * C) N * C sub problems</span></span><br><span class="line"><span class="comment">//Space O(N * C + N) dp array + call stack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[profits.length][capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(dp, profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(Integer[][] dp, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] profits, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] weights, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> capacity, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex][capacity] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( weights[currentIndex] &lt;= capacity ) &#123;</span><br><span class="line">            profit1 = profits[currentIndex] + knapsackRecursive(dp, profits, weights, capacity - weights[currentIndex], currentIndex + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit2 = knapsackRecursive(dp, profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line">        dp[currentIndex][capacity] = Math.max(profit1, profit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have already solved a similar problem, return the result from memory directly</span></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since our memoization array <code>dp[profits.length][capacity+1]</code> stores the results for all the subproblems, we can conclude that we will not have more than N<em>C</em>N<em>‚àó</em>C* subproblems (where ‚ÄòN‚Äô is the number of items and ‚ÄòC‚Äô is the knapsack capacity). This means that our time complexity will be O(N<em>C)*O</em>(<em>N</em>‚àó<em>C</em>).</p>
<p>The above algorithm will be using O(N<em>C)*O</em>(<em>N</em>‚àó<em>C</em>) space for the memoization array. Other than that, we will use O(N)<em>O</em>(<em>N</em>) space for the recursion call-stack. So the total space complexity will be O(N<em>C + N)*O</em>(<em>N</em>‚àó<em>C</em>+<em>N</em>), which is asymptotically equivalent to O(N<em>C)*O</em>(<em>N</em>‚àó<em>C</em>).</p>
<h3 id="Bottom-up-Dynamic-Programming"><a href="#Bottom-up-Dynamic-Programming" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><p><strong>This means, <code>dp[i][c]</code> will represent the maximum knapsack profit for capacity ‚Äòc‚Äô calculated from the first ‚Äòi‚Äô items.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][c] &#x3D; max (dp[i-1][c], profits[i] + dp[i-1][c-weights[i]])</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// basic checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = profits.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the capacity=0 columns, with '0' capacity we have '0' profit</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have only one weight, we will take it if it is not more than the capacity</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(weights[<span class="number">0</span>] &lt;= c)</span><br><span class="line">            dp[<span class="number">0</span>][c] = profits[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// process all sub-arrays for all the capacities</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit1= <span class="number">0</span>, profit2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// include the item, if it is not more than the capacity</span></span><br><span class="line">            <span class="keyword">if</span>(weights[i] &lt;= c)</span><br><span class="line">                profit1 = profits[i] + dp[i-<span class="number">1</span>][c-weights[i]];</span><br><span class="line">            <span class="comment">// exclude the item</span></span><br><span class="line">            profit2 = dp[i-<span class="number">1</span>][c];</span><br><span class="line">            <span class="comment">// take maximum</span></span><br><span class="line">            dp[i][c] = Math.max(profit1, profit2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maximum profit will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåïEqual-Subset-Sum-Partition‚ú®"><a href="#üåïEqual-Subset-Sum-Partition‚ú®" class="headerlink" title="üåïEqual Subset Sum Partition‚ú®"></a>üåïEqual Subset Sum Partition‚ú®</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 1, 3, 4, 7&#125;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: The given set can be partitioned into two subsets with equal sum: &#123;1, 3, 4&#125; &amp; &#123;1, 7&#125;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; find a set equal to sum &#x2F; 2;</span><br></pre></td></tr></table></figure>

<h3 id="brute-force-algorithm"><a href="#brute-force-algorithm" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n) exponential</span></span><br><span class="line"><span class="comment">//Space O(n) recursion stack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 'sum' is a an odd number, we can't have two subsets with equal sum</span></span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(num, sum/<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPartitionRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after choosing the number at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">if</span>(num[currentIndex] &lt;= sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(canPartitionRecursive(num, sum - num[currentIndex], currentIndex + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">    <span class="keyword">return</span> canPartitionRecursive(num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-1"><a href="#Top-down-Dynamic-Programming-with-Memoization-1" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 'sum' is a an odd number, we can't have two subsets with equal sum</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Boolean[][] dp = <span class="keyword">new</span> Boolean[num.length][sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(dp, num, sum / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPartitionRecursive</span><span class="params">(Boolean[][] dp, <span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have not already processed a similar problem</span></span><br><span class="line">    <span class="keyword">if</span> (dp[currentIndex][sum] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// recursive call after choosing the number at the currentIndex</span></span><br><span class="line">        <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">        <span class="keyword">if</span> (num[currentIndex] &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canPartitionRecursive(dp, num, sum - num[currentIndex], currentIndex + <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[currentIndex][sum] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">        dp[currentIndex][sum] = canPartitionRecursive(dp, num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-1"><a href="#Bottom-up-Dynamic-Programming-1" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="comment">// find the total sum</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 'sum' is a an odd number, we can't have two subsets with same total</span></span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we are trying to find a subset of given numbers that has a total sum of ‚Äòsum/2‚Äô.</span></span><br><span class="line">    sum /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 column, as we can always have '0' sum without including any element</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to its value</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            <span class="comment">// if we can get the sum 's' without the number at index 'i'</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][s]) &#123;</span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123; <span class="comment">// else if we can find a subset to get the remaining sum</span></span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="416-Partition-Equal-Subset-Sum‚ú®"><a href="#416-Partition-Equal-Subset-Sum‚ú®" class="headerlink" title="416. Partition Equal Subset Sum‚ú®"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. Partition Equal Subset Sum‚ú®</a></h3><h3 id="Solution0-2"><a href="#Solution0-2" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute Force</li>
<li>Time exceed</li>
<li>Time Complexity : \mathcal{O}(2^{n})O(2<em>n</em>), where n<em>n</em> is equal to number of array elements. The recursive solution takes the form of a binary tree where there are 2 possibilities for every array element and the maximum depth of the tree could be n<em>n</em>. The time complexity is exponential, hence this approach is exhaustive and results in <em>Time Limit Exceeded (TLE)</em>.</li>
<li>Space Complexity: \mathcal{O}(N)O(<em>N</em>) This space will be used to store the recursion stack. We can‚Äôt have more than n<em>n</em> recursive calls on the call stack at any time.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(2^n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// find sum of all array elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        totalSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if totalSum is odd,it cannot be partitioned into equal sum subset</span></span><br><span class="line">    <span class="keyword">if</span> (totalSum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> subSetSum = totalSum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, n - <span class="number">1</span>, subSetSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> subSetSum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base Cases</span></span><br><span class="line">    <span class="keyword">if</span> (subSetSum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || subSetSum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, n - <span class="number">1</span>, subSetSum - nums[n - <span class="number">1</span>]) || dfs(nums, n - <span class="number">1</span>, subSetSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-40"><a href="#Solution1-40" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time Complexity : \mathcal{O}(m \cdot n)O(<em>m</em>‚ãÖ<em>n</em>).<ul>
<li>In the worst case where there is no overlapping calculation, the maximum number of entries in the <code>memo</code> would be m \cdot n<em>m</em>‚ãÖ<em>n</em>. For each entry, overall we could consider that it takes constant time, <em>i.e.</em> each invocation of <code>dfs()</code> at most emits one entry in the <code>memo</code>.</li>
<li>The overall computation is proportional to the number of entries in <code>memo</code>. Hence, the overall time complexity is \mathcal{O}(m \cdot n)O(<em>m</em>‚ãÖ<em>n</em>).</li>
</ul>
</li>
<li>Space Complexity: \mathcal{O}(m \cdot n)O(<em>m</em>‚ãÖ<em>n</em>). We are using a 2 dimensional array \text{memo}memo of size (m \cdot n)(<em>m</em>‚ãÖ<em>n</em>) and \mathcal{O}(n)O(<em>n</em>) space to store the recursive call stack. This gives us the space complexity as \mathcal{O}(n)O(<em>n</em>) + \mathcal{O}(m \cdot n)O(<em>m</em>‚ãÖ<em>n</em>) = \mathcal{O}(m \cdot n)O(<em>m</em>‚ãÖ<em>n</em>)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// find sum of all array elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        totalSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if totalSum is odd, it cannot be partitioned into equal sum subset</span></span><br><span class="line">    <span class="keyword">if</span> (totalSum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> subSetSum = totalSum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    Boolean[][] memo = <span class="keyword">new</span> Boolean[n + <span class="number">1</span>][subSetSum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, n - <span class="number">1</span>, subSetSum, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, <span class="keyword">int</span> subSetSum, Boolean[][] memo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base Cases</span></span><br><span class="line">    <span class="keyword">if</span> (subSetSum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span> || subSetSum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// check if subSetSum for given n is already computed and stored in memo</span></span><br><span class="line">    <span class="keyword">if</span> (memo[idx][subSetSum] != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[n][subSetSum];</span><br><span class="line">    <span class="keyword">boolean</span> result = dfs(nums, idx - <span class="number">1</span>, subSetSum - nums[idx - <span class="number">1</span>], memo) ||</span><br><span class="line">        dfs(nums, idx - <span class="number">1</span>, subSetSum, memo);</span><br><span class="line">    <span class="comment">// store the result in memo</span></span><br><span class="line">    memo[idx][subSetSum] = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="üåïUnsolved-698-Partition-to-K-Equal-Sum-Subsets"><a href="#üåïUnsolved-698-Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="üåïUnsolved 698. Partition to K Equal Sum Subsets"></a><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/" target="_blank" rel="noopener">üåïUnsolved 698. Partition to K Equal Sum Subsets</a></h3><h2 id="Subset-Sum"><a href="#Subset-Sum" class="headerlink" title="Subset Sum"></a>Subset Sum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 2, 3, 7&#125;, S&#x3D;6</span><br><span class="line">Output: True</span><br><span class="line">The given set has a subset whose sum is &#39;6&#39;: &#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>

<h3 id="brute-force-algorithm-1"><a href="#brute-force-algorithm-1" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each number &#39;i&#39; </span><br><span class="line">  create a new set which INCLUDES number &#39;i&#39; if it does not exceed &#39;S&#39;, and recursively </span><br><span class="line">     process the remaining numbers</span><br><span class="line">  create a new set WITHOUT number &#39;i&#39;, and recursively process the remaining numbers </span><br><span class="line">return true if any of the above two sets has a sum equal to &#39;S&#39;, otherwise return false</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-2"><a href="#Top-down-Dynamic-Programming-with-Memoization-2" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> Write - Your - Code</span></span><br><span class="line">    Boolean[][] dp = <span class="keyword">new</span> Boolean[num.length][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> partition(<span class="number">0</span>, num, sum, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, Boolean[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num.length == <span class="number">0</span> || idx &gt;= num.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][sum] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[idx] &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (partition(idx + <span class="number">1</span>, num, sum - num[idx], dp)) &#123;</span><br><span class="line">                dp[idx][sum] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx][sum] = partition(idx + <span class="number">1</span>, num, sum, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-2"><a href="#Bottom-up-Dynamic-Programming-2" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we can always form '0' sum with an empty set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is</span></span><br><span class="line">    <span class="comment">// equal to its value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            <span class="comment">// if we can get the sum 's' without the number at index 'i'</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][s]) &#123;</span><br><span class="line">                dp[i][s] = dp[i - <span class="number">1</span>][s];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                <span class="comment">// else include the number and see if we can find a subset to get the remaining</span></span><br><span class="line">                <span class="comment">// sum</span></span><br><span class="line">                dp[i][s] = dp[i - <span class="number">1</span>][s - num[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[num.length - <span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåïMinimum-Subset-Sum-Differenceüé∂"><a href="#üåïMinimum-Subset-Sum-Differenceüé∂" class="headerlink" title="üåïMinimum Subset Sum Differenceüé∂"></a>üåïMinimum Subset Sum Differenceüé∂</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 2, 3, 9&#125;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can partition the given set into two subsets where minimum absolute difference </span><br><span class="line">between the sum of numbers is &#39;3&#39;. Following are the two subsets: &#123;1, 2, 3&#125; &amp; &#123;9&#125;.</span><br><span class="line"></span><br><span class="line">Input: &#123;1, 2, 7, 1, 5&#125;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: We can partition the given set into two subsets where minimum absolute difference </span><br><span class="line">between the sum of number is &#39;0&#39;. Following are the two subsets: &#123;1, 2, 5&#125; &amp; &#123;7, 1&#125;.</span><br></pre></td></tr></table></figure>

<h3 id="brute-force-algorithm-2"><a href="#brute-force-algorithm-2" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for each number &#39;i&#39; </span><br><span class="line">  add number &#39;i&#39; to S1 and recursively process the remaining numbers</span><br><span class="line">  add number &#39;i&#39; to S2 and recursively process the remaining numbers</span><br><span class="line">return the minimum absolute difference of the above two sets</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n)</span></span><br><span class="line"><span class="comment">//Space O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(num, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">canPartitionRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> sum1, <span class="keyword">int</span> sum2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (currentIndex == num.length)</span><br><span class="line">        <span class="keyword">return</span> Math.abs(sum1 - sum2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after including the number at the currentIndex in the first set</span></span><br><span class="line">    <span class="keyword">int</span> diff1 = canPartitionRecursive(num, currentIndex+<span class="number">1</span>, sum1+num[currentIndex], sum2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after including the number at the currentIndex in the second set</span></span><br><span class="line">    <span class="keyword">int</span> diff2 = canPartitionRecursive(num, currentIndex+<span class="number">1</span>, sum1, sum2+num[currentIndex]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(diff1, diff2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-3"><a href="#Top-down-Dynamic-Programming-with-Memoization-3" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">      sum += num[i];</span><br><span class="line"></span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[num.length][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(dp, num, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">canPartitionRecursive</span><span class="params">(Integer[][] dp, <span class="keyword">int</span>[] num, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> sum1, <span class="keyword">int</span> sum2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex == num.length)</span><br><span class="line">      <span class="keyword">return</span> Math.abs(sum1 - sum2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we have not already processed similar problem</span></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex][sum1] == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// recursive call after including the number at the currentIndex in the first set</span></span><br><span class="line">      <span class="keyword">int</span> diff1 = canPartitionRecursive(dp, num, currentIndex + <span class="number">1</span>, sum1 + num[currentIndex], sum2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// recursive call after including the number at the currentIndex in the second set</span></span><br><span class="line">      <span class="keyword">int</span> diff2 = canPartitionRecursive(dp, num, currentIndex + <span class="number">1</span>, sum1, sum2 + num[currentIndex]);</span><br><span class="line"></span><br><span class="line">      dp[currentIndex][sum1] = Math.min(diff1, diff2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][sum1];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-3"><a href="#Bottom-up-Dynamic-Programming-3" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum/<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we can always form '0' sum with an empty set</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to that number</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum/<span class="number">2</span> ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum/<span class="number">2</span>; s++) &#123;</span><br><span class="line">            <span class="comment">// if we can get the sum 's' without the number at index 'i'</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][s]) &#123;</span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                <span class="comment">// else include the number and see if we can find a subset to get the remaining sum</span></span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Find the largest index in the last row which is true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sum / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n-<span class="number">1</span>][i] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            sum1 = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum2 = sum - sum1;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(sum2-sum1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1049-Last-Stone-Weight-II"><a href="#1049-Last-Stone-Weight-II" class="headerlink" title="1049. Last Stone Weight II"></a><a href="https://leetcode.com/problems/last-stone-weight-ii/" target="_blank" rel="noopener">1049. Last Stone Weight II</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s : stones) &#123;</span><br><span class="line">        sum += s;</span><br><span class="line">    &#125;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[stones.length + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, stones, <span class="number">0</span>, <span class="number">0</span>, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] stones, <span class="keyword">int</span> sum1, <span class="keyword">int</span> sum2, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == stones.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(sum1 - sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][sum1] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> way1 = dfs(idx + <span class="number">1</span>, stones, sum1 + stones[idx], sum2, dp);</span><br><span class="line">        <span class="keyword">int</span> way2 = dfs(idx + <span class="number">1</span>, stones, sum1, sum2 + stones[idx], dp);</span><br><span class="line">        dp[idx][sum1] = Math.min(way1, way2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][sum1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="üåïCount-of-Subset-Sum"><a href="#üåïCount-of-Subset-Sum" class="headerlink" title="üåïCount of Subset Sum"></a>üåïCount of Subset Sum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 1, 2, 3&#125;, S&#x3D;4</span><br><span class="line">Output: 3</span><br><span class="line">The given set has &#39;3&#39; subsets whose sum is &#39;4&#39;: &#123;1, 1, 2&#125;, &#123;1, 3&#125;, &#123;1, 3&#125;</span><br><span class="line">Note that we have two similar sets &#123;1, 3&#125;, because we have two &#39;1&#39; in our input.</span><br><span class="line"></span><br><span class="line">Input: &#123;1, 2, 7, 1, 5&#125;, S&#x3D;9</span><br><span class="line">Output: 3</span><br><span class="line">The given set has &#39;3&#39; subsets whose sum is &#39;9&#39;: &#123;2, 7&#125;, &#123;1, 7, 1&#125;, &#123;1, 2, 1, 5&#125;</span><br></pre></td></tr></table></figure>

<h3 id="brute-force-algorithm-3"><a href="#brute-force-algorithm-3" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each number &#39;i&#39; </span><br><span class="line">  create a new set which includes number &#39;i&#39; if it does not exceed &#39;S&#39;, and recursively   </span><br><span class="line">      process the remaining numbers and sum</span><br><span class="line">  create a new set without number &#39;i&#39;, and recursively process the remaining numbers </span><br><span class="line">return the count of subsets who has a sum equal to &#39;S&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countSubsetsRecursive(num, sum, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSubsetsRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the number at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num[currentIndex] &lt;= sum)</span><br><span class="line">        sum1 = countSubsetsRecursive(num, sum - num[currentIndex], currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> sum2 = countSubsetsRecursive(num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-4"><a href="#Top-down-Dynamic-Programming-with-Memoization-4" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countSubsetsRecursive(num, sum, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSubsetsRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the number at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][sum] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[idx] &lt;= sum) &#123;</span><br><span class="line">            sum1 = count(idx + <span class="number">1</span>, num, sum - num[idx], dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = count(idx + <span class="number">1</span>, num, sum, dp);</span><br><span class="line">        dp[idx][sum] = sum1 + sum2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-4"><a href="#Bottom-up-Dynamic-Programming-4" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we will always have an empty set for zero sum</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to its value</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            <span class="comment">// exclude the number</span></span><br><span class="line">            dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            <span class="comment">// include the number, if it does not exceed the sum</span></span><br><span class="line">            <span class="keyword">if</span>(s &gt;= num[i])</span><br><span class="line">                dp[i][s] += dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[num.length-<span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåïTarget-Sum"><a href="#üåïTarget-Sum" class="headerlink" title="üåïTarget Sum"></a>üåïTarget Sum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 1, 2, 3&#125;, S&#x3D;1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The given set has &#39;3&#39; ways to make a sum of &#39;1&#39;: &#123;+1-1-2+3&#125; &amp; &#123;-1+1-2+3&#125; &amp; &#123;+1+1+2-3&#125;</span><br><span class="line"></span><br><span class="line">Input: &#123;1, 2, 7, 1&#125;, S&#x3D;9</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The given set has &#39;2&#39; ways to make a sum of &#39;9&#39;: &#123;+1+2+7-1&#125; &amp; &#123;-1+2+7+1&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">We are asked to find two subsets of the given numbers whose difference is equal to the given target ‚ÄòS‚Äô. Take the first example above. As we saw, one solution is &#123;+1-1-2+3&#125;. So, the two subsets we are asked to find are &#123;1, 3&#125; &amp; &#123;1, 2&#125; because,</span><br><span class="line">(1 + 3) - (1 + 2) &#x3D; 1</span><br><span class="line"></span><br><span class="line">Sum(s1) - Sum(s2) &#x3D; S</span><br><span class="line">Sum(s1) + Sum(s2) &#x3D; Sum(num)</span><br><span class="line">Let‚Äôs add the above two equations:</span><br><span class="line">&#x3D;&gt; Sum(s1) - Sum(s2) + Sum(s1) + Sum(s2) &#x3D; S + Sum(num)</span><br><span class="line">&#x3D;&gt; 2 * Sum(s1) &#x3D;  S + Sum(num)</span><br><span class="line">&#x3D;&gt; Sum(s1) &#x3D; (S + Sum(num)) &#x2F; 2</span><br><span class="line"></span><br><span class="line">This essentially converts our problem to: ‚ÄúFind count of subsets of the given numbers whose sum is equal to‚Äù,</span><br><span class="line">&#x3D;&gt; (S + Sum(num)) &#x2F; 2</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The above solution has time O(N*S)</span></span><br><span class="line"><span class="comment">//space complexity of O(N‚àóS), where ‚ÄòN‚Äô represents total numbers and ‚ÄòS‚Äô is the desired sum.</span></span><br><span class="line"><span class="comment">//We can further improve the solution to use only O(S)O(S) space.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num)&#123;</span><br><span class="line">        totalSum += n;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//invalid input, the problem expects only positive numbers</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 's + totalSum' is odd, we can't find a subset with sum equal to '(s + totalSum) / 2'</span></span><br><span class="line">    <span class="keyword">if</span> (totalSum &lt; s || (s + totalSum) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> countSubsets(num, (s + totalSum) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this function is exactly similar to what we have in 'Count of Subset Sum' problem.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we will always have an empty set for zero sum</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to the number</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            <span class="keyword">if</span>(s &gt;= num[i])</span><br><span class="line">                dp[i][s] += dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[num.length-<span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="üåïUnsolved-494-Target-Sum‚ú®"><a href="#üåïUnsolved-494-Target-Sum‚ú®" class="headerlink" title="üåïUnsolved 494. Target Sum‚ú®"></a><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">üåïUnsolved 494. Target Sum‚ú®</a></h3><h3 id="Solution1-41"><a href="#Solution1-41" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>DFS</p>
</li>
<li><p>È¢òÁõÆÂ§ßÊÑèÔºöÁªô‰Ω†‰∏Ä‰∏≤Êï∞Â≠óÔºå‰Ω†ÂèØ‰ª•Âú®ÊØè‰∏™Êï∞Â≠óÂâçÊîæÁΩÆ+Êàñ-ÔºåÈóÆÊúâÂ§öÂ∞ëÁßçÊñπÊ≥ïÂèØ‰ª•‰ΩøÂæóË°®ËææÂºèÁöÑÂÄºÁ≠â‰∫étarget„ÄÇYou are given a list of non-negative integers, a1, a2, ‚Ä¶, an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p>
<p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p>
</li>
<li><p>Time complexity: O(2^n)</p>
<p>Space complexity: O(n)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; Math.abs(S)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    dfs(nums, <span class="number">0</span>, S);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (start == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="number">0</span>) ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(nums, start + <span class="number">1</span>, S + nums[start]);</span><br><span class="line">    dfs(nums, start + <span class="number">1</span>, S - nums[start]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-Solution2"><a href="#Unsolved-Solution2" class="headerlink" title="Unsolved Solution2:"></a>Unsolved Solution2:</h3><ol>
<li><a href="https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-494-target-sum/" target="_blank" rel="noopener">DP</a></li>
</ol>
<h1 id="Pattern-2-Unbounded-Knapsack"><a href="#Pattern-2-Unbounded-Knapsack" class="headerlink" title="Pattern 2: Unbounded Knapsack"></a>Pattern 2: Unbounded Knapsack</h1><h2 id="üåïUnbounded-Knapsack"><a href="#üåïUnbounded-Knapsack" class="headerlink" title="üåïUnbounded Knapsack"></a>üåïUnbounded Knapsack</h2><p>The only difference between the <a href="https://www.educative.io/collection/page/5668639101419520/5633779737559040/5666387129270272/" target="_blank" rel="noopener">0/1 Knapsack</a> problem and this problem is that we are allowed to use an unlimited quantity of an item.</p>
<h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute-force"></a>brute-force</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each item &#39;i&#39; </span><br><span class="line">  create a new set which includes one quantity of item &#39;i&#39; if it does not exceed the capacity, and </span><br><span class="line">     recursively call to process all items </span><br><span class="line">  create a new set without item &#39;i&#39;, and recursively process the remaining items </span><br><span class="line">return the set from the above two sets with higher profit</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length || </span><br><span class="line">        currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after choosing the items at the currentIndex, note that we recursive call on all items as we did not increment currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weights[currentIndex] &lt;= capacity) &#123;</span><br><span class="line">        profit1 = profits[currentIndex] + knapsackRecursive(profits, weights, capacity - weights[currentIndex], currentIndex);  <span class="comment">//&lt;---------------currentIndex not increase, can be use again</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the element at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> profit2 = knapsackRecursive(profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(profit1, profit2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-5"><a href="#Top-down-Dynamic-Programming-with-Memoization-5" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[profits.length][capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(dp, profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(Integer[][] dp, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] profits, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] weights, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> capacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length ||</span><br><span class="line">        currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we have not already processed a similar sub-problem</span></span><br><span class="line">    <span class="keyword">if</span> (dp[currentIndex][capacity] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// recursive call after choosing the items at the currentIndex, note that we recursive call on all</span></span><br><span class="line">        <span class="comment">// items as we did not increment currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (weights[currentIndex] &lt;= capacity) &#123;</span><br><span class="line">            profit1 = profits[currentIndex] + knapsackRecursive(dp, profits, weights, capacity - weights[currentIndex], currentIndex);  <span class="comment">//&lt;---------------currentIndex not increase, can be use again</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursive call after excluding the element at the currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> profit2 = knapsackRecursive(dp, profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        dp[currentIndex][capacity] = Math.max(profit1, profit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-5"><a href="#Bottom-up-Dynamic-Programming-5" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[index][c] &#x3D; max (dp[index-1][c], profit[index] + dp[index][c-weight[index]])</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = profits.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the capacity=0 columns</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all sub-arrays for all capacities</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit1=<span class="number">0</span>, profit2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(weights[i] &lt;= c)</span><br><span class="line">                profit1 = profits[i] + dp[i][c-weights[i]];</span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span> )</span><br><span class="line">                profit2 = dp[i-<span class="number">1</span>][c];</span><br><span class="line">            dp[i][c] = profit1 &gt; profit2 ? profit1 : profit2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maximum profit will be in the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rod-Cutting"><a href="#Rod-Cutting" class="headerlink" title="Rod Cutting"></a>Rod Cutting</h2><h3 id="brute-force-solution-1"><a href="#brute-force-solution-1" class="headerlink" title="brute-force solution"></a>brute-force solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each rod length &#39;i&#39; </span><br><span class="line">  create a new set which includes one quantity of length &#39;i&#39;, and recursively process </span><br><span class="line">      all rod lengths for the remaining length </span><br><span class="line">  create a new set without rod length &#39;i&#39;, and recursively process for remaining rod lengths</span><br><span class="line">return the set from the above two sets with a higher sales price</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-6"><a href="#Top-down-Dynamic-Programming-with-Memoization-6" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveRodCutting</span><span class="params">(<span class="keyword">int</span>[] lengths, <span class="keyword">int</span>[] prices, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[lengths.length][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findTheMax(<span class="number">0</span>, lengths, prices, n, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheMax</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] lengths, <span class="keyword">int</span>[] prices, <span class="keyword">int</span> n, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (lengths.length == <span class="number">0</span> || lengths.length != prices.length || idx &gt;= lengths.length || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][n] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lengths[idx] &lt;= n) &#123;</span><br><span class="line">            profit1 = prices[idx] + findTheMax(idx, lengths, prices, n - lengths[idx], dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit2 = findTheMax(idx + <span class="number">1</span>, lengths, prices, n, dp);</span><br><span class="line">        dp[idx][n] = Math.max(profit1, profit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-6"><a href="#Bottom-up-Dynamic-Programming-6" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveRodCutting</span><span class="params">(<span class="keyword">int</span>[] lengths, <span class="keyword">int</span>[] prices, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || prices.length == <span class="number">0</span> || prices.length != lengths.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lengthCount = lengths.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lengthCount][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all rod lengths for all prices</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lengthCount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p1=<span class="number">0</span>, p2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(lengths[i] &lt;= len)</span><br><span class="line">                p1 = prices[i] + dp[i][len-lengths[i]];</span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span> )</span><br><span class="line">                p2 = dp[i-<span class="number">1</span>][len];</span><br><span class="line">            dp[i][len] = Math.max(p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maximum price will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[lengthCount-<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="518-Coin-Change‚ú®-ways-to-change"><a href="#518-Coin-Change‚ú®-ways-to-change" class="headerlink" title="518. Coin Change‚ú® ways to change"></a><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">518. Coin Change‚ú® ways to change</a></h2><h3 id="Basic-Solution"><a href="#Basic-Solution" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each coin &#39;c&#39; </span><br><span class="line">  create a new set which includes one quantity of coin &#39;c&#39; if it does not exceed &#39;T&#39;, and </span><br><span class="line">     recursively call to process all coins </span><br><span class="line">  create a new set without coin &#39;c&#39;, and recursively call to process the remaining coins </span><br><span class="line">return the count of sets who have a sum equal to &#39;T&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countChangeRecursive(denominations, total, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countChangeRecursive</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// basic checks</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(denominations.length == <span class="number">0</span> || currentIndex &gt;= denominations.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the coin at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the coin at currentIndex exceeds the total, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( denominations[currentIndex] &lt;= total )</span><br><span class="line">        sum1 = countChangeRecursive(denominations, total - denominations[currentIndex], currentIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the coin at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> sum2 = countChangeRecursive(denominations, total, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-7"><a href="#Top-down-Dynamic-Programming-with-Memoization-7" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[denominations.length][total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findCount(<span class="number">0</span>, denominations, total, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCount</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (denominations.length == <span class="number">0</span> || idx &gt;= denominations.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][total] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> way1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (denominations[idx] &lt;= total) &#123;</span><br><span class="line">            way1 = findCount(idx, denominations, total - denominations[idx], dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> way2 = findCount(idx + <span class="number">1</span>, denominations, total, dp);</span><br><span class="line">        dp[idx][total] = way1 + way2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-7"><a href="#Bottom-up-Dynamic-Programming-7" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = denominations.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][total + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the total=0 columns, as we will always have an empty set for zero total</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all sub-arrays for all capacities</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; t &lt;= total; t++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                dp[i][t] = dp[i-<span class="number">1</span>][t];</span><br><span class="line">            <span class="keyword">if</span>(t &gt;= denominations[i])</span><br><span class="line">                dp[i][t] += dp[i][t-denominations[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total combinations will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåïMinimum-Coin-Change‚ú®üé∂"><a href="#üåïMinimum-Coin-Change‚ú®üé∂" class="headerlink" title="üåïMinimum Coin Change‚ú®üé∂"></a><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">üåïMinimum Coin Change‚ú®üé∂</a></h2><h3 id="Basic-Solution-1"><a href="#Basic-Solution-1" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each coin &#39;c&#39; </span><br><span class="line">  create a new set which includes one quantity of coin &#39;c&#39; if it does not exceed &#39;T&#39;, and </span><br><span class="line">     recursively call to process all coins </span><br><span class="line">  create a new set without coin &#39;c&#39;, and recursively call to process the remaining coins </span><br><span class="line">return the count of coins from the above two sets with a smaller number of coins</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="keyword">this</span>.countChangeRecursive(denominations, total, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (result == Integer.MAX_VALUE ? -<span class="number">1</span> : result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countChangeRecursive</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(denominations.length == <span class="number">0</span> || currentIndex &gt;= denominations.length)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the coin at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the coin at currentIndex exceeds the total, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> count1 = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>( denominations[currentIndex] &lt;= total ) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = countChangeRecursive(denominations, total - denominations[currentIndex], currentIndex);</span><br><span class="line">        <span class="comment">//use Integer.MAX_VALUE -&gt; can't slpit the money to coin</span></span><br><span class="line">        <span class="keyword">if</span>(res != Integer.MAX_VALUE)&#123;</span><br><span class="line">            count1 = res + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the coin at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> count2 = countChangeRecursive(denominations, total, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(count1, count2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-8"><a href="#Top-down-Dynamic-Programming-with-Memoization-8" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[denominations.length][total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="keyword">this</span>.countChangeRecursive(dp, denominations, total, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (result == Integer.MAX_VALUE ? -<span class="number">1</span> : result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countChangeRecursive</span><span class="params">(Integer[][] dp, <span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (denominations.length == <span class="number">0</span> || currentIndex &gt;= denominations.length)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we have not already processed a similar sub-problem</span></span><br><span class="line">    <span class="keyword">if</span> (dp[currentIndex][total] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// recursive call after selecting the coin at the currentIndex</span></span><br><span class="line">        <span class="comment">// if the coin at currentIndex exceeds the total, we shouldn't process this</span></span><br><span class="line">        <span class="keyword">int</span> count1 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (denominations[currentIndex] &lt;= total) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = countChangeRecursive(dp, denominations, total - denominations[currentIndex], currentIndex);</span><br><span class="line">            <span class="keyword">if</span> (res != Integer.MAX_VALUE) &#123;</span><br><span class="line">                count1 = res + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursive call after excluding the coin at the currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> count2 = countChangeRecursive(dp, denominations, total, currentIndex + <span class="number">1</span>);</span><br><span class="line">        dp[currentIndex][total] = Math.min(count1, count2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-8"><a href="#Bottom-up-Dynamic-Programming-8" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = denominations.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][total + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt;= total; j++)</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the total=0 columns, as we don't need any coin to make zero total</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; t &lt;= total; t++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                dp[i][t] = dp[i-<span class="number">1</span>][t]; <span class="comment">//exclude the coin</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt;= denominations[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][t-denominations[i]] != Integer.MAX_VALUE)</span><br><span class="line">                    dp[i][t] = Math.min(dp[i][t], dp[i][t-denominations[i]]+<span class="number">1</span>); <span class="comment">// include the coin</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total combinations will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> (dp[n-<span class="number">1</span>][total] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[n-<span class="number">1</span>][total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Min-Number-Of-Coins-For-Change-AE-‚ú®"><a href="#Min-Number-Of-Coins-For-Change-AE-‚ú®" class="headerlink" title="Min Number Of Coins For Change(AE)‚ú®"></a>Min Number Of Coins For Change(AE)‚ú®</h3><ol>
<li><p>two inputs, target of amount of money and array of coin combinations</p>
</li>
<li><p>find the min number to get the amount</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">6</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]  <span class="number">2</span> coins(<span class="number">2</span>$ + <span class="number">4</span>$);</span><br><span class="line">with <span class="number">1</span>$</span><br><span class="line">coins-&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">$    -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">2</span> - <span class="number">1</span> = <span class="number">1</span>, <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">min[<span class="number">1</span>] += min[<span class="number">1</span> - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">with <span class="number">1</span>$ &amp; <span class="number">2</span>$</span><br><span class="line">coins-&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">$    -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> - <span class="number">2</span> = <span class="number">0</span></span><br><span class="line"><span class="number">3</span> - <span class="number">2</span> = <span class="number">1</span>, <span class="number">4</span> - <span class="number">2</span> = <span class="number">2</span>, <span class="number">5</span> - <span class="number">2</span> = <span class="number">3</span>, <span class="number">6</span> - <span class="number">2</span> = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">with <span class="number">1</span>$ &amp; <span class="number">2</span>$ &amp; <span class="number">4</span>$</span><br><span class="line">coins-&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">$    -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span> - <span class="number">4</span> = <span class="number">0</span></span><br><span class="line"><span class="number">5</span> - <span class="number">4</span> = <span class="number">1</span>, <span class="number">6</span> - <span class="number">4</span> = <span class="number">2</span>;</span><br><span class="line"><span class="number">1</span>($denom) &lt;= <span class="number">1</span>(amount)</span><br></pre></td></tr></table></figure>
</li>
<li><p>if amount &gt;= denom: <strong><code>nums[amount]</code></strong> = min(<strong><code>nums[amount]</code></strong>, <strong><code>1(eg. a 4$ coin) + nums[amount - denom]</code></strong>)</p>
</li>
</ol>
<h3 id="Solution1-42"><a href="#Solution1-42" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(nd) d is denom time | O(n) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberOfCoinsForChange</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] denoms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] numOfCoins = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];  <span class="comment">//add o amount which is base case at beginning</span></span><br><span class="line">    Arrays.fill(numOfCoins, Integer.MAX_VALUE);</span><br><span class="line">    numOfCoins[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> toCompare  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> denom : denoms) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> amount = <span class="number">0</span>; amount &lt; numOfCoins.length; ++amount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &gt;= denom) &#123;  <span class="comment">//if amount can use denom coin, apply the formula</span></span><br><span class="line">                <span class="keyword">if</span> (numOfCoins[amount - denom] = Integer.MAX_VALUE) &#123;</span><br><span class="line">                    toCompare = numOfCoins[amount - denom];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    toCompare = numOfCoins[amount - denom] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                numOfCoins[amount] = Math.min(numOfCoins[amount], toCompare);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfCoins[n] != Integer.MAX_VALUE ? numOfCoins[n] : - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="322-Coin-Change‚ú®"><a href="#322-Coin-Change‚ú®" class="headerlink" title="322. Coin Change‚ú®"></a><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change‚ú®</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">min number</span><br><span class="line">amount-&gt; <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span></span><br><span class="line">types</span><br><span class="line"><span class="number">0</span>        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"><span class="number">1</span>(<span class="number">1</span>$)    <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span></span><br><span class="line"><span class="number">2</span>(<span class="number">5</span>$)    <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>(<span class="number">10</span>$)   <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dp[<span class="number">2</span>][<span class="number">5</span>] = Math.min(dp[<span class="number">1</span>][<span class="number">5</span>], <span class="number">1</span> + dp[<span class="number">2</span>][<span class="number">5</span> - <span class="number">5</span>]) = Math.min(<span class="number">5</span>, <span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">formula: dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], <span class="number">1</span> + dp[i][j - denom])</span><br><span class="line">nums[amount] = min(**`nums[amount]`**, **`<span class="number">1</span>(eg. a <span class="number">4</span>$ coin) + nums[amount - denom]`**)</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-43"><a href="#Solution1-43" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time complexity : O(S<em>n)*O</em>(<em>S</em>‚àó<em>n</em>). On each step the algorithm finds the next <em>F(i)*F</em>(*i<em>)</em> in n<em>n</em> iterations, where 1\leq i \leq S1‚â§<em>i</em>‚â§<em>S</em>. Therefore in total the iterations are S<em>n</em>S<em>‚àó</em>n*.</li>
<li>Space complexity : O(S)<em>O</em>(<em>S</em>). We use extra space for the memoization table.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tocompare = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> denom : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= denom) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i - denom] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    tocompare = dp[i - denom];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tocompare = dp[i - denom] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = Math.min(dp[i], tocompare);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] != Integer.MAX_VALUE ? dp[amount] : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-13"><a href="#Solution2-13" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>ÊÄùË∑ØÔºöÂä®ÊÄÅËßÑÂàí„ÄÇ‰ΩøÁî®Âíå‰∏ç‰ΩøÁî®ÊØè‰∏ÄÁßç Coin ÂØπ‰∫éÊØè‰∏ÄÁßç Amount ÁöÑÊÉÖÂÜµÈÄêÊ∏êÁ¥ØÂä†ÔºåÁõ¥Âà∞ËææÂà∞ Amount„ÄÇ</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    Arrays.fill(dp, max);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin)</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[i - coins[j]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ?  -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåïMaximum-Ribbon-Cut"><a href="#üåïMaximum-Ribbon-Cut" class="headerlink" title="üåïMaximum Ribbon Cut"></a>üåïMaximum Ribbon Cut</h2><h3 id="Basic-Solution-2"><a href="#Basic-Solution-2" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each length &#39;l&#39; </span><br><span class="line">  create a new set which includes one quantity of length &#39;l&#39; if it does not exceed &#39;n&#39;, and </span><br><span class="line">     recursively call to process all lengths </span><br><span class="line">  create a new set without length &#39;l&#39;, and recursively call to process the remaining lengths</span><br><span class="line">return the number of pieces from the above two sets with a higher number of pieces</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRibbonPieces</span><span class="params">(<span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxPieces = <span class="keyword">this</span>.countRibbonPiecesRecursive(ribbonLengths, total, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> maxPieces == Integer.MIN_VALUE ? -<span class="number">1</span> : maxPieces;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countRibbonPiecesRecursive</span><span class="params">(<span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ribbonLengths.length == <span class="number">0</span> || currentIndex &gt;= ribbonLengths.length)</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the ribbon length at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the ribbon length at the currentIndex exceeds the total, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> c1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span>( ribbonLengths[currentIndex] &lt;= total ) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = countRibbonPiecesRecursive(ribbonLengths, total - ribbonLengths[currentIndex], currentIndex);</span><br><span class="line">        <span class="keyword">if</span>(result != Integer.MIN_VALUE)&#123;</span><br><span class="line">            c1 = result + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the ribbon length at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> c2 = countRibbonPiecesRecursive(ribbonLengths, total, currentIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-9"><a href="#Top-down-Dynamic-Programming-with-Memoization-9" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRibbonPieces</span><span class="params">(<span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//find the max pieces</span></span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[ribbonLengths.length][total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> result = findTheMax(<span class="number">0</span>, ribbonLengths, total, dp);</span><br><span class="line">    <span class="keyword">return</span> result == Integer.MIN_VALUE? -<span class="number">1</span> : result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheMax</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ribbonLengths.length == <span class="number">0</span> || idx &gt;= ribbonLengths.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][total] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> way1 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (ribbonLengths[idx] &lt;= total) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = findTheMax(idx, ribbonLengths, total - ribbonLengths[idx], dp);</span><br><span class="line">            <span class="keyword">if</span> (remain != Integer.MIN_VALUE) &#123;</span><br><span class="line">                way1 = remain + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> way2 = findTheMax(idx + <span class="number">1</span>, ribbonLengths, total, dp);</span><br><span class="line">        dp[idx][total] = Math.max(way1, way2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-9"><a href="#Bottom-up-Dynamic-Programming-9" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRibbonPieces</span><span class="params">(<span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = ribbonLengths.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][total + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt;= total; j++)</span><br><span class="line">            dp[i][j] = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the total=0 columns, as we don't need any ribbon to make zero total</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; t &lt;= total; t++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) <span class="comment">//exclude the ribbon</span></span><br><span class="line">                dp[i][t] = dp[i-<span class="number">1</span>][t];</span><br><span class="line">            <span class="comment">// include the ribbon and check if the remaining length can be cut into available lengths</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt;= ribbonLengths[i] &amp;&amp; dp[i][t-ribbonLengths[i]] != Integer.MIN_VALUE)</span><br><span class="line">                dp[i][t] = Math.max(dp[i][t], dp[i][t-ribbonLengths[i]]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total combinations will be at the bottom-right corner, return '-1' if cutting is not possible</span></span><br><span class="line">    <span class="keyword">return</span> (dp[n-<span class="number">1</span>][total] == Integer.MIN_VALUE ? -<span class="number">1</span> : dp[n-<span class="number">1</span>][total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a><a href="https://leetcode.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. Combination Sum IV</a></h2><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p><a href="https://leetcode.com/problems/combination-sum-iv/discuss/736395/JavaScript-Solution-Top-Down-with-Memoization" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum-iv/discuss/736395/JavaScript-Solution-Top-Down-with-Memoization</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Integer[] memo = <span class="keyword">new</span> Integer[target + <span class="number">1</span>];</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, target, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, Integer[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (memo[target] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[target];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[i]) &#123;</span><br><span class="line">                ans += dfs(nums, target - nums[i], memo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[target] = ans;</span><br><span class="line">        <span class="keyword">return</span> memo[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Pattern-3-Fibonacci-Numbers"><a href="#Pattern-3-Fibonacci-Numbers" class="headerlink" title="Pattern 3: Fibonacci Numbers"></a>Pattern 3: Fibonacci Numbers</h1><h2 id="Fibonacci-Numbers"><a href="#Fibonacci-Numbers" class="headerlink" title="Fibonacci Numbers"></a>Fibonacci Numbers</h2><h3 id="Memory-optimization"><a href="#Memory-optimization" class="headerlink" title="Memory optimization"></a>Memory optimization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">1</span>, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        temp = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//The above solution has a time complexity of O(n) but a constant space complexity O(1).</span></span><br></pre></td></tr></table></figure>

<h2 id="Staircase"><a href="#Staircase" class="headerlink" title="Staircase"></a>Staircase</h2><h3 id="Basic-Solution-3"><a href="#Basic-Solution-3" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// base case, we don't need to take any step, so there is only one way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can take one step to reach the end, and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// we can take one step twice or jump two steps to reach at the top</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we take 1 step, we are left with 'n-1' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take1Step = CountWays(n-<span class="number">1</span>); </span><br><span class="line">    <span class="comment">// similarly, if we took 2 steps, we are left with 'n-2' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take2Step = CountWays(n-<span class="number">2</span>); </span><br><span class="line">    <span class="comment">// if we took 3 steps, we are left with 'n-3' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take3Step = CountWays(n-<span class="number">3</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> take1Step + take2Step + take3Step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Top-down-Dynamic-Programming-with-Memoization-10"><a href="#Top-down-Dynamic-Programming-with-Memoization-10" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> CountWaysRecursive(dp, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWaysRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// base case, we don't need to take any step, so there is only one way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can take one step to reach the end, and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// we can take one step twice or jump two steps to reach at the top</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[n] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if we take 1 step, we are left with 'n-1' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take1Step = CountWaysRecursive(dp, n-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// similarly, if we took 2 steps, we are left with 'n-2' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take2Step = CountWaysRecursive(dp, n-<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// if we took 3 steps, we are left with 'n-3' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take3Step = CountWaysRecursive(dp, n-<span class="number">3</span>);</span><br><span class="line">        dp[n] = take1Step + take2Step + take3Step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-10"><a href="#Bottom-up-Dynamic-Programming-10" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>] + dp[i-<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memory-optimization-1"><a href="#Memory-optimization-1" class="headerlink" title="Memory optimization"></a>Memory optimization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">1</span>, n2=<span class="number">1</span>, n3=<span class="number">2</span>, temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        temp = n1 + n2 + n3;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">        n3 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//The above solution has a time complexity of O(n) and a constant space complexity O(1).</span></span><br></pre></td></tr></table></figure>

<h2 id="Number-factors"><a href="#Number-factors" class="headerlink" title="Number factors"></a>Number factors</h2><p>Given a number ‚Äòn‚Äô, implement a method to count how many possible ways there are to express ‚Äòn‚Äô as the sum of 1, 3, or 4.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n : 4</span><br><span class="line">Number of ways &#x3D; 4</span><br><span class="line">Explanation: Following are the four ways we can express &#39;n&#39; : &#123;1,1,1,1&#125;, &#123;1,3&#125;, &#123;3,1&#125;, &#123;4&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-4"><a href="#Basic-Solution-4" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// base case, we don't need to subtract any thing, so there is only one way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can subtract 1 to be left with zero, and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can subtract 1 twice to get zero and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// '3' can be expressed as &#123;1,1,1&#125;, &#123;3&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we subtract 1, we are left with 'n-1'</span></span><br><span class="line">    <span class="keyword">int</span> subtract1 = CountWays(n-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// if we subtract 3, we are left with 'n-3'</span></span><br><span class="line">    <span class="keyword">int</span> subtract3 = CountWays(n-<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// if we subtract 4, we are left with 'n-4'</span></span><br><span class="line">    <span class="keyword">int</span> subtract4 = CountWays(n-<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subtract1 + subtract3 + subtract4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-11"><a href="#Top-down-Dynamic-Programming-with-Memoization-11" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> CountWaysRecursive(dp, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWaysRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// base case, we don't need to subtract any thing, so there is only one way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can take subtract 1 to be left with zero, and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can subtract 1 twice to get zero and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// '3' can be expressed as &#123;1,1,1&#125;, &#123;3&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[n] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if we subtract 1, we are left with 'n-1'</span></span><br><span class="line">        <span class="keyword">int</span> subtract1 = CountWaysRecursive(dp, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// if we subtract 3, we are left with 'n-3'</span></span><br><span class="line">        <span class="keyword">int</span> subtract3 = CountWaysRecursive(dp, n - <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// if we subtract 4, we are left with 'n-4'</span></span><br><span class="line">        <span class="keyword">int</span> subtract4 = CountWaysRecursive(dp, n - <span class="number">4</span>);</span><br><span class="line">        dp[n] = subtract1 + subtract3 + subtract4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-11"><a href="#Bottom-up-Dynamic-Programming-11" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n &lt;= <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">3</span> ) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=n; i++)</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">3</span>] + dp[i-<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fibonacci-number-pattern"><a href="#Fibonacci-number-pattern" class="headerlink" title="Fibonacci number pattern"></a>Fibonacci number pattern</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountWays(n) &#x3D; CountWays(n-1) + CountWays(n-3) + CountWays(n-4), for n &gt;&#x3D; 4</span><br></pre></td></tr></table></figure>

<h2 id="üåïMinimum-jumps-to-reach-the-end-Jump-game‚≠ê"><a href="#üåïMinimum-jumps-to-reach-the-end-Jump-game‚≠ê" class="headerlink" title="üåïMinimum jumps to reach the end || Jump game‚≠ê"></a>üåïMinimum jumps to reach the end || Jump game‚≠ê</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input &#x3D; &#123;2,1,1,1,4&#125;</span><br><span class="line">Output &#x3D; 3</span><br><span class="line">Explanation: Starting from index &#39;0&#39;, we can reach the last index through: 0-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-5"><a href="#Basic-Solution-5" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n)</span></span><br><span class="line"><span class="comment">//Space O(n) call stack</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMinJumps</span><span class="params">(<span class="keyword">int</span>[] jumps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countMinJumpsRecursive(jumps, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countMinJumpsRecursive</span><span class="params">(<span class="keyword">int</span>[] jumps, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if we have reached the last index, we don't need any more jumps</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex == jumps.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jumps[currentIndex] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalJumps = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> start = currentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = currentIndex + jumps[currentIndex];</span><br><span class="line">    <span class="keyword">while</span>(start &lt; jumps.length &amp;&amp; start &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// jump one step and recurse for the remaining array</span></span><br><span class="line">        <span class="keyword">int</span> minJumps = countMinJumpsRecursive(jumps, start++);</span><br><span class="line">        <span class="keyword">if</span>(minJumps != Integer.MAX_VALUE)</span><br><span class="line">            totalJumps = Math.min(totalJumps, minJumps + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalJumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-12"><a href="#Top-down-Dynamic-Programming-with-Memoization-12" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMinJumps</span><span class="params">(<span class="keyword">int</span>[] jumps)</span> </span>&#123;</span><br><span class="line">    Integer[] dp = <span class="keyword">new</span> Integer[jumps.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findMinJumps(<span class="number">0</span>, jumps, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinJumps</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] jumps, Integer[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == jumps.length  - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jumps[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> steps = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + idx &lt; jumps.length &amp;&amp; i &lt;= jumps[idx]; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minJumps = findMinJumps(i + idx, jumps, dp);</span><br><span class="line">            <span class="keyword">if</span> (minJumps != Integer.MAX_VALUE) &#123;</span><br><span class="line">                steps = Math.min(steps, minJumps + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx] = steps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMinJumps</span><span class="params">(<span class="keyword">int</span>[] jumps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[jumps.length];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countMinJumpsRecursive(dp, jumps, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countMinJumpsRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span>[] jumps, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if we have reached the last index, we don't need any more jumps</span></span><br><span class="line">    <span class="keyword">if</span>( currentIndex == jumps.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If an element is 0, then we cannot move through that element</span></span><br><span class="line">    <span class="keyword">if</span> (jumps[currentIndex] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have already solved this problem, return the result</span></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[currentIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalJumps = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> start = currentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = currentIndex + jumps[currentIndex];</span><br><span class="line">    <span class="keyword">while</span>(start &lt; jumps.length &amp;&amp; start &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// jump one step and recurse for the remaining array</span></span><br><span class="line">        <span class="keyword">int</span> minJumps = countMinJumpsRecursive(dp, jumps, start++);</span><br><span class="line">        <span class="keyword">if</span>(minJumps != Integer.MAX_VALUE)</span><br><span class="line">            totalJumps = Math.min(totalJumps, minJumps + <span class="number">1</span>); <span class="comment">//&lt;---------------don't forget +1</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp[currentIndex] = totalJumps;</span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-12"><a href="#Bottom-up-Dynamic-Programming-12" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMinJumps</span><span class="params">(<span class="keyword">int</span>[] jumps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[jumps.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initialize with infinity, except the first index which should be zero as we start from there</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;jumps.length; i++)</span><br><span class="line">        dp[i] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>; start &lt; jumps.length-<span class="number">1</span>; start++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end=start+<span class="number">1</span>; end &lt;= start+jumps[start] &amp;&amp; end &lt; jumps.length; end++)</span><br><span class="line">            dp[end] = Math.min(dp[end], dp[start]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[jumps.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fibonacci-number-pattern-1"><a href="#Fibonacci-number-pattern-1" class="headerlink" title="Fibonacci number pattern"></a>Fibonacci number pattern</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[end] &#x3D; Math.min(dp[end], dp[start]+1);</span><br></pre></td></tr></table></figure>

<h3 id="Min-Number-Of-Jumps-AE-‚≠ê"><a href="#Min-Number-Of-Jumps-AE-‚≠ê" class="headerlink" title="Min Number Of Jumps(AE)‚≠ê"></a>Min Number Of Jumps(AE)‚≠ê</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">nums [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">value of array mean the large pos you can jump to</span><br><span class="line">ex. nums[<span class="number">0</span>] = <span class="number">3</span>, means you can go to, nums[<span class="number">1</span>] || nums[<span class="number">2</span>] || nums[<span class="number">3</span>]</span><br><span class="line">answer <span class="number">4</span> jump : <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span> -&gt; <span class="number">7</span> -&gt; <span class="number">3</span> </span><br><span class="line">find out the min jump from start to end</span><br><span class="line"></span><br><span class="line">creat a jumps array represent the min jumps we need to current position, inital it infinate <span class="keyword">default</span> value Integer.MAX_VALUE</span><br><span class="line">jumps [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, , , , <span class="number">4</span>] </span><br><span class="line">Position jumps[<span class="number">1</span>]:</span><br><span class="line">j = <span class="number">0</span>, nums[j] = <span class="number">3</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="number">3</span> + <span class="number">0</span> &gt;= <span class="number">1</span>, and junps[<span class="number">0</span>] + <span class="number">1</span> = <span class="number">1</span> &lt; Integer.MAX_VALUE, update it</span><br><span class="line">Position jumps[<span class="number">1</span>]:</span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">j = <span class="number">0</span>, nums[j] = <span class="number">3</span></span><br><span class="line"><span class="number">3</span> + <span class="number">0</span> &gt;= <span class="number">2</span>, and junps[<span class="number">0</span>] + <span class="number">1</span> = <span class="number">1</span> &lt; Integer.MAX_VALUE, update it</span><br><span class="line">j = <span class="number">1</span>, nums[j] = <span class="number">4</span></span><br><span class="line"><span class="number">4</span> + <span class="number">1</span> &gt;= <span class="number">2</span>, and junps[<span class="number">1</span>] + <span class="number">1</span> = <span class="number">2</span> &gt; <span class="number">1</span>, <span class="keyword">do</span> nothing, keep it <span class="number">1</span></span><br><span class="line"></span><br><span class="line">formula:</span><br><span class="line"><span class="keyword">if</span> nums[j] + j &gt;= i</span><br><span class="line">    jumps[i] = Math.min(jumps[i], jumps[j] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-44"><a href="#Solution1-44" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>O(n^2) time, O(n) space</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberOfJumps</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] jumps = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    Arrays.fill(jumps, Integer.MAX_VALUE);</span><br><span class="line">    jumps[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//in first index don't need jump, initial it to 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] + j &gt;= i) &#123;  <span class="comment">//if this position i is reachable from position j</span></span><br><span class="line">                jumps[i] = Math.min(jumps[j] + <span class="number">1</span>, jumps[i]);  <span class="comment">//update it to min nums of jumps</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps[jumps.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-14"><a href="#Solution2-14" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>O(n) time, O(1) space</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nums [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">pos <span class="number">0</span> : maxReach = <span class="number">3</span> step = <span class="number">3</span>(mean we can take <span class="number">3</span> step until need a jump, <span class="keyword">if</span> arrive <span class="number">1</span>, step = <span class="number">0</span>)</span><br><span class="line">steps = <span class="number">3</span>, maxReach = <span class="number">3</span>, jumps = <span class="number">0</span></span><br><span class="line">pos <span class="number">1</span> : maxReach = <span class="number">4</span> + <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span> <span class="params">(<span class="number">1</span>, len(array)</span>)</span></span><br><span class="line"><span class="function">    maxReach </span>= max(maxReach, array[i] + i)</span><br><span class="line">    step -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> stemp == <span class="number">0</span>  <span class="comment">//is run out of steps we need a jump</span></span><br><span class="line">	    jumps += <span class="number">1</span></span><br><span class="line">        steps = maxReach - i</span><br><span class="line"><span class="keyword">return</span> jumps + <span class="number">1</span></span><br><span class="line">ex. in nums[<span class="number">3</span>] run out of steps, maxReach = nums[<span class="number">5</span>] = <span class="number">3</span>,</span><br><span class="line">update stpes = <span class="number">5</span> - <span class="number">3</span> = <span class="number">2</span>, keep going</span><br><span class="line"><span class="keyword">return</span> jumps + <span class="number">1</span> because in the end once we at the <span class="keyword">final</span> index we are done</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberOfJumps</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">1</span>)  <span class="comment">//edge case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> jumps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxReach = array[<span class="number">0</span>];  <span class="comment">//initail the array[0] as maxReach and steps</span></span><br><span class="line">    <span class="keyword">int</span> steps = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;  <span class="comment">//start traverse</span></span><br><span class="line">        maxReach = Math.max(maxReach, i + array[i]);  <span class="comment">//update the maxReach</span></span><br><span class="line">        steps--;  <span class="comment">//each iteration we consume a step, we reduce steps by one</span></span><br><span class="line">        <span class="keyword">if</span> (steps == <span class="number">0</span>) &#123;  <span class="comment">//if we run out of steps, we need to jump</span></span><br><span class="line">            jumps++;</span><br><span class="line">            steps = maxReach - i;  <span class="comment">//how many steps we need form index i to maxReach</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps + <span class="number">1</span>;  <span class="comment">//iterate to &lt; array.length - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="55-Jump-Game‚ú®"><a href="#55-Jump-Game‚ú®" class="headerlink" title="55.Jump Game‚ú®"></a><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">55.Jump Game‚ú®</a></h3><p>Given an array of <strong><code>non-negative</code></strong> integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="keyword">true</span></span><br><span class="line">Explanation: Jump <span class="number">1</span> step from index <span class="number">0</span> to <span class="number">1</span>, then <span class="number">3</span> steps to the last index.</span><br><span class="line">    </span><br><span class="line">Input: nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation: You will always arrive at index <span class="number">3</span> no matter what. Its maximum jump length is <span class="number">0</span>, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-45"><a href="#Solution1-45" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>ÊÄùË∑ØÔºöÊ≠•Ê≠•‰∏∫Ëê•„ÄÇÊØèÊ¨°ÁúãÊâÄÊúâÂΩìÂâçÂÖÉÁ¥†ÊâÄËÉΩËææÂà∞ÁöÑÊúÄËøú‰ΩçÁΩÆÔºåÂπ∂ÁºìÂ≠òÂÖ• maxÔºåÂ¶ÇÊûú i Ë∂ÖËøá max ÂàôË°®ÊòéÊó†Ê≥ïËææÂà∞„ÄÇ</p>
</li>
<li><p>The basic idea is this: at each step, we keep <strong><code>track of the furthest reachable index</code></strong>. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable.</p>
<p>Hence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reachable = <span class="number">0</span>;  <span class="comment">//track the farthest index can reach</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; reachable) <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//base line</span></span><br><span class="line">        reachable = Math.max(reachable, i + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max position one could reach </span></span><br><span class="line">    <span class="comment">// starting from index &lt;= i</span></span><br><span class="line">    <span class="keyword">int</span> maxPos = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// if one could't reach this point</span></span><br><span class="line">        <span class="keyword">if</span> (maxPos &lt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxPos = Math.max(maxPos, nums[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Approach-1-Backtracking"><a href="#Approach-1-Backtracking" class="headerlink" title="Approach 1: Backtracking"></a>Approach 1: Backtracking</h3><p><a href="https://leetcode.com/problems/jump-game/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game/solution/</a></p>
<ol>
<li>Time : O(2^n)</li>
<li>Space : O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (position == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> furthestJump = Math.min(position + nums[position], nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nextPosition = position + <span class="number">1</span>; nextPosition &lt;= furthestJump; nextPosition++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (canJumpFromPosition(nextPosition, nums)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-45-Jump-Game-II‚ú®"><a href="#Unsolved-45-Jump-Game-II‚ú®" class="headerlink" title="Unsolved 45. Jump Game II‚ú®"></a><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">Unsolved 45. Jump Game II‚ú®</a></h3><p><strong>Optimal solution</strong></p>
<p>There are several ways to solve this problem:</p>
<ul>
<li>Backtracking, \mathcal{O}(2^N)O(2<em>N</em>) time.</li>
<li>Dynamic programming, \mathcal{O}(N)O(<em>N</em>) time, \mathcal{O}(N)O(<em>N</em>) space.</li>
<li>Greedy, \mathcal{O}(N)O(<em>N</em>) time and \mathcal{O}(1)O(1) space.</li>
</ul>
<p>In this article we will consider in details the optimal greedy approach.</p>
<h3 id="Solution1-46"><a href="#Solution1-46" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Greedy</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max position one could reach </span></span><br><span class="line">    <span class="comment">// starting from index &lt;= i </span></span><br><span class="line">    <span class="keyword">int</span> maxPos = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// max number of steps one could do</span></span><br><span class="line">    <span class="comment">// inside this jump</span></span><br><span class="line">    <span class="keyword">int</span> maxSteps = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> jumps = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// if to reach this point </span></span><br><span class="line">        <span class="comment">// one needs one more jump</span></span><br><span class="line">        <span class="keyword">if</span> (maxSteps &lt; i) &#123;</span><br><span class="line">            ++jumps;</span><br><span class="line">            maxSteps = maxPos;</span><br><span class="line">        &#125;</span><br><span class="line">        maxPos = Math.max(maxPos, nums[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-15"><a href="#Solution2-15" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curMax = <span class="number">0</span>; <span class="comment">// to mark the last element in a level</span></span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= curMax) &#123; </span><br><span class="line">        <span class="keyword">int</span> furthest = curMax; <span class="comment">// to mark the last element in the next level</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= curMax; i++) &#123;</span><br><span class="line">            furthest = Math.max(furthest, nums[i] + i);</span><br><span class="line">            <span class="keyword">if</span> (furthest &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">        curMax = furthest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// if i &lt; curMax, i can't move forward anymore (the last element in the array can't be reached)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a><a href="https://leetcode.com/problems/jump-game-iii/" target="_blank" rel="noopener">1306. Jump Game III</a></h3><h3 id="Solution1-47"><a href="#Solution1-47" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="number">0</span> &amp;&amp; start &lt; arr.length &amp;&amp; arr[start] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> jump = arr[start];</span><br><span class="line">        arr[start] = -arr[start];</span><br><span class="line">        <span class="keyword">return</span> jump == <span class="number">0</span> || canReach(arr, start + jump) || canReach(arr, start - jump);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-16"><a href="#Solution2-16" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    stack.push(start);</span><br><span class="line">    set.add(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = cur + arr[cur];</span><br><span class="line">        <span class="keyword">int</span> right = cur - arr[cur];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; left &lt; arr.length &amp;&amp; !set.contains(left)) &#123;</span><br><span class="line">            stack.push(left);</span><br><span class="line">            set.add(left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; right &lt; arr.length &amp;&amp; !set.contains(right)) &#123;</span><br><span class="line">            stack.push(right);</span><br><span class="line">            set.add(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minimum-jumps-with-fee"><a href="#Minimum-jumps-with-fee" class="headerlink" title="Minimum jumps with fee"></a>Minimum jumps with fee</h2><p>Given a staircase with ‚Äòn‚Äô steps and an array of ‚Äòn‚Äô numbers representing the fee that you have to pay if you take the step. Implement a method to calculate the minimum fee required to reach the top of the staircase (beyond the top-most step). </p>
<p>At every step, you have an option to take either 1 step, 2 steps, or 3 steps. You should assume that you are standing at the first step.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Number of stairs (n) : 6</span><br><span class="line">Fee: &#123;1,2,5,2,1,2&#125;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Starting from index &#39;0&#39;, we can reach the top through: 0-&gt;3-&gt;top</span><br><span class="line">The total fee we have to pay will be (1+2).</span><br><span class="line"></span><br><span class="line">Number of stairs (n): 4</span><br><span class="line">Fee: &#123;2,3,4,5&#125;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Starting from index &#39;0&#39;, we can reach the top through: 0-&gt;1-&gt;top</span><br><span class="line">The total fee we have to pay will be (2+3).</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-6"><a href="#Basic-Solution-6" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinFee</span><span class="params">(<span class="keyword">int</span>[] fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findMinFeeRecursive(fee, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMinFeeRecursive</span><span class="params">(<span class="keyword">int</span>[] fee, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentIndex &gt; fee.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we take 1 step, we are left with 'n-1' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take1Step = findMinFeeRecursive(fee, currentIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// similarly, if we took 2 steps, we are left with 'n-2' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take2Step = findMinFeeRecursive(fee, currentIndex + <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// if we took 3 steps, we are left with 'n-3' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take3Step = findMinFeeRecursive(fee, currentIndex + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = Math.min(Math.min(take1Step, take2Step), take3Step);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min + fee[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-13"><a href="#Top-down-Dynamic-Programming-with-Memoization-13" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinFee</span><span class="params">(<span class="keyword">int</span>[] fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[fee.length];</span><br><span class="line">    <span class="keyword">return</span> findMinFeeRecursive(dp, fee, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMinFeeRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span>[] fee, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( currentIndex &gt; fee.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if we take 1 step, we are left with 'n-1' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take1Step = findMinFeeRecursive(dp, fee, currentIndex + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// similarly, if we took 2 steps, we are left with 'n-2' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take2Step = findMinFeeRecursive(dp, fee, currentIndex + <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// if we took 3 steps, we are left with 'n-3' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take3Step = findMinFeeRecursive(dp, fee, currentIndex + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        dp[currentIndex] = fee[currentIndex] + Math.min(Math.min(take1Step, take2Step), take3Step);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-13"><a href="#Bottom-up-Dynamic-Programming-13" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinFee</span><span class="params">(<span class="keyword">int</span>[] fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[fee.length + <span class="number">1</span>]; <span class="comment">// +1 to handle the 0th step</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// if there are no steps, we dont have to pay any fee</span></span><br><span class="line">    dp[<span class="number">1</span>] = fee[<span class="number">0</span>]; <span class="comment">// only one step, so we have to pay its fee</span></span><br><span class="line">    <span class="comment">// for 2 or 3 steps staircase, since we start from the first step so we have to pay its fee</span></span><br><span class="line">    <span class="comment">// and from the first step we can reach the top by taking two or three steps, so we don't</span></span><br><span class="line">    <span class="comment">// have to pay any other fee.</span></span><br><span class="line">    dp[<span class="number">2</span>] = dp[<span class="number">3</span>] = fee[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; fee.length; i++)</span><br><span class="line">        dp[i + <span class="number">1</span>] = Math.min(fee[i] + dp[i], Math.min(fee[i - <span class="number">1</span>] + dp[i - <span class="number">1</span>], fee[i - <span class="number">2</span>] + dp[i - <span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[fee.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="House-thief"><a href="#House-thief" class="headerlink" title="House thief"></a>House thief</h2><h3 id="Basic-Solution-7"><a href="#Basic-Solution-7" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxSteal</span><span class="params">(<span class="keyword">int</span>[] wealth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findMaxStealRecursive(wealth, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxStealRecursive</span><span class="params">(<span class="keyword">int</span>[] wealth, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex &gt;= wealth.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// steal from current house and skip one to steal from the next house</span></span><br><span class="line">    <span class="keyword">int</span> stealCurrent = wealth[currentIndex] + findMaxStealRecursive(wealth, currentIndex + <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// skip current house to steel from the adjacent house</span></span><br><span class="line">    <span class="keyword">int</span> skipCurrent = findMaxStealRecursive(wealth, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(stealCurrent, skipCurrent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-14"><a href="#Top-down-Dynamic-Programming-with-Memoization-14" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxSteal</span><span class="params">(<span class="keyword">int</span>[] wealth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[wealth.length];</span><br><span class="line">    <span class="keyword">return</span> findMaxStealRecursive(dp, wealth, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxStealRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span>[] wealth, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( currentIndex &gt;= wealth.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// steal from current house and skip one to steal next</span></span><br><span class="line">        <span class="keyword">int</span> stealCurrent = wealth[currentIndex] + findMaxStealRecursive(dp, wealth, currentIndex + <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// skip current house to steel from the adjacent house</span></span><br><span class="line">        <span class="keyword">int</span> skipCurrent = findMaxStealRecursive(dp, wealth, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        dp[currentIndex] = Math.max(stealCurrent, skipCurrent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-14"><a href="#Bottom-up-Dynamic-Programming-14" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxSteal</span><span class="params">(<span class="keyword">int</span>[] wealth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wealth.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[wealth.length+<span class="number">1</span>]; <span class="comment">// '+1' to handle the zero house</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// if there are no houses, the thief can't steal anything</span></span><br><span class="line">    dp[<span class="number">1</span>] = wealth[<span class="number">0</span>]; <span class="comment">// only one house, so the thief have to steal from it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// please note that dp[] has one extra element to handle zero house</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; wealth.length; i++)</span><br><span class="line">        dp[i+<span class="number">1</span>] = Math.max(wealth[i] + dp[i-<span class="number">1</span>], dp[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[wealth.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memory-optimization-2"><a href="#Memory-optimization-2" class="headerlink" title="Memory optimization"></a>Memory optimization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxSteal</span><span class="params">(<span class="keyword">int</span>[] wealth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wealth.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">0</span>, n2=wealth[<span class="number">0</span>], temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; wealth.length; i++) &#123;</span><br><span class="line">        temp = Math.max(n1 + wealth[i], n2);</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pattern-4-Palindromic-Subsequence"><a href="#Pattern-4-Palindromic-Subsequence" class="headerlink" title="Pattern 4: Palindromic Subsequence"></a>Pattern 4: Palindromic Subsequence</h1><h2 id="‚ú®516-Longest-Palindromic-Subsequence"><a href="#‚ú®516-Longest-Palindromic-Subsequence" class="headerlink" title="‚ú®516. Longest Palindromic Subsequence"></a><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">‚ú®516. Longest Palindromic Subsequence</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &#x3D; &quot;cddpd&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: LPS is &quot;ddd&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-8"><a href="#Basic-Solution-8" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>try all the subsequences of the given sequence</p>
<p>We can start processing from the beginning and the end of the sequence. So at any step, we have two options:</p>
<ol>
<li>If the element at the beginning and the end are the same, we increment our count by two and make a recursive call for the remaining sequence.</li>
<li>We will skip the element either from the beginning or the end to make two recursive calls for the remaining subsequence.</li>
</ol>
<p>If option one applies then it will give us the length of LPS; otherwise, the length of LPS will be the maximum number returned by the two recurse calls from the second option.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLPSLength</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findLPSLengthRecursive(st, <span class="number">0</span>, st.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLPSLengthRecursive</span><span class="params">(String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt; endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every sequence with one element is a palindrome of length 1</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex == endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 1: elements at the beginning and the end are the same</span></span><br><span class="line">    <span class="keyword">if</span>(st.charAt(startIndex) == st.charAt(endIndex))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> + findLPSLengthRecursive(st, startIndex+<span class="number">1</span>, endIndex-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2: skip one element either from the beginning or the end</span></span><br><span class="line">    <span class="keyword">int</span> c1 =  findLPSLengthRecursive(st, startIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">    <span class="keyword">int</span> c2 =  findLPSLengthRecursive(st, startIndex, endIndex-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-15"><a href="#Top-down-Dynamic-Programming-with-Memoization-15" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><p>The two changing values to our recursive function are the two indexes, startIndex and endIndex. Therefore, we can store the results of all the subproblems in a two-dimensional array. (Another alternative could be to use a hash-table whose key would be a string (startIndex + ‚Äú|‚Äù + endIndex))</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLPSLength</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[st.length()][st.length()];</span><br><span class="line">    <span class="keyword">return</span> findLPSLengthRecursive(dp, st, <span class="number">0</span>, st.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLPSLengthRecursive</span><span class="params">(Integer[][] dp, String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt; endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every sequence with one element is a palindrome of length 1</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex == endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[startIndex][endIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// case 1: elements at the beginning and the end are the same</span></span><br><span class="line">        <span class="keyword">if</span>(st.charAt(startIndex) == st.charAt(endIndex)) &#123;</span><br><span class="line">            dp[startIndex][endIndex] = <span class="number">2</span> + findLPSLengthRecursive(dp, st, startIndex+<span class="number">1</span>, endIndex-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// case 2: skip one element either from the beginning or the end</span></span><br><span class="line">            <span class="keyword">int</span> c1 =  findLPSLengthRecursive(dp, st, startIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">            <span class="keyword">int</span> c2 =  findLPSLengthRecursive(dp, st, startIndex, endIndex-<span class="number">1</span>);</span><br><span class="line">            dp[startIndex][endIndex] = Math.max(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[startIndex][endIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a>Longest Palindromic Substring</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &#x3D; &quot;cddpd&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: LPS is &quot;dpd&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-9"><a href="#Basic-Solution-9" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLPSLength</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findLPSLengthRecursive(st, <span class="number">0</span>, st.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLPSLengthRecursive</span><span class="params">(String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt; endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every string with one character is a palindrome</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex == endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 1: elements at the beginning and the end are the same</span></span><br><span class="line">    <span class="keyword">if</span> (st.charAt(startIndex) == st.charAt(endIndex)) &#123;</span><br><span class="line">        <span class="keyword">int</span> remainingLength = endIndex - startIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// check if the remaining string is also a palindrome</span></span><br><span class="line">        <span class="keyword">if</span> (remainingLength == findLPSLengthRecursive(st, startIndex + <span class="number">1</span>, endIndex - <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> remainingLength + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2: skip one character either from the beginning or the end</span></span><br><span class="line">    <span class="keyword">int</span> c1 = findLPSLengthRecursive(st, startIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">    <span class="keyword">int</span> c2 = findLPSLengthRecursive(st, startIndex, endIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-16"><a href="#Top-down-Dynamic-Programming-with-Memoization-16" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLPSLength</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[st.length()][st.length()];</span><br><span class="line">    <span class="keyword">return</span> findLPSLengthRecursive(dp, st, <span class="number">0</span>, st.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLPSLengthRecursive</span><span class="params">(Integer[][] dp, String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt; endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every string with one character is a palindrome</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex == endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[startIndex][endIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// case 1: elements at the beginning and the end are the same</span></span><br><span class="line">        <span class="keyword">if</span> (st.charAt(startIndex) == st.charAt(endIndex)) &#123;</span><br><span class="line">            <span class="keyword">int</span> remainingLength = endIndex - startIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// check if the remaining string is also a palindrome</span></span><br><span class="line">            <span class="keyword">if</span> (remainingLength == findLPSLengthRecursive(dp, st, startIndex + <span class="number">1</span>, endIndex - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[startIndex][endIndex] = remainingLength + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// case 2: skip one character either from the beginning or the end</span></span><br><span class="line">            <span class="keyword">int</span> c1 = findLPSLengthRecursive(dp, st, startIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">            <span class="keyword">int</span> c2 = findLPSLengthRecursive(dp, st, startIndex, endIndex - <span class="number">1</span>);</span><br><span class="line">            dp[startIndex][endIndex] = Math.max(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[startIndex][endIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåïUnsolved-Count-of-Palindromic-Substrings"><a href="#üåïUnsolved-Count-of-Palindromic-Substrings" class="headerlink" title="üåïUnsolved Count of Palindromic Substrings"></a>üåïUnsolved Count of Palindromic Substrings</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abdbca&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Here are the palindromic substrings, &quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;bdb&quot;.</span><br></pre></td></tr></table></figure>

<p>can be easily converted to <a href="https://www.educative.io/collection/page/5668639101419520/5633779737559040/5661601461960704/" target="_blank" rel="noopener">Longest Palindromic Substring</a>. The only difference is that instead of calculating the longest palindromic substring, we will instead count all the palindromic substrings.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCPS</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[st.length()][st.length()];</span><br><span class="line">    <span class="keyword">return</span> findLPSLengthRecursive(dp, st, <span class="number">0</span>, st.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLPSLengthRecursive</span><span class="params">(Integer[][] dp, String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt; endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every string with one character is a palindrome</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex == endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[startIndex][endIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// case 1: elements at the beginning and the end are the same</span></span><br><span class="line">        <span class="keyword">int</span> way1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (st.charAt(startIndex) == st.charAt(endIndex)) &#123;</span><br><span class="line">            <span class="keyword">int</span> remainingLength = endIndex - startIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// check if the remaining string is also a palindrome</span></span><br><span class="line">            <span class="keyword">if</span> (remainingLength == findLPSLengthRecursive(dp, st, startIndex + <span class="number">1</span>, endIndex - <span class="number">1</span>)) &#123;</span><br><span class="line">                way1 = remainingLength + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// case 2: skip one character either from the beginning or the end</span></span><br><span class="line">        <span class="keyword">int</span> way2 = findLPSLengthRecursive(dp, st, startIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">        <span class="keyword">int</span> way3 = findLPSLengthRecursive(dp, st, startIndex, endIndex - <span class="number">1</span>);</span><br><span class="line">        dp[startIndex][endIndex] = way1 + way2 + way3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[startIndex][endIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="‚≠êMinimum-Deletions-in-a-String-to-make-it-a-Palindrome"><a href="#‚≠êMinimum-Deletions-in-a-String-to-make-it-a-Palindrome" class="headerlink" title="‚≠êMinimum Deletions in a String to make it a Palindrome"></a>‚≠êMinimum Deletions in a String to make it a Palindrome</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abdbca&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: By removing &quot;c&quot;, we get a palindrome &quot;abdba&quot;.</span><br><span class="line"></span><br><span class="line">Input: &#x3D; &quot;cddpd&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Deleting &quot;cp&quot;, we get a palindrome &quot;ddd&quot;.</span><br></pre></td></tr></table></figure>

<p>This problem can be easily converted to the <a href="https://www.educative.io/collection/page/5668639101419520/5633779737559040/5748119283171328/" target="_blank" rel="noopener">Longest Palindromic Subsequence</a> (LPS) problem. We can use the fact that LPS is the best subsequence we can have, so any character that is not part of LPS must be removed. Please note that it is ‚ÄòLongest Palindromic SubSequence‚Äô and not ‚ÄòLongest Palindrome Substring‚Äô.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Minimum_deletions_to_make_palindrome &#x3D; Length(st) - LPS(st)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinimumDeletions</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// subtracting the length of Longest Palindromic Subsequence from the length of</span></span><br><span class="line">    <span class="comment">// the input string to get minimum number of deletions</span></span><br><span class="line">    <span class="keyword">return</span> st.length() - findLPSLength(st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLPSLength</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[st.length()][st.length()];</span><br><span class="line">    <span class="keyword">return</span> findLPSLengthRecursive(dp, st, <span class="number">0</span>, st.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLPSLengthRecursive</span><span class="params">(Integer[][] dp, String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt; endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every sequence with one element is a palindrome of length 1</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex == endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[startIndex][endIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// case 1: elements at the beginning and the end are the same</span></span><br><span class="line">        <span class="keyword">if</span>(st.charAt(startIndex) == st.charAt(endIndex)) &#123;</span><br><span class="line">            dp[startIndex][endIndex] = <span class="number">2</span> + findLPSLengthRecursive(dp, st, startIndex+<span class="number">1</span>, endIndex-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// case 2: skip one element either from the beginning or the end</span></span><br><span class="line">            <span class="keyword">int</span> c1 =  findLPSLengthRecursive(dp, st, startIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">            <span class="keyword">int</span> c2 =  findLPSLengthRecursive(dp, st, startIndex, endIndex-<span class="number">1</span>);</span><br><span class="line">            dp[startIndex][endIndex] = Math.max(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[startIndex][endIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Similar-problems"><a href="#Similar-problems" class="headerlink" title="Similar problems"></a>Similar problems</h3><h3 id="1-1312-Minimum-insertions-in-a-string-to-make-it-a-palindrome‚ú®"><a href="#1-1312-Minimum-insertions-in-a-string-to-make-it-a-palindrome‚ú®" class="headerlink" title="1. 1312 Minimum insertions in a string to make it a palindrome‚ú®"></a><a href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/" target="_blank" rel="noopener">1. 1312 Minimum insertions in a string to make it a palindrome‚ú®</a></h3><p>the length of the Longest Palindromic Subsequence is the best palindromic subsequence we can have.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abdbca&quot;   </span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>Explanation: By inserting ‚Äúc‚Äù, we get a palindrome ‚Äúa<strong>c</strong>bdbca‚Äù.</p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &#x3D; &quot;cddpd&quot;  </span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>Explanation: Inserting ‚Äúcp‚Äù, we get a palindrome ‚Äúcd<strong>p</strong>dpd<strong>c</strong>‚Äù. We can also get a palindrome by inserting ‚Äúdc‚Äù: ‚Äúcddpd<strong>dc</strong>‚Äù</p>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &#x3D; &quot;pqr&quot;  </span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>Explanation: We have to insert any two characters to get a palindrome (e.g. if we insert ‚Äúpq‚Äù, we get a palindrome ‚Äúpqr<strong>qp</strong>‚Äù).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[s.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> maxSub = findMax(<span class="number">0</span>, s.length() - <span class="number">1</span>, s, dp);</span><br><span class="line">    <span class="keyword">return</span> s.length() - maxSub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String s, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[left][right] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            dp[left][right] = <span class="number">2</span> + findMax(left + <span class="number">1</span>, right - <span class="number">1</span>, s, dp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> way1 = findMax(left + <span class="number">1</span>, right, s, dp);</span><br><span class="line">            <span class="keyword">int</span> way2 = findMax(left, right - <span class="number">1</span>, s, dp);</span><br><span class="line">            dp[left][right] = Math.max(way1, way2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[left][right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Find-if-a-string-is-K-Palindromic"><a href="#2-Find-if-a-string-is-K-Palindromic" class="headerlink" title="2. Find if a string is K-Palindromic"></a>2. Find if a string is K-Palindromic</h3><p>Any string will be called K-palindromic if it can be transformed into a palindrome by removing at most ‚ÄòK‚Äô characters from it.</p>
<p>This problem can easily be converted to our base problem of finding the minimum deletions in a string to make it a palindrome. I</p>
<p>f the ‚Äúminimum deletion count‚Äù is not more than ‚ÄòK‚Äô, the string will be K-Palindromic.</p>
<h2 id="üåï‚ú®Unsolved-132-Palindromic-Partitioning"><a href="#üåï‚ú®Unsolved-132-Palindromic-Partitioning" class="headerlink" title="üåï‚ú®Unsolved 132. Palindromic Partitioning"></a><a href="https://leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">üåï‚ú®Unsolved 132. Palindromic Partitioning</a></h2><p>Given a string, we want to cut it into pieces such that each piece is a palindrome. Write a function to return the minimum number of cuts needed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abdbca&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Palindrome pieces are &quot;a&quot;, &quot;bdb&quot;, &quot;c&quot;, &quot;a&quot;.</span><br><span class="line"></span><br><span class="line">Input: &#x3D; &quot;cddpd&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Palindrome pieces are &quot;c&quot;, &quot;d&quot;, &quot;dpd&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-10"><a href="#Basic-Solution-10" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>The brute-force solution will be to try all the substring combinations of the given string. We can start processing from the beginning of the string and keep adding one character at a time. At any step, if we get a palindrome, we take it as one piece and recursively process the remaining length of the string to find the minimum cuts needed.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMPPCuts</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.findMPPCutsRecursive(st, <span class="number">0</span>, st.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMPPCutsRecursive</span><span class="params">(String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// we don't need to cut the string if it is a palindrome</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt;= endIndex || isPalindrome(st, startIndex, endIndex))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// at max, we need to cut the string into its 'length-1' pieces</span></span><br><span class="line">    <span class="keyword">int</span> minimumCuts = endIndex-startIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=startIndex; i &lt;= endIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPalindrome(st, startIndex, i))&#123;</span><br><span class="line">            <span class="comment">// we can cut here as we have a palindrome from 'startIndex' to 'i'</span></span><br><span class="line">            minimumCuts = Math.min(minimumCuts, <span class="number">1</span> + findMPPCutsRecursive(st, i+<span class="number">1</span>, endIndex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimumCuts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String st, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(st.charAt(x++) != st.charAt(y--))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-17"><a href="#Top-down-Dynamic-Programming-with-Memoization-17" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><p>We can memoize both functions <code>findMPPCutsRecursive()</code> and <code>isPalindrome()</code>. The two changing values in both these functions are the two indexes; therefore, we can store the results of all the subproblems in a two-dimensional array. (alternatively, we can use a hash-table).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMPPCuts</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    Integer dp[][] = <span class="keyword">new</span> Integer[st.length()][st.length()];</span><br><span class="line">    Boolean dpIsPalindrome[][] = <span class="keyword">new</span> Boolean[st.length()][st.length()];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.findMPPCutsRecursive(dp, dpIsPalindrome, st, <span class="number">0</span>, st.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMPPCutsRecursive</span><span class="params">(Integer dp[][], Boolean dpIsPalindrome[][],</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex || isPalindrome(dpIsPalindrome, st, startIndex, endIndex))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[startIndex][endIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// at max, we need to cut the string into its 'length-1' pieces</span></span><br><span class="line">        <span class="keyword">int</span> minimumCuts = endIndex - startIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=startIndex; i &lt;= endIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(dpIsPalindrome, st, startIndex, i)) &#123;</span><br><span class="line">                <span class="comment">// we can cut here as we have a palindrome from 'startIndex' to 'i'</span></span><br><span class="line">                minimumCuts = Math.min(minimumCuts, <span class="number">1</span> + findMPPCutsRecursive(dp, dpIsPalindrome, st, i+<span class="number">1</span>, endIndex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[startIndex][endIndex] = minimumCuts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[startIndex][endIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(Boolean dpIsPalindrome[][], String st, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dpIsPalindrome[x][y] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        dpIsPalindrome[x][y]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i=x, j=y;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.charAt(i++) != st.charAt(j--)) &#123;</span><br><span class="line">                dpIsPalindrome[x][y]=<span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// use memoization to find if the remaining string is a palindrome</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; j &amp;&amp; dpIsPalindrome[i][j] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dpIsPalindrome[x][y] = dpIsPalindrome[i][j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpIsPalindrome[x][y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[s.length()][s.length()];</span><br><span class="line">    Boolean[][] dpIsPalindrome = <span class="keyword">new</span> Boolean[s.length()][s.length()];</span><br><span class="line">    <span class="keyword">return</span> findMaxCut(<span class="number">0</span>, s.length() - <span class="number">1</span>, s, dpIsPalindrome, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxCut</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String s, Boolean[][] dpIsPalindrome, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right || isPalindrome(left, right, s, dpIsPalindrome)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[left][right] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> minCut = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(left, i, s, dpIsPalindrome)) &#123;</span><br><span class="line">                minCut = Math.min(minCut, <span class="number">1</span> + findMaxCut(i + <span class="number">1</span>, right, s, dpIsPalindrome, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[left][right] = minCut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[left][right];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String s, Boolean[][] dpIsPalindrome)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dpIsPalindrome[left][right] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        dpIsPalindrome[left][right] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i++) != s.charAt(j--)) &#123;</span><br><span class="line">                dpIsPalindrome[left][right] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j &amp;&amp; dpIsPalindrome[i][j] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dpIsPalindrome[left][right] = dpIsPalindrome[i][j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpIsPalindrome[left][right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåï131-Palindrome-Partitioning‚ú®"><a href="#üåï131-Palindrome-Partitioning‚ú®" class="headerlink" title="üåï131. Palindrome Partitioning‚ú®"></a><a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">üåï131. Palindrome Partitioning‚ú®</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s = <span class="string">"aab"</span></span><br><span class="line">Output: [[<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"aa"</span>,<span class="string">"b"</span>]]</span><br><span class="line"></span><br><span class="line">Input: s = <span class="string">"a"</span></span><br><span class="line">Output: [[<span class="string">"a"</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-48"><a href="#Solution1-48" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; partitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; tempPartition = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    doPartition(s, partitions, tempPartition);</span><br><span class="line">    <span class="keyword">return</span> partitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPartition</span><span class="params">(String s, List&lt;List&lt;String&gt;&gt; partitions, List&lt;String&gt; tempPartition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        partitions.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempPartition));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPalindrome(s, <span class="number">0</span>, i)) &#123;</span><br><span class="line">            tempPartition.add(s.substring(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">            doPartition(s.substring(i + <span class="number">1</span>), partitions, tempPartition);</span><br><span class="line">            tempPartition.remove(tempPartition.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(begin++) != s.charAt(end--)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-17"><a href="#Solution2-17" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getPartition(s, <span class="number">0</span>, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPartition</span><span class="params">(String s, <span class="keyword">int</span> start, List&lt;String&gt; cur, List&lt;List&lt;String&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, start, i)) &#123;</span><br><span class="line">                cur.add(s.substring(start, i+<span class="number">1</span>));</span><br><span class="line">                getPartition(s, i+<span class="number">1</span>, cur, ans);</span><br><span class="line">                cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i++) != s.charAt(j--)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="267-Palindrome-Permutation-II"><a href="#267-Palindrome-Permutation-II" class="headerlink" title="267. Palindrome Permutation II"></a><a href="https://leetcode.com/problems/palindrome-permutation-ii/" target="_blank" rel="noopener">267. Palindrome Permutation II</a></h3><h3 id="Solution1-49"><a href="#Solution1-49" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generatePalindromes</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> odds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) count[c]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            odds++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (odds &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        Character center = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                center = (<span class="keyword">char</span>) i;</span><br><span class="line">                count[i]--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        generate(ans, count, (center != <span class="keyword">null</span>? String.valueOf(center) : <span class="keyword">new</span> String()), s.length());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(List&lt;String&gt; ans, <span class="keyword">int</span>[] count, String cur, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count[i] -= <span class="number">2</span>;</span><br><span class="line">            generate(ans, count, ((<span class="keyword">char</span>) i) + cur + ((<span class="keyword">char</span>) i), size);</span><br><span class="line">            count[i] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur.length() == size) ans.add(<span class="keyword">new</span> String(cur));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pattern-5-Longest-Common-Substring"><a href="#Pattern-5-Longest-Common-Substring" class="headerlink" title="Pattern 5: Longest Common Substring"></a>Pattern 5: Longest Common Substring</h1><h2 id="üåïLongest-Common-Substring"><a href="#üåïLongest-Common-Substring" class="headerlink" title="üåïLongest Common Substring"></a>üåïLongest Common Substring</h2><p>Given two strings ‚Äòs1‚Äô and ‚Äòs2‚Äô, find the length of the longest substring which is common in both the strings.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;abdca&quot;</span><br><span class="line">       s2 &#x3D; &quot;cbda&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest common substring is &quot;bd&quot;.</span><br><span class="line"></span><br><span class="line">Input: s1 &#x3D; &quot;passport&quot;</span><br><span class="line">       s2 &#x3D; &quot;ppsspt&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common substring is &quot;ssp&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-11"><a href="#Basic-Solution-11" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>A basic brute-force solution could be to try all substrings of ‚Äòs1‚Äô and ‚Äòs2‚Äô to find the longest common one. We can start matching both the strings one character at a time, so we have two options at any step:</p>
<ol>
<li>If the strings have a matching character, we can recursively match for the remaining lengths and keep a track of the current matching length.</li>
<li>If the strings don‚Äôt match, we start two new recursive calls by skipping one character separately from each string and reset the matching length.</li>
</ol>
<p>The length of the Longest Common Substring (LCS) will be the maximum number returned by the three recurse calls in the above two options.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLCSLength</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findLCSLengthRecursive(s1, s2, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLCSLengthRecursive</span><span class="params">(String s1, String s2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i1 == s1.length() || i2 == s2.length())</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s1.charAt(i1) == s2.charAt(i2))</span><br><span class="line">        count = findLCSLengthRecursive(s1, s2, i1+<span class="number">1</span>, i2+<span class="number">1</span>, count+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1 = findLCSLengthRecursive(s1, s2, i1, i2+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> c2 = findLCSLengthRecursive(s1, s2, i1+<span class="number">1</span>, i2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(count, Math.max(c1, c2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-18"><a href="#Top-down-Dynamic-Programming-with-Memoization-18" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><p>The three changing values to our recursive function are the two indexes (i1 and i2) and the ‚Äòcount‚Äô. Therefore, we can store the results of all subproblems in a three-dimensional array. (Another alternative could be to use a hash-table whose key would be a string (i1 + ‚Äú|‚Äù i2 + ‚Äú|‚Äù + count)).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLCSLength</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = Math.min(s1.length(), s2.length());</span><br><span class="line">    Integer[][][] dp = <span class="keyword">new</span> Integer[s1.length()][s2.length()][maxLength];</span><br><span class="line">    <span class="keyword">return</span> findLCSLengthRecursive(dp, s1, s2, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLCSLengthRecursive</span><span class="params">(Integer[][][] dp, String s1, String s2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i1 == s1.length() || i2 == s2.length())</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[i1][i2][count] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> c1 = count;</span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(i1) == s2.charAt(i2))</span><br><span class="line">            c1 = findLCSLengthRecursive(dp, s1, s2, i1+<span class="number">1</span>, i2+<span class="number">1</span>, count+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> c2 = findLCSLengthRecursive(dp, s1, s2, i1, i2+<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">//count -&gt; ÂΩíÈõ∂</span></span><br><span class="line">        <span class="keyword">int</span> c3 = findLCSLengthRecursive(dp, s1, s2, i1+<span class="number">1</span>, i2, <span class="number">0</span>);</span><br><span class="line">        dp[i1][i2][count] = Math.max(c1, Math.max(c2, c3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i1][i2][count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="‚ú®1143-Longest-Common-Subsequence"><a href="#‚ú®1143-Longest-Common-Subsequence" class="headerlink" title="‚ú®1143. Longest Common Subsequence"></a><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">‚ú®1143. Longest Common Subsequence</a></h2><p>A <a href="https://en.wikipedia.org/wiki/Subsequence" target="_blank" rel="noopener">subsequence</a> is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;abdca&quot;</span><br><span class="line">       s2 &#x3D; &quot;cbda&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;bda&quot;.</span><br><span class="line"></span><br><span class="line">Input: s1 &#x3D; &quot;passport&quot;</span><br><span class="line">       s2 &#x3D; &quot;ppsspt&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest common subsequence is &quot;psspt&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-12"><a href="#Basic-Solution-12" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLCSLength</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findLCSLengthRecursive(s1, s2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLCSLengthRecursive</span><span class="params">(String s1, String s2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i1 == s1.length() || i2 == s2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s1.charAt(i1) == s2.charAt(i2))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + findLCSLengthRecursive(s1, s2, i1+<span class="number">1</span>, i2+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1 = findLCSLengthRecursive(s1, s2, i1, i2+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> c2 = findLCSLengthRecursive(s1, s2, i1+<span class="number">1</span>, i2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-19"><a href="#Top-down-Dynamic-Programming-with-Memoization-19" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLCSLength</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[s1.length()][s2.length()];</span><br><span class="line">    <span class="keyword">return</span> findLCSLengthRecursive(dp, s1, s2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLCSLengthRecursive</span><span class="params">(Integer[][] dp, String s1, String s2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i1 == s1.length() || i2 == s2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[i1][i2] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i1) == s2.charAt(i2))</span><br><span class="line">            dp[i1][i2] = <span class="number">1</span> + findLCSLengthRecursive(dp, s1, s2, i1 + <span class="number">1</span>, i2 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> c1 = findLCSLengthRecursive(dp, s1, s2, i1, i2 + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> c2 = findLCSLengthRecursive(dp, s1, s2, i1 + <span class="number">1</span>, i2);</span><br><span class="line">            dp[i1][i2] = Math.max(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i1][i2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minimum-Deletions-amp-Insertions-to-Transform-a-String-into-another"><a href="#Minimum-Deletions-amp-Insertions-to-Transform-a-String-into-another" class="headerlink" title="Minimum Deletions &amp; Insertions to Transform a String into another"></a>Minimum Deletions &amp; Insertions to Transform a String into another</h2><p>Given strings s1 and s2, we need to transform s1 into s2 by deleting and inserting characters. Write a function to calculate the count of the minimum number of deletion and insertion operations.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;abc&quot;</span><br><span class="line">       s2 &#x3D; &quot;fbc&quot;</span><br><span class="line">Output: 1 deletion and 1 insertion.</span><br><span class="line">Explanation: We need to delete &#123;&#39;a&#39;&#125; and insert &#123;&#39;f&#39;&#125; to s1 to transform it into s2.</span><br></pre></td></tr></table></figure>

<p>This problem can easily be converted to the <a href="https://www.educative.io/collection/page/5668639101419520/5633779737559040/5657535201673216/" target="_blank" rel="noopener">Longest Common Subsequence</a> (LCS). If we can find the LCS of the two input strings, we can easily find how many characters we need to insert and delete from s1. Here is how we can do this:</p>
<ol>
<li>Let‚Äôs assume <code>len1</code> is the length of s1 and <code>len2</code> is the length of s2.</li>
<li>Now let‚Äôs assume <code>c1</code> is the length of LCS of the two strings s1 and s2.</li>
<li>To transform s1 into s2, we need to delete everything from s1 which is not part of LCS, so minimum deletions we need to perform from s1 =&gt; <code>len1 - c1</code></li>
<li>Similarly, we need to insert everything in s1 which is present in s2 but not part of LCS, so minimum insertions we need to perform in s1 =&gt; <code>len2 - c1</code></li>
</ol>
<h3 id="üíé583-Delete-Operation-for-Two-Strings"><a href="#üíé583-Delete-Operation-for-Two-Strings" class="headerlink" title="üíé583. Delete Operation for Two Strings"></a><a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">üíé583. Delete Operation for Two Strings</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[word1.length()][word2.length()];</span><br><span class="line">    <span class="keyword">int</span> c = findMax(<span class="number">0</span>, <span class="number">0</span>, word1, word2, dp);</span><br><span class="line">    <span class="keyword">return</span> (word1.length() + word2.length() - <span class="number">2</span> * c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2, String s1, String s2, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i1 &gt;= s1.length() || i2 &gt;= s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[i1][i2] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i1) == s2.charAt(i2)) &#123;</span><br><span class="line">            dp[i1][i2] = <span class="number">1</span> + findMax(i1 + <span class="number">1</span>, i2 + <span class="number">1</span>, s1, s2, dp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> c1 = findMax(i1 + <span class="number">1</span>, i2, s1, s2, dp);</span><br><span class="line">            <span class="keyword">int</span> c2 = findMax(i1, i2 + <span class="number">1</span>, s1, s2, dp);</span><br><span class="line">            dp[i1][i2] = Math.max(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i1][i2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåï300-Longest-Increasing-Subsequence‚≠ê"><a href="#üåï300-Longest-Increasing-Subsequence‚≠ê" class="headerlink" title="üåï300. Longest Increasing Subsequence‚≠ê"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">üåï300. Longest Increasing Subsequence‚≠ê</a></h2><p>Given a number sequence, find the length of its Longest Increasing Subsequence (LIS). In an increasing subsequence, all the elements are in increasing order (from lowest to highest).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;4,2,3,6,10,1,12&#125;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LIS is &#123;2,3,6,10,12&#125;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-13"><a href="#Basic-Solution-13" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>We can process one number at a time, so we have two options at any step:</p>
<ol>
<li>If the current number is greater than the previous number that we included, we can increment our count and make a recursive call for the remaining array.</li>
<li>We can skip the current number to make a recursive call for the remaining array.</li>
</ol>
<p>The length of the longest increasing subsequence will be the maximum number returned by the two recurse calls from the above two options.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLISLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findLISLengthRecursive(nums, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLISLengthRecursive</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> previousIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(currentIndex == nums.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// include nums[currentIndex] if it is larger than the last included number</span></span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(previousIndex == -<span class="number">1</span> || nums[currentIndex] &gt; nums[previousIndex])</span><br><span class="line">        c1 = <span class="number">1</span> + findLISLengthRecursive(nums, currentIndex+<span class="number">1</span>, currentIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// excluding the number at currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> c2 = findLISLengthRecursive(nums, currentIndex+<span class="number">1</span>, previousIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-20"><a href="#Top-down-Dynamic-Programming-with-Memoization-20" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLISLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[nums.length][nums.length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findLISLengthRecursive(dp, nums, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLISLengthRecursive</span><span class="params">(Integer[][] dp, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> previousIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentIndex == nums.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[currentIndex][previousIndex + <span class="number">1</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// include nums[currentIndex] if it is larger than the last included number</span></span><br><span class="line">        <span class="keyword">int</span> c1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (previousIndex == -<span class="number">1</span> || nums[currentIndex] &gt; nums[previousIndex])</span><br><span class="line">            c1 = <span class="number">1</span> + findLISLengthRecursive(dp, nums, currentIndex+<span class="number">1</span>, currentIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c2 = findLISLengthRecursive(dp, nums, currentIndex+<span class="number">1</span>, previousIndex);</span><br><span class="line">        dp[currentIndex][previousIndex + <span class="number">1</span>] = Math.max(c1, c2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][previousIndex + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåïMaximum-Sum-Increasing-Subsequence"><a href="#üåïMaximum-Sum-Increasing-Subsequence" class="headerlink" title="üåïMaximum Sum Increasing Subsequence"></a>üåïMaximum Sum Increasing Subsequence</h2><p>Given a number sequence, find the increasing subsequence with the highest sum. Write a method that returns the highest sum.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;4,1,2,6,10,1,12&#125;</span><br><span class="line">Output: 32</span><br><span class="line">Explanation: The increaseing sequence is &#123;4,6,10,12&#125;. </span><br><span class="line">Please note the difference, as the LIS is &#123;1,2,6,10,12&#125; which has a sum of &#39;31&#39;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-14"><a href="#Basic-Solution-14" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>We can process one number at a time, so we have two options at any step:</p>
<ol>
<li>If the current number is greater than the previous number that we included, we include that number in a running sum and make a recursive call for the remaining array.</li>
<li>We can skip the current number to make a recursive call for the remaining array.</li>
</ol>
<p>The highest sum of any increasing subsequence would be the max value returned by the two recurse calls from the above two options.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMSIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findMSISRecursive(nums, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMSISRecursive</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> previousIndex, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(currentIndex == nums.length)</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// include nums[currentIndex] if it is larger than the last included number</span></span><br><span class="line">    <span class="keyword">int</span> s1 = sum;</span><br><span class="line">    <span class="keyword">if</span>(previousIndex == -<span class="number">1</span> || nums[currentIndex] &gt; nums[previousIndex])</span><br><span class="line">        s1 = findMSISRecursive(nums, currentIndex+<span class="number">1</span>, currentIndex, sum + nums[currentIndex]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// excluding the number at currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> s2 = findMSISRecursive(nums, currentIndex+<span class="number">1</span>, previousIndex, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-21"><a href="#Top-down-Dynamic-Programming-with-Memoization-21" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMSIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; dp = <span class="keyword">new</span> HashMap&lt;&gt;();  </span><br><span class="line">    <span class="keyword">return</span> findMSISRecursive(dp, nums, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMSISRecursive</span><span class="params">(Map&lt;String, Integer&gt; dp, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] nums, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> previousIndex, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentIndex == nums.length)</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    String subProblemKey = currentIndex + <span class="string">"-"</span> + previousIndex + <span class="string">"-"</span> + sum;</span><br><span class="line">    <span class="keyword">if</span> (!dp.containsKey(subProblemKey)) &#123;</span><br><span class="line">        <span class="comment">// include nums[currentIndex] if it is larger than the last included number</span></span><br><span class="line">        <span class="keyword">int</span> s1 = sum;</span><br><span class="line">        <span class="keyword">if</span>(previousIndex == -<span class="number">1</span> || nums[currentIndex] &gt; nums[previousIndex])</span><br><span class="line">            s1 = findMSISRecursive(dp, nums, currentIndex+<span class="number">1</span>, currentIndex, sum + nums[currentIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// excluding the number at currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> s2 = findMSISRecursive(dp, nums, currentIndex+<span class="number">1</span>, previousIndex, sum);</span><br><span class="line">        dp.put(subProblemKey, Math.max(s1, s2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp.get(subProblemKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="üåï‚ú®1092-Shortest-Common-Super-sequence"><a href="#üåï‚ú®1092-Shortest-Common-Super-sequence" class="headerlink" title="üåï‚ú®1092. Shortest Common Super-sequence"></a><a href="https://leetcode.com/problems/shortest-common-supersequence/" target="_blank" rel="noopener">üåï‚ú®1092. Shortest Common Super-sequence</a></h2><p>Given two sequences ‚Äòs1‚Äô and ‚Äòs2‚Äô, write a method to find the length of the shortest sequence which has ‚Äòs1‚Äô and ‚Äòs2‚Äô as subsequences.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: s1: &quot;abcf&quot; s2:&quot;bdcf&quot; </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The shortest common super-sequence (SCS) is &quot;abdcf&quot;. </span><br><span class="line"></span><br><span class="line">Input: s1: &quot;dynamic&quot; s2:&quot;programming&quot; </span><br><span class="line">Output: 15</span><br><span class="line">Explanation: The SCS is &quot;dynprogrammicng&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-15"><a href="#Basic-Solution-15" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>We can process both of the sequences one character at a time, so at any step we must choose between:</p>
<ol>
<li>If the sequences have a matching character, we can skip one character from both the sequences and make a recursive call for the remaining lengths to get SCS.</li>
<li>If the strings don‚Äôt match, we start two new recursive calls by skipping one character separately from each string. The minimum of these two recursive calls will have our answer.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSCSLength</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findSCSLengthRecursive(s1, s2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSCSLengthRecursive</span><span class="params">(String s1, String s2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if we have reached the end of a string, return the remaining length of the other string, </span></span><br><span class="line">    <span class="comment">// as in this case we have to take all of the remaining other string</span></span><br><span class="line">    <span class="keyword">if</span>(i1 == s1.length())</span><br><span class="line">        <span class="keyword">return</span> s2.length()-i2;</span><br><span class="line">    <span class="keyword">if</span>(i2 == s2.length())</span><br><span class="line">        <span class="keyword">return</span> s1.length()-i1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s1.charAt(i1) == s2.charAt(i2))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + findSCSLengthRecursive(s1, s2, i1+<span class="number">1</span>, i2+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length1 = <span class="number">1</span> + findSCSLengthRecursive(s1, s2, i1, i2+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> length2 = <span class="number">1</span> + findSCSLengthRecursive(s1, s2, i1+<span class="number">1</span>, i2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(length1, length2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-22"><a href="#Top-down-Dynamic-Programming-with-Memoization-22" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSCSLength</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[s1.length()][s2.length()];</span><br><span class="line">    <span class="keyword">return</span> findSCSLengthRecursive(dp, s1, s2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSCSLengthRecursive</span><span class="params">(Integer[][] dp, String s1, String s2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if we have reached the end of a string, return the remaining length of the other string, </span></span><br><span class="line">    <span class="comment">// as in this case we have to take all of the remaining other string</span></span><br><span class="line">    <span class="keyword">if</span>(i1 == s1.length())</span><br><span class="line">        <span class="keyword">return</span> s2.length()-i2;</span><br><span class="line">    <span class="keyword">if</span>(i2 == s2.length())</span><br><span class="line">        <span class="keyword">return</span> s1.length()-i1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[i1][i2] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(i1) == s2.charAt(i2))</span><br><span class="line">            dp[i1][i2] = <span class="number">1</span> + findSCSLengthRecursive(dp, s1, s2, i1+<span class="number">1</span>, i2+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> length1 = <span class="number">1</span> + findSCSLengthRecursive(dp, s1, s2, i1, i2+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> length2 = <span class="number">1</span> + findSCSLengthRecursive(dp, s1, s2, i1+<span class="number">1</span>, i2);</span><br><span class="line">            dp[i1][i2] = Math.min(length1, length2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i1][i2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/200/" rel="tag"># 200</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/17/Recursion/" rel="prev" title="Recursion">
      <i class="fa fa-chevron-left"></i> Recursion
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/18/Programming%20Interviews%20Exposed/" rel="next" title="Programming Interviews Exposed">
      Programming Interviews Exposed <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          ÊñáÁ´†ÁõÆÂΩï
        </li>
        <li class="sidebar-nav-overview">
          Á´ôÁÇπÊ¶ÇËßà
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsolved-932-Beautiful-Arrayüíé"><span class="nav-number">1.</span> <span class="nav-text">Unsolved 932. Beautiful Arrayüíé</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#120-Triangle"><span class="nav-number"></span> <span class="nav-text">120. Triangle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#474-Ones-and-Zeroes"><span class="nav-number"></span> <span class="nav-text">474. Ones and Zeroes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-Brute-Force-Time-Limit-Exceeded"><span class="nav-number">1.</span> <span class="nav-text">Solution1: Brute Force [Time Limit Exceeded]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-1"><span class="nav-number">2.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïUnsolved-1262-Greatest-Sum-Divisible-by-Three-Shopee"><span class="nav-number"></span> <span class="nav-text">üåïUnsolved 1262. Greatest Sum Divisible by Three(Shopee)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-2"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåï10-Regular-Expression-Matching‚≠ê"><span class="nav-number"></span> <span class="nav-text">üåï10. Regular Expression Matching‚≠ê</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#376-Wiggle-Subsequence‚û∞"><span class="nav-number"></span> <span class="nav-text">376. Wiggle Subsequence‚û∞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-3"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåï1359-Count-All-Valid-Pickup-and-Delivery-Options"><span class="nav-number"></span> <span class="nav-text">üåï1359. Count All Valid Pickup and Delivery Options</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-4"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dynamic-Programming"><span class="nav-number"></span> <span class="nav-text">Dynamic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïUnsolved-1335-Minimum-Difficulty-of-a-Job-Schedule‚≠ê"><span class="nav-number"></span> <span class="nav-text">üåïUnsolved 1335. Minimum Difficulty of a Job Schedule‚≠ê</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-5"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2"><span class="nav-number">2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïUnsolved-72-Edit-Distance‚ú®"><span class="nav-number"></span> <span class="nav-text">üåïUnsolved 72. Edit Distance‚ú®</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-6"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåï53-Maximum-Subarray‚ú®"><span class="nav-number"></span> <span class="nav-text">üåï53. Maximum Subarray‚ú®</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-7"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-1"><span class="nav-number">2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåï91-Decode-Ways‚ú®üé∂"><span class="nav-number"></span> <span class="nav-text">üåï91. Decode Ways‚ú®üé∂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-8"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-2"><span class="nav-number">2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#221-Maximal-Square‚≠ê"><span class="nav-number"></span> <span class="nav-text">221. Maximal Square‚≠ê</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution0"><span class="nav-number">1.</span> <span class="nav-text">Solution0:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-9"><span class="nav-number">2.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1155-Number-of-Dice-Rolls-With-Target-Sum‚≠ê"><span class="nav-number"></span> <span class="nav-text">1155. Number of Dice Rolls With Target Sum‚≠ê</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-10"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-3"><span class="nav-number">2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#139-Word-Break‚≠êüé∂"><span class="nav-number"></span> <span class="nav-text">139. Word Break‚≠êüé∂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-4"><span class="nav-number">1.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-140-Word-Break-II‚≠ê"><span class="nav-number"></span> <span class="nav-text">Unsolved 140. Word Break II‚≠ê</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-11"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-5"><span class="nav-number">2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-472-Concatenated-Words‚≠ê"><span class="nav-number"></span> <span class="nav-text">Unsolved 472. Concatenated Words‚≠ê</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-Minimum-Path-Sum‚≠ê"><span class="nav-number"></span> <span class="nav-text">64. Minimum Path Sum‚≠ê</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-12"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock‚≠ê"><span class="nav-number"></span> <span class="nav-text">121. Best Time to Buy and Sell Stock‚≠ê</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Most-consistent-ways-of-dealing-with-the-series-of-stock-problems"><span class="nav-number">1.</span> <span class="nav-text">Most consistent ways of dealing with the series of stock problems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution0-1"><span class="nav-number">2.</span> <span class="nav-text">Solution0:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-13"><span class="nav-number">3.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II‚ú®"><span class="nav-number"></span> <span class="nav-text">122. Best Time to Buy and Sell Stock II‚ú®</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-14"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-123-Best-Time-to-Buy-and-Sell-Stock-III‚ú®"><span class="nav-number"></span> <span class="nav-text">Unsolved 123. Best Time to Buy and Sell Stock III‚ú®</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-188-Best-Time-to-Buy-and-Sell-Stock-IV‚ú®"><span class="nav-number"></span> <span class="nav-text">Unsolved 188. Best Time to Buy and Sell Stock IV‚ú®</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-15"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-6"><span class="nav-number">2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution3"><span class="nav-number">3.</span> <span class="nav-text">Solution3:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><span class="nav-number"></span> <span class="nav-text">Unsolved 309. Best Time to Buy and Sell Stock with Cooldown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Feeüåï"><span class="nav-number"></span> <span class="nav-text">Unsolved 714. Best Time to Buy and Sell Stock with Transaction Feeüåï</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-dp"><span class="nav-number">1.</span> <span class="nav-text">Top down dp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#152-Maximum-Product-Subarray"><span class="nav-number"></span> <span class="nav-text">152. Maximum Product Subarray</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-16"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Max-Subset-Sum-No-Adjacent-AE-‚ú®"><span class="nav-number"></span> <span class="nav-text">Max Subset Sum No Adjacent(AE)‚ú®</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-17"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-7"><span class="nav-number">2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198-House-Robber‚ú®üé∂"><span class="nav-number">3.</span> <span class="nav-text">198.House Robber‚ú®üé∂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-18"><span class="nav-number">4.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-8"><span class="nav-number">5.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#213-House-Robber-II"><span class="nav-number">6.</span> <span class="nav-text">213.House Robber II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-19"><span class="nav-number">7.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number-Of-Ways-To-Make-Change-AE"><span class="nav-number"></span> <span class="nav-text">Number Of Ways To Make Change(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-20"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#518-Coin-Change-2"><span class="nav-number">2.</span> <span class="nav-text">518. Coin Change 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-21"><span class="nav-number">3.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-9"><span class="nav-number">4.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Levenshtein-Distance-AE-‚≠ê"><span class="nav-number"></span> <span class="nav-text">Levenshtein Distance(AE)‚≠ê</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-22"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-10"><span class="nav-number">2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsolved-583-Delete-Operation-for-Two-Strings"><span class="nav-number">3.</span> <span class="nav-text">Unsolved 583. Delete Operation for Two Strings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-23"><span class="nav-number">4.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-Max-Sum-Increasing-Subsequence-AE"><span class="nav-number"></span> <span class="nav-text">Unsolved Max Sum Increasing Subsequence(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-24"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-Longest-Common-Subsequence-AE-‚ú®"><span class="nav-number"></span> <span class="nav-text">Unsolved Longest Common Subsequence(AE)‚ú®</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-25"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1143-Longest-Common-Subsequence‚ú®"><span class="nav-number">2.</span> <span class="nav-text">1143. Longest Common Subsequence‚ú®</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-26"><span class="nav-number">3.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Knapsack-Problem-AE"><span class="nav-number"></span> <span class="nav-text">Knapsack Problem(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-27"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Disk-Stacking-AE"><span class="nav-number"></span> <span class="nav-text">Disk Stacking(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-28"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#‚úÖNumber-of-Pathsüíú"><span class="nav-number"></span> <span class="nav-text">‚úÖNumber of Pathsüíú</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#62-Unique-Paths"><span class="nav-number">1.</span> <span class="nav-text">62.Unique Paths</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-29"><span class="nav-number">2.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-Unique-Paths-II"><span class="nav-number">3.</span> <span class="nav-text">63. Unique Paths II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sulution1"><span class="nav-number">4.</span> <span class="nav-text">Sulution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UnsolvedSolution2"><span class="nav-number">5.</span> <span class="nav-text">UnsolvedSolution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70-Climbing-Stairs‚ú®"><span class="nav-number"></span> <span class="nav-text">70. Climbing Stairs‚ú®</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-30"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-11"><span class="nav-number">2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-1659-Maximize-Grid-Happiness"><span class="nav-number"></span> <span class="nav-text">Unsolved 1659. Maximize Grid Happiness</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1621-Number-of-Sets-of-K-Non-Overlapping-Line-SegmentsüéÉ"><span class="nav-number"></span> <span class="nav-text">1621. Number of Sets of K Non-Overlapping Line SegmentsüéÉ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-31"><span class="nav-number"></span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåï343-Integer-Breaküé∂"><span class="nav-number"></span> <span class="nav-text">üåï343. Integer Breaküé∂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-32"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#516-Unsolved-Longest-Palindromic-Subsequence"><span class="nav-number"></span> <span class="nav-text">516. Unsolved Longest Palindromic Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-33"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#486-Predict-the-Winner"><span class="nav-number"></span> <span class="nav-text">486. Predict the Winner</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-34"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-787-Cheapest-Flights-Within-K-StopsüéÇ"><span class="nav-number"></span> <span class="nav-text">Unsolved 787. Cheapest Flights Within K StopsüéÇ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-1373-Maximum-Sum-BST-in-Binary-TreeüéÇ‚ú®"><span class="nav-number"></span> <span class="nav-text">Unsolved 1373. Maximum Sum BST in Binary TreeüéÇ‚ú®</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-44-Wildcard-MatchingüéÇ‚ú®üé∂"><span class="nav-number"></span> <span class="nav-text">Unsolved 44. Wildcard MatchingüéÇ‚ú®üé∂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-35"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-12"><span class="nav-number">2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#256-Paint-House"><span class="nav-number"></span> <span class="nav-text">256. Paint House</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-36"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-464-Can-I-WinüéÇ"><span class="nav-number"></span> <span class="nav-text">Unsolved 464. Can I WinüéÇ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-37"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1664-Ways-to-Make-a-Fair-Array"><span class="nav-number"></span> <span class="nav-text">1664. Ways to Make a Fair Array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-38"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïUnsolved-410-Split-Array-Largest-SumüéÇ‚ú®üé∂"><span class="nav-number"></span> <span class="nav-text">üåïUnsolved 410. Split Array Largest SumüéÇ‚ú®üé∂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-39"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Grokking-Dynamic-Programming-Patterns-for-Coding-Interviews"><span class="nav-number"></span> <span class="nav-text">Grokking Dynamic Programming Patterns for Coding Interviews</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number"></span> <span class="nav-text">Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Nth-Fib"><span class="nav-number"></span> <span class="nav-text">Nth Fib</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-with-Memoization"><span class="nav-number">1.</span> <span class="nav-text">Top-down with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-with-Tabulation"><span class="nav-number">2.</span> <span class="nav-text">Bottom-up with Tabulation</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pattern-1-0-1-Knapsack"><span class="nav-number"></span> <span class="nav-text">Pattern 1: 0&#x2F;1 Knapsack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#üåï0-1-Knapsack‚ú®"><span class="nav-number"></span> <span class="nav-text">üåï0&#x2F;1 Knapsack‚ú®</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-solution"><span class="nav-number">1.</span> <span class="nav-text">brute-force solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïEqual-Subset-Sum-Partition‚ú®"><span class="nav-number"></span> <span class="nav-text">üåïEqual Subset Sum Partition‚ú®</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-algorithm"><span class="nav-number">1.</span> <span class="nav-text">brute-force algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-1"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-1"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#416-Partition-Equal-Subset-Sum‚ú®"><span class="nav-number">4.</span> <span class="nav-text">416. Partition Equal Subset Sum‚ú®</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution0-2"><span class="nav-number">5.</span> <span class="nav-text">Solution0:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-40"><span class="nav-number">6.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#üåïUnsolved-698-Partition-to-K-Equal-Sum-Subsets"><span class="nav-number">7.</span> <span class="nav-text">üåïUnsolved 698. Partition to K Equal Sum Subsets</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Subset-Sum"><span class="nav-number"></span> <span class="nav-text">Subset Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-algorithm-1"><span class="nav-number">1.</span> <span class="nav-text">brute-force algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-2"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-2"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïMinimum-Subset-Sum-Differenceüé∂"><span class="nav-number"></span> <span class="nav-text">üåïMinimum Subset Sum Differenceüé∂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-algorithm-2"><span class="nav-number">1.</span> <span class="nav-text">brute-force algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-3"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-3"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1049-Last-Stone-Weight-II"><span class="nav-number">4.</span> <span class="nav-text">1049. Last Stone Weight II</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïCount-of-Subset-Sum"><span class="nav-number"></span> <span class="nav-text">üåïCount of Subset Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-algorithm-3"><span class="nav-number">1.</span> <span class="nav-text">brute-force algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-4"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-4"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïTarget-Sum"><span class="nav-number"></span> <span class="nav-text">üåïTarget Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#üåïUnsolved-494-Target-Sum‚ú®"><span class="nav-number">1.</span> <span class="nav-text">üåïUnsolved 494. Target Sum‚ú®</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-41"><span class="nav-number">2.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsolved-Solution2"><span class="nav-number">3.</span> <span class="nav-text">Unsolved Solution2:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pattern-2-Unbounded-Knapsack"><span class="nav-number"></span> <span class="nav-text">Pattern 2: Unbounded Knapsack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïUnbounded-Knapsack"><span class="nav-number"></span> <span class="nav-text">üåïUnbounded Knapsack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force"><span class="nav-number">1.</span> <span class="nav-text">brute-force</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-5"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-5"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rod-Cutting"><span class="nav-number"></span> <span class="nav-text">Rod Cutting</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-solution-1"><span class="nav-number">1.</span> <span class="nav-text">brute-force solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-6"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-6"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#518-Coin-Change‚ú®-ways-to-change"><span class="nav-number"></span> <span class="nav-text">518. Coin Change‚ú® ways to change</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-7"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-7"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïMinimum-Coin-Change‚ú®üé∂"><span class="nav-number"></span> <span class="nav-text">üåïMinimum Coin Change‚ú®üé∂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-1"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-8"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-8"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Min-Number-Of-Coins-For-Change-AE-‚ú®"><span class="nav-number">4.</span> <span class="nav-text">Min Number Of Coins For Change(AE)‚ú®</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-42"><span class="nav-number">5.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#322-Coin-Change‚ú®"><span class="nav-number">6.</span> <span class="nav-text">322. Coin Change‚ú®</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-43"><span class="nav-number">7.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-13"><span class="nav-number">8.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïMaximum-Ribbon-Cut"><span class="nav-number"></span> <span class="nav-text">üåïMaximum Ribbon Cut</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-2"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-9"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-9"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#377-Combination-Sum-IV"><span class="nav-number"></span> <span class="nav-text">377. Combination Sum IV</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution"><span class="nav-number">1.</span> <span class="nav-text">Solution:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pattern-3-Fibonacci-Numbers"><span class="nav-number"></span> <span class="nav-text">Pattern 3: Fibonacci Numbers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Fibonacci-Numbers"><span class="nav-number"></span> <span class="nav-text">Fibonacci Numbers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-optimization"><span class="nav-number">1.</span> <span class="nav-text">Memory optimization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Staircase"><span class="nav-number"></span> <span class="nav-text">Staircase</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-3"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-10"><span class="nav-number"></span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-10"><span class="nav-number">1.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-optimization-1"><span class="nav-number">2.</span> <span class="nav-text">Memory optimization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number-factors"><span class="nav-number"></span> <span class="nav-text">Number factors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-4"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-11"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-11"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fibonacci-number-pattern"><span class="nav-number">4.</span> <span class="nav-text">Fibonacci number pattern</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïMinimum-jumps-to-reach-the-end-Jump-game‚≠ê"><span class="nav-number"></span> <span class="nav-text">üåïMinimum jumps to reach the end || Jump game‚≠ê</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-5"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-12"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-12"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fibonacci-number-pattern-1"><span class="nav-number">4.</span> <span class="nav-text">Fibonacci number pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Min-Number-Of-Jumps-AE-‚≠ê"><span class="nav-number">5.</span> <span class="nav-text">Min Number Of Jumps(AE)‚≠ê</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-44"><span class="nav-number">6.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-14"><span class="nav-number">7.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-Jump-Game‚ú®"><span class="nav-number">8.</span> <span class="nav-text">55.Jump Game‚ú®</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-45"><span class="nav-number">9.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Approach-1-Backtracking"><span class="nav-number">10.</span> <span class="nav-text">Approach 1: Backtracking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsolved-45-Jump-Game-II‚ú®"><span class="nav-number">11.</span> <span class="nav-text">Unsolved 45. Jump Game II‚ú®</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-46"><span class="nav-number">12.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-15"><span class="nav-number">13.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1306-Jump-Game-III"><span class="nav-number">14.</span> <span class="nav-text">1306. Jump Game III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-47"><span class="nav-number">15.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-16"><span class="nav-number">16.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Minimum-jumps-with-fee"><span class="nav-number"></span> <span class="nav-text">Minimum jumps with fee</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-6"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-13"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-13"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-thief"><span class="nav-number"></span> <span class="nav-text">House thief</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-7"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-14"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-14"><span class="nav-number">3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-optimization-2"><span class="nav-number">4.</span> <span class="nav-text">Memory optimization</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pattern-4-Palindromic-Subsequence"><span class="nav-number"></span> <span class="nav-text">Pattern 4: Palindromic Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#‚ú®516-Longest-Palindromic-Subsequence"><span class="nav-number"></span> <span class="nav-text">‚ú®516. Longest Palindromic Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-8"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-15"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Longest-Palindromic-Substring"><span class="nav-number"></span> <span class="nav-text">Longest Palindromic Substring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-9"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-16"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïUnsolved-Count-of-Palindromic-Substrings"><span class="nav-number"></span> <span class="nav-text">üåïUnsolved Count of Palindromic Substrings</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#‚≠êMinimum-Deletions-in-a-String-to-make-it-a-Palindrome"><span class="nav-number"></span> <span class="nav-text">‚≠êMinimum Deletions in a String to make it a Palindrome</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Similar-problems"><span class="nav-number">1.</span> <span class="nav-text">Similar problems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1312-Minimum-insertions-in-a-string-to-make-it-a-palindrome‚ú®"><span class="nav-number">2.</span> <span class="nav-text">1. 1312 Minimum insertions in a string to make it a palindrome‚ú®</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Find-if-a-string-is-K-Palindromic"><span class="nav-number">3.</span> <span class="nav-text">2. Find if a string is K-Palindromic</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåï‚ú®Unsolved-132-Palindromic-Partitioning"><span class="nav-number"></span> <span class="nav-text">üåï‚ú®Unsolved 132. Palindromic Partitioning</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-10"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-17"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåï131-Palindrome-Partitioning‚ú®"><span class="nav-number"></span> <span class="nav-text">üåï131. Palindrome Partitioning‚ú®</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-48"><span class="nav-number">1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-17"><span class="nav-number">2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#267-Palindrome-Permutation-II"><span class="nav-number">3.</span> <span class="nav-text">267. Palindrome Permutation II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-49"><span class="nav-number">4.</span> <span class="nav-text">Solution1:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pattern-5-Longest-Common-Substring"><span class="nav-number"></span> <span class="nav-text">Pattern 5: Longest Common Substring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïLongest-Common-Substring"><span class="nav-number"></span> <span class="nav-text">üåïLongest Common Substring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-11"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-18"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#‚ú®1143-Longest-Common-Subsequence"><span class="nav-number"></span> <span class="nav-text">‚ú®1143. Longest Common Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-12"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-19"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Minimum-Deletions-amp-Insertions-to-Transform-a-String-into-another"><span class="nav-number"></span> <span class="nav-text">Minimum Deletions &amp; Insertions to Transform a String into another</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#üíé583-Delete-Operation-for-Two-Strings"><span class="nav-number">1.</span> <span class="nav-text">üíé583. Delete Operation for Two Strings</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåï300-Longest-Increasing-Subsequence‚≠ê"><span class="nav-number"></span> <span class="nav-text">üåï300. Longest Increasing Subsequence‚≠ê</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-13"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-20"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåïMaximum-Sum-Increasing-Subsequence"><span class="nav-number"></span> <span class="nav-text">üåïMaximum Sum Increasing Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-14"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-21"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#üåï‚ú®1092-Shortest-Common-Super-sequence"><span class="nav-number"></span> <span class="nav-text">üåï‚ú®1092. Shortest Common Super-sequence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-15"><span class="nav-number">1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-22"><span class="nav-number">2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dejavu"
      src="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
  <p class="site-author-name" itemprop="name">Dejavu</p>
  <div class="site-description" itemprop="description">Stay gold</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">87</span>
          <span class="site-state-item-name">Êó•Âøó</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">ÂàÜÁ±ª</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">Ê†áÁ≠æ</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Dejavu-19" title="GitHub ‚Üí https:&#x2F;&#x2F;github.com&#x2F;Dejavu-19" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/liu.kunling19@gmail.com" title="E-Mail ‚Üí liu.kunling19@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 ‚Äì 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dejavu</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false});</script></body>
</html>
