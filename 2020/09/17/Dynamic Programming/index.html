<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dejavi-19.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Pattern : 0&#x2F;1 Knapsack (Dynamic Programming)0&#x2F;1 Knapsack (medium)brute-force solution ,recursion12345678910111213141516171819202122232425&#x2F;&#x2F;Time O(2^n)&#x2F;&#x2F;Space O(n) call stackpublic int solveKnapsack(in">
<meta property="og:type" content="article">
<meta property="og:title" content="Dynamic Programming">
<meta property="og:url" content="https://dejavi-19.github.io/2020/09/17/Dynamic%20Programming/index.html">
<meta property="og:site_name" content="Dejavu&#39;s Notebook">
<meta property="og:description" content="Pattern : 0&#x2F;1 Knapsack (Dynamic Programming)0&#x2F;1 Knapsack (medium)brute-force solution ,recursion12345678910111213141516171819202122232425&#x2F;&#x2F;Time O(2^n)&#x2F;&#x2F;Space O(n) call stackpublic int solveKnapsack(in">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/01/16/untitled.png">
<meta property="og:image" content="https://zxi.mytechroad.com/blog/wp-content/uploads/2020/01/56F9A2C8-3F83-4C84-880B-F7551A06029D-1024x580.jpeg">
<meta property="og:image" content="https://assets.leetcode.com/users/leetcode/image_1573111823.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/JiawenQi98/PrampPractice/master/Number%20of%20Paths/example.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png">
<meta property="article:published_time" content="2020-09-17T04:16:45.004Z">
<meta property="article:modified_time" content="2021-03-03T05:22:46.155Z">
<meta property="article:author" content="Dejavu">
<meta property="article:tag" content="200">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode.com/uploads/2020/01/16/untitled.png">

<link rel="canonical" href="https://dejavi-19.github.io/2020/09/17/Dynamic%20Programming/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Dynamic Programming | Dejavu's Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/Dejavu-19" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dejavu's Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Alea iacta est</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首&emsp;&emsp;页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于博主</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标&emsp;&emsp;签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分&emsp;&emsp;类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归&emsp;&emsp;档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/17/Dynamic%20Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dynamic Programming
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 13:16:45" itemprop="dateCreated datePublished" datetime="2020-09-17T13:16:45+09:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 14:22:46" itemprop="dateModified" datetime="2021-03-03T14:22:46+09:00">2021-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Pattern-0-1-Knapsack-Dynamic-Programming"><a href="#Pattern-0-1-Knapsack-Dynamic-Programming" class="headerlink" title="Pattern : 0/1 Knapsack (Dynamic Programming)"></a>Pattern : 0/1 Knapsack (Dynamic Programming)</h1><h2 id="0-1-Knapsack-medium"><a href="#0-1-Knapsack-medium" class="headerlink" title="0/1 Knapsack (medium)"></a>0/1 Knapsack (medium)</h2><h3 id="brute-force-solution-recursion"><a href="#brute-force-solution-recursion" class="headerlink" title="brute-force solution ,recursion"></a>brute-force solution ,recursion</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n)</span></span><br><span class="line"><span class="comment">//Space O(n) call stack</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Write your code here</span></span><br><span class="line">    <span class="keyword">return</span> findProfit(<span class="number">0</span>, profits, weights, capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findProfit</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span>(capacity &lt;= <span class="number">0</span> || idx &gt;= profits.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> profitTakeCur = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// recursive call after choosing the element at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the weight of the element at currentIndex exceeds the capacity, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weights[idx] &lt;= capacity) &#123;</span><br><span class="line">        profitTakeCur = profits[idx] + findProfit(idx + <span class="number">1</span>, profits, weights, capacity - weights[idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recursive call after excluding the element at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> profitSkipCur = findProfit(idx + <span class="number">1</span>, profits, weights, capacity);</span><br><span class="line">    <span class="keyword">return</span> Math.max(profitTakeCur, profitSkipCur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization"><a href="#Top-down-Dynamic-Programming-with-Memoization" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[profits.length][capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(dp, profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(Integer[][] dp, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] profits, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] weights, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> capacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have already solved a similar problem, return the result from memory</span></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex][capacity] != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[currentIndex][capacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after choosing the element at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the weight of the element at currentIndex exceeds the capacity, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( weights[currentIndex] &lt;= capacity )</span><br><span class="line">        profit1 = profits[currentIndex] + knapsackRecursive(dp, profits, weights,</span><br><span class="line">                                                            capacity - weights[currentIndex], currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the element at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> profit2 = knapsackRecursive(dp, profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    dp[currentIndex][capacity] = Math.max(profit1, profit2);</span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since our memoization array <code>dp[profits.length][capacity+1]</code> stores the results for all subproblems, we can conclude that we will not have more than N<em>C</em>N<em>∗</em>C* subproblems (where ‘N’ is the number of items and ‘C’ is the knapsack capacity). This means that our time complexity will be O(N<em>C)*O</em>(<em>N</em>∗<em>C</em>).</p>
<p>The above algorithm will use O(N<em>C)*O</em>(<em>N</em>∗<em>C</em>) space for the memoization array. Other than that, we will use O(N)<em>O</em>(<em>N</em>) space for the recursion call-stack. So the total space complexity will be O(N<em>C + N)*O</em>(<em>N</em>∗<em>C</em>+<em>N</em>), which is asymptotically equivalent to O(N<em>C).*O</em>(<em>N</em>∗<em>C</em>).</p>
<h3 id="Bottom-up-Dynamic-Programming"><a href="#Bottom-up-Dynamic-Programming" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// basic checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = profits.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the capacity=0 columns, with '0' capacity we have '0' profit</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have only one weight, we will take it if it is not more than the capacity</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(weights[<span class="number">0</span>] &lt;= c)</span><br><span class="line">            dp[<span class="number">0</span>][c] = profits[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all sub-arrays for all the capacities</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit1= <span class="number">0</span>, profit2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// include the item, if it is not more than the capacity</span></span><br><span class="line">            <span class="keyword">if</span>(weights[i] &lt;= c)</span><br><span class="line">                profit1 = profits[i] + dp[i-<span class="number">1</span>][c-weights[i]];</span><br><span class="line">            <span class="comment">// exclude the item</span></span><br><span class="line">            profit2 = dp[i-<span class="number">1</span>][c];</span><br><span class="line">            <span class="comment">// take maximum</span></span><br><span class="line">            dp[i][c] = Math.max(profit1, profit2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maximum profit will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Equal-Subset-Sum-Partition-medium-✨"><a href="#Equal-Subset-Sum-Partition-medium-✨" class="headerlink" title="Equal Subset Sum Partition (medium)✨"></a>Equal Subset Sum Partition (medium)✨</h2><h3 id="brute-force-solution"><a href="#brute-force-solution" class="headerlink" title="brute-force solution"></a>brute-force solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 'sum' is a an odd number, we can't have two subsets with equal sum</span></span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(num, sum/<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPartitionRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after choosing the number at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">if</span>( num[currentIndex] &lt;= sum ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(canPartitionRecursive(num, sum - num[currentIndex], currentIndex + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">    <span class="keyword">return</span> canPartitionRecursive(num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-1"><a href="#Top-down-Dynamic-Programming-with-Memoization-1" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><ol>
<li>The algorithm has the time and space complexity of O(N<em>S)*O</em>(<em>N</em>∗<em>S</em>), where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 'sum' is a an odd number, we can't have two subsets with equal sum</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Boolean[][] dp = <span class="keyword">new</span> Boolean[num.length][sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(dp, num, sum / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPartitionRecursive</span><span class="params">(Boolean[][] dp, <span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have not already processed a similar problem</span></span><br><span class="line">    <span class="keyword">if</span> (dp[currentIndex][sum] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// recursive call after choosing the number at the currentIndex</span></span><br><span class="line">        <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">        <span class="keyword">if</span> (num[currentIndex] &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canPartitionRecursive(dp, num, sum - num[currentIndex], currentIndex + <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[currentIndex][sum] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">        dp[currentIndex][sum] = canPartitionRecursive(dp, num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-1"><a href="#Bottom-up-Dynamic-Programming-1" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><ol>
<li>The above solution the has time and space complexity of O(N<em>S)*O</em>(<em>N</em>∗<em>S</em>), where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="comment">// find the total sum</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 'sum' is a an odd number, we can't have two subsets with same total</span></span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we are trying to find a subset of given numbers that has a total sum of ‘sum/2’.</span></span><br><span class="line">    sum /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we can always for '0' sum with an empty set</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to its value</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            <span class="comment">// if we can get the sum 's' without the number at index 'i'</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][s]) &#123;</span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123; <span class="comment">// else if we can find a subset to get the remaining sum</span></span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="416-Partition-Equal-Subset-Sum✨"><a href="#416-Partition-Equal-Subset-Sum✨" class="headerlink" title="416. Partition Equal Subset Sum✨"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. Partition Equal Subset Sum✨</a></h3><h3 id="Solution0"><a href="#Solution0" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute Force</li>
<li>Time exceed</li>
<li>Time Complexity : \mathcal{O}(2^{n})O(2<em>n</em>), where n<em>n</em> is equal to number of array elements. The recursive solution takes the form of a binary tree where there are 2 possibilities for every array element and the maximum depth of the tree could be n<em>n</em>. The time complexity is exponential, hence this approach is exhaustive and results in <em>Time Limit Exceeded (TLE)</em>.</li>
<li>Space Complexity: \mathcal{O}(N)O(<em>N</em>) This space will be used to store the recursion stack. We can’t have more than n<em>n</em> recursive calls on the call stack at any time.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(2^n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// find sum of all array elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        totalSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if totalSum is odd,it cannot be partitioned into equal sum subset</span></span><br><span class="line">    <span class="keyword">if</span> (totalSum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> subSetSum = totalSum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, n - <span class="number">1</span>, subSetSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> subSetSum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base Cases</span></span><br><span class="line">    <span class="keyword">if</span> (subSetSum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || subSetSum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, n - <span class="number">1</span>, subSetSum - nums[n - <span class="number">1</span>]) || dfs(nums, n - <span class="number">1</span>, subSetSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time Complexity : \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>).<ul>
<li>In the worst case where there is no overlapping calculation, the maximum number of entries in the <code>memo</code> would be m \cdot n<em>m</em>⋅<em>n</em>. For each entry, overall we could consider that it takes constant time, <em>i.e.</em> each invocation of <code>dfs()</code> at most emits one entry in the <code>memo</code>.</li>
<li>The overall computation is proportional to the number of entries in <code>memo</code>. Hence, the overall time complexity is \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>).</li>
</ul>
</li>
<li>Space Complexity: \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>). We are using a 2 dimensional array \text{memo}memo of size (m \cdot n)(<em>m</em>⋅<em>n</em>) and \mathcal{O}(n)O(<em>n</em>) space to store the recursive call stack. This gives us the space complexity as \mathcal{O}(n)O(<em>n</em>) + \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>) = \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// find sum of all array elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        totalSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if totalSum is odd, it cannot be partitioned into equal sum subset</span></span><br><span class="line">    <span class="keyword">if</span> (totalSum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> subSetSum = totalSum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    Boolean[][] memo = <span class="keyword">new</span> Boolean[n + <span class="number">1</span>][subSetSum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, n - <span class="number">1</span>, subSetSum, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, <span class="keyword">int</span> subSetSum, Boolean[][] memo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base Cases</span></span><br><span class="line">    <span class="keyword">if</span> (subSetSum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span> || subSetSum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// check if subSetSum for given n is already computed and stored in memo</span></span><br><span class="line">    <span class="keyword">if</span> (memo[idx][subSetSum] != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[n][subSetSum];</span><br><span class="line">    <span class="keyword">boolean</span> result = dfs(nums, idx - <span class="number">1</span>, subSetSum - nums[idx - <span class="number">1</span>], memo) ||</span><br><span class="line">        dfs(nums, idx - <span class="number">1</span>, subSetSum, memo);</span><br><span class="line">    <span class="comment">// store the result in memo</span></span><br><span class="line">    memo[idx][subSetSum] = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Subset-Sum-medium"><a href="#Subset-Sum-medium" class="headerlink" title="Subset Sum (medium)"></a>Subset Sum (medium)</h2><h3 id="brute-force-algorithm"><a href="#brute-force-algorithm" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each number &#39;i&#39; </span><br><span class="line">  create a new set which INCLUDES number &#39;i&#39; if it does not exceed &#39;S&#39;, and recursively </span><br><span class="line">     process the remaining numbers</span><br><span class="line">  create a new set WITHOUT number &#39;i&#39;, and recursively process the remaining numbers </span><br><span class="line">return true if any of the above two sets has a sum equal to &#39;S&#39;, otherwise return false</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> Write - Your - Code</span></span><br><span class="line">    Boolean[][] dp = <span class="keyword">new</span> Boolean[num.length][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> partition(<span class="number">0</span>, num, sum, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, Boolean[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num.length == <span class="number">0</span> || idx &gt;= num.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][sum] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[idx] &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (partition(idx + <span class="number">1</span>, num, sum - num[idx], dp)) &#123;</span><br><span class="line">                dp[idx][sum] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx][sum] = partition(idx + <span class="number">1</span>, num, sum, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Bottom-up-Dynamic-Programming-2"><a href="#Bottom-up-Dynamic-Programming-2" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><ol>
<li>The above solution has the time and space complexity of O(N<em>S)*O</em>(<em>N</em>∗<em>S</em>), where ‘N’ represents total numbers and ‘S’ is the required sum.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we can always form '0' sum with an empty set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is</span></span><br><span class="line">    <span class="comment">// equal to its value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            <span class="comment">// if we can get the sum 's' without the number at index 'i'</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][s]) &#123;</span><br><span class="line">                dp[i][s] = dp[i - <span class="number">1</span>][s];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                <span class="comment">// else include the number and see if we can find a subset to get the remaining</span></span><br><span class="line">                <span class="comment">// sum</span></span><br><span class="line">                dp[i][s] = dp[i - <span class="number">1</span>][s - num[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[num.length - <span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minimum-Subset-Sum-Difference-hard"><a href="#Minimum-Subset-Sum-Difference-hard" class="headerlink" title="Minimum Subset Sum Difference (hard)"></a>Minimum Subset Sum Difference (hard)</h2><p>brute-force solution</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n)</span></span><br><span class="line"><span class="comment">//Space O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(num, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">canPartitionRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> sum1, <span class="keyword">int</span> sum2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (currentIndex == num.length)</span><br><span class="line">        <span class="keyword">return</span> Math.abs(sum1 - sum2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after including the number at the currentIndex in the first set</span></span><br><span class="line">    <span class="keyword">int</span> diff1 = canPartitionRecursive(num, currentIndex+<span class="number">1</span>, sum1+num[currentIndex], sum2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after including the number at the currentIndex in the second set</span></span><br><span class="line">    <span class="keyword">int</span> diff2 = canPartitionRecursive(num, currentIndex+<span class="number">1</span>, sum1, sum2+num[currentIndex]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(diff1, diff2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-3"><a href="#Bottom-up-Dynamic-Programming-3" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><ol>
<li>The above solution has the time and space complexity of O(N<em>S)*O</em>(<em>N</em>∗<em>S</em>), where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum/<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we can always form '0' sum with an empty set</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to that number</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum/<span class="number">2</span> ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum/<span class="number">2</span>; s++) &#123;</span><br><span class="line">            <span class="comment">// if we can get the sum 's' without the number at index 'i'</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][s]) &#123;</span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                <span class="comment">// else include the number and see if we can find a subset to get the remaining sum</span></span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Find the largest index in the last row which is true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sum / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n-<span class="number">1</span>][i] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            sum1 = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum2 = sum - sum1;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(sum2-sum1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-1-Count-of-Subset-Sum-hard"><a href="#Challenge-1-Count-of-Subset-Sum-hard" class="headerlink" title="Challenge 1 Count of Subset Sum (hard)"></a>Challenge 1 Count of Subset Sum (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 1, 2, 3&#125;, S&#x3D;4</span><br><span class="line">Output: 3</span><br><span class="line">The given set has &#39;3&#39; subsets whose sum is &#39;4&#39;: &#123;1, 1, 2&#125;, &#123;1, 3&#125;, &#123;1, 3&#125;</span><br><span class="line">Note that we have two similar sets &#123;1, 3&#125;, because we have two &#39;1&#39; in our input.</span><br></pre></td></tr></table></figure>

<p>brute-force algorithm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each number &#39;i&#39; </span><br><span class="line">  create a new set which includes number &#39;i&#39; if it does not exceed &#39;S&#39;, and recursively   </span><br><span class="line">      process the remaining numbers and sum</span><br><span class="line">  create a new set without number &#39;i&#39;, and recursively process the remaining numbers </span><br><span class="line">return the count of subsets who has a sum equal to &#39;S&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n)</span></span><br><span class="line"><span class="comment">//Space O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countSubsetsRecursive(num, sum, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSubsetsRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the number at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( num[currentIndex] &lt;= sum )</span><br><span class="line">        sum1 = countSubsetsRecursive(num, sum - num[currentIndex], currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> sum2 = countSubsetsRecursive(num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-2"><a href="#Top-down-Dynamic-Programming-with-Memoization-2" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[num.length][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countSubsetsRecursive(dp, num, sum, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSubsetsRecursive</span><span class="params">(Integer[][] dp, <span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we have not already processed a similar problem</span></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex][sum] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// recursive call after choosing the number at the currentIndex</span></span><br><span class="line">        <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( num[currentIndex] &lt;= sum )</span><br><span class="line">            sum1 = countSubsetsRecursive(dp, num, sum - num[currentIndex], currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = countSubsetsRecursive(dp, num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        dp[currentIndex][sum] = sum1 + sum2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-4"><a href="#Bottom-up-Dynamic-Programming-4" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we will always have an empty set for zero sum</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to its value</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            <span class="comment">// exclude the number</span></span><br><span class="line">            dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            <span class="comment">// include the number, if it does not exceed the sum</span></span><br><span class="line">            <span class="keyword">if</span>(s &gt;= num[i])</span><br><span class="line">                dp[i][s] += dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[num.length-<span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-2-Target-Sum-hard"><a href="#Challenge-2-Target-Sum-hard" class="headerlink" title="Challenge 2 Target Sum (hard)"></a>Challenge 2 Target Sum (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 1, 2, 3&#125;, S&#x3D;1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The given set has &#39;3&#39; ways to make a sum of &#39;1&#39;: &#123;+1-1-2+3&#125; &amp; &#123;-1+1-2+3&#125; &amp; &#123;+1+1+2-3&#125;</span><br><span class="line"></span><br><span class="line">Input: &#123;1, 2, 7, 1&#125;, S&#x3D;9</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The given set has &#39;2&#39; ways to make a sum of &#39;9&#39;: &#123;+1+2+7-1&#125; &amp; &#123;-1+2+7+1&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><p><a href="https://zhuanlan.zhihu.com/p/91582909" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91582909</a></p>
<h2 id="🌕Unsolved-1335-Minimum-Difficulty-of-a-Job-Schedule⭐"><a href="#🌕Unsolved-1335-Minimum-Difficulty-of-a-Job-Schedule⭐" class="headerlink" title="🌕Unsolved 1335. Minimum Difficulty of a Job Schedule⭐"></a><a href="https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/" target="_blank" rel="noopener">🌕Unsolved 1335. Minimum Difficulty of a Job Schedule⭐</a></h2><p><img src="https://assets.leetcode.com/uploads/2020/01/16/untitled.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: jobDifficulty &#x3D; [6,5,4,3,2,1], d &#x3D; 2</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: First day you can finish the first 5 jobs, total difficulty &#x3D; 6.</span><br><span class="line">Second day you can finish the last job, total difficulty &#x3D; 1.</span><br><span class="line">The difficulty of the schedule &#x3D; 6 + 1 &#x3D; 7</span><br></pre></td></tr></table></figure>

<p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2020/01/56F9A2C8-3F83-4C84-880B-F7551A06029D-1024x580.jpeg" alt=""></p>
<h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>dp[i][k] := min difficulties to schedule jobs 1~i in k days.</p>
<p>Schedule 1 ~ j in k – 1 days and schedule j + 1 ~ i in 1 day.</p>
<p>Init: dp[0] [0] = 0<br>Transition: dp[i][k] := min(dp[j] [k -1] + max(jobs[j + 1 ~ i]), k – 1 &lt;= j &lt; i<br>Answer: dp[n] [d]</p>
<p>Time complexity: O(n^2*d)<br>Space complexity: O(n)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="keyword">int</span>[] jobDifficulty, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">int</span> n = jobDifficulty.length;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; d) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][d+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] a : dp) &#123;</span><br><span class="line">        Arrays.fill(a, Integer.MAX_VALUE/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= d; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxDifficulty = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= k-<span class="number">1</span>; j--) &#123;</span><br><span class="line">                maxDifficulty = Math.max(maxDifficulty, jobDifficulty[j]);</span><br><span class="line">                dp[i][k] = Math.min(dp[i][k], dp[j][k-<span class="number">1</span>] + maxDifficulty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][d];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Solution1: DP</span></span><br><span class="line"><span class="comment">dp[i][k] = minimum jod difficulty to schedule first i jobs in k days</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">initial: dp[0][0] = 0;, dp[*][*] = Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Transition:</span></span><br><span class="line"><span class="comment">d[i][k] = min&#123;dp[j][k-1] + max(jobs[j+1 ~ i])&#125;;</span></span><br><span class="line"><span class="comment">k-1 &lt;= j &lt; i;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Answer: dp[n][d];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(n^2k)</span></span><br><span class="line"><span class="comment">Space O(nk)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Solution 1: Top-down DP with cache</p>
</li>
<li><p><code>dfs</code> help find the the minimum difficulty<br>if start work at <code>i</code>th job with <code>d</code> days left.</p>
<p>If <code>d = 1</code>, only one day left, we have to do all jobs,<br>return the maximum difficulty of jobs.</p>
<p>Time complexity <code>O(nnd)</code><br>Space complexity <code>O(nd)</code></p>
</li>
</ol>
<p><a href="https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/490316/JavaC%2B%2BPython3-DP-O(nd)-Solution" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/490316/JavaC%2B%2BPython3-DP-O(nd)-Solution</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="keyword">int</span>[] jobDifficulty, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = jobDifficulty.length;</span><br><span class="line">    <span class="keyword">if</span>(N &lt; D) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[N][D + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] row : memo) Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(D, <span class="number">0</span>, jobDifficulty, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> len, <span class="keyword">int</span>[] jobDifficulty, <span class="keyword">int</span>[][] memo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = jobDifficulty.length;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span> &amp;&amp; len == N) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span> || len == N) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(memo[len][d] != -<span class="number">1</span>) <span class="keyword">return</span> memo[len][d];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curMax = jobDifficulty[len];</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> schedule = len; schedule &lt; N; ++schedule)&#123;</span><br><span class="line">        curMax = Math.max(curMax, jobDifficulty[schedule]);</span><br><span class="line">        <span class="keyword">int</span> temp = dfs(d - <span class="number">1</span>, schedule + <span class="number">1</span>, jobDifficulty, memo);</span><br><span class="line">        <span class="keyword">if</span>(temp != Integer.MAX_VALUE)</span><br><span class="line">            min = Math.min(min, temp + curMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[len][d] = min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="221-Maximal-Square⭐"><a href="#221-Maximal-Square⭐" class="headerlink" title="221. Maximal Square⭐"></a><a href="https://leetcode.com/problems/maximal-square/" target="_blank" rel="noopener">221. Maximal Square⭐</a></h2><p><img src="https://assets.leetcode.com/users/leetcode/image_1573111823.png" alt=""></p>
<h3 id="Solution0-1"><a href="#Solution0-1" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute force</li>
<li>Time complexity : O\big((mn)^2\big)<em>O</em>((<em>m**n</em>)2). In worst case, we need to traverse the complete matrix for every 1.</li>
<li>Space complexity : O(1)<em>O</em>(1). No extra space is used.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxsqlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> sqlen = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">while</span> (sqlen + i &lt; rows &amp;&amp; sqlen + j &lt; cols &amp;&amp; flag) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= sqlen + j; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + sqlen][k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            flag = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= sqlen + i; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[k][j + sqlen] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            flag = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (flag)</span><br><span class="line">                        sqlen++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (maxsqlen &lt; sqlen) &#123;</span><br><span class="line">                    maxsqlen = sqlen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><code>dp[i][j]</code> represents the length of the square which lower right corner is located at <code>(i, j)</code>.<br>If the value of this cell is also <code>1</code>, then the length of the square is the <strong>minimum</strong> of: the one above, its left, and diagonal up-left value +1. Because if one side is short or missing, it will not form a square.</li>
<li>Time complexity : O(mn)<em>O</em>(<em>m**n</em>). Single pass.</li>
<li>Space complexity : O(mn)<em>O</em>(<em>m**n</em>). Another matrix of same size is used for dp.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length; </span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> edge = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n+<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]), dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                edge = Math.max(edge, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edge * edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1155-Number-of-Dice-Rolls-With-Target-Sum⭐"><a href="#1155-Number-of-Dice-Rolls-With-Target-Sum⭐" class="headerlink" title="1155. Number of Dice Rolls With Target Sum⭐"></a><a href="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/" target="_blank" rel="noopener">1155. Number of Dice Rolls With Target Sum⭐</a></h2><h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>dfs + memorization</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> MOD = <span class="number">1000000000</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span> || target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    String s = d + <span class="string">"|"</span> + target;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &gt;= i) &#123;</span><br><span class="line">            res = (res + numRollsToTarget(d - <span class="number">1</span>, f, target - i)) % MOD;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>dp</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[d + <span class="number">1</span>][target + <span class="number">1</span>]; </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//how many possibility can i dices sum up to j;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; i * f) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;         <span class="comment">//If j is larger than largest possible sum of i dices, there is no possible ways.        </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                      <span class="comment">//watch out below condition, or NPE</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f &amp;&amp; k &lt;= j ; k++) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j - k]) % MOD; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[d][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="139-Word-Break⭐"><a href="#139-Word-Break⭐" class="headerlink" title="139. Word Break⭐"></a><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">139. Word Break⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">递归求解，划分left, right substring</span><br><span class="line">check <span class="keyword">if</span> dic contains right, recursively apply function to left</span><br><span class="line">wordbreak(<span class="string">"leetcode"</span>) = </span><br><span class="line">wordbreak(<span class="string">""</span>) &amp;&amp; inDict(<span class="string">"leetcode"</span>)</span><br><span class="line">|| wordbreak(<span class="string">"l"</span>) &amp;&amp; inDict(<span class="string">"eetcode"</span>)</span><br><span class="line">|| wordbreak(<span class="string">"le"</span>) &amp;&amp; inDict(<span class="string">"etcode"</span>)</span><br><span class="line">|| wordbreak(<span class="string">"lee"</span>) &amp;&amp; inDict(<span class="string">"tcode"</span>)</span><br><span class="line">|| wordbreak(<span class="string">"leet"</span>) &amp;&amp; inDict(<span class="string">"code"</span>) ✔</span><br><span class="line">|| wordbreak(<span class="string">"lettc"</span>) &amp;&amp; inDict(<span class="string">"leetcode"</span>)</span><br><span class="line"></span><br><span class="line">wordbreak(<span class="string">"leet"</span>) =</span><br><span class="line">||wordbreak(<span class="string">""</span>) &amp;&amp; inDict(<span class="string">"leet"</span>)✔</span><br><span class="line">||wordbreak(<span class="string">"l"</span>) &amp;&amp; inDict(<span class="string">"eet"</span>)</span><br><span class="line">||wordbreak(<span class="string">"le"</span>) &amp;&amp; inDict(<span class="string">"et"</span>)</span><br><span class="line">||wordbreak(<span class="string">"lee"</span>) &amp;&amp; inDict(<span class="string">"t"</span>)</span><br><span class="line">||wordbreak(<span class="string">"leet"</span>) &amp;&amp; inDict(<span class="string">""</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">    Map&lt;String, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> wordBreak(s, map, dict);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, Map&lt;String, Boolean&gt; map, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//in memory directly return</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//base case, if s is valid word memorie it and return</span></span><br><span class="line">    <span class="keyword">if</span> (dict.contains(s)) &#123;</span><br><span class="line">        map.put(s, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//divie the string to left right two part, in all possibilities</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        String left = s.substring(<span class="number">0</span>, i);</span><br><span class="line">        String right = s.substring(i);</span><br><span class="line">        <span class="keyword">if</span> (dict.contains(right) &amp;&amp; wordBreak(left, map, dict)) &#123;</span><br><span class="line">            map.put(s, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>思路 1：动态规划，每次都利用已处理部分可分信息看到当前位置是否可分，如果可分置 True。O(n2k)</p>
</li>
<li><p>f[i] stands for whether subarray(0, i) can be segmented into words from the dictionary. So f[0] means whether subarray(0, 0) (which is an empty string) can be segmented, and of course the answer is yes.</p>
<p>The default value for boolean array is false. Therefore we need to set f[0] to be true.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-140-Word-Break-II⭐"><a href="#Unsolved-140-Word-Break-II⭐" class="headerlink" title="Unsolved 140. Word Break II⭐"></a><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">Unsolved 140. Word Break II⭐</a></h2><h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路 1：DFS+回溯，每次试用词典中每一个词作为下一段开始的一种可能。O（n^2k）。</li>
<li>Using DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">    Set&lt;String&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    <span class="keyword">return</span> wordBreak(s, map, words);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, HashMap&lt;String,List&lt;String&gt;&gt; map, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//in memory</span></span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//base case, a whole string is a word</span></span><br><span class="line">    <span class="keyword">if</span>(wordDict.contains(s)) &#123;</span><br><span class="line">        res.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; s.length() ; i++) &#123;</span><br><span class="line">        String left = s.substring(<span class="number">0</span> , i);</span><br><span class="line">        String right = s.substring(i);</span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(right)) &#123;</span><br><span class="line">            List&lt;String&gt; temp = wordBreak(left, map, wordDict);</span><br><span class="line">            <span class="keyword">if</span>(temp.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; temp.size() ; j++) &#123;</span><br><span class="line">                    res.add(temp.get(j) + <span class="string">" "</span> + right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s , res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    <span class="keyword">return</span> dfs(s, words, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">dfs</span><span class="params">(String s, Set&lt;String&gt; words, Map&lt;String, List&lt;String&gt;&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.startsWith(word)) &#123;</span><br><span class="line">            List&lt;String&gt; sublist = dfs(s.substring(word.length()), words, map);</span><br><span class="line">            <span class="keyword">for</span> (String sub : sublist) &#123;</span><br><span class="line">                res.add(word + (sub.isEmpty() ? <span class="string">""</span> : <span class="string">" "</span>) + sub);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路 2：与思路 1 类似，不是词去匹配字符串，而是字符串先切分，再看分出来的部分是不是在词典中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE, max = <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">        set.add(word);</span><br><span class="line">        <span class="keyword">int</span> curLen = word.length();</span><br><span class="line">        min = (curLen &lt; min) ? curLen : min;</span><br><span class="line">        max = (curLen &gt; max) ? curLen : max;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] invalid = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()]; <span class="comment">// invalid[i]: [i:] is unbreakable</span></span><br><span class="line">    seperate(s, result, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, set, invalid, min, max);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">seperate</span><span class="params">(String s, List&lt;String&gt; res, StringBuilder tmp, <span class="keyword">int</span> index, HashSet&lt;String&gt; set, <span class="keyword">boolean</span>[] invalid, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">        res.add(tmp.toString().trim());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> breakable = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> prelen = tmp.length();</span><br><span class="line">    <span class="keyword">int</span> rightbound = Math.min(s.length(), index + max);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = index + min; end &lt;= rightbound; end++) &#123;</span><br><span class="line">        <span class="keyword">int</span> curLen = end - index;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; s.length() &amp;&amp; invalid[end])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        String cur = s.substring(index, end);</span><br><span class="line">        <span class="keyword">if</span> (set.contains(cur)) &#123;</span><br><span class="line">            tmp.append(<span class="string">" "</span>).append(cur);</span><br><span class="line">            breakable |= seperate(s, res, tmp, end, set, invalid, min, max);</span><br><span class="line">            tmp.setLength(prelen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    invalid[index] = !breakable;</span><br><span class="line">    <span class="keyword">return</span> breakable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-472-Concatenated-Words⭐"><a href="#Unsolved-472-Concatenated-Words⭐" class="headerlink" title="Unsolved 472. Concatenated Words⭐"></a><a href="https://leetcode.com/problems/concatenated-words/" target="_blank" rel="noopener">Unsolved 472. Concatenated Words⭐</a></h2><p><a href="https://leetcode.com/problems/concatenated-words/discuss/95652/Java-DP-Solution" target="_blank" rel="noopener">https://leetcode.com/problems/concatenated-words/discuss/95652/Java-DP-Solution</a></p>
<p><a href="https://leetcode.com/problems/concatenated-words/discuss/541520/Java-DFS-%2B-Memoization-Clean-code" target="_blank" rel="noopener">https://leetcode.com/problems/concatenated-words/discuss/541520/Java-DFS-%2B-Memoization-Clean-code</a></p>
<p><a href="https://leetcode.com/problems/concatenated-words/discuss/348972/Java-Common-template-Word-Break-I-Word-Break-II-Concatenated-Words" target="_blank" rel="noopener">https://leetcode.com/problems/concatenated-words/discuss/348972/Java-Common-template-Word-Break-I-Word-Break-II-Concatenated-Words</a></p>
<h2 id="64-Minimum-Path-Sum⭐"><a href="#64-Minimum-Path-Sum⭐" class="headerlink" title="64. Minimum Path Sum⭐"></a><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. Minimum Path Sum⭐</a></h2><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[ [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>] ]</span><br><span class="line">Output: <span class="number">7</span></span><br><span class="line">Explanation: Because the path <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> minimizes the sum.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：动态规划。边界上只能直接加上一位置数值到当前位置，非边界的则取上行或列中较小的加到当前数值中，最终位置数值即最小。</li>
<li>minimizes, 优化问题经常是动态规划</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//initial</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//tarverse</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n; ++j) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[[1,3,1],</span></span><br><span class="line"><span class="comment">[1,5,1],</span></span><br><span class="line"><span class="comment">[4,2,1]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Error check :</span></span><br><span class="line"><span class="comment">if input is empty or null. return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">1. First another matrix to store the path sum</span></span><br><span class="line"><span class="comment">   eg. matrix[i][j] = currnet smallest path sum from start point to current pos</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">2. Initial the boundary conditions</span></span><br><span class="line"><span class="comment">    eg. in first row like a prefix sum calculate the all the element value from start point to here: in first col, same with row</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. Traverse from [1,1] position, keep update the cur matrix value</span></span><br><span class="line"><span class="comment">    since we want minimizes the value, we will peek the smaller one from top, or left unit, and add this value with cur num value</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    [1,4,5]</span></span><br><span class="line"><span class="comment">    [2,2+5 = 7, 6]</span></span><br><span class="line"><span class="comment">    [6,8, 7]</span></span><br><span class="line"><span class="comment">4. return matrix[i][j], end point matrix path sum value</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(mn)</span></span><br><span class="line"><span class="comment">Space O(mn)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="121-Best-Time-to-Buy-and-Sell-Stock⭐"><a href="#121-Best-Time-to-Buy-and-Sell-Stock⭐" class="headerlink" title="121. Best Time to Buy and Sell Stock⭐"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock⭐</a></h2><h3 id="Most-consistent-ways-of-dealing-with-the-series-of-stock-problems"><a href="#Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" class="headerlink" title="Most consistent ways of dealing with the series of stock problems"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">Most consistent ways of dealing with the series of stock problems</a></h3><p><a href="https://mp.weixin.qq.com/s/61CU8PcT2z4Po7cVdwTprg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/61CU8PcT2z4Po7cVdwTprg</a></p>
<h3 id="Solution0-2"><a href="#Solution0-2" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute Force</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(N^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">            <span class="keyword">if</span> (profit &gt; maxprofit)</span><br><span class="line">                maxprofit = profit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>One Pass</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">            minprice = prices[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">            maxprofit = prices[i] - minprice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check:</span></span><br><span class="line"><span class="comment">1. If price == null || price.length == 0 return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">Brute force:</span></span><br><span class="line"><span class="comment">Apply double for loop, eg.</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; prices.length; i++) &#123;</span></span><br><span class="line"><span class="comment">    for (int j = i + 1; j &lt; prices.length; j++) &#123;</span></span><br><span class="line"><span class="comment">        if (prices[j] - prices[i] &gt; max) &#123;</span></span><br><span class="line"><span class="comment">            max = prices[j] - prices[i];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Time O(n^2)</span></span><br><span class="line"><span class="comment">Spcae: O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution2:</span></span><br><span class="line"><span class="comment">maxProfit</span></span><br><span class="line"><span class="comment">we want buy the stock in min price and sold it at max prices in the future</span></span><br><span class="line"><span class="comment">we can tarck the current min price, travrse the prices, say </span></span><br><span class="line"><span class="comment">if (current price - Curmin &gt; maxProfit) &#123;</span></span><br><span class="line"><span class="comment">    maxProfit = current price - Curmin;</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">curmin = Math.min(curMin, price) //keep updating min price we have seen</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Go through example: [7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">day: </span></span><br><span class="line"><span class="comment">price: 1</span></span><br><span class="line"><span class="comment">min: 1</span></span><br><span class="line"><span class="comment">profit: </span></span><br><span class="line"><span class="comment">max: </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(n)</span></span><br><span class="line"><span class="comment">Space O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II✨"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II✨" class="headerlink" title="122. Best Time to Buy and Sell Stock II✨"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">7</span></span><br><span class="line">Explanation: Buy on day <span class="number">2</span> (price = <span class="number">1</span>) and sell on day <span class="number">3</span> (price = <span class="number">5</span>), profit = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span>.</span><br><span class="line">             Then buy on day <span class="number">4</span> (price = <span class="number">3</span>) and sell on day <span class="number">5</span> (price = <span class="number">6</span>), profit = <span class="number">6</span>-<span class="number">3</span> = <span class="number">3</span>.</span><br><span class="line">    </span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Buy on day <span class="number">1</span> (price = <span class="number">1</span>) and sell on day <span class="number">5</span> (price = <span class="number">5</span>), profit = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span>.</span><br><span class="line">             Note that you cannot buy on day <span class="number">1</span>, buy on day <span class="number">2</span> and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//but that day higer the previous day tehn sell next day</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i + <span class="number">1</span>] &gt; prices[i]) &#123; </span><br><span class="line">            profit += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def compare(a, b):</span><br><span class="line">        if abs(a) &lt; abs(b): return -1</span><br><span class="line">        if abs(a) &gt; abs(b): return 1</span><br><span class="line">        if a &lt; b: return -1</span><br><span class="line">        if a &gt; b: return 1</span><br><span class="line">        return 0</span><br><span class="line"></span><br><span class="line">    arr.sort(cmp &#x3D; compare)</span><br><span class="line">    return arr</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-123-Best-Time-to-Buy-and-Sell-Stock-III✨"><a href="#Unsolved-123-Best-Time-to-Buy-and-Sell-Stock-III✨" class="headerlink" title="Unsolved 123. Best Time to Buy and Sell Stock III✨"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">Unsolved 123. Best Time to Buy and Sell Stock III✨</a></h2><h2 id="Unsolved-188-Best-Time-to-Buy-and-Sell-Stock-IV✨"><a href="#Unsolved-188-Best-Time-to-Buy-and-Sell-Stock-IV✨" class="headerlink" title="Unsolved 188. Best Time to Buy and Sell Stock IV✨"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">Unsolved 188. Best Time to Buy and Sell Stock IV✨</a></h2><h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：同 122 和 123 题。如果次数不小于天数一半，则可任意多次交易，只要上涨就计入即为最大收益。如 果次数不到天数一半，二维动态规。O(kn)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> maxCum(prices);</span><br><span class="line">    <span class="keyword">int</span>[] balance = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(balance, Integer.MIN_VALUE);</span><br><span class="line">    <span class="keyword">int</span>[] profit = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            balance[j] = Math.max(profit[j - <span class="number">1</span>] - price, balance[j]);</span><br><span class="line">            profit[j] = Math.max(balance[j] + price, profit[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCum</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (prices[i + <span class="number">1</span>] &gt; prices[i])</span><br><span class="line">            ans += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i, j] represents the max profit up until prices[j] using at most i transactions. </span></span><br><span class="line"><span class="comment"> * dp[i, j] = max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]) &#123; jj in range of [0, j-1] &#125;</span></span><br><span class="line"><span class="comment"> *          = max(dp[i, j-1], prices[j] + max(dp[i-1, jj] - prices[jj]))</span></span><br><span class="line"><span class="comment"> * dp[0, j] = 0; 0 transactions makes 0 profit</span></span><br><span class="line"><span class="comment"> * dp[i, 0] = 0; if there is only one price data point you can't make any transaction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = prices.length;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//if k &gt;= n/2, then you can make maximum number of transactions.</span></span><br><span class="line">	<span class="keyword">if</span> (k &gt;=  n/<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> maxPro = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (prices[i] &gt; prices[i-<span class="number">1</span>])</span><br><span class="line">				maxPro += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maxPro;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">    	<span class="keyword">int</span> localMax = dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    		dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>],  prices[j] + localMax);</span><br><span class="line">    		localMax = Math.max(localMax, dp[i-<span class="number">1</span>][j] - prices[j]);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3:"></a>Solution3:</h3><ol>
<li>The general idea is DP, while I had to add a “quickSolve” function to tackle some corner cases to avoid TLE. DP: t(i,j) is the max profit for up to i transactions by time j (0&lt;=i&lt;=K, 0&lt;=j&lt;=T).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= len / <span class="number">2</span>) <span class="keyword">return</span> quickSolve(prices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] t = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>][len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmpMax =  -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            t[i][j] = Math.max(t[i][j - <span class="number">1</span>], prices[j] + tmpMax);</span><br><span class="line">            tmpMax =  Math.max(tmpMax, t[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t[k][len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSolve</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length, profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        <span class="comment">// as long as there is a price gap, we gain a profit.</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Unsolved-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Unsolved 309. Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">Unsolved 309. Best Time to Buy and Sell Stock with Cooldown</a></h2><h2 id="Unsolved-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#Unsolved-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="Unsolved Best Time to Buy and Sell Stock with Transaction Fee"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">Unsolved Best Time to Buy and Sell Stock with Transaction Fee</a></h2><h2 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. Maximum Product Subarray</a></h2><h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="Unsolved-72-Edit-Distance✨"><a href="#Unsolved-72-Edit-Distance✨" class="headerlink" title="Unsolved 72. Edit Distance✨"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">Unsolved 72. Edit Distance✨</a></h2><h2 id="53-Maximum-Subarray✨"><a href="#53-Maximum-Subarray✨" class="headerlink" title="53. Maximum Subarray✨"></a><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. Maximum Subarray✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Find the contiguous subarray within an <span class="title">array</span> <span class="params">(containing at least one number)</span> which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum </span>= <span class="number">6</span>.</span><br><span class="line"></span><br><span class="line">Input: nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] has the largest sum = <span class="number">6</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路 1：类似股票题目，逐一求和，如果小于 0 则再从 0 开始。O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[i];</span><br><span class="line">        sum += cur;</span><br><span class="line">        max = Math.max(max, sum);</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/maximum-subarray/discuss/20193/DP-solution-and-some-thoughts" target="_blank" rel="noopener">思路</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        curSum = Math.max(nums[i], curSum + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (curSum &gt; max) &#123;</span><br><span class="line">            max = curSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//dp[i] means the maximum subarray ending with A[i];</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="91-Decode-Ways✨"><a href="#91-Decode-Ways✨" class="headerlink" title="91. Decode Ways✨"></a><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">91. Decode Ways✨</a></h2><h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><a href="https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation" target="_blank" rel="noopener">explanation</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//""</span></span><br><span class="line">    dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> oneDigits = Integer.valueOf(s.substring(i - <span class="number">1</span>, i));</span><br><span class="line">        <span class="keyword">int</span> twoDigits = Integer.valueOf(s.substring(i - <span class="number">2</span>, i));</span><br><span class="line">        <span class="keyword">if</span> (oneDigits &gt;= <span class="number">1</span> &amp;&amp; oneDigits &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">            dp[i] += dp[i-<span class="number">1</span>];  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (twoDigits &gt;= <span class="number">10</span> &amp;&amp; twoDigits &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Max-Subset-Sum-No-Adjacent-AE-✨"><a href="#Max-Subset-Sum-No-Adjacent-AE-✨" class="headerlink" title="Max Subset Sum No Adjacent(AE)✨"></a>Max Subset Sum No Adjacent(AE)✨</h2><ol>
<li><p>Given a no negative integer array</p>
</li>
<li><p>Built an array same length with the input array, maxSums array to storing the greatest number with no adjacent numbers</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">14</span>]  <span class="comment">//input array</span></span><br><span class="line"></span><br><span class="line">[<span class="number">7</span>, <span class="number">10</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">28</span>, <span class="number">33</span>]   <span class="comment">//maxSums </span></span><br><span class="line"><span class="comment">//33 = 19 + 14</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>formula: <strong><code>maxSums[i]</code></strong> = max(<strong><code>maxSums[i - 1]</code></strong>, <strong><code>maxSums[i - 2] + array[i]</code></strong>)</p>
</li>
<li><p>time O(N), space O(N), because we build an array in length N</p>
</li>
</ol>
<h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(n) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubsetSumNoAdjacent</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;  <span class="comment">//edge case1 need take care of, the array is empty</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array.length = <span class="number">1</span>) &#123;  <span class="comment">//edge case2, the array only have one value</span></span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] maxSums = array.clone();  <span class="comment">//copy the main array, fix first 2 element,because maxSums[0] = array[0]</span></span><br><span class="line">    maxSums[<span class="number">1</span>] = Math.max(array[<span class="number">0</span>], array[<span class="number">1</span>]);  <span class="comment">//set the second value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//start traversal and apply the foluma</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">        maxSums[i] = Math.max(maxSums[i - <span class="number">1</span>], maxSums[i - <span class="number">2</span>] + array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSums[array.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Like nth Fib, sliding window</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">14</span>]  <span class="comment">//input array</span></span><br><span class="line"></span><br><span class="line">first &amp; second</span><br><span class="line">[<span class="number">7</span>, <span class="number">10</span>], <span class="number">19</span>, <span class="number">19</span>, <span class="number">28</span>, <span class="number">33</span></span><br><span class="line"><span class="number">7</span>, [<span class="number">10</span>, <span class="number">19</span>], <span class="number">19</span>, <span class="number">28</span>, <span class="number">33</span></span><br><span class="line"><span class="number">7</span>, <span class="number">10</span>, [<span class="number">19</span>, <span class="number">19</span>], <span class="number">28</span>, <span class="number">33</span></span><br><span class="line"><span class="number">7</span>, <span class="number">10</span>, <span class="number">19</span>, [<span class="number">19</span>, <span class="number">28</span>], <span class="number">33</span></span><br><span class="line"><span class="number">7</span>, <span class="number">10</span>, <span class="number">19</span>, <span class="number">19</span>, [<span class="number">28</span>, <span class="number">33</span>]   <span class="comment">//maxSums</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(1) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubsetSumNoAdjacent</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = array[<span class="number">0</span>];  <span class="comment">//create two varaible to store value rather than array in order to save space complexity, represent maxSums[i - 2], in the begining is array[0]</span></span><br><span class="line">    <span class="keyword">int</span> second = Math.max(array[<span class="number">0</span>], array[<span class="number">1</span>]);  <span class="comment">//represent maxSums[i - 1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = Math.max(second, first + array[i]);  <span class="comment">//create varaible to represent maxSums[i - 1]</span></span><br><span class="line">        first = second;</span><br><span class="line">        second = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="198-House-Robber✨"><a href="#198-House-Robber✨" class="headerlink" title="198.House Robber✨"></a><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198.House Robber✨</a></h3><h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Time complexity : O(n). Assume that n<em>n</em> is the number of houses, the time complexity is O(n)<em>O</em>(<em>n</em>).</li>
<li>Space complexity : O(1).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prevMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : num) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = currMax;</span><br><span class="line">        currMax = Math.max(prevMax + x, currMax);</span><br><span class="line">        prevMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = Math.max(first + nums[i], second);</span><br><span class="line">        first = second;</span><br><span class="line">        second = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213.House Robber II"></a><a href="https://leetcode.com/problems/house-robber-ii/" target="_blank" rel="noopener">213.House Robber II</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regard ayyay[<span class="number">0</span>] and array[array.length - <span class="number">1</span>] as adjacent houses</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：与第 198 题思路一致，只不过要从 0 到 n-1，1 到 n 中取较大的。因为 n 和 0 相邻。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>), rob(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, preMax = <span class="number">0</span>, noRob, rob;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[i];</span><br><span class="line">        rob = preMax + cur;</span><br><span class="line">        noRob = max;</span><br><span class="line">        max = Math.max(rob, noRob);</span><br><span class="line">        preMax = noRob;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Number-Of-Ways-To-Make-Change-AE"><a href="#Number-Of-Ways-To-Make-Change-AE" class="headerlink" title="Number Of Ways To Make Change(AE)"></a>Number Of Ways To Make Change(AE)</h2><ol>
<li><p>Given an integer to represents a target amount of money, and an array input represent the coin denominations</p>
</li>
<li><p>Dynamic programming</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">10</span> [<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>]  <span class="number">4</span> ways (<span class="number">1</span>x10$, <span class="number">2</span>x5$, <span class="number">1</span>x5$+<span class="number">5</span>x1$, <span class="number">10</span>x1$);</span><br><span class="line">ways-&gt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">$   -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">initals:only <span class="number">1</span> way to change <span class="number">0</span>$ which is use <span class="number">0</span> coins, base <span class="keyword">case</span></span><br><span class="line">    </span><br><span class="line">amount &gt;= <span class="number">1</span>$ coin: </span><br><span class="line">ways-&gt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">$   -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">way[<span class="number">1</span>] += way[<span class="number">1</span> - <span class="number">1</span>]</span><br><span class="line">way[<span class="number">2</span>] += way[<span class="number">2</span> - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">amount &gt;= <span class="number">5</span>$ coin: </span><br><span class="line">ways-&gt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">$   -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">way[<span class="number">5</span>] += way[<span class="number">5</span> - <span class="number">5</span>] </span><br><span class="line">way[<span class="number">10</span>] += way[<span class="number">10</span> - <span class="number">5</span>]</span><br><span class="line">    </span><br><span class="line">amount &gt;= <span class="number">10</span>$ coin: </span><br><span class="line">ways-&gt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">$   -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">way[<span class="number">10</span>] += way[<span class="number">10</span> - <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>if denom &lt;= amount: ways[amount] += ways[amount -denom];</p>
</li>
</ol>
<h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(nd) d is denoms | O(n) space n is target amount</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfWayToMakeChange</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] denoms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ways = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//base line, only one way to change 0 $</span></span><br><span class="line">    ways[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> denom : denoms) &#123;  <span class="comment">//denoms : 1, 5, 10 ,25</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> amount = <span class="number">1</span>; amount &lt; n + <span class="number">1</span>; ++amount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (denom &lt;= amount) &#123;</span><br><span class="line">                ways[amount] += ways[amount - denom];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="518-Coin-Change-2"><a href="#518-Coin-Change-2" class="headerlink" title="518. Coin Change 2"></a><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">518. Coin Change 2</a></h3><h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><strong>Algorithm</strong><ul>
<li>Initiate number of combinations array with the base case “no coins”: <code>dp[0] = 1</code>, and all the rest = 0.</li>
<li>Loop over all coins:<ul>
<li>For each coin, loop over all amounts from 0 to <code>amount</code>:<ul>
<li>For each amount x, compute the number of combinations: <code>dp[x] += dp[x - coin]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>dp[amount]</code>.</li>
</ul>
</li>
<li>Time complexity: \mathcal{O}(N \times \textrm{amount})O(<em>N</em>×amount), where N is a length of coins array.</li>
<li>Space complexity: \mathcal{O}(\textrm{amount})O(amount) to keep dp array.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coin &lt;= i) &#123;</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>This is a classic knapsack problem. </p>
<p><code>dp[i][j]</code> : the number of combinations to make up amount <code>j</code> by using the first <code>i</code> types of coins<br><code>State transition</code>:</p>
<ol>
<li>not using the <code>i</code>th coin, only using the first <code>i-1</code> coins to make up amount <code>j</code>, then we have <code>dp[i-1][j]</code> ways.</li>
<li>using the <code>i</code>th coin, since we can use unlimited same coin, we need to know how many ways to make up amount <code>j - coins[i-1]</code> by using first <code>i</code> coins(including <code>i</code>th), which is <code>dp[i][j-coins[i-1]]</code></li>
</ol>
</li>
<li><p><strong><code>Initialization:dp[i][0] = 1</code></strong></p>
</li>
<li><pre><code class="java">different ways
amount-&gt; <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span>
types
<span class="number">0</span>        <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>   <span class="number">1</span> 
<span class="number">1</span>(<span class="number">1</span>$)    <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>   <span class="number">1</span> 
<span class="number">2</span>(<span class="number">5</span>$)    <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>   <span class="number">3</span>
<span class="number">3</span>(<span class="number">10</span>$)   <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>   <span class="number">4</span>

dp[<span class="number">2</span>][<span class="number">5</span>] = dp[<span class="number">1</span>][<span class="number">5</span>] + dp[<span class="number">2</span>][<span class="number">5</span> - <span class="number">5</span>] = <span class="number">2</span>
formula:dp[i][j] = dp[i-<span class="number">1</span>][j] + (j &gt;= coins[i-<span class="number">1</span>] ? dp[i][j-coins[i-<span class="number">1</span>]] : <span class="number">0</span>)
&lt;!--￼<span class="number">59</span>--&gt;
</code></pre>
</li>
</ol>
<p>Now we can see that <code>dp[i][j]</code> only rely on <code>dp[i-1][j]</code> and <code>dp[i][j-coins[i]]</code>, then we can optimize the space by only using one-dimension array.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> denom : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (denom &lt;= i) &#123;</span><br><span class="line">                dp[i] += dp[i - denom];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Min-Number-Of-Coins-For-Change-AE-✨"><a href="#Min-Number-Of-Coins-For-Change-AE-✨" class="headerlink" title="Min Number Of Coins For Change(AE)✨"></a>Min Number Of Coins For Change(AE)✨</h2><ol>
<li><p>two inputs, target of amount of money and array of coin combinations</p>
</li>
<li><p>find the min number to get the amount</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">6</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]  <span class="number">2</span> coins(<span class="number">2</span>$ + <span class="number">4</span>$);</span><br><span class="line">with <span class="number">1</span>$</span><br><span class="line">coins-&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">$    -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">2</span> - <span class="number">1</span> = <span class="number">1</span>, <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">min[<span class="number">1</span>] += min[<span class="number">1</span> - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">with <span class="number">1</span>$ &amp; <span class="number">2</span>$</span><br><span class="line">coins-&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">$    -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> - <span class="number">2</span> = <span class="number">0</span></span><br><span class="line"><span class="number">3</span> - <span class="number">2</span> = <span class="number">1</span>, <span class="number">4</span> - <span class="number">2</span> = <span class="number">2</span>, <span class="number">5</span> - <span class="number">2</span> = <span class="number">3</span>, <span class="number">6</span> - <span class="number">2</span> = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">with <span class="number">1</span>$ &amp; <span class="number">2</span>$ &amp; <span class="number">4</span>$</span><br><span class="line">coins-&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">$    -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span> - <span class="number">4</span> = <span class="number">0</span></span><br><span class="line"><span class="number">5</span> - <span class="number">4</span> = <span class="number">1</span>, <span class="number">6</span> - <span class="number">4</span> = <span class="number">2</span>;</span><br><span class="line"><span class="number">1</span>($denom) &lt;= <span class="number">1</span>(amount)</span><br></pre></td></tr></table></figure>
</li>
<li><p>if amount &gt;= denom: <strong><code>nums[amount]</code></strong> = min(<strong><code>nums[amount]</code></strong>, <strong><code>1(eg. a 4$ coin) + nums[amount - denom]</code></strong>)</p>
</li>
</ol>
<h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(nd) d is denom time | O(n) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberOfCoinsForChange</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] denoms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] numOfCoins = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];  <span class="comment">//add o amount which is base case at beginning</span></span><br><span class="line">    Arrays.fill(numOfCoins, Integer.MAX_VALUE);</span><br><span class="line">    numOfCoins[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> toCompare  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> denom : denoms) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> amount = <span class="number">0</span>; amount &lt; numOfCoins.length; ++amount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &gt;= denom) &#123;  <span class="comment">//if amount can use denom coin, apply the formula</span></span><br><span class="line">                <span class="keyword">if</span> (numOfCoins[amount - denom] = Integer.MAX_VALUE) &#123;</span><br><span class="line">                    toCompare = numOfCoins[amount - denom];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    toCompare = numOfCoins[amount - denom] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                numOfCoins[amount] = Math.min(numOfCoins[amount], toCompare);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfCoins[n] != Integer.MAX_VALUE ? numOfCoins[n] : - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="322-Coin-Change✨"><a href="#322-Coin-Change✨" class="headerlink" title="322. Coin Change✨"></a><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">min number</span><br><span class="line">amount-&gt; <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span></span><br><span class="line">types</span><br><span class="line"><span class="number">0</span>        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"><span class="number">1</span>(<span class="number">1</span>$)    <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span></span><br><span class="line"><span class="number">2</span>(<span class="number">5</span>$)    <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>(<span class="number">10</span>$)   <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dp[<span class="number">2</span>][<span class="number">5</span>] = Math.min(dp[<span class="number">1</span>][<span class="number">5</span>], <span class="number">1</span> + dp[<span class="number">2</span>][<span class="number">5</span> - <span class="number">5</span>]) = Math.min(<span class="number">5</span>, <span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">formula: dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], <span class="number">1</span> + dp[i][j - denom])</span><br><span class="line">nums[amount] = min(**`nums[amount]`**, **`<span class="number">1</span>(eg. a <span class="number">4</span>$ coin) + nums[amount - denom]`**)</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time complexity : O(S<em>n)*O</em>(<em>S</em>∗<em>n</em>). On each step the algorithm finds the next <em>F(i)*F</em>(*i<em>)</em> in n<em>n</em> iterations, where 1\leq i \leq S1≤<em>i</em>≤<em>S</em>. Therefore in total the iterations are S<em>n</em>S<em>∗</em>n*.</li>
<li>Space complexity : O(S)<em>O</em>(<em>S</em>). We use extra space for the memoization table.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tocompare = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> denom : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= denom) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i - denom] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    tocompare = dp[i - denom];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tocompare = dp[i - denom] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = Math.min(dp[i], tocompare);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] != Integer.MAX_VALUE ? dp[amount] : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：动态规划。使用和不使用每一种 Coin 对于每一种 Amount 的情况逐渐累加，直到达到 Amount。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    Arrays.fill(dp, max);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin)</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[i - coins[j]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ?  -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Levenshtein-Distance-AE-⭐"><a href="#Levenshtein-Distance-AE-⭐" class="headerlink" title="Levenshtein Distance(AE)⭐"></a>Levenshtein Distance(AE)⭐</h2><ol>
<li><p>Return the minimum of edit operations to turn string1 to string2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"abc"</span></span><br><span class="line">str2 = <span class="string">"yabd"</span></span><br><span class="line">insert <span class="string">'y'</span> -&gt; yabc</span><br><span class="line">substitude <span class="string">'d'</span> -&gt; yabd</span><br><span class="line"><span class="number">2</span> operations</span><br><span class="line">   <span class="string">""</span> y a b d  -&gt; row mean <span class="string">""</span>、<span class="string">"y"</span>、<span class="string">"ya"</span>、<span class="string">"yab"</span>、<span class="string">"yabd"</span></span><br><span class="line"><span class="string">""</span> <span class="number">0</span>  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">a  <span class="number">1</span>  <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">b  <span class="number">2</span>  <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">c  <span class="number">3</span>  <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">formula: </span><br><span class="line"><span class="keyword">if</span> str1[r] == str2[c]</span><br><span class="line">    E[r] [c] = E[r - <span class="number">1</span>] [c - <span class="number">1</span>], diagonally equal</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	E[r] [c] = <span class="number">1</span> + min(E[r] [c - <span class="number">1</span>], E[r - <span class="number">1</span>] [c], E[r - <span class="number">1</span>] [c - <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>time O(nm) | space O(nm) -&gt; O(min(n, m)) space</p>
</li>
</ol>
<h3 id="Solution1-19"><a href="#Solution1-19" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">levenshteinDistance</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] edits = <span class="keyword">new</span> <span class="keyword">int</span>[str2.length() + <span class="number">1</span>][str1.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//initial the base line</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str2.length() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str1.length() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            edits[i][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        edits[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//start traversal and apply the formula</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str2.length() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; str1.length() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str2.charAt(i - <span class="number">1</span>) == str1.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                edits[i][j] = edits[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                edits[i][j] = <span class="number">1</span> + Math.min(edits[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(edits[i - <span class="number">1</span>][j], edits[i][j - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edits[str2.length()][str1.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-10"><a href="#Solution2-10" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">levenshteinDistance</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    String small = str1.length() &lt; str2.length()? str1 : str2;</span><br><span class="line">    String big = str1.length() &gt;= str2.length()? str1 : str2;</span><br><span class="line">    <span class="keyword">int</span>[] evenEdits = <span class="keyword">new</span> <span class="keyword">int</span>[small.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] oddEdits = <span class="keyword">new</span> <span class="keyword">int</span>[small.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; small.length() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        evenEdits[j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] currentEdits;</span><br><span class="line">    <span class="keyword">int</span>[] previousEdits;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; big.length() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            currentEdits = oddEdits;</span><br><span class="line">            previousEdits = evenEdits;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentEdits = evenEdits;</span><br><span class="line">            previousEdits = oddEdits;</span><br><span class="line">        &#125;</span><br><span class="line">        currentEdits[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; small.length() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (big.charAt(j - <span class="number">1</span>) == small.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                currentEdits[j] = previousEdits[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentEdits[j] = <span class="number">1</span> + Math.min(previousEdits[j - <span class="number">1</span>], Math.min(previousEdits[j], currentEdits[j - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> big.length() % <span class="number">2</span> == <span class="number">0</span> ? evenEdits[small.length()] : oddEdits[small.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-583-Delete-Operation-for-Two-Strings"><a href="#Unsolved-583-Delete-Operation-for-Two-Strings" class="headerlink" title="Unsolved 583. Delete Operation for Two Strings"></a><a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">Unsolved 583. Delete Operation for Two Strings</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"sea"</span>, <span class="string">"eat"</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: You need one step to make <span class="string">"sea"</span> to <span class="string">"ea"</span> and another step to make <span class="string">"eat"</span> to <span class="string">"ea"</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-20"><a href="#Solution1-20" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="Unsolved-Max-Sum-Increasing-Subsequence-AE"><a href="#Unsolved-Max-Sum-Increasing-Subsequence-AE" class="headerlink" title="Unsolved Max Sum Increasing Subsequence(AE)"></a>Unsolved Max Sum Increasing Subsequence(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array [<span class="number">8</span>,   <span class="number">12</span>, <span class="number">2</span>,   <span class="number">3</span>,      <span class="number">15</span>, <span class="number">5</span> , <span class="number">7</span>]</span><br><span class="line">sums  [<span class="number">8</span>, <span class="number">8</span>+<span class="number">12</span>, <span class="number">2</span>, <span class="number">2</span>+<span class="number">3</span>, <span class="number">8</span>+<span class="number">12</span>+<span class="number">15</span>,  ]</span><br><span class="line">	  [<span class="number">8</span>, <span class="number">20</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">35</span>, ]</span><br><span class="line">sequ  [none,<span class="number">0</span>,none, <span class="number">2</span>, <span class="number">1</span>] (track the index)</span><br><span class="line">    </span><br><span class="line">formula:</span><br><span class="line">currentSum = array[i] (ex. i = <span class="number">5</span>)</span><br><span class="line">otherSum = array[j] <span class="number">0</span> =&lt; j &lt; i</span><br><span class="line">    <span class="keyword">if</span> otherSum &lt; currentSum and sums[j] + currentSum &gt;=  sums[i]</span><br><span class="line">        update sums</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-21"><a href="#Solution1-21" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Space O(n) Time O(n^2)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; maxSumIncreasingSubsequence(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] sequences = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    Arrays.fill(sequences, Integer.MIN_VALUE);</span><br><span class="line">    <span class="keyword">int</span>[] sums = array.clone();</span><br><span class="line">    <span class="keyword">int</span> maxSumIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> currentNum = array[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> otherNum = array[j];</span><br><span class="line">            <span class="keyword">if</span> (otherNum &lt; currentNum &amp;&amp; sums[j] + currentNum &gt;= sums[i]) &#123;</span><br><span class="line">                sums[i] = sums[j] + currentNum;</span><br><span class="line">                sequences[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sums[i] &gt;= sums[maxSumIdx]) &#123;</span><br><span class="line">            maxSumIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildSequence(array, sequences, maxSumIdx, sums[maxSumIdx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; buildSequence(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] sequences, <span class="keyword">int</span> currentIdx, <span class="keyword">int</span> sums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; sequence = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    sequence.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    sequence.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    sequence.get(<span class="number">0</span>).add(sums);</span><br><span class="line">    <span class="keyword">while</span> (currentIdx != Integer.MIN_VALUE) &#123;</span><br><span class="line">        sequence.get(<span class="number">1</span>).add(<span class="number">0</span>, array[currentIdx]);</span><br><span class="line">        currentIdx = sequences[currentIdx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Longest-Common-Subsequence-AE-✨"><a href="#Unsolved-Longest-Common-Subsequence-AE-✨" class="headerlink" title="Unsolved Longest Common Subsequence(AE)✨"></a>Unsolved Longest Common Subsequence(AE)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Str1:ZXVVYZW</span><br><span class="line">Str2:XKYKZPW</span><br><span class="line">   <span class="string">""</span>   X   K   Y   K   Z   P   W</span><br><span class="line"><span class="string">""</span> <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span></span><br><span class="line">Z  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>   Z   Z   Z</span><br><span class="line">X  <span class="string">""</span>   X   X   X   X   X   X   X</span><br><span class="line">V  <span class="string">""</span>   X   X   X   X   X   X   X</span><br><span class="line">V  <span class="string">""</span>   X   X   X   X   X   X   X</span><br><span class="line">Y  <span class="string">""</span>   X   X  XY  XY  XY  XY  XY</span><br><span class="line">Z  <span class="string">""</span>   X   X  XY  XY XYZ XYZ XYZ</span><br><span class="line">W  <span class="string">""</span>   X   X  XY  XY XYZ XYZ XYZW</span><br><span class="line">in pos[<span class="number">1</span>,<span class="number">1</span>] compare <span class="string">"Z"</span>,<span class="string">"X"</span> </span><br><span class="line">    last letter is not same so remove one become <span class="string">""</span>,<span class="string">"X"</span> or <span class="string">"Z"</span>,<span class="string">""</span> correspond to pos[<span class="number">0</span>,<span class="number">1</span>] pos[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">in pos[<span class="number">1</span>,<span class="number">2</span>] compare <span class="string">"Z"</span>,<span class="string">"XK"</span> <span class="comment">//same flow</span></span><br><span class="line">    last letter is not same so remove one become <span class="string">""</span>,<span class="string">"XK"</span> or <span class="string">"Z"</span>,<span class="string">"X"</span> correspond to pos[<span class="number">0</span>,<span class="number">2</span>] pos[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">in pos[<span class="number">1</span>,<span class="number">5</span>] compare <span class="string">"Z"</span>,<span class="string">"XKYKZ"</span></span><br><span class="line">    last letter is same, we remove last letter and add it to LCS, which is diagram pos[<span class="number">0</span>, <span class="number">4</span>] = <span class="string">""</span></span><br><span class="line">in pos[<span class="number">1</span>,<span class="number">6</span>] compare <span class="string">"Z"</span>,<span class="string">"XKYKZP"</span></span><br><span class="line">    last letter is not same, so remove one become <span class="string">""</span>,<span class="string">"XKYKZP"</span> or <span class="string">"Z"</span>,<span class="string">"XKYKZP"</span></span><br><span class="line">in pos[<span class="number">5</span>,<span class="number">3</span>] compare <span class="string">"ZXVVY"</span>,<span class="string">"XKY"</span></span><br><span class="line">    last letter is same, we remove last letter and add it to LCS, which is diagram pos[<span class="number">4</span>, <span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line">in pos[<span class="number">6</span>,<span class="number">3</span>] compare <span class="string">"ZXVVYZ"</span>,<span class="string">"XKY"</span></span><br><span class="line">    last letter is not same so remove one become <span class="string">"ZXVVY"</span>,<span class="string">"XKY"</span> or <span class="string">"ZXVVYZ"</span>,<span class="string">"XK"</span> correspond to pos[<span class="number">5</span>,<span class="number">3</span>] = <span class="string">"XY"</span> pos[<span class="number">6</span>,<span class="number">2</span>] = <span class="string">"X"</span>, take longer one</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-22"><a href="#Solution1-22" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>O(NM*min(N, M)) time, O(NM *min(N, M)) space </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Character&gt; <span class="title">longestCommonSubsequence</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;List&lt;Character&gt;&gt;&gt; lcs = <span class="keyword">new</span> ArrayList&lt;List&lt;List&lt;Character&gt;&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str2.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        lcs.add(<span class="keyword">new</span> ArrayList&lt;List&lt;Character&gt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str1.length() + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            lcs.get(i).add(<span class="keyword">new</span> ArrayList&lt;Character&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str2.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; str1.length() + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str2.charAt(i - <span class="number">1</span>) == str1.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">            	List&lt;Character&gt; copy = <span class="keyword">new</span> ArrayList&lt;Character&gt;(lcs.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>));</span><br><span class="line">	            lcs.get(i).set(j, copy);</span><br><span class="line">    	        lcs.get(i).get(j).add(str2.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lcs.get(i - <span class="number">1</span>).get(j).size() &gt; lcs.get(i).get(j - <span class="number">1</span>).size()) &#123;</span><br><span class="line">                    lcs.get(i).set(j, lcs.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lcs.get(i).set(j, lcs.get(i).get(j - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lcs.get(str2.length()).get(str1.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1143-Longest-Common-Subsequence✨"><a href="#1143-Longest-Common-Subsequence✨" class="headerlink" title="1143. Longest Common Subsequence✨"></a><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. Longest Common Subsequence✨</a></h3><h3 id="Solution1-23"><a href="#Solution1-23" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="Knapsack-Problem-AE"><a href="#Knapsack-Problem-AE" class="headerlink" title="Knapsack Problem(AE)"></a>Knapsack Problem(AE)</h2><h3 id="Solution1-24"><a href="#Solution1-24" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">first index represent the value</span><br><span class="line">second index represent the weight</span><br><span class="line">maximizing the value and the weight did not exceed the knapsack capacity</span><br><span class="line">build a <span class="number">2</span>D array</span><br><span class="line">capacity: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">[]        <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>  <span class="number">1</span></span><br><span class="line">[<span class="number">4</span>,<span class="number">3</span>]     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span>  <span class="number">5</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>]     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span>  <span class="number">9</span></span><br><span class="line">[<span class="number">6</span>,<span class="number">7</span>]     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> w &lt;= j</span><br><span class="line">	values[i][j] = Math.max(values[i - <span class="number">1</span>][j], value[i - <span class="number">1</span>][j - w] + v)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	values[i][j] = values[i - <span class="number">1</span>][j]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; knapsackProblem(<span class="keyword">int</span>[][] items, <span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] knapsackValues = <span class="keyword">new</span> <span class="keyword">int</span>[items.length + <span class="number">1</span>][capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; items.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> currentWeight = items[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> currentValue = items[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; capacity + <span class="number">1</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentWeight &gt; c) &#123;</span><br><span class="line">                knapsackValues[i][c] = knapsackValues[i - <span class="number">1</span>][c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                knapsackValues[i][c] = Math.max(knapsackValues[i - <span class="number">1</span>][c], knapsackValues[i - <span class="number">1</span>][c - currentWeight] + currentValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getKnapsackItems(knapsackValues, items, knapsackValues[items.length][capacity]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getKnapsackItems(<span class="keyword">int</span>[][] knapsackValues, <span class="keyword">int</span>[][] items, <span class="keyword">int</span> weight) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; sequence = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; totalWeight = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    totalWeight.add(weight);</span><br><span class="line">    sequence.add(totalWeight);</span><br><span class="line">    sequence.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">int</span> i = knapsackValues.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = knapsackValues[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (knapsackValues[i][c] == knapsackValues[i - <span class="number">1</span>][c]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence.get(<span class="number">1</span>).add(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">            c -= items[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Disk-Stacking-AE"><a href="#Disk-Stacking-AE" class="headerlink" title="Disk Stacking(AE)"></a>Disk Stacking(AE)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[2,2,1], [2,1,2],[3,2,3],[2,3,4],[4,4,5],[2,2,8]]</span><br><span class="line">width, depth, height</span><br><span class="line">sort by height</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-25"><a href="#Solution1-25" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer[]&gt; diskStacking(List&lt;Integer[]&gt; disks) &#123;</span><br><span class="line">    disks.sort((disk1, disk2) -&gt; disk1[<span class="number">2</span>].compareTo(disk[<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[disk.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disks.size(); i++) &#123;</span><br><span class="line">        heights[i] = disks.get(i)[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] sequences = <span class="keyword">new</span> <span class="keyword">int</span>[disks.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; disk.size(); i++) &#123;</span><br><span class="line">        Integer[] currentDisk = disks.get(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            Integer[] otehrDisk = disk.get(j);</span><br><span class="line">            <span class="keyword">if</span> (areValidDimensions(otherDisk, currentDisk)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (heights[i] &lt;= currentDisk[<span class="number">2</span>] + heights[j]) &#123;</span><br><span class="line">                    heights[i] = currentDIsk[<span class="number">2</span>] + heights[j];</span><br><span class="line">                    sequences[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heights[i] &gt;= heights[maxHeightIdx]) &#123;</span><br><span class="line">            maxHeightIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildSequence(disks, sequences, maxHeightIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="✅Number-of-Paths💜"><a href="#✅Number-of-Paths💜" class="headerlink" title="✅Number of Paths💜"></a><a href="https://github.com/JiawenQi98/PrampPractice/tree/master/Number%20of%20Paths" target="_blank" rel="noopener">✅Number of Paths💜</a></h2><p><img src="https://raw.githubusercontent.com/JiawenQi98/PrampPractice/master/Number%20of%20Paths/example.png" alt=""></p>
<ol>
<li><p>If you are already at the destination, there is obviously only one possible path to the destination, so we set the value for the destination to <code>1</code> (this would be the base case in your recursive version):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          ？</span><br><span class="line">        ? ?</span><br><span class="line">      ? ? ?</span><br><span class="line">    ? ? ? ?</span><br><span class="line">  ? ? ? ? ?</span><br><span class="line"><span class="number">1</span> ? ? ? ? ?</span><br></pre></td></tr></table></figure>

<p>Since every value in the lookup table is the sum of the value above it and the value to its right, we can first fill up the rightmost column from top to bottom (since the values in the rightmost column have no value to their right, every value in this column is identical to the value above it):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">1</span></span><br><span class="line">        ? <span class="number">1</span></span><br><span class="line">      ? ? <span class="number">1</span></span><br><span class="line">    ? ? ? <span class="number">1</span></span><br><span class="line">  ? ? ? ? <span class="number">1</span></span><br><span class="line">? ? ? ? ? <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Now we fill up the next rightmost column in the same way. The upmost element has no value above it, so it is identical to the value to its right.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">1</span></span><br><span class="line">        <span class="number">1</span> <span class="number">1</span></span><br><span class="line">      ? <span class="number">2</span> <span class="number">1</span></span><br><span class="line">    ? ? <span class="number">3</span> <span class="number">1</span></span><br><span class="line">  ? ? ? <span class="number">4</span> <span class="number">1</span></span><br><span class="line">? ? ? ? <span class="number">5</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Repeat this for all the other columns until you have the final lookup table:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">            ? ← destination</span><br><span class="line">          ? ?</span><br><span class="line">        ? ? ?</span><br><span class="line">      ? ? ? ?</span><br><span class="line">    ? ? ? ? ?</span><br><span class="line">  ? ? ? ? ? ?</span><br><span class="line">  ↑</span><br><span class="line">start</span><br><span class="line">                <span class="number">1</span></span><br><span class="line">             <span class="number">1</span>  <span class="number">1</span></span><br><span class="line">          <span class="number">2</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">       <span class="number">5</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">1</span></span><br><span class="line">   <span class="number">14</span> <span class="number">14</span>  <span class="number">9</span>  <span class="number">4</span>  <span class="number">1</span></span><br><span class="line"><span class="number">42</span> <span class="number">42</span> <span class="number">28</span> <span class="number">14</span>  <span class="number">5</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">calculate how many ways form current position to destination</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];     </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        dp[i][j] += dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOfPaths</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DP method: Time O(n^2), Space O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numOfPathsToDest</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">40</span>;</span><br><span class="line">        System.out.println(<span class="string">"Number of ways of n = "</span> + n1 + <span class="string">" is: "</span>+ numOfPathsToDest(n1));</span><br><span class="line">        System.out.println(<span class="string">"Number of ways of n = "</span> + n2 + <span class="string">" is: "</span>+ numOfPathsToDest(n2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62.Unique Paths"></a><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">62.Unique Paths</a></h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). </p>
<p>The robot can <strong>only move either down or right</strong> at any point in time. </p>
<p>The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there?</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt=""></p>
<p>Above is a 3 x 7 grid. How many possible unique paths are there? Note: m and n will be at most 100.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of <span class="number">3</span> ways to reach the bottom-right corner:</span><br><span class="line"><span class="number">1</span>. Right -&gt; Down -&gt; Down</span><br><span class="line"><span class="number">2</span>. Down -&gt; Down -&gt; Right</span><br><span class="line"><span class="number">3</span>. Down -&gt; Right -&gt; Down</span><br><span class="line">    </span><br><span class="line">Input: m = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">Output: <span class="number">28</span></span><br><span class="line">    </span><br><span class="line">formula dp[i] [j] = dp[i - <span class="number">1</span>] [j] + dp[i] [j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-26"><a href="#Solution1-26" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：动态规划，如果沿某边走则只有一种可能（初始化），然后内侧逐 1 添加可能性，当前可能性是上一 行和上一列相应位置的和。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        table[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        table[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; m; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">1</span>; column &lt; n; column++) &#123;</span><br><span class="line">            table[row][column] = table[row - <span class="number">1</span>][column] + table[row][column - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. Unique Paths II</a></h3><p>Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example, There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[ [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] ]</span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation:</span><br><span class="line">There is one obstacle in the middle of the <span class="number">3</span>x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line"><span class="number">1</span>. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line"><span class="number">2</span>. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure>

<p>The total number of unique paths is 2.</p>
<h3 id="Sulution1"><a href="#Sulution1" class="headerlink" title="Sulution1:"></a>Sulution1:</h3><ol>
<li>思路：动态规划。与上题解法类似，多一点碰障碍置零。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">//initial start point</span></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//initial upper boarder base line</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//initial left boarder base line</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//start traversal and apply the formula</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UnsolvedSolution2"><a href="#UnsolvedSolution2" class="headerlink" title="UnsolvedSolution2:"></a>UnsolvedSolution2:</h3><ol>
<li><a href="https://leetcode.com/problems/unique-paths-ii/discuss/23250/Short-JAVA-solution" target="_blank" rel="noopener">思路</a></li>
<li>More explanation:<br>This is a typical 2D DP problem, we can store value in 2D DP array, but since we only need to use value at dp[i - 1][j] and dp[i][j - 1] to update dp[i][j], we don’t need to store the whole 2D table, but instead store value in an 1D array, and update data by using dp[j] = dp[j] + dp[j - 1], (where here dp[j] corresponding to the dp[i - 1][j]) and dp[j - 1] corresponding to the dp[i][j - 1] in the 2D array)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> width = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[width];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] row : obstacleGrid) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[j] == <span class="number">1</span>)</span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[width - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="70-Climbing-Stairs✨"><a href="#70-Climbing-Stairs✨" class="headerlink" title="70. Climbing Stairs✨"></a><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing Stairs✨</a></h2><h3 id="Solution1-27"><a href="#Solution1-27" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Basically it’s a fibonacci.</p>
<p>Base cases:<br>if n &lt;= 0, then the number of ways should be zero.<br>if n == 1, then there is only way to climb the stair.<br>if n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time.</p>
</li>
<li><p>The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points <code>[n-1]</code> and <code>[n-2]</code> respectively, denoted as <code>n1</code> and <code>n2</code> , then the total ways to get to the point <code>[n]</code> is <code>n1 + n2</code>. Because from the <code>[n-1]</code> point, we can take one single step to reach <code>[n]</code>. And from the <code>[n-2]</code> point, we could take two steps to get there.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base cases</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] ways = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    ways[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    ways[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ways[i] = ways[i - <span class="number">1</span>] + ways[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-11"><a href="#Solution2-11" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>sliding windows</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] steps = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = steps[<span class="number">0</span>] + steps[<span class="number">1</span>];</span><br><span class="line">        steps[<span class="number">0</span>] = steps[<span class="number">1</span>];</span><br><span class="line">        steps[<span class="number">1</span>] = cur;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = first + second;</span><br><span class="line">        first = second;</span><br><span class="line">        second = cur;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">1</span> ? second : first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-1659-Maximize-Grid-Happiness"><a href="#Unsolved-1659-Maximize-Grid-Happiness" class="headerlink" title="Unsolved 1659. Maximize Grid Happiness"></a><a href="https://leetcode.com/problems/maximize-grid-happiness/" target="_blank" rel="noopener">Unsolved 1659. Maximize Grid Happiness</a></h2><h2 id="1621-Number-of-Sets-of-K-Non-Overlapping-Line-Segments🎃"><a href="#1621-Number-of-Sets-of-K-Non-Overlapping-Line-Segments🎃" class="headerlink" title="1621. Number of Sets of K Non-Overlapping Line Segments🎃"></a><a href="https://leetcode.com/contest/biweekly-contest-37/problems/number-of-sets-of-k-non-overlapping-line-segments/" target="_blank" rel="noopener">1621. Number of Sets of K Non-Overlapping Line Segments🎃</a></h2><h2 id="Solution1-28"><a href="#Solution1-28" class="headerlink" title="Solution1:"></a>Solution1:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Integer[][][] memo;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSets</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.memo = <span class="keyword">new</span> Integer[n+<span class="number">1</span>][k+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp(<span class="number">0</span>, k, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k, <span class="keyword">int</span> isStart)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memo[i][k][isStart] != <span class="keyword">null</span>) <span class="keyword">return</span> memo[i][k][isStart];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// Found a way to draw k valid segments</span></span><br><span class="line">    <span class="keyword">if</span> (i == n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Reach end of points</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = dp(i+<span class="number">1</span>, k, isStart); <span class="comment">// Skip ith point</span></span><br><span class="line">    <span class="keyword">if</span> (isStart == <span class="number">1</span>)</span><br><span class="line">        ans += dp(i+<span class="number">1</span>, k, <span class="number">0</span>); <span class="comment">// Take ith point as start</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans += dp(i, k-<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// Take ith point as end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[i][k][isStart] = ans % <span class="number">1_000_000_007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="343-Integer-Break"><a href="#343-Integer-Break" class="headerlink" title="343. Integer Break"></a><a href="https://leetcode.com/problems/integer-break/" target="_blank" rel="noopener">343. Integer Break</a></h2><h3 id="Solution1-29"><a href="#Solution1-29" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Integer[] dp = <span class="keyword">new</span> Integer[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> findMaxValue(n, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxValue</span><span class="params">(<span class="keyword">int</span> n, Integer[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[n] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> curMax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            curMax = Math.max(curMax, i * findMaxValue(n - i, dp));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n] = curMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="516-Unsolved-Longest-Palindromic-Subsequence"><a href="#516-Unsolved-Longest-Palindromic-Subsequence" class="headerlink" title="516. Unsolved Longest Palindromic Subsequence"></a><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. Unsolved Longest Palindromic Subsequence</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]`: the longest palindromic subsequence<span class="string">'s length of substring(i, j), here i, j represent left, right indexes in the string</span></span><br><span class="line"><span class="string">`State transition`:</span></span><br><span class="line"><span class="string">`dp[i][j] = dp[i+1][j-1] + 2` if s.charAt(i) == s.charAt(j)</span></span><br><span class="line"><span class="string">otherwise, `dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])`</span></span><br><span class="line"><span class="string">`Initialization`: `dp[i][i] = 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-30"><a href="#Solution1-30" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()][s.length()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][s.length()-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="486-Predict-the-Winner"><a href="#486-Predict-the-Winner" class="headerlink" title="486. Predict the Winner"></a><a href="https://leetcode.com/problems/predict-the-winner/" target="_blank" rel="noopener">486. Predict the Winner</a></h2><h3 id="Solution1-31"><a href="#Solution1-31" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="Unsolved-787-Cheapest-Flights-Within-K-Stops🎂"><a href="#Unsolved-787-Cheapest-Flights-Within-K-Stops🎂" class="headerlink" title="Unsolved 787. Cheapest Flights Within K Stops🎂"></a><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 787. Cheapest Flights Within K Stops🎂</a></h2><h2 id="Unsolved-1373-Maximum-Sum-BST-in-Binary-Tree🎂✨"><a href="#Unsolved-1373-Maximum-Sum-BST-in-Binary-Tree🎂✨" class="headerlink" title="Unsolved 1373. Maximum Sum BST in Binary Tree🎂✨"></a><a href="https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 1373. Maximum Sum BST in Binary Tree🎂✨</a></h2><h2 id="Unsolved-44-Wildcard-Matching🎂✨"><a href="#Unsolved-44-Wildcard-Matching🎂✨" class="headerlink" title="Unsolved 44. Wildcard Matching🎂✨"></a><a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">Unsolved 44. Wildcard Matching🎂✨</a></h2><h3 id="Solution1-32"><a href="#Solution1-32" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：动态规划。推理条件：如果 p 是<em>，则与 p 或 s 上一位置结果相同；如果不是</em>，则看当前字符是否 match。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != <span class="string">'*'</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                &amp;&amp; (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>)</span><br><span class="line">                    || p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-12"><a href="#Solution2-12" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>The basic idea is to have one pointer for the string and one pointer for the pattern. This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step.</li>
<li><a href="https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution" target="_blank" rel="noopener">explanation</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">comparison</span><span class="params">(String str, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, p = <span class="number">0</span>, match = <span class="number">0</span>, starIdx = -<span class="number">1</span>;            </span><br><span class="line">    <span class="keyword">while</span> (s &lt; str.length())&#123;</span><br><span class="line">        <span class="comment">// advancing both pointers</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; pattern.length()  &amp;&amp; (pattern.charAt(p) == <span class="string">'?'</span> || str.charAt(s) == pattern.charAt(p)))&#123;</span><br><span class="line">            s++;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// * found, only advancing pattern pointer</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            starIdx = p;</span><br><span class="line">            match = s;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// last pattern pointer was *, advancing string pointer</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (starIdx != -<span class="number">1</span>)&#123;</span><br><span class="line">            p = starIdx + <span class="number">1</span>;</span><br><span class="line">            match++;</span><br><span class="line">            s = match;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//current pattern pointer is not star, last patter pointer was not *</span></span><br><span class="line">        <span class="comment">//characters do not match</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//check for remaining characters in pattern</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == <span class="string">'*'</span>)</span><br><span class="line">        p++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p == pattern.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="256-Paint-House"><a href="#256-Paint-House" class="headerlink" title="256. Paint House"></a><a href="https://leetcode.com/problems/paint-house/" target="_blank" rel="noopener">256. Paint House</a></h2><h3 id="Solution1-33"><a href="#Solution1-33" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">        costs[i][<span class="number">0</span>] += Math.min(costs[i - <span class="number">1</span>][<span class="number">1</span>], costs[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        costs[i][<span class="number">1</span>] += Math.min(costs[i - <span class="number">1</span>][<span class="number">0</span>], costs[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        costs[i][<span class="number">2</span>] += Math.min(costs[i - <span class="number">1</span>][<span class="number">0</span>], costs[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = Math.min(costs[costs.length - <span class="number">1</span>][<span class="number">0</span>], costs[costs.length - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    min = Math.min(min, costs[costs.length - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-464-Can-I-Win🎂"><a href="#Unsolved-464-Can-I-Win🎂" class="headerlink" title="Unsolved 464. Can I Win🎂"></a><a href="https://leetcode.com/problems/can-i-win/" target="_blank" rel="noopener">Unsolved 464. Can I Win🎂</a></h2><h3 id="Solution1-34"><a href="#Solution1-34" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><a href="https://leetcode.com/problems/can-i-win/discuss/95277/Java-solution-using-HashMap-with-detailed-explanation" target="_blank" rel="noopener">explanation</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (desiredTotal&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxChoosableInteger*(maxChoosableInteger+<span class="number">1</span>)/<span class="number">2</span>&lt;desiredTotal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> canIWin(desiredTotal, <span class="keyword">new</span> <span class="keyword">int</span>[maxChoosableInteger], <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">int</span>[] state, HashMap&lt;String, Boolean&gt; hashMap)</span> </span>&#123;</span><br><span class="line">    String curr=Arrays.toString(state);</span><br><span class="line">    <span class="keyword">if</span> (hashMap.containsKey(curr)) <span class="keyword">return</span> hashMap.get(curr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;state.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state[i]==<span class="number">0</span>) &#123;</span><br><span class="line">            state[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (total&lt;=i+<span class="number">1</span> || !canIWin(total-(i+<span class="number">1</span>), state, hashMap)) &#123;</span><br><span class="line">                hashMap.put(curr, <span class="keyword">true</span>);</span><br><span class="line">                state[i]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            state[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hashMap.put(curr, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1664-Ways-to-Make-a-Fair-Array"><a href="#1664-Ways-to-Make-a-Fair-Array" class="headerlink" title="1664. Ways to Make a Fair Array"></a><a href="https://leetcode.com/problems/ways-to-make-a-fair-array/" target="_blank" rel="noopener">1664. Ways to Make a Fair Array</a></h2><h3 id="Solution1-35"><a href="#Solution1-35" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Explanation</p>
<p>We will split the array into two parts, <code>left</code> and <code>right</code>.<br>Firstly we count the sum to an array <code>right</code>,<br>where <code>right[0] = A[0] + A[2] +...</code><br>and <code>right[1] = A[1] + A[3] +...</code></p>
<p>Now we iterates the whole array <code>A</code>, and try to split at each <code>A[i]</code>.<br>When move one element from <code>right</code> to <code>left</code>,<br>we reduce the sum in <code>right</code>,<br>check the if it’s fair,<br>then increse the sum in <code>left</code>.</p>
<p>Complexity</p>
<p>Time <code>O(N)</code><br>Space <code>O(1)</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToMakeFair</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sumEven = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sumOdd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) sumEven += nums[i];</span><br><span class="line">        <span class="keyword">else</span> sumOdd += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curEven = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curOdd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEven + sumOdd - curOdd == curOdd + sumEven - curEven - nums[i]) count++;</span><br><span class="line">            curEven += nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEven + sumOdd - curOdd - nums[i] == curOdd + sumEven - curEven) count++;</span><br><span class="line">            curOdd += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Grokking-Dynamic-Programming-Patterns-for-Coding-Interviews"><a href="#Grokking-Dynamic-Programming-Patterns-for-Coding-Interviews" class="headerlink" title="Grokking Dynamic Programming Patterns for Coding Interviews"></a>Grokking Dynamic Programming Patterns for Coding Interviews</h1><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="Nth-Fib"><a href="#Nth-Fib" class="headerlink" title="Nth Fib"></a>Nth Fib</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CalculateFibonacci(n-<span class="number">1</span>) + CalculateFibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-with-Memoization"><a href="#Top-down-with-Memoization" class="headerlink" title="Top-down with Memoization"></a>Top-down with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> memoize[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> CalculateFibonacciRecursive(memoize, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacciRecursive</span><span class="params">(<span class="keyword">int</span>[] memoize, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have already solved this subproblem, simply return the result from the cache</span></span><br><span class="line">    <span class="keyword">if</span>(memoize[n] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> memoize[n];</span><br><span class="line"></span><br><span class="line">    memoize[n] = CalculateFibonacciRecursive(memoize, n-<span class="number">1</span>) + CalculateFibonacciRecursive(memoize, n-<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memoize[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-with-Tabulation"><a href="#Bottom-up-with-Tabulation" class="headerlink" title="Bottom-up with Tabulation"></a>Bottom-up with Tabulation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base cases</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pattern-1-0-1-Knapsack"><a href="#Pattern-1-0-1-Knapsack" class="headerlink" title="Pattern 1: 0/1 Knapsack"></a>Pattern 1: 0/1 Knapsack</h1><h2 id="🌕0-1-Knapsack✨"><a href="#🌕0-1-Knapsack✨" class="headerlink" title="🌕0/1 Knapsack✨"></a>🌕0/1 Knapsack✨</h2><h3 id="brute-force-solution-1"><a href="#brute-force-solution-1" class="headerlink" title="brute-force solution"></a>brute-force solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n) recursion tree</span></span><br><span class="line"><span class="comment">//Space O(n) call stack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after choosing the element at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the weight of the element at currentIndex exceeds the capacity, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( weights[currentIndex] &lt;= capacity ) &#123;</span><br><span class="line">        profit1 = profits[currentIndex] + knapsackRecursive(profits, weights, capacity - weights[currentIndex], currentIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the element at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> profit2 = knapsackRecursive(profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(profit1, profit2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-3"><a href="#Top-down-Dynamic-Programming-with-Memoization-3" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(N * C) N * C sub problems</span></span><br><span class="line"><span class="comment">//Space O(N * C + N) dp array + call stack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[profits.length][capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(dp, profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(Integer[][] dp, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] profits, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] weights, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> capacity, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex][capacity] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( weights[currentIndex] &lt;= capacity ) &#123;</span><br><span class="line">            profit1 = profits[currentIndex] + knapsackRecursive(dp, profits, weights, capacity - weights[currentIndex], currentIndex + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit2 = knapsackRecursive(dp, profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line">        dp[currentIndex][capacity] = Math.max(profit1, profit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have already solved a similar problem, return the result from memory directly</span></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since our memoization array <code>dp[profits.length][capacity+1]</code> stores the results for all the subproblems, we can conclude that we will not have more than N<em>C</em>N<em>∗</em>C* subproblems (where ‘N’ is the number of items and ‘C’ is the knapsack capacity). This means that our time complexity will be O(N<em>C)*O</em>(<em>N</em>∗<em>C</em>).</p>
<p>The above algorithm will be using O(N<em>C)*O</em>(<em>N</em>∗<em>C</em>) space for the memoization array. Other than that, we will use O(N)<em>O</em>(<em>N</em>) space for the recursion call-stack. So the total space complexity will be O(N<em>C + N)*O</em>(<em>N</em>∗<em>C</em>+<em>N</em>), which is asymptotically equivalent to O(N<em>C)*O</em>(<em>N</em>∗<em>C</em>).</p>
<h3 id="Bottom-up-Dynamic-Programming-5"><a href="#Bottom-up-Dynamic-Programming-5" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><p><strong>This means, <code>dp[i][c]</code> will represent the maximum knapsack profit for capacity ‘c’ calculated from the first ‘i’ items.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][c] &#x3D; max (dp[i-1][c], profits[i] + dp[i-1][c-weights[i]])</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// basic checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = profits.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the capacity=0 columns, with '0' capacity we have '0' profit</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have only one weight, we will take it if it is not more than the capacity</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(weights[<span class="number">0</span>] &lt;= c)</span><br><span class="line">            dp[<span class="number">0</span>][c] = profits[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// process all sub-arrays for all the capacities</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit1= <span class="number">0</span>, profit2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// include the item, if it is not more than the capacity</span></span><br><span class="line">            <span class="keyword">if</span>(weights[i] &lt;= c)</span><br><span class="line">                profit1 = profits[i] + dp[i-<span class="number">1</span>][c-weights[i]];</span><br><span class="line">            <span class="comment">// exclude the item</span></span><br><span class="line">            profit2 = dp[i-<span class="number">1</span>][c];</span><br><span class="line">            <span class="comment">// take maximum</span></span><br><span class="line">            dp[i][c] = Math.max(profit1, profit2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maximum profit will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Equal-Subset-Sum-Partition✨"><a href="#🌕Equal-Subset-Sum-Partition✨" class="headerlink" title="🌕Equal Subset Sum Partition✨"></a>🌕Equal Subset Sum Partition✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 1, 3, 4, 7&#125;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: The given set can be partitioned into two subsets with equal sum: &#123;1, 3, 4&#125; &amp; &#123;1, 7&#125;</span><br></pre></td></tr></table></figure>

<h3 id="brute-force-algorithm-1"><a href="#brute-force-algorithm-1" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n) exponential</span></span><br><span class="line"><span class="comment">//Space O(n) recursion stack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 'sum' is a an odd number, we can't have two subsets with equal sum</span></span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(num, sum/<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPartitionRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after choosing the number at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">if</span>(num[currentIndex] &lt;= sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(canPartitionRecursive(num, sum - num[currentIndex], currentIndex + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">    <span class="keyword">return</span> canPartitionRecursive(num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-4"><a href="#Top-down-Dynamic-Programming-with-Memoization-4" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 'sum' is a an odd number, we can't have two subsets with equal sum</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Boolean[][] dp = <span class="keyword">new</span> Boolean[num.length][sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(dp, num, sum / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPartitionRecursive</span><span class="params">(Boolean[][] dp, <span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have not already processed a similar problem</span></span><br><span class="line">    <span class="keyword">if</span> (dp[currentIndex][sum] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// recursive call after choosing the number at the currentIndex</span></span><br><span class="line">        <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">        <span class="keyword">if</span> (num[currentIndex] &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canPartitionRecursive(dp, num, sum - num[currentIndex], currentIndex + <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[currentIndex][sum] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">        dp[currentIndex][sum] = canPartitionRecursive(dp, num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-6"><a href="#Bottom-up-Dynamic-Programming-6" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="comment">// find the total sum</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 'sum' is a an odd number, we can't have two subsets with same total</span></span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we are trying to find a subset of given numbers that has a total sum of ‘sum/2’.</span></span><br><span class="line">    sum /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 column, as we can always have '0' sum without including any element</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to its value</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            <span class="comment">// if we can get the sum 's' without the number at index 'i'</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][s]) &#123;</span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123; <span class="comment">// else if we can find a subset to get the remaining sum</span></span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="416-Partition-Equal-Subset-Sum✨-1"><a href="#416-Partition-Equal-Subset-Sum✨-1" class="headerlink" title="416. Partition Equal Subset Sum✨"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. Partition Equal Subset Sum✨</a></h3><h3 id="Solution0-3"><a href="#Solution0-3" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute Force</li>
<li>Time exceed</li>
<li>Time Complexity : \mathcal{O}(2^{n})O(2<em>n</em>), where n<em>n</em> is equal to number of array elements. The recursive solution takes the form of a binary tree where there are 2 possibilities for every array element and the maximum depth of the tree could be n<em>n</em>. The time complexity is exponential, hence this approach is exhaustive and results in <em>Time Limit Exceeded (TLE)</em>.</li>
<li>Space Complexity: \mathcal{O}(N)O(<em>N</em>) This space will be used to store the recursion stack. We can’t have more than n<em>n</em> recursive calls on the call stack at any time.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(2^n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// find sum of all array elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        totalSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if totalSum is odd,it cannot be partitioned into equal sum subset</span></span><br><span class="line">    <span class="keyword">if</span> (totalSum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> subSetSum = totalSum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, n - <span class="number">1</span>, subSetSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> subSetSum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base Cases</span></span><br><span class="line">    <span class="keyword">if</span> (subSetSum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || subSetSum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, n - <span class="number">1</span>, subSetSum - nums[n - <span class="number">1</span>]) || dfs(nums, n - <span class="number">1</span>, subSetSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-36"><a href="#Solution1-36" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time Complexity : \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>).<ul>
<li>In the worst case where there is no overlapping calculation, the maximum number of entries in the <code>memo</code> would be m \cdot n<em>m</em>⋅<em>n</em>. For each entry, overall we could consider that it takes constant time, <em>i.e.</em> each invocation of <code>dfs()</code> at most emits one entry in the <code>memo</code>.</li>
<li>The overall computation is proportional to the number of entries in <code>memo</code>. Hence, the overall time complexity is \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>).</li>
</ul>
</li>
<li>Space Complexity: \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>). We are using a 2 dimensional array \text{memo}memo of size (m \cdot n)(<em>m</em>⋅<em>n</em>) and \mathcal{O}(n)O(<em>n</em>) space to store the recursive call stack. This gives us the space complexity as \mathcal{O}(n)O(<em>n</em>) + \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>) = \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// find sum of all array elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        totalSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if totalSum is odd, it cannot be partitioned into equal sum subset</span></span><br><span class="line">    <span class="keyword">if</span> (totalSum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> subSetSum = totalSum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    Boolean[][] memo = <span class="keyword">new</span> Boolean[n + <span class="number">1</span>][subSetSum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, n - <span class="number">1</span>, subSetSum, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, <span class="keyword">int</span> subSetSum, Boolean[][] memo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base Cases</span></span><br><span class="line">    <span class="keyword">if</span> (subSetSum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span> || subSetSum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// check if subSetSum for given n is already computed and stored in memo</span></span><br><span class="line">    <span class="keyword">if</span> (memo[idx][subSetSum] != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[n][subSetSum];</span><br><span class="line">    <span class="keyword">boolean</span> result = dfs(nums, idx - <span class="number">1</span>, subSetSum - nums[idx - <span class="number">1</span>], memo) ||</span><br><span class="line">        dfs(nums, idx - <span class="number">1</span>, subSetSum, memo);</span><br><span class="line">    <span class="comment">// store the result in memo</span></span><br><span class="line">    memo[idx][subSetSum] = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Subset-Sum"><a href="#Subset-Sum" class="headerlink" title="Subset Sum"></a>Subset Sum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 2, 3, 7&#125;, S&#x3D;6</span><br><span class="line">Output: True</span><br><span class="line">The given set has a subset whose sum is &#39;6&#39;: &#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>

<h3 id="brute-force-algorithm-2"><a href="#brute-force-algorithm-2" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each number &#39;i&#39; </span><br><span class="line">  create a new set which INCLUDES number &#39;i&#39; if it does not exceed &#39;S&#39;, and recursively </span><br><span class="line">     process the remaining numbers</span><br><span class="line">  create a new set WITHOUT number &#39;i&#39;, and recursively process the remaining numbers </span><br><span class="line">return true if any of the above two sets has a sum equal to &#39;S&#39;, otherwise return false</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-5"><a href="#Top-down-Dynamic-Programming-with-Memoization-5" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> Write - Your - Code</span></span><br><span class="line">    Boolean[][] dp = <span class="keyword">new</span> Boolean[num.length][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> partition(<span class="number">0</span>, num, sum, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, Boolean[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num.length == <span class="number">0</span> || idx &gt;= num.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][sum] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[idx] &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (partition(idx + <span class="number">1</span>, num, sum - num[idx], dp)) &#123;</span><br><span class="line">                dp[idx][sum] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx][sum] = partition(idx + <span class="number">1</span>, num, sum, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-7"><a href="#Bottom-up-Dynamic-Programming-7" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we can always form '0' sum with an empty set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is</span></span><br><span class="line">    <span class="comment">// equal to its value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            <span class="comment">// if we can get the sum 's' without the number at index 'i'</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][s]) &#123;</span><br><span class="line">                dp[i][s] = dp[i - <span class="number">1</span>][s];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                <span class="comment">// else include the number and see if we can find a subset to get the remaining</span></span><br><span class="line">                <span class="comment">// sum</span></span><br><span class="line">                dp[i][s] = dp[i - <span class="number">1</span>][s - num[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[num.length - <span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minimum-Subset-Sum-Difference"><a href="#Minimum-Subset-Sum-Difference" class="headerlink" title="Minimum Subset Sum Difference"></a>Minimum Subset Sum Difference</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 2, 3, 9&#125;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can partition the given set into two subsets where minimum absolute difference </span><br><span class="line">between the sum of numbers is &#39;3&#39;. Following are the two subsets: &#123;1, 2, 3&#125; &amp; &#123;9&#125;.</span><br><span class="line"></span><br><span class="line">Input: &#123;1, 2, 7, 1, 5&#125;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: We can partition the given set into two subsets where minimum absolute difference </span><br><span class="line">between the sum of number is &#39;0&#39;. Following are the two subsets: &#123;1, 2, 5&#125; &amp; &#123;7, 1&#125;.</span><br></pre></td></tr></table></figure>

<h3 id="brute-force-algorithm-3"><a href="#brute-force-algorithm-3" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for each number &#39;i&#39; </span><br><span class="line">  add number &#39;i&#39; to S1 and recursively process the remaining numbers</span><br><span class="line">  add number &#39;i&#39; to S2 and recursively process the remaining numbers</span><br><span class="line">return the minimum absolute difference of the above two sets</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n)</span></span><br><span class="line"><span class="comment">//Space O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(num, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">canPartitionRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> sum1, <span class="keyword">int</span> sum2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (currentIndex == num.length)</span><br><span class="line">        <span class="keyword">return</span> Math.abs(sum1 - sum2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after including the number at the currentIndex in the first set</span></span><br><span class="line">    <span class="keyword">int</span> diff1 = canPartitionRecursive(num, currentIndex+<span class="number">1</span>, sum1+num[currentIndex], sum2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after including the number at the currentIndex in the second set</span></span><br><span class="line">    <span class="keyword">int</span> diff2 = canPartitionRecursive(num, currentIndex+<span class="number">1</span>, sum1, sum2+num[currentIndex]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(diff1, diff2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-6"><a href="#Top-down-Dynamic-Programming-with-Memoization-6" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">      sum += num[i];</span><br><span class="line"></span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[num.length][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(dp, num, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">canPartitionRecursive</span><span class="params">(Integer[][] dp, <span class="keyword">int</span>[] num, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> sum1, <span class="keyword">int</span> sum2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex == num.length)</span><br><span class="line">      <span class="keyword">return</span> Math.abs(sum1 - sum2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we have not already processed similar problem</span></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex][sum1] == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// recursive call after including the number at the currentIndex in the first set</span></span><br><span class="line">      <span class="keyword">int</span> diff1 = canPartitionRecursive(dp, num, currentIndex + <span class="number">1</span>, sum1 + num[currentIndex], sum2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// recursive call after including the number at the currentIndex in the second set</span></span><br><span class="line">      <span class="keyword">int</span> diff2 = canPartitionRecursive(dp, num, currentIndex + <span class="number">1</span>, sum1, sum2 + num[currentIndex]);</span><br><span class="line"></span><br><span class="line">      dp[currentIndex][sum1] = Math.min(diff1, diff2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][sum1];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-8"><a href="#Bottom-up-Dynamic-Programming-8" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum/<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we can always form '0' sum with an empty set</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to that number</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum/<span class="number">2</span> ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum/<span class="number">2</span>; s++) &#123;</span><br><span class="line">            <span class="comment">// if we can get the sum 's' without the number at index 'i'</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][s]) &#123;</span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                <span class="comment">// else include the number and see if we can find a subset to get the remaining sum</span></span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Find the largest index in the last row which is true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sum / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n-<span class="number">1</span>][i] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            sum1 = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum2 = sum - sum1;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(sum2-sum1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Count-of-Subset-Sum"><a href="#🌕Count-of-Subset-Sum" class="headerlink" title="🌕Count of Subset Sum"></a>🌕Count of Subset Sum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 1, 2, 3&#125;, S&#x3D;4</span><br><span class="line">Output: 3</span><br><span class="line">The given set has &#39;3&#39; subsets whose sum is &#39;4&#39;: &#123;1, 1, 2&#125;, &#123;1, 3&#125;, &#123;1, 3&#125;</span><br><span class="line">Note that we have two similar sets &#123;1, 3&#125;, because we have two &#39;1&#39; in our input.</span><br><span class="line"></span><br><span class="line">Input: &#123;1, 2, 7, 1, 5&#125;, S&#x3D;9</span><br><span class="line">Output: 3</span><br><span class="line">The given set has &#39;3&#39; subsets whose sum is &#39;9&#39;: &#123;2, 7&#125;, &#123;1, 7, 1&#125;, &#123;1, 2, 1, 5&#125;</span><br></pre></td></tr></table></figure>

<h3 id="brute-force-algorithm-4"><a href="#brute-force-algorithm-4" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each number &#39;i&#39; </span><br><span class="line">  create a new set which includes number &#39;i&#39; if it does not exceed &#39;S&#39;, and recursively   </span><br><span class="line">      process the remaining numbers and sum</span><br><span class="line">  create a new set without number &#39;i&#39;, and recursively process the remaining numbers </span><br><span class="line">return the count of subsets who has a sum equal to &#39;S&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countSubsetsRecursive(num, sum, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSubsetsRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the number at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( num[currentIndex] &lt;= sum )</span><br><span class="line">        sum1 = countSubsetsRecursive(num, sum - num[currentIndex], currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> sum2 = countSubsetsRecursive(num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-7"><a href="#Top-down-Dynamic-Programming-with-Memoization-7" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countSubsetsRecursive(num, sum, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSubsetsRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the number at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][sum] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[idx] &lt;= sum) &#123;</span><br><span class="line">            sum1 = count(idx + <span class="number">1</span>, num, sum - num[idx], dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = count(idx + <span class="number">1</span>, num, sum, dp);</span><br><span class="line">        dp[idx][sum] = sum1 + sum2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-9"><a href="#Bottom-up-Dynamic-Programming-9" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we will always have an empty set for zero sum</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to its value</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            <span class="comment">// exclude the number</span></span><br><span class="line">            dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            <span class="comment">// include the number, if it does not exceed the sum</span></span><br><span class="line">            <span class="keyword">if</span>(s &gt;= num[i])</span><br><span class="line">                dp[i][s] += dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[num.length-<span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Target-Sum"><a href="#🌕Target-Sum" class="headerlink" title="🌕Target Sum"></a>🌕Target Sum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 1, 2, 3&#125;, S&#x3D;1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The given set has &#39;3&#39; ways to make a sum of &#39;1&#39;: &#123;+1-1-2+3&#125; &amp; &#123;-1+1-2+3&#125; &amp; &#123;+1+1+2-3&#125;</span><br><span class="line"></span><br><span class="line">Input: &#123;1, 2, 7, 1&#125;, S&#x3D;9</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The given set has &#39;2&#39; ways to make a sum of &#39;9&#39;: &#123;+1+2+7-1&#125; &amp; &#123;-1+2+7+1&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">We are asked to find two subsets of the given numbers whose difference is equal to the given target ‘S’. Take the first example above. As we saw, one solution is &#123;+1-1-2+3&#125;. So, the two subsets we are asked to find are &#123;1, 3&#125; &amp; &#123;1, 2&#125; because,</span><br><span class="line">(1 + 3) - (1 + 2 ) &#x3D; 1</span><br><span class="line"></span><br><span class="line">Sum(s1) - Sum(s2) &#x3D; S</span><br><span class="line">Sum(s1) + Sum(s2) &#x3D; Sum(num)</span><br><span class="line">Let’s add the above two equations:</span><br><span class="line">&#x3D;&gt; Sum(s1) - Sum(s2) + Sum(s1) + Sum(s2) &#x3D; S + Sum(num)</span><br><span class="line">&#x3D;&gt; 2 * Sum(s1) &#x3D;  S + Sum(num)</span><br><span class="line">&#x3D;&gt; Sum(s1) &#x3D; (S + Sum(num)) &#x2F; 2</span><br><span class="line"></span><br><span class="line">This essentially converts our problem to: “Find count of subsets of the given numbers whose sum is equal to”,</span><br><span class="line">&#x3D;&gt; (S + Sum(num)) &#x2F; 2</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The above solution has time O(N*S)</span></span><br><span class="line"><span class="comment">//space complexity of O(N∗S), where ‘N’ represents total numbers and ‘S’ is the desired sum.</span></span><br><span class="line"></span><br><span class="line"><span class="function">We can further improve the solution to use only <span class="title">O</span><span class="params">(S)</span><span class="title">O</span><span class="params">(S)</span> space.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num)&#123;</span><br><span class="line">        totalSum += n;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//invalid input, the problem expects only positive numbers</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 's + totalSum' is odd, we can't find a subset with sum equal to '(s + totalSum) / 2'</span></span><br><span class="line">    <span class="keyword">if</span>(totalSum &lt; s || (s + totalSum) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> countSubsets(num, (s + totalSum) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this function is exactly similar to what we have in 'Count of Subset Sum' problem.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we will always have an empty set for zero sum</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to the number</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            <span class="keyword">if</span>(s &gt;= num[i])</span><br><span class="line">                dp[i][s] += dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[num.length-<span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🌕Unsolved-494-Target-Sum✨"><a href="#🌕Unsolved-494-Target-Sum✨" class="headerlink" title="🌕Unsolved 494. Target Sum✨"></a><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">🌕Unsolved 494. Target Sum✨</a></h3><h3 id="Solution1-37"><a href="#Solution1-37" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>DFS</p>
</li>
<li><p>题目大意：给你一串数字，你可以在每个数字前放置+或-，问有多少种方法可以使得表达式的值等于target。You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p>
<p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p>
</li>
<li><p>Time complexity: O(2^n)</p>
<p>Space complexity: O(n)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; Math.abs(S)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    dfs(nums, <span class="number">0</span>, S);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (start == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="number">0</span>) ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(nums, start + <span class="number">1</span>, S + nums[start]);</span><br><span class="line">    dfs(nums, start + <span class="number">1</span>, S - nums[start]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-Solution2"><a href="#Unsolved-Solution2" class="headerlink" title="Unsolved Solution2:"></a>Unsolved Solution2:</h3><ol>
<li><a href="https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-494-target-sum/" target="_blank" rel="noopener">DP</a></li>
</ol>
<h1 id="Pattern-2-Unbounded-Knapsack"><a href="#Pattern-2-Unbounded-Knapsack" class="headerlink" title="Pattern 2: Unbounded Knapsack"></a>Pattern 2: Unbounded Knapsack</h1><h2 id="🌕Unbounded-Knapsack"><a href="#🌕Unbounded-Knapsack" class="headerlink" title="🌕Unbounded Knapsack"></a>🌕Unbounded Knapsack</h2><p>The only difference between the <a href="https://www.educative.io/collection/page/5668639101419520/5633779737559040/5666387129270272/" target="_blank" rel="noopener">0/1 Knapsack</a> problem and this problem is that we are allowed to use an unlimited quantity of an item.</p>
<h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute-force"></a>brute-force</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each item &#39;i&#39; </span><br><span class="line">  create a new set which includes one quantity of item &#39;i&#39; if it does not exceed the capacity, and </span><br><span class="line">     recursively call to process all items </span><br><span class="line">  create a new set without item &#39;i&#39;, and recursively process the remaining items </span><br><span class="line">return the set from the above two sets with higher profit</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length || </span><br><span class="line">        currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after choosing the items at the currentIndex, note that we recursive call on all items as we did not increment currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weights[currentIndex] &lt;= capacity) &#123;</span><br><span class="line">        profit1 = profits[currentIndex] + knapsackRecursive(profits, weights, capacity - weights[currentIndex], currentIndex);  <span class="comment">//&lt;---------------currentIndex not increase, can be use again</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the element at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> profit2 = knapsackRecursive(profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(profit1, profit2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-8"><a href="#Top-down-Dynamic-Programming-with-Memoization-8" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[profits.length][capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(dp, profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(Integer[][] dp, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] profits, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] weights, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> capacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length ||</span><br><span class="line">        currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we have not already processed a similar sub-problem</span></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex][capacity] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// recursive call after choosing the items at the currentIndex, note that we recursive call on all</span></span><br><span class="line">        <span class="comment">// items as we did not increment currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( weights[currentIndex] &lt;= capacity ) &#123;</span><br><span class="line">            profit1 = profits[currentIndex] + knapsackRecursive(dp, profits, weights, capacity - weights[currentIndex], currentIndex);  <span class="comment">//&lt;---------------currentIndex not increase, can be use again</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursive call after excluding the element at the currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> profit2 = knapsackRecursive(dp, profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        dp[currentIndex][capacity] = Math.max(profit1, profit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-10"><a href="#Bottom-up-Dynamic-Programming-10" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[index][c] &#x3D; max (dp[index-1][c], profit[index] + dp[index][c-weight[index]])</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = profits.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the capacity=0 columns</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all sub-arrays for all capacities</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit1=<span class="number">0</span>, profit2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(weights[i] &lt;= c)</span><br><span class="line">                profit1 = profits[i] + dp[i][c-weights[i]];</span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span> )</span><br><span class="line">                profit2 = dp[i-<span class="number">1</span>][c];</span><br><span class="line">            dp[i][c] = profit1 &gt; profit2 ? profit1 : profit2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maximum profit will be in the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rod-Cutting"><a href="#Rod-Cutting" class="headerlink" title="Rod Cutting"></a>Rod Cutting</h2><h3 id="brute-force-solution-2"><a href="#brute-force-solution-2" class="headerlink" title="brute-force solution"></a>brute-force solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each rod length &#39;i&#39; </span><br><span class="line">  create a new set which includes one quantity of length &#39;i&#39;, and recursively process </span><br><span class="line">      all rod lengths for the remaining length </span><br><span class="line">  create a new set without rod length &#39;i&#39;, and recursively process for remaining rod lengths</span><br><span class="line">return the set from the above two sets with a higher sales price</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-9"><a href="#Top-down-Dynamic-Programming-with-Memoization-9" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveRodCutting</span><span class="params">(<span class="keyword">int</span>[] lengths, <span class="keyword">int</span>[] prices, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[lengths.length][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findTheMax(<span class="number">0</span>, lengths, prices, n, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheMax</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] lengths, <span class="keyword">int</span>[] prices, <span class="keyword">int</span> n, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (lengths.length == <span class="number">0</span> || lengths.length != prices.length || idx &gt;= lengths.length || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][n] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lengths[idx] &lt;= n) &#123;</span><br><span class="line">            profit1 = prices[idx] + findTheMax(idx, lengths, prices, n - lengths[idx], dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit2 = findTheMax(idx + <span class="number">1</span>, lengths, prices, n, dp);</span><br><span class="line">        dp[idx][n] = Math.max(profit1, profit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-11"><a href="#Bottom-up-Dynamic-Programming-11" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveRodCutting</span><span class="params">(<span class="keyword">int</span>[] lengths, <span class="keyword">int</span>[] prices, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || prices.length == <span class="number">0</span> || prices.length != lengths.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lengthCount = lengths.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lengthCount][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all rod lengths for all prices</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lengthCount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p1=<span class="number">0</span>, p2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(lengths[i] &lt;= len)</span><br><span class="line">                p1 = prices[i] + dp[i][len-lengths[i]];</span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span> )</span><br><span class="line">                p2 = dp[i-<span class="number">1</span>][len];</span><br><span class="line">            dp[i][len] = Math.max(p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maximum price will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[lengthCount-<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h2><h3 id="Basic-Solution"><a href="#Basic-Solution" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each coin &#39;c&#39; </span><br><span class="line">  create a new set which includes one quantity of coin &#39;c&#39; if it does not exceed &#39;T&#39;, and </span><br><span class="line">     recursively call to process all coins </span><br><span class="line">  create a new set without coin &#39;c&#39;, and recursively call to process the remaining coins </span><br><span class="line">return the count of sets who have a sum equal to &#39;T&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countChangeRecursive(denominations, total, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countChangeRecursive</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// basic checks</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(denominations.length == <span class="number">0</span> || currentIndex &gt;= denominations.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the coin at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the coin at currentIndex exceeds the total, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( denominations[currentIndex] &lt;= total )</span><br><span class="line">        sum1 = countChangeRecursive(denominations, total - denominations[currentIndex], currentIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the coin at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> sum2 = countChangeRecursive(denominations, total, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-10"><a href="#Top-down-Dynamic-Programming-with-Memoization-10" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[denominations.length][total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findCount(<span class="number">0</span>, denominations, total, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCount</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (denominations.length == <span class="number">0</span> || idx &gt;= denominations.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][total] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> way1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (denominations[idx] &lt;= total) &#123;</span><br><span class="line">            way1 = findCount(idx, denominations, total - denominations[idx], dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> way2 = findCount(idx + <span class="number">1</span>, denominations, total, dp);</span><br><span class="line">        dp[idx][total] = way1 + way2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-12"><a href="#Bottom-up-Dynamic-Programming-12" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = denominations.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][total + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the total=0 columns, as we will always have an empty set for zero total</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all sub-arrays for all capacities</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; t &lt;= total; t++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                dp[i][t] = dp[i-<span class="number">1</span>][t];</span><br><span class="line">            <span class="keyword">if</span>(t &gt;= denominations[i])</span><br><span class="line">                dp[i][t] += dp[i][t-denominations[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total combinations will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Minimum-Coin-Change"><a href="#🌕Minimum-Coin-Change" class="headerlink" title="🌕Minimum Coin Change"></a>🌕Minimum Coin Change</h2><h3 id="Basic-Solution-1"><a href="#Basic-Solution-1" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each coin &#39;c&#39; </span><br><span class="line">  create a new set which includes one quantity of coin &#39;c&#39; if it does not exceed &#39;T&#39;, and </span><br><span class="line">     recursively call to process all coins </span><br><span class="line">  create a new set without coin &#39;c&#39;, and recursively call to process the remaining coins </span><br><span class="line">return the count of coins from the above two sets with a smaller number of coins</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="keyword">this</span>.countChangeRecursive(denominations, total, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (result == Integer.MAX_VALUE ? -<span class="number">1</span> : result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countChangeRecursive</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(denominations.length == <span class="number">0</span> || currentIndex &gt;= denominations.length)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the coin at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the coin at currentIndex exceeds the total, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> count1 = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>( denominations[currentIndex] &lt;= total ) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = countChangeRecursive(denominations, total - denominations[currentIndex], currentIndex);</span><br><span class="line">        <span class="comment">//use Integer.MAX_VALUE -&gt; can't slpit the money to coin</span></span><br><span class="line">        <span class="keyword">if</span>(res != Integer.MAX_VALUE)&#123;</span><br><span class="line">            count1 = res + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the coin at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> count2 = countChangeRecursive(denominations, total, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(count1, count2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-11"><a href="#Top-down-Dynamic-Programming-with-Memoization-11" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[denominations.length][total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="keyword">this</span>.countChangeRecursive(dp, denominations, total, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (result == Integer.MAX_VALUE ? -<span class="number">1</span> : result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countChangeRecursive</span><span class="params">(Integer[][] dp, <span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(denominations.length == <span class="number">0</span> || currentIndex &gt;= denominations.length)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we have not already processed a similar sub-problem</span></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex][total] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// recursive call after selecting the coin at the currentIndex</span></span><br><span class="line">        <span class="comment">// if the coin at currentIndex exceeds the total, we shouldn't process this</span></span><br><span class="line">        <span class="keyword">int</span> count1 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>( denominations[currentIndex] &lt;= total ) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = countChangeRecursive(dp, denominations, total - denominations[currentIndex], currentIndex);</span><br><span class="line">            <span class="keyword">if</span>(res != Integer.MAX_VALUE)&#123;</span><br><span class="line">                count1 = res + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursive call after excluding the coin at the currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> count2 = countChangeRecursive(dp, denominations, total, currentIndex + <span class="number">1</span>);</span><br><span class="line">        dp[currentIndex][total] = Math.min(count1, count2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-13"><a href="#Bottom-up-Dynamic-Programming-13" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = denominations.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][total + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt;= total; j++)</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the total=0 columns, as we don't need any coin to make zero total</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; t &lt;= total; t++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                dp[i][t] = dp[i-<span class="number">1</span>][t]; <span class="comment">//exclude the coin</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt;= denominations[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][t-denominations[i]] != Integer.MAX_VALUE)</span><br><span class="line">                    dp[i][t] = Math.min(dp[i][t], dp[i][t-denominations[i]]+<span class="number">1</span>); <span class="comment">// include the coin</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total combinations will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> (dp[n-<span class="number">1</span>][total] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[n-<span class="number">1</span>][total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Maximum-Ribbon-Cut"><a href="#🌕Maximum-Ribbon-Cut" class="headerlink" title="🌕Maximum Ribbon Cut"></a>🌕Maximum Ribbon Cut</h2><h3 id="Basic-Solution-2"><a href="#Basic-Solution-2" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each length &#39;l&#39; </span><br><span class="line">  create a new set which includes one quantity of length &#39;l&#39; if it does not exceed &#39;n&#39;, and </span><br><span class="line">     recursively call to process all lengths </span><br><span class="line">  create a new set without length &#39;l&#39;, and recursively call to process the remaining lengths</span><br><span class="line">return the number of pieces from the above two sets with a higher number of pieces</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRibbonPieces</span><span class="params">(<span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxPieces = <span class="keyword">this</span>.countRibbonPiecesRecursive(ribbonLengths, total, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> maxPieces == Integer.MIN_VALUE ? -<span class="number">1</span> : maxPieces;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countRibbonPiecesRecursive</span><span class="params">(<span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ribbonLengths.length == <span class="number">0</span> || currentIndex &gt;= ribbonLengths.length)</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the ribbon length at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the ribbon length at the currentIndex exceeds the total, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> c1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span>( ribbonLengths[currentIndex] &lt;= total ) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = countRibbonPiecesRecursive(ribbonLengths, total - ribbonLengths[currentIndex], currentIndex);</span><br><span class="line">        <span class="keyword">if</span>(result != Integer.MIN_VALUE)&#123;</span><br><span class="line">            c1 = result + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the ribbon length at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> c2 = countRibbonPiecesRecursive(ribbonLengths, total, currentIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-12"><a href="#Top-down-Dynamic-Programming-with-Memoization-12" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRibbonPieces</span><span class="params">(<span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//find the max pieces</span></span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[ribbonLengths.length][total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> result = findTheMax(<span class="number">0</span>, ribbonLengths, total, dp);</span><br><span class="line">    <span class="keyword">return</span> result == Integer.MIN_VALUE? -<span class="number">1</span> : result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheMax</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ribbonLengths.length == <span class="number">0</span> || idx &gt;= ribbonLengths.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][total] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> way1 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (ribbonLengths[idx] &lt;= total) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = findTheMax(idx, ribbonLengths, total - ribbonLengths[idx], dp);</span><br><span class="line">            <span class="keyword">if</span> (remain != Integer.MIN_VALUE) &#123;</span><br><span class="line">                way1 = remain + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> way2 = findTheMax(idx + <span class="number">1</span>, ribbonLengths, total, dp);</span><br><span class="line">        dp[idx][total] = Math.max(way1, way2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Bottom-up-Dynamic-Programming-14"><a href="#Bottom-up-Dynamic-Programming-14" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRibbonPieces</span><span class="params">(<span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = ribbonLengths.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][total + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt;= total; j++)</span><br><span class="line">            dp[i][j] = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the total=0 columns, as we don't need any ribbon to make zero total</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; t &lt;= total; t++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) <span class="comment">//exclude the ribbon</span></span><br><span class="line">                dp[i][t] = dp[i-<span class="number">1</span>][t];</span><br><span class="line">            <span class="comment">// include the ribbon and check if the remaining length can be cut into available lengths</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt;= ribbonLengths[i] &amp;&amp; dp[i][t-ribbonLengths[i]] != Integer.MIN_VALUE)</span><br><span class="line">                dp[i][t] = Math.max(dp[i][t], dp[i][t-ribbonLengths[i]]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total combinations will be at the bottom-right corner, return '-1' if cutting is not possible</span></span><br><span class="line">    <span class="keyword">return</span> (dp[n-<span class="number">1</span>][total] == Integer.MIN_VALUE ? -<span class="number">1</span> : dp[n-<span class="number">1</span>][total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pattern-3-Fibonacci-Numbers"><a href="#Pattern-3-Fibonacci-Numbers" class="headerlink" title="Pattern 3: Fibonacci Numbers"></a>Pattern 3: Fibonacci Numbers</h1><h2 id="Fibonacci-Numbers"><a href="#Fibonacci-Numbers" class="headerlink" title="Fibonacci Numbers"></a>Fibonacci Numbers</h2><h3 id="Memory-optimization"><a href="#Memory-optimization" class="headerlink" title="Memory optimization"></a>Memory optimization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">1</span>, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        temp = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//The above solution has a time complexity of O(n) but a constant space complexity O(1).</span></span><br></pre></td></tr></table></figure>

<h2 id="Staircase"><a href="#Staircase" class="headerlink" title="Staircase"></a>Staircase</h2><h3 id="Basic-Solution-3"><a href="#Basic-Solution-3" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// base case, we don't need to take any step, so there is only one way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can take one step to reach the end, and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// we can take one step twice or jump two steps to reach at the top</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we take 1 step, we are left with 'n-1' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take1Step = CountWays(n-<span class="number">1</span>); </span><br><span class="line">    <span class="comment">// similarly, if we took 2 steps, we are left with 'n-2' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take2Step = CountWays(n-<span class="number">2</span>); </span><br><span class="line">    <span class="comment">// if we took 3 steps, we are left with 'n-3' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take3Step = CountWays(n-<span class="number">3</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> take1Step + take2Step + take3Step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Top-down-Dynamic-Programming-with-Memoization-13"><a href="#Top-down-Dynamic-Programming-with-Memoization-13" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> CountWaysRecursive(dp, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWaysRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// base case, we don't need to take any step, so there is only one way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can take one step to reach the end, and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// we can take one step twice or jump two steps to reach at the top</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[n] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if we take 1 step, we are left with 'n-1' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take1Step = CountWaysRecursive(dp, n-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// similarly, if we took 2 steps, we are left with 'n-2' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take2Step = CountWaysRecursive(dp, n-<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// if we took 3 steps, we are left with 'n-3' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take3Step = CountWaysRecursive(dp, n-<span class="number">3</span>);</span><br><span class="line">        dp[n] = take1Step + take2Step + take3Step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-15"><a href="#Bottom-up-Dynamic-Programming-15" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>] + dp[i-<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memory-optimization-1"><a href="#Memory-optimization-1" class="headerlink" title="Memory optimization"></a>Memory optimization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">1</span>, n2=<span class="number">1</span>, n3=<span class="number">2</span>, temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        temp = n1 + n2 + n3;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">        n3 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//The above solution has a time complexity of O(n) and a constant space complexity O(1).</span></span><br></pre></td></tr></table></figure>

<h2 id="Number-factors"><a href="#Number-factors" class="headerlink" title="Number factors"></a>Number factors</h2><p>Given a number ‘n’, implement a method to count how many possible ways there are to express ‘n’ as the sum of 1, 3, or 4.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n : 4</span><br><span class="line">Number of ways &#x3D; 4</span><br><span class="line">Explanation: Following are the four ways we can express &#39;n&#39; : &#123;1,1,1,1&#125;, &#123;1,3&#125;, &#123;3,1&#125;, &#123;4&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-4"><a href="#Basic-Solution-4" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// base case, we don't need to subtract any thing, so there is only one way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can subtract 1 to be left with zero, and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can subtract 1 twice to get zero and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// '3' can be expressed as &#123;1,1,1&#125;, &#123;3&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we subtract 1, we are left with 'n-1'</span></span><br><span class="line">    <span class="keyword">int</span> subtract1 = CountWays(n-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// if we subtract 3, we are left with 'n-3'</span></span><br><span class="line">    <span class="keyword">int</span> subtract3 = CountWays(n-<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// if we subtract 4, we are left with 'n-4'</span></span><br><span class="line">    <span class="keyword">int</span> subtract4 = CountWays(n-<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subtract1 + subtract3 + subtract4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-14"><a href="#Top-down-Dynamic-Programming-with-Memoization-14" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> CountWaysRecursive(dp, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWaysRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// base case, we don't need to subtract any thing, so there is only one way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can take subtract 1 to be left with zero, and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can subtract 1 twice to get zero and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// '3' can be expressed as &#123;1,1,1&#125;, &#123;3&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[n] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if we subtract 1, we are left with 'n-1'</span></span><br><span class="line">        <span class="keyword">int</span> subtract1 = CountWaysRecursive(dp, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// if we subtract 3, we are left with 'n-3'</span></span><br><span class="line">        <span class="keyword">int</span> subtract3 = CountWaysRecursive(dp, n - <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// if we subtract 4, we are left with 'n-4'</span></span><br><span class="line">        <span class="keyword">int</span> subtract4 = CountWaysRecursive(dp, n - <span class="number">4</span>);</span><br><span class="line">        dp[n] = subtract1 + subtract3 + subtract4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-16"><a href="#Bottom-up-Dynamic-Programming-16" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n &lt;= <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">3</span> ) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=n; i++)</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">3</span>] + dp[i-<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fibonacci-number-pattern"><a href="#Fibonacci-number-pattern" class="headerlink" title="Fibonacci number pattern"></a>Fibonacci number pattern</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountWays(n) &#x3D; CountWays(n-1) + CountWays(n-3) + CountWays(n-4), for n &gt;&#x3D; 4</span><br></pre></td></tr></table></figure>

<h2 id="🌕Minimum-jumps-to-reach-the-end-Jump-game⭐"><a href="#🌕Minimum-jumps-to-reach-the-end-Jump-game⭐" class="headerlink" title="🌕Minimum jumps to reach the end || Jump game⭐"></a>🌕Minimum jumps to reach the end || Jump game⭐</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input &#x3D; &#123;2,1,1,1,4&#125;</span><br><span class="line">Output &#x3D; 3</span><br><span class="line">Explanation: Starting from index &#39;0&#39;, we can reach the last index through: 0-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-5"><a href="#Basic-Solution-5" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n)</span></span><br><span class="line"><span class="comment">//Space O(n) call stack</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMinJumps</span><span class="params">(<span class="keyword">int</span>[] jumps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countMinJumpsRecursive(jumps, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countMinJumpsRecursive</span><span class="params">(<span class="keyword">int</span>[] jumps, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if we have reached the last index, we don't need any more jumps</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex == jumps.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jumps[currentIndex] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalJumps = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> start = currentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = currentIndex + jumps[currentIndex];</span><br><span class="line">    <span class="keyword">while</span>(start &lt; jumps.length &amp;&amp; start &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// jump one step and recurse for the remaining array</span></span><br><span class="line">        <span class="keyword">int</span> minJumps = countMinJumpsRecursive(jumps, start++);</span><br><span class="line">        <span class="keyword">if</span>(minJumps != Integer.MAX_VALUE)</span><br><span class="line">            totalJumps = Math.min(totalJumps, minJumps + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalJumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-15"><a href="#Top-down-Dynamic-Programming-with-Memoization-15" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMinJumps</span><span class="params">(<span class="keyword">int</span>[] jumps)</span> </span>&#123;</span><br><span class="line">    Integer[] dp = <span class="keyword">new</span> Integer[jumps.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findMinJumps(<span class="number">0</span>, jumps, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinJumps</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] jumps, Integer[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == jumps.length  - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jumps[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> steps = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + idx &lt; jumps.length &amp;&amp; i &lt;= jumps[idx]; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minJumps = findMinJumps(i + idx, jumps, dp);</span><br><span class="line">            <span class="keyword">if</span> (minJumps != Integer.MAX_VALUE) &#123;</span><br><span class="line">                steps = Math.min(steps, minJumps + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx] = steps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMinJumps</span><span class="params">(<span class="keyword">int</span>[] jumps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[jumps.length];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countMinJumpsRecursive(dp, jumps, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countMinJumpsRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span>[] jumps, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if we have reached the last index, we don't need any more jumps</span></span><br><span class="line">    <span class="keyword">if</span>( currentIndex == jumps.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If an element is 0, then we cannot move through that element</span></span><br><span class="line">    <span class="keyword">if</span> (jumps[currentIndex] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have already solved this problem, return the result</span></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[currentIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalJumps = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> start = currentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = currentIndex + jumps[currentIndex];</span><br><span class="line">    <span class="keyword">while</span>(start &lt; jumps.length &amp;&amp; start &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// jump one step and recurse for the remaining array</span></span><br><span class="line">        <span class="keyword">int</span> minJumps = countMinJumpsRecursive(dp, jumps, start++);</span><br><span class="line">        <span class="keyword">if</span>(minJumps != Integer.MAX_VALUE)</span><br><span class="line">            totalJumps = Math.min(totalJumps, minJumps + <span class="number">1</span>); <span class="comment">//&lt;---------------don't forget +1</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp[currentIndex] = totalJumps;</span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-17"><a href="#Bottom-up-Dynamic-Programming-17" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMinJumps</span><span class="params">(<span class="keyword">int</span>[] jumps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[jumps.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initialize with infinity, except the first index which should be zero as we start from there</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;jumps.length; i++)</span><br><span class="line">        dp[i] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>; start &lt; jumps.length-<span class="number">1</span>; start++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end=start+<span class="number">1</span>; end &lt;= start+jumps[start] &amp;&amp; end &lt; jumps.length; end++)</span><br><span class="line">            dp[end] = Math.min(dp[end], dp[start]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[jumps.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fibonacci-number-pattern-1"><a href="#Fibonacci-number-pattern-1" class="headerlink" title="Fibonacci number pattern"></a>Fibonacci number pattern</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[end] &#x3D; Math.min(dp[end], dp[start]+1);</span><br></pre></td></tr></table></figure>

<h3 id="Min-Number-Of-Jumps-AE-⭐"><a href="#Min-Number-Of-Jumps-AE-⭐" class="headerlink" title="Min Number Of Jumps(AE)⭐"></a>Min Number Of Jumps(AE)⭐</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">nums [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">value of array mean the large pos you can jump to</span><br><span class="line">ex. nums[<span class="number">0</span>] = <span class="number">3</span>, means you can go to, nums[<span class="number">1</span>] || nums[<span class="number">2</span>] || nums[<span class="number">3</span>]</span><br><span class="line">answer <span class="number">4</span> jump : <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span> -&gt; <span class="number">7</span> -&gt; <span class="number">3</span> </span><br><span class="line">find out the min jump from start to end</span><br><span class="line"></span><br><span class="line">creat a jumps array represent the min jumps we need to current position, inital it infinate <span class="keyword">default</span> value Integer.MAX_VALUE</span><br><span class="line">jumps [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, , , , <span class="number">4</span>] </span><br><span class="line">Position jumps[<span class="number">1</span>]:</span><br><span class="line">j = <span class="number">0</span>, nums[j] = <span class="number">3</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="number">3</span> + <span class="number">0</span> &gt;= <span class="number">1</span>, and junps[<span class="number">0</span>] + <span class="number">1</span> = <span class="number">1</span> &lt; Integer.MAX_VALUE, update it</span><br><span class="line">Position jumps[<span class="number">1</span>]:</span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">j = <span class="number">0</span>, nums[j] = <span class="number">3</span></span><br><span class="line"><span class="number">3</span> + <span class="number">0</span> &gt;= <span class="number">2</span>, and junps[<span class="number">0</span>] + <span class="number">1</span> = <span class="number">1</span> &lt; Integer.MAX_VALUE, update it</span><br><span class="line">j = <span class="number">1</span>, nums[j] = <span class="number">4</span></span><br><span class="line"><span class="number">4</span> + <span class="number">1</span> &gt;= <span class="number">2</span>, and junps[<span class="number">1</span>] + <span class="number">1</span> = <span class="number">2</span> &gt; <span class="number">1</span>, <span class="keyword">do</span> nothing, keep it <span class="number">1</span></span><br><span class="line"></span><br><span class="line">formula:</span><br><span class="line"><span class="keyword">if</span> nums[j] + j &gt;= i</span><br><span class="line">    jumps[i] = Math.min(jumps[i], jumps[j] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-38"><a href="#Solution1-38" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>O(n^2) time, O(n) space</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberOfJumps</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] jumps = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    Arrays.fill(jumps, Integer.MAX_VALUE);</span><br><span class="line">    jumps[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//in first index don't need jump, initial it to 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] + j &gt;= i) &#123;  <span class="comment">//if this position i is reachable from position j</span></span><br><span class="line">                jumps[i] = Math.min(jumps[j] + <span class="number">1</span>, jumps[i]);  <span class="comment">//update it to min nums of jumps</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps[jumps.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-13"><a href="#Solution2-13" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>O(n) time, O(1) space</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nums [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">pos <span class="number">0</span> : maxReach = <span class="number">3</span> step = <span class="number">3</span>(mean we can take <span class="number">3</span> step until need a jump, <span class="keyword">if</span> arrive <span class="number">1</span>, step = <span class="number">0</span>)</span><br><span class="line">steps = <span class="number">3</span>, maxReach = <span class="number">3</span>, jumps = <span class="number">0</span></span><br><span class="line">pos <span class="number">1</span> : maxReach = <span class="number">4</span> + <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span> <span class="params">(<span class="number">1</span>, len(array)</span>)</span></span><br><span class="line"><span class="function">    maxReach </span>= max(maxReach, array[i] + i)</span><br><span class="line">    step -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> stemp == <span class="number">0</span>  <span class="comment">//is run out of steps we need a jump</span></span><br><span class="line">	    jumps += <span class="number">1</span></span><br><span class="line">        steps = maxReach - i</span><br><span class="line"><span class="keyword">return</span> jumps + <span class="number">1</span></span><br><span class="line">ex. in nums[<span class="number">3</span>] run out of steps, maxReach = nums[<span class="number">5</span>] = <span class="number">3</span>,</span><br><span class="line">update stpes = <span class="number">5</span> - <span class="number">3</span> = <span class="number">2</span>, keep going</span><br><span class="line"><span class="keyword">return</span> jumps + <span class="number">1</span> because in the end once we at the <span class="keyword">final</span> index we are done</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberOfJumps</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">1</span>)  <span class="comment">//edge case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> jumps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxReach = array[<span class="number">0</span>];  <span class="comment">//initail the array[0] as maxReach and steps</span></span><br><span class="line">    <span class="keyword">int</span> steps = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;  <span class="comment">//start traverse</span></span><br><span class="line">        maxReach = Math.max(maxReach, i + array[i]);  <span class="comment">//update the maxReach</span></span><br><span class="line">        steps--;  <span class="comment">//each iteration we consume a step, we reduce steps by one</span></span><br><span class="line">        <span class="keyword">if</span> (steps == <span class="number">0</span>) &#123;  <span class="comment">//if we run out of steps, we need to jump</span></span><br><span class="line">            jumps++;</span><br><span class="line">            steps = maxReach - i;  <span class="comment">//how many steps we need form index i to maxReach</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps + <span class="number">1</span>;  <span class="comment">//iterate to &lt; array.length - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="55-Jump-Game✨"><a href="#55-Jump-Game✨" class="headerlink" title="55.Jump Game✨"></a><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">55.Jump Game✨</a></h3><p>Given an array of <strong><code>non-negative</code></strong> integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="keyword">true</span></span><br><span class="line">Explanation: Jump <span class="number">1</span> step from index <span class="number">0</span> to <span class="number">1</span>, then <span class="number">3</span> steps to the last index.</span><br><span class="line">    </span><br><span class="line">Input: nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation: You will always arrive at index <span class="number">3</span> no matter what. Its maximum jump length is <span class="number">0</span>, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-39"><a href="#Solution1-39" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>思路：步步为营。每次看所有当前元素所能达到的最远位置，并缓存入 max，如果 i 超过 max 则表明无法达到。</p>
</li>
<li><p>The basic idea is this: at each step, we keep <strong><code>track of the furthest reachable index</code></strong>. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable.</p>
<p>Hence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reachable = <span class="number">0</span>;  <span class="comment">//track the farthest index can reach</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; reachable) <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//base line</span></span><br><span class="line">        reachable = Math.max(reachable, i + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max position one could reach </span></span><br><span class="line">    <span class="comment">// starting from index &lt;= i</span></span><br><span class="line">    <span class="keyword">int</span> maxPos = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// if one could't reach this point</span></span><br><span class="line">        <span class="keyword">if</span> (maxPos &lt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxPos = Math.max(maxPos, nums[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Approach-1-Backtracking"><a href="#Approach-1-Backtracking" class="headerlink" title="Approach 1: Backtracking"></a>Approach 1: Backtracking</h3><p><a href="https://leetcode.com/problems/jump-game/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game/solution/</a></p>
<ol>
<li>Time : O(2^n)</li>
<li>Space : O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (position == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> furthestJump = Math.min(position + nums[position], nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nextPosition = position + <span class="number">1</span>; nextPosition &lt;= furthestJump; nextPosition++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (canJumpFromPosition(nextPosition, nums)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-45-Jump-Game-II✨"><a href="#Unsolved-45-Jump-Game-II✨" class="headerlink" title="Unsolved 45. Jump Game II✨"></a><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">Unsolved 45. Jump Game II✨</a></h3><p><strong>Optimal solution</strong></p>
<p>There are several ways to solve this problem:</p>
<ul>
<li>Backtracking, \mathcal{O}(2^N)O(2<em>N</em>) time.</li>
<li>Dynamic programming, \mathcal{O}(N)O(<em>N</em>) time, \mathcal{O}(N)O(<em>N</em>) space.</li>
<li>Greedy, \mathcal{O}(N)O(<em>N</em>) time and \mathcal{O}(1)O(1) space.</li>
</ul>
<p>In this article we will consider in details the optimal greedy approach.</p>
<h3 id="Solution1-40"><a href="#Solution1-40" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Greedy</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max position one could reach </span></span><br><span class="line">    <span class="comment">// starting from index &lt;= i </span></span><br><span class="line">    <span class="keyword">int</span> maxPos = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// max number of steps one could do</span></span><br><span class="line">    <span class="comment">// inside this jump</span></span><br><span class="line">    <span class="keyword">int</span> maxSteps = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> jumps = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// if to reach this point </span></span><br><span class="line">        <span class="comment">// one needs one more jump</span></span><br><span class="line">        <span class="keyword">if</span> (maxSteps &lt; i) &#123;</span><br><span class="line">            ++jumps;</span><br><span class="line">            maxSteps = maxPos;</span><br><span class="line">        &#125;</span><br><span class="line">        maxPos = Math.max(maxPos, nums[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-14"><a href="#Solution2-14" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curMax = <span class="number">0</span>; <span class="comment">// to mark the last element in a level</span></span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= curMax) &#123; </span><br><span class="line">        <span class="keyword">int</span> furthest = curMax; <span class="comment">// to mark the last element in the next level</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= curMax; i++) &#123;</span><br><span class="line">            furthest = Math.max(furthest, nums[i] + i);</span><br><span class="line">            <span class="keyword">if</span> (furthest &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">        curMax = furthest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// if i &lt; curMax, i can't move forward anymore (the last element in the array can't be reached)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a><a href="https://leetcode.com/problems/jump-game-iii/" target="_blank" rel="noopener">1306. Jump Game III</a></h3><h3 id="Solution1-41"><a href="#Solution1-41" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="number">0</span> &amp;&amp; start &lt; arr.length &amp;&amp; arr[start] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> jump = arr[start];</span><br><span class="line">        arr[start] = -arr[start];</span><br><span class="line">        <span class="keyword">return</span> jump == <span class="number">0</span> || canReach(arr, start + jump) || canReach(arr, start - jump);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-15"><a href="#Solution2-15" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    stack.push(start);</span><br><span class="line">    set.add(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = cur + arr[cur];</span><br><span class="line">        <span class="keyword">int</span> right = cur - arr[cur];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; left &lt; arr.length &amp;&amp; !set.contains(left)) &#123;</span><br><span class="line">            stack.push(left);</span><br><span class="line">            set.add(left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; right &lt; arr.length &amp;&amp; !set.contains(right)) &#123;</span><br><span class="line">            stack.push(right);</span><br><span class="line">            set.add(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minimum-jumps-with-fee"><a href="#Minimum-jumps-with-fee" class="headerlink" title="Minimum jumps with fee"></a>Minimum jumps with fee</h2><p>Given a staircase with ‘n’ steps and an array of ‘n’ numbers representing the fee that you have to pay if you take the step. Implement a method to calculate the minimum fee required to reach the top of the staircase (beyond the top-most step). </p>
<p>At every step, you have an option to take either 1 step, 2 steps, or 3 steps. You should assume that you are standing at the first step.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Number of stairs (n) : 6</span><br><span class="line">Fee: &#123;1,2,5,2,1,2&#125;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Starting from index &#39;0&#39;, we can reach the top through: 0-&gt;3-&gt;top</span><br><span class="line">The total fee we have to pay will be (1+2).</span><br><span class="line"></span><br><span class="line">Number of stairs (n): 4</span><br><span class="line">Fee: &#123;2,3,4,5&#125;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Starting from index &#39;0&#39;, we can reach the top through: 0-&gt;1-&gt;top</span><br><span class="line">The total fee we have to pay will be (2+3).</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-6"><a href="#Basic-Solution-6" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinFee</span><span class="params">(<span class="keyword">int</span>[] fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findMinFeeRecursive(fee, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMinFeeRecursive</span><span class="params">(<span class="keyword">int</span>[] fee, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( currentIndex &gt; fee.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we take 1 step, we are left with 'n-1' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take1Step = findMinFeeRecursive(fee, currentIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// similarly, if we took 2 steps, we are left with 'n-2' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take2Step = findMinFeeRecursive(fee, currentIndex + <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// if we took 3 steps, we are left with 'n-3' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take3Step = findMinFeeRecursive(fee, currentIndex + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = Math.min(Math.min(take1Step, take2Step), take3Step);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min + fee[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-16"><a href="#Top-down-Dynamic-Programming-with-Memoization-16" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinFee</span><span class="params">(<span class="keyword">int</span>[] fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[fee.length];</span><br><span class="line">    <span class="keyword">return</span> findMinFeeRecursive(dp, fee, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMinFeeRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span>[] fee, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( currentIndex &gt; fee.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if we take 1 step, we are left with 'n-1' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take1Step = findMinFeeRecursive(dp, fee, currentIndex + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// similarly, if we took 2 steps, we are left with 'n-2' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take2Step = findMinFeeRecursive(dp, fee, currentIndex + <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// if we took 3 steps, we are left with 'n-3' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take3Step = findMinFeeRecursive(dp, fee, currentIndex + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        dp[currentIndex] = fee[currentIndex] + Math.min(Math.min(take1Step, take2Step), take3Step);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-18"><a href="#Bottom-up-Dynamic-Programming-18" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinFee</span><span class="params">(<span class="keyword">int</span>[] fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[fee.length + <span class="number">1</span>]; <span class="comment">// +1 to handle the 0th step</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// if there are no steps, we dont have to pay any fee</span></span><br><span class="line">    dp[<span class="number">1</span>] = fee[<span class="number">0</span>]; <span class="comment">// only one step, so we have to pay its fee</span></span><br><span class="line">    <span class="comment">// for 2 or 3 steps staircase, since we start from the first step so we have to pay its fee</span></span><br><span class="line">    <span class="comment">// and from the first step we can reach the top by taking two or three steps, so we don't</span></span><br><span class="line">    <span class="comment">// have to pay any other fee.</span></span><br><span class="line">    dp[<span class="number">2</span>] = dp[<span class="number">3</span>] = fee[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; fee.length; i++)</span><br><span class="line">        dp[i + <span class="number">1</span>] = Math.min(fee[i] + dp[i], Math.min(fee[i - <span class="number">1</span>] + dp[i - <span class="number">1</span>], fee[i - <span class="number">2</span>] + dp[i - <span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[fee.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="House-thief"><a href="#House-thief" class="headerlink" title="House thief"></a>House thief</h2><h3 id="Basic-Solution-7"><a href="#Basic-Solution-7" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxSteal</span><span class="params">(<span class="keyword">int</span>[] wealth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findMaxStealRecursive(wealth, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxStealRecursive</span><span class="params">(<span class="keyword">int</span>[] wealth, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex &gt;= wealth.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// steal from current house and skip one to steal from the next house</span></span><br><span class="line">    <span class="keyword">int</span> stealCurrent = wealth[currentIndex] + findMaxStealRecursive(wealth, currentIndex + <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// skip current house to steel from the adjacent house</span></span><br><span class="line">    <span class="keyword">int</span> skipCurrent = findMaxStealRecursive(wealth, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(stealCurrent, skipCurrent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-17"><a href="#Top-down-Dynamic-Programming-with-Memoization-17" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxSteal</span><span class="params">(<span class="keyword">int</span>[] wealth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[wealth.length];</span><br><span class="line">    <span class="keyword">return</span> findMaxStealRecursive(dp, wealth, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxStealRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span>[] wealth, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( currentIndex &gt;= wealth.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// steal from current house and skip one to steal next</span></span><br><span class="line">        <span class="keyword">int</span> stealCurrent = wealth[currentIndex] + findMaxStealRecursive(dp, wealth, currentIndex + <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// skip current house to steel from the adjacent house</span></span><br><span class="line">        <span class="keyword">int</span> skipCurrent = findMaxStealRecursive(dp, wealth, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        dp[currentIndex] = Math.max(stealCurrent, skipCurrent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-19"><a href="#Bottom-up-Dynamic-Programming-19" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxSteal</span><span class="params">(<span class="keyword">int</span>[] wealth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wealth.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[wealth.length+<span class="number">1</span>]; <span class="comment">// '+1' to handle the zero house</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// if there are no houses, the thief can't steal anything</span></span><br><span class="line">    dp[<span class="number">1</span>] = wealth[<span class="number">0</span>]; <span class="comment">// only one house, so the thief have to steal from it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// please note that dp[] has one extra element to handle zero house</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; wealth.length; i++)</span><br><span class="line">        dp[i+<span class="number">1</span>] = Math.max(wealth[i] + dp[i-<span class="number">1</span>], dp[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[wealth.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memory-optimization-2"><a href="#Memory-optimization-2" class="headerlink" title="Memory optimization"></a>Memory optimization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxSteal</span><span class="params">(<span class="keyword">int</span>[] wealth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wealth.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">0</span>, n2=wealth[<span class="number">0</span>], temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; wealth.length; i++) &#123;</span><br><span class="line">        temp = Math.max(n1 + wealth[i], n2);</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/200/" rel="tag"># 200</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/17/Recursion/" rel="prev" title="Recursion">
      <i class="fa fa-chevron-left"></i> Recursion
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/18/Programming%20Interviews%20Exposed/" rel="next" title="Programming Interviews Exposed">
      Programming Interviews Exposed <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Pattern-0-1-Knapsack-Dynamic-Programming"><span class="nav-number">1.</span> <span class="nav-text">Pattern : 0&#x2F;1 Knapsack (Dynamic Programming)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-1-Knapsack-medium"><span class="nav-number">1.1.</span> <span class="nav-text">0&#x2F;1 Knapsack (medium)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-solution-recursion"><span class="nav-number">1.1.1.</span> <span class="nav-text">brute-force solution ,recursion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization"><span class="nav-number">1.1.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming"><span class="nav-number">1.1.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Equal-Subset-Sum-Partition-medium-✨"><span class="nav-number">1.2.</span> <span class="nav-text">Equal Subset Sum Partition (medium)✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-solution"><span class="nav-number">1.2.1.</span> <span class="nav-text">brute-force solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#416-Partition-Equal-Subset-Sum✨"><span class="nav-number">1.2.4.</span> <span class="nav-text">416. Partition Equal Subset Sum✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution0"><span class="nav-number">1.2.5.</span> <span class="nav-text">Solution0:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1"><span class="nav-number">1.2.6.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Subset-Sum-medium"><span class="nav-number">1.3.</span> <span class="nav-text">Subset Sum (medium)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-algorithm"><span class="nav-number">1.3.1.</span> <span class="nav-text">brute-force algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Minimum-Subset-Sum-Difference-hard"><span class="nav-number">1.4.</span> <span class="nav-text">Minimum Subset Sum Difference (hard)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-1-Count-of-Subset-Sum-hard"><span class="nav-number">1.5.</span> <span class="nav-text">Challenge 1 Count of Subset Sum (hard)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-2"><span class="nav-number">1.5.1.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-4"><span class="nav-number">1.5.2.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-2-Target-Sum-hard"><span class="nav-number">1.6.</span> <span class="nav-text">Challenge 2 Target Sum (hard)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dynamic-Programming"><span class="nav-number">2.</span> <span class="nav-text">Dynamic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Unsolved-1335-Minimum-Difficulty-of-a-Job-Schedule⭐"><span class="nav-number">2.1.</span> <span class="nav-text">🌕Unsolved 1335. Minimum Difficulty of a Job Schedule⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-1"><span class="nav-number">2.1.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2"><span class="nav-number">2.1.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#221-Maximal-Square⭐"><span class="nav-number">2.2.</span> <span class="nav-text">221. Maximal Square⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution0-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">Solution0:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-2"><span class="nav-number">2.2.2.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1155-Number-of-Dice-Rolls-With-Target-Sum⭐"><span class="nav-number">2.3.</span> <span class="nav-text">1155. Number of Dice Rolls With Target Sum⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-3"><span class="nav-number">2.3.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#139-Word-Break⭐"><span class="nav-number">2.4.</span> <span class="nav-text">139. Word Break⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-140-Word-Break-II⭐"><span class="nav-number">2.5.</span> <span class="nav-text">Unsolved 140. Word Break II⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-4"><span class="nav-number">2.5.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-3"><span class="nav-number">2.5.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-472-Concatenated-Words⭐"><span class="nav-number">2.6.</span> <span class="nav-text">Unsolved 472. Concatenated Words⭐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-Minimum-Path-Sum⭐"><span class="nav-number">2.7.</span> <span class="nav-text">64. Minimum Path Sum⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-5"><span class="nav-number">2.7.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock⭐"><span class="nav-number">2.8.</span> <span class="nav-text">121. Best Time to Buy and Sell Stock⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Most-consistent-ways-of-dealing-with-the-series-of-stock-problems"><span class="nav-number">2.8.1.</span> <span class="nav-text">Most consistent ways of dealing with the series of stock problems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution0-2"><span class="nav-number">2.8.2.</span> <span class="nav-text">Solution0:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-6"><span class="nav-number">2.8.3.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II✨"><span class="nav-number">2.9.</span> <span class="nav-text">122. Best Time to Buy and Sell Stock II✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-7"><span class="nav-number">2.9.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-123-Best-Time-to-Buy-and-Sell-Stock-III✨"><span class="nav-number">2.10.</span> <span class="nav-text">Unsolved 123. Best Time to Buy and Sell Stock III✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-188-Best-Time-to-Buy-and-Sell-Stock-IV✨"><span class="nav-number">2.11.</span> <span class="nav-text">Unsolved 188. Best Time to Buy and Sell Stock IV✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-8"><span class="nav-number">2.11.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-4"><span class="nav-number">2.11.2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution3"><span class="nav-number">2.11.3.</span> <span class="nav-text">Solution3:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><span class="nav-number">2.12.</span> <span class="nav-text">Unsolved 309. Best Time to Buy and Sell Stock with Cooldown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><span class="nav-number">2.13.</span> <span class="nav-text">Unsolved Best Time to Buy and Sell Stock with Transaction Fee</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#152-Maximum-Product-Subarray"><span class="nav-number">2.14.</span> <span class="nav-text">152. Maximum Product Subarray</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-9"><span class="nav-number">2.14.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-72-Edit-Distance✨"><span class="nav-number">2.15.</span> <span class="nav-text">Unsolved 72. Edit Distance✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-Maximum-Subarray✨"><span class="nav-number">2.16.</span> <span class="nav-text">53. Maximum Subarray✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-10"><span class="nav-number">2.16.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-5"><span class="nav-number">2.16.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#91-Decode-Ways✨"><span class="nav-number">2.17.</span> <span class="nav-text">91. Decode Ways✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-11"><span class="nav-number">2.17.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Max-Subset-Sum-No-Adjacent-AE-✨"><span class="nav-number">2.18.</span> <span class="nav-text">Max Subset Sum No Adjacent(AE)✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-12"><span class="nav-number">2.18.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-6"><span class="nav-number">2.18.2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198-House-Robber✨"><span class="nav-number">2.18.3.</span> <span class="nav-text">198.House Robber✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-13"><span class="nav-number">2.18.4.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-7"><span class="nav-number">2.18.5.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#213-House-Robber-II"><span class="nav-number">2.18.6.</span> <span class="nav-text">213.House Robber II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-14"><span class="nav-number">2.18.7.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number-Of-Ways-To-Make-Change-AE"><span class="nav-number">2.19.</span> <span class="nav-text">Number Of Ways To Make Change(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-15"><span class="nav-number">2.19.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#518-Coin-Change-2"><span class="nav-number">2.19.2.</span> <span class="nav-text">518. Coin Change 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-16"><span class="nav-number">2.19.3.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-8"><span class="nav-number">2.19.4.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Min-Number-Of-Coins-For-Change-AE-✨"><span class="nav-number">2.20.</span> <span class="nav-text">Min Number Of Coins For Change(AE)✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-17"><span class="nav-number">2.20.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#322-Coin-Change✨"><span class="nav-number">2.20.2.</span> <span class="nav-text">322. Coin Change✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-18"><span class="nav-number">2.20.3.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-9"><span class="nav-number">2.20.4.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Levenshtein-Distance-AE-⭐"><span class="nav-number">2.21.</span> <span class="nav-text">Levenshtein Distance(AE)⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-19"><span class="nav-number">2.21.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-10"><span class="nav-number">2.21.2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsolved-583-Delete-Operation-for-Two-Strings"><span class="nav-number">2.21.3.</span> <span class="nav-text">Unsolved 583. Delete Operation for Two Strings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-20"><span class="nav-number">2.21.4.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-Max-Sum-Increasing-Subsequence-AE"><span class="nav-number">2.22.</span> <span class="nav-text">Unsolved Max Sum Increasing Subsequence(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-21"><span class="nav-number">2.22.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-Longest-Common-Subsequence-AE-✨"><span class="nav-number">2.23.</span> <span class="nav-text">Unsolved Longest Common Subsequence(AE)✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-22"><span class="nav-number">2.23.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1143-Longest-Common-Subsequence✨"><span class="nav-number">2.23.2.</span> <span class="nav-text">1143. Longest Common Subsequence✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-23"><span class="nav-number">2.23.3.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Knapsack-Problem-AE"><span class="nav-number">2.24.</span> <span class="nav-text">Knapsack Problem(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-24"><span class="nav-number">2.24.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Disk-Stacking-AE"><span class="nav-number">2.25.</span> <span class="nav-text">Disk Stacking(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-25"><span class="nav-number">2.25.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#✅Number-of-Paths💜"><span class="nav-number">2.26.</span> <span class="nav-text">✅Number of Paths💜</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#62-Unique-Paths"><span class="nav-number">2.26.1.</span> <span class="nav-text">62.Unique Paths</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-26"><span class="nav-number">2.26.2.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-Unique-Paths-II"><span class="nav-number">2.26.3.</span> <span class="nav-text">63. Unique Paths II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sulution1"><span class="nav-number">2.26.4.</span> <span class="nav-text">Sulution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UnsolvedSolution2"><span class="nav-number">2.26.5.</span> <span class="nav-text">UnsolvedSolution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70-Climbing-Stairs✨"><span class="nav-number">2.27.</span> <span class="nav-text">70. Climbing Stairs✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-27"><span class="nav-number">2.27.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-11"><span class="nav-number">2.27.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-1659-Maximize-Grid-Happiness"><span class="nav-number">2.28.</span> <span class="nav-text">Unsolved 1659. Maximize Grid Happiness</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1621-Number-of-Sets-of-K-Non-Overlapping-Line-Segments🎃"><span class="nav-number">2.29.</span> <span class="nav-text">1621. Number of Sets of K Non-Overlapping Line Segments🎃</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-28"><span class="nav-number">2.30.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#343-Integer-Break"><span class="nav-number">2.31.</span> <span class="nav-text">343. Integer Break</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-29"><span class="nav-number">2.31.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#516-Unsolved-Longest-Palindromic-Subsequence"><span class="nav-number">2.32.</span> <span class="nav-text">516. Unsolved Longest Palindromic Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-30"><span class="nav-number">2.32.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#486-Predict-the-Winner"><span class="nav-number">2.33.</span> <span class="nav-text">486. Predict the Winner</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-31"><span class="nav-number">2.33.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-787-Cheapest-Flights-Within-K-Stops🎂"><span class="nav-number">2.34.</span> <span class="nav-text">Unsolved 787. Cheapest Flights Within K Stops🎂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-1373-Maximum-Sum-BST-in-Binary-Tree🎂✨"><span class="nav-number">2.35.</span> <span class="nav-text">Unsolved 1373. Maximum Sum BST in Binary Tree🎂✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-44-Wildcard-Matching🎂✨"><span class="nav-number">2.36.</span> <span class="nav-text">Unsolved 44. Wildcard Matching🎂✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-32"><span class="nav-number">2.36.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-12"><span class="nav-number">2.36.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#256-Paint-House"><span class="nav-number">2.37.</span> <span class="nav-text">256. Paint House</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-33"><span class="nav-number">2.37.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-464-Can-I-Win🎂"><span class="nav-number">2.38.</span> <span class="nav-text">Unsolved 464. Can I Win🎂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-34"><span class="nav-number">2.38.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1664-Ways-to-Make-a-Fair-Array"><span class="nav-number">2.39.</span> <span class="nav-text">1664. Ways to Make a Fair Array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-35"><span class="nav-number">2.39.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Grokking-Dynamic-Programming-Patterns-for-Coding-Interviews"><span class="nav-number">3.</span> <span class="nav-text">Grokking Dynamic Programming Patterns for Coding Interviews</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number">4.</span> <span class="nav-text">Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Nth-Fib"><span class="nav-number">4.1.</span> <span class="nav-text">Nth Fib</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-with-Memoization"><span class="nav-number">4.1.1.</span> <span class="nav-text">Top-down with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-with-Tabulation"><span class="nav-number">4.1.2.</span> <span class="nav-text">Bottom-up with Tabulation</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pattern-1-0-1-Knapsack"><span class="nav-number">5.</span> <span class="nav-text">Pattern 1: 0&#x2F;1 Knapsack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕0-1-Knapsack✨"><span class="nav-number">5.1.</span> <span class="nav-text">🌕0&#x2F;1 Knapsack✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-solution-1"><span class="nav-number">5.1.1.</span> <span class="nav-text">brute-force solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-3"><span class="nav-number">5.1.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-5"><span class="nav-number">5.1.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Equal-Subset-Sum-Partition✨"><span class="nav-number">5.2.</span> <span class="nav-text">🌕Equal Subset Sum Partition✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-algorithm-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">brute-force algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-4"><span class="nav-number">5.2.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-6"><span class="nav-number">5.2.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#416-Partition-Equal-Subset-Sum✨-1"><span class="nav-number">5.2.4.</span> <span class="nav-text">416. Partition Equal Subset Sum✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution0-3"><span class="nav-number">5.2.5.</span> <span class="nav-text">Solution0:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-36"><span class="nav-number">5.2.6.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Subset-Sum"><span class="nav-number">5.3.</span> <span class="nav-text">Subset Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-algorithm-2"><span class="nav-number">5.3.1.</span> <span class="nav-text">brute-force algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-5"><span class="nav-number">5.3.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-7"><span class="nav-number">5.3.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Minimum-Subset-Sum-Difference"><span class="nav-number">5.4.</span> <span class="nav-text">Minimum Subset Sum Difference</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-algorithm-3"><span class="nav-number">5.4.1.</span> <span class="nav-text">brute-force algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-6"><span class="nav-number">5.4.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-8"><span class="nav-number">5.4.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Count-of-Subset-Sum"><span class="nav-number">5.5.</span> <span class="nav-text">🌕Count of Subset Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-algorithm-4"><span class="nav-number">5.5.1.</span> <span class="nav-text">brute-force algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-7"><span class="nav-number">5.5.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-9"><span class="nav-number">5.5.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Target-Sum"><span class="nav-number">5.6.</span> <span class="nav-text">🌕Target Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#🌕Unsolved-494-Target-Sum✨"><span class="nav-number">5.6.1.</span> <span class="nav-text">🌕Unsolved 494. Target Sum✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-37"><span class="nav-number">5.6.2.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsolved-Solution2"><span class="nav-number">5.6.3.</span> <span class="nav-text">Unsolved Solution2:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pattern-2-Unbounded-Knapsack"><span class="nav-number">6.</span> <span class="nav-text">Pattern 2: Unbounded Knapsack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Unbounded-Knapsack"><span class="nav-number">6.1.</span> <span class="nav-text">🌕Unbounded Knapsack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force"><span class="nav-number">6.1.1.</span> <span class="nav-text">brute-force</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-8"><span class="nav-number">6.1.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-10"><span class="nav-number">6.1.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rod-Cutting"><span class="nav-number">6.2.</span> <span class="nav-text">Rod Cutting</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#brute-force-solution-2"><span class="nav-number">6.2.1.</span> <span class="nav-text">brute-force solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-9"><span class="nav-number">6.2.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-11"><span class="nav-number">6.2.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Coin-Change"><span class="nav-number">6.3.</span> <span class="nav-text">Coin Change</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution"><span class="nav-number">6.3.1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-10"><span class="nav-number">6.3.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-12"><span class="nav-number">6.3.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Minimum-Coin-Change"><span class="nav-number">6.4.</span> <span class="nav-text">🌕Minimum Coin Change</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-1"><span class="nav-number">6.4.1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-11"><span class="nav-number">6.4.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-13"><span class="nav-number">6.4.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Maximum-Ribbon-Cut"><span class="nav-number">6.5.</span> <span class="nav-text">🌕Maximum Ribbon Cut</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-2"><span class="nav-number">6.5.1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-12"><span class="nav-number">6.5.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-14"><span class="nav-number">6.5.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pattern-3-Fibonacci-Numbers"><span class="nav-number">7.</span> <span class="nav-text">Pattern 3: Fibonacci Numbers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Fibonacci-Numbers"><span class="nav-number">7.1.</span> <span class="nav-text">Fibonacci Numbers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-optimization"><span class="nav-number">7.1.1.</span> <span class="nav-text">Memory optimization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Staircase"><span class="nav-number">7.2.</span> <span class="nav-text">Staircase</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-3"><span class="nav-number">7.2.1.</span> <span class="nav-text">Basic Solution</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-13"><span class="nav-number">7.3.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-15"><span class="nav-number">7.3.1.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-optimization-1"><span class="nav-number">7.3.2.</span> <span class="nav-text">Memory optimization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number-factors"><span class="nav-number">7.4.</span> <span class="nav-text">Number factors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-4"><span class="nav-number">7.4.1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-14"><span class="nav-number">7.4.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-16"><span class="nav-number">7.4.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fibonacci-number-pattern"><span class="nav-number">7.4.4.</span> <span class="nav-text">Fibonacci number pattern</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Minimum-jumps-to-reach-the-end-Jump-game⭐"><span class="nav-number">7.5.</span> <span class="nav-text">🌕Minimum jumps to reach the end || Jump game⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-5"><span class="nav-number">7.5.1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-15"><span class="nav-number">7.5.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-17"><span class="nav-number">7.5.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fibonacci-number-pattern-1"><span class="nav-number">7.5.4.</span> <span class="nav-text">Fibonacci number pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Min-Number-Of-Jumps-AE-⭐"><span class="nav-number">7.5.5.</span> <span class="nav-text">Min Number Of Jumps(AE)⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-38"><span class="nav-number">7.5.6.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-13"><span class="nav-number">7.5.7.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-Jump-Game✨"><span class="nav-number">7.5.8.</span> <span class="nav-text">55.Jump Game✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-39"><span class="nav-number">7.5.9.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Approach-1-Backtracking"><span class="nav-number">7.5.10.</span> <span class="nav-text">Approach 1: Backtracking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsolved-45-Jump-Game-II✨"><span class="nav-number">7.5.11.</span> <span class="nav-text">Unsolved 45. Jump Game II✨</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-40"><span class="nav-number">7.5.12.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-14"><span class="nav-number">7.5.13.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1306-Jump-Game-III"><span class="nav-number">7.5.14.</span> <span class="nav-text">1306. Jump Game III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-41"><span class="nav-number">7.5.15.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-15"><span class="nav-number">7.5.16.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Minimum-jumps-with-fee"><span class="nav-number">7.6.</span> <span class="nav-text">Minimum jumps with fee</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-6"><span class="nav-number">7.6.1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-16"><span class="nav-number">7.6.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-18"><span class="nav-number">7.6.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-thief"><span class="nav-number">7.7.</span> <span class="nav-text">House thief</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Solution-7"><span class="nav-number">7.7.1.</span> <span class="nav-text">Basic Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-down-Dynamic-Programming-with-Memoization-17"><span class="nav-number">7.7.2.</span> <span class="nav-text">Top-down Dynamic Programming with Memoization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom-up-Dynamic-Programming-19"><span class="nav-number">7.7.3.</span> <span class="nav-text">Bottom-up Dynamic Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-optimization-2"><span class="nav-number">7.7.4.</span> <span class="nav-text">Memory optimization</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dejavu"
      src="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
  <p class="site-author-name" itemprop="name">Dejavu</p>
  <div class="site-description" itemprop="description">Stay gold</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Dejavu-19" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Dejavu-19" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/liu.kunling19@gmail.com" title="E-Mail → liu.kunling19@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dejavu</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false});</script></body>
</html>
