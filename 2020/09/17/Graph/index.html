<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dejavi-19.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Pattern: Topological Sort (Graph)Topological Sort (medium)123456789101112131415Input: Vertices&#x3D;4, Edges&#x3D;[3, 2], [3, 0], [2, 0], [2, 1]Output: Following are the two valid topological sorts fo">
<meta property="og:type" content="article">
<meta property="og:title" content="Graph">
<meta property="og:url" content="https://dejavi-19.github.io/2020/09/17/Graph/index.html">
<meta property="og:site_name" content="Dejavu&#39;s Notebook">
<meta property="og:description" content="Pattern: Topological Sort (Graph)Topological Sort (medium)123456789101112131415Input: Vertices&#x3D;4, Edges&#x3D;[3, 2], [3, 0], [2, 0], [2, 1]Output: Following are the two valid topological sorts fo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zxi.mytechroad.com/blog/wp-content/uploads/2017/10/207-ep93.png">
<meta property="og:image" content="http://zxi.mytechroad.com/blog/wp-content/uploads/2017/10/207-ep93-1.png">
<meta property="og:image" content="https://zxi.mytechroad.com/blog/wp-content/uploads/2017/12/210-ep133.png">
<meta property="og:image" content="https://zxi.mytechroad.com/blog/wp-content/uploads/2018/06/863-ep202.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png">
<meta property="og:image" content="https://assets.leetcode.com/users/hiepit/image_1573965953.png">
<meta property="article:published_time" content="2020-09-17T04:03:03.310Z">
<meta property="article:modified_time" content="2021-02-24T02:44:18.190Z">
<meta property="article:author" content="Dejavu">
<meta property="article:tag" content="200">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zxi.mytechroad.com/blog/wp-content/uploads/2017/10/207-ep93.png">

<link rel="canonical" href="https://dejavi-19.github.io/2020/09/17/Graph/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Graph | Dejavu's Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/Dejavu-19" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dejavu's Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Alea iacta est</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首&emsp;&emsp;页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于博主</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标&emsp;&emsp;签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分&emsp;&emsp;类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归&emsp;&emsp;档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/17/Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Graph
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 13:03:03" itemprop="dateCreated datePublished" datetime="2020-09-17T13:03:03+09:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-24 11:44:18" itemprop="dateModified" datetime="2021-02-24T11:44:18+09:00">2021-02-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Pattern-Topological-Sort-Graph"><a href="#Pattern-Topological-Sort-Graph" class="headerlink" title="Pattern: Topological Sort (Graph)"></a>Pattern: Topological Sort (Graph)</h1><h2 id="Topological-Sort-medium"><a href="#Topological-Sort-medium" class="headerlink" title="Topological Sort (medium)"></a>Topological Sort (medium)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: Vertices&#x3D;4, Edges&#x3D;[3, 2], [3, 0], [2, 0], [2, 1]</span><br><span class="line">Output: Following are the two valid topological sorts for the given graph:</span><br><span class="line">1) 3, 2, 0, 1</span><br><span class="line">2) 3, 2, 1, 0</span><br><span class="line"></span><br><span class="line">Input: Vertices&#x3D;5, Edges&#x3D;[4, 2], [4, 3], [2, 0], [2, 1], [3, 1]</span><br><span class="line">Output: Following are all valid topological sorts for the given graph:</span><br><span class="line">1) 4, 2, 3, 0, 1</span><br><span class="line">2) 4, 3, 2, 0, 1</span><br><span class="line">3) 4, 3, 2, 1, 0</span><br><span class="line">4) 4, 2, 3, 1, 0</span><br><span class="line">5) 4, 2, 0, 3, 1</span><br><span class="line"></span><br><span class="line">A topological ordering is possible only when the graph has no directed cycles, i.e. if the graph is a Directed Acyclic Graph (DAG). </span><br><span class="line">If the graph has a cycle, some vertices will have cyclic dependencies which makes it impossible to find a linear ordering among vertices.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">sort</span><span class="params">(<span class="keyword">int</span> vertices, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (vertices &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sortedOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = edges[i][<span class="number">0</span>], child = edges[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">    <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">    <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> vertex = sources.poll();</span><br><span class="line">        sortedOrder.add(vertex);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                sources.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sortedOrder.size() != vertices) <span class="comment">// topological sort is not possible as the graph has a cycle</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tasks-Scheduling-medium"><a href="#Tasks-Scheduling-medium" class="headerlink" title="Tasks Scheduling (medium)"></a>Tasks Scheduling (medium)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSchedulingPossible</span><span class="params">(<span class="keyword">int</span> tasks, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (tasks &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = prerequisites[i][<span class="number">0</span>], child = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">        <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">        <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> vertex = sources.poll();</span><br><span class="line">            sortedOrder.add(vertex);</span><br><span class="line">            List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">                inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                    sources.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder doesn't contain all tasks, there is a cyclic dependency between tasks, therefore, we</span></span><br><span class="line">    <span class="comment">// will not be able to schedule all tasks</span></span><br><span class="line">    <span class="keyword">return</span> sortedOrder.size() == tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="207-Course-Schedule⭐"><a href="#207-Course-Schedule⭐" class="headerlink" title="207. Course Schedule⭐"></a><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">207. Course Schedule⭐</a></h2><p>There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2, [[1,0]]</span><br><span class="line">return true</span><br><span class="line">2, [[1,0],[0,1]]</span><br><span class="line">return false</span><br></pre></td></tr></table></figure>

<p>题目描述：一个课程可能会先修课程，判断给定的先修课程规定是否合法。</p>
<p>本题不需要使用拓扑排序，只需要检测有向图是否存在环即可。</p>
<p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2017/10/207-ep93.png" alt=""></p>
<p><img src="http://zxi.mytechroad.com/blog/wp-content/uploads/2017/10/207-ep93-1.png" alt=""></p>
<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//initial graph</span></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> child = p[<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child);</span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initial queue for source vertice</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> node : inDegree.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree.get(node) == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">        sortedList.add(cur);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedList.size() == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Topological Sort</li>
<li>思路：用一个 Map 记录课程的后续课程，用一个数组记录每门课前提课程的门数。把前提门数为零的放入一个队列，然后 逐个元素看能达到的所有课程，如果达到某课，则该课的前提减 1，如果该课前提为零，则加入队列。重复直到队列为空， 如果队列中累计弹出的课程数=总课程数，则表示可以完成。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> course = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pre = p[<span class="number">1</span>];</span><br><span class="line">        graph.get(course).add(pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">boolean</span>[] visiting = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, i, visited, visiting)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs for detect cycle</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> cur, <span class="keyword">boolean</span>[] visited, <span class="keyword">boolean</span>[] visiting)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (visiting[cur]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[cur]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    visiting[cur] = <span class="keyword">true</span>;</span><br><span class="line">    visited[cur] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(cur)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, next, visited, visiting)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visiting[cur] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Author: Huahua</span></span><br><span class="line"><span class="comment">// Runtime: 6 ms</span></span><br><span class="line"><span class="comment">// HashMap is slower than ArrayList in this problem.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;        </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> course = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> prerequisite = prerequisites[i][<span class="number">1</span>];            </span><br><span class="line">            graph.get(course).add(prerequisite);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span> (dfs(i, graph, visited)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        visited[curr] = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(curr))</span><br><span class="line">            <span class="keyword">if</span> (dfs(next, graph, visited)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        visited[curr] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tasks-Scheduling-Order-medium"><a href="#Tasks-Scheduling-Order-medium" class="headerlink" title="Tasks Scheduling Order (medium)"></a>Tasks Scheduling Order (medium)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> tasks, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (tasks &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sortedOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = prerequisites[i][<span class="number">0</span>], child = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">    <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">    <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> vertex = sources.poll();</span><br><span class="line">        sortedOrder.add(vertex);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                sources.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder doesn't contain all tasks, there is a cyclic dependency between tasks, therefore, we</span></span><br><span class="line">    <span class="comment">// will not be able to schedule all tasks</span></span><br><span class="line">    <span class="keyword">if</span> (sortedOrder.size() != tasks)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-210-Course-Schedule-II🎂💜⭐"><a href="#🌕Unsolved-210-Course-Schedule-II🎂💜⭐" class="headerlink" title="🌕Unsolved 210. Course Schedule II🎂💜⭐"></a><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">🌕Unsolved 210. Course Schedule II🎂💜⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>]]</span><br><span class="line">There are a total of <span class="number">4</span> courses to take. To take course <span class="number">3</span> you should have finished both courses <span class="number">1</span> and <span class="number">2</span>. Both courses <span class="number">1</span> and <span class="number">2</span> should be taken after you finished course <span class="number">0</span>. So one correct course order is [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]. Another correct ordering is[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>].</span><br></pre></td></tr></table></figure>

<p>There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. For example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>

<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>

<p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p>
<p>Note: </p>
<ol>
<li>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. </li>
<li>You may assume that there are no duplicate edges in the input prerequisites. Hints:</li>
<li>This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses. </li>
<li>Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort. </li>
<li>Topological sort could also be done via BFS</li>
</ol>
<p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2017/12/210-ep133.png" alt=""></p>
<p><a href="http://zxi.mytechroad.com/blog/graph/leetcode-210-course-schedule-ii/" target="_blank" rel="noopener">http://zxi.mytechroad.com/blog/graph/leetcode-210-course-schedule-ii/</a></p>
<h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">    List&lt;Integer&gt; sortedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initial graph inDegree -&gt; count in coming edges for vertice</span></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = p[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> child = p[<span class="number">0</span>];</span><br><span class="line">        graph.get(parent).add(child);</span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//prepare queue, add current source into it</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> node : inDegree.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree.get(node) == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//treverse left part add the node to sotedlist followe the releationship</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">        sortedList.add(cur);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//check cycle</span></span><br><span class="line">    <span class="keyword">if</span> (sortedList.size() != numCourses) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedList.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Topological Sorting</p>
<p>Time complexity: O(V+E)</p>
<p>Space complexity: O(V+E)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> course = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pre = p[<span class="number">1</span>];</span><br><span class="line">        graph.get(course).add(pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">boolean</span>[] visiting = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, i, visited, visiting, ans)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> cur, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span>[] visited, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span>[] visiting,</span></span></span><br><span class="line"><span class="function"><span class="params">                   List&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (visiting[cur]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[cur]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    visiting[cur] = <span class="keyword">true</span>;</span><br><span class="line">    visited[cur] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(cur)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, next, visited, visiting, ans)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans.add(cur);</span><br><span class="line">    visiting[cur] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Author: Huahua</span></span><br><span class="line"><span class="comment">// Runtime: 83 ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> course = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> prerequisite = prerequisites[i][<span class="number">1</span>];            </span><br><span class="line">            graph.get(course).add(prerequisite);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Integer index = numCourses;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span> (dfs(i, graph, visited, ans)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[] visited, List&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        visited[curr] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(curr))</span><br><span class="line">            <span class="keyword">if</span> (dfs(next, graph, visited, ans)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        visited[curr] = <span class="number">2</span>;</span><br><span class="line">        ans.add(curr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-All-Tasks-Scheduling-Orders-hard"><a href="#🌕Unsolved-All-Tasks-Scheduling-Orders-hard" class="headerlink" title="🌕Unsolved All Tasks Scheduling Orders (hard)"></a>🌕Unsolved All Tasks Scheduling Orders (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Input: Tasks&#x3D;4, Prerequisites&#x3D;[3, 2], [3, 0], [2, 0], [2, 1]</span><br><span class="line">Output: </span><br><span class="line">1) [3, 2, 0, 1]</span><br><span class="line">2) [3, 2, 1, 0]</span><br><span class="line">Explanation: There are two possible orderings of the tasks meeting all prerequisites.</span><br><span class="line"></span><br><span class="line">Input: Tasks&#x3D;6, Prerequisites&#x3D;[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]</span><br><span class="line">Output: </span><br><span class="line">1) [0, 1, 4, 3, 2, 5]</span><br><span class="line">2) [0, 1, 3, 4, 2, 5]</span><br><span class="line">3) [0, 1, 3, 2, 4, 5]</span><br><span class="line">4) [0, 1, 3, 2, 5, 4]</span><br><span class="line">5) [1, 0, 3, 4, 2, 5]</span><br><span class="line">6) [1, 0, 3, 2, 4, 5]</span><br><span class="line">7) [1, 0, 3, 2, 5, 4]</span><br><span class="line">8) [1, 0, 4, 3, 2, 5]</span><br><span class="line">9) [1, 3, 0, 2, 4, 5]</span><br><span class="line">10) [1, 3, 0, 2, 5, 4]</span><br><span class="line">11) [1, 3, 0, 4, 2, 5]</span><br><span class="line">12) [1, 3, 2, 0, 5, 4]</span><br><span class="line">13) [1, 3, 2, 0, 4, 5]</span><br><span class="line"></span><br><span class="line">This problem is similar to Tasks Scheduling Order, the only difference is that we need to find all the topological orderings of the tasks.</span><br><span class="line"></span><br><span class="line">At any stage, if we have more than one source available and since we can choose any source, therefore, in this case, we will have multiple orderings of the tasks. We can use a recursive approach with Backtracking to consider all sources at any step.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOrders</span><span class="params">(<span class="keyword">int</span> tasks, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (tasks &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = prerequisites[i][<span class="number">0</span>], child = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printAllTopologicalSorts(graph, inDegree, sources, sortedOrder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllTopologicalSorts</span><span class="params">(HashMap&lt;Integer, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             List&lt;Integer&gt;&gt; graph,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             HashMap&lt;Integer, Integer&gt; inDegree, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             Queue&lt;Integer&gt; sources, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             List&lt;Integer&gt; sortedOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer vertex : sources) &#123;</span><br><span class="line">            sortedOrder.add(vertex);</span><br><span class="line">            Queue&lt;Integer&gt; sourcesForNextCall = cloneQueue(sources);</span><br><span class="line">            <span class="comment">// only remove the current source, all other sources should remain in the queue for the next call</span></span><br><span class="line">            sourcesForNextCall.remove(vertex);</span><br><span class="line">            List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">                inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                    sourcesForNextCall.add(child); <span class="comment">// save the new source for the next call</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// recursive call to print other orderings from the remaining (and new) sources</span></span><br><span class="line">            printAllTopologicalSorts(graph, inDegree, sourcesForNextCall, sortedOrder);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// backtrack, remove the vertex from the sorted order and put all of its children back to consider </span></span><br><span class="line">            <span class="comment">// the next source instead of the current vertex</span></span><br><span class="line">            sortedOrder.remove(vertex);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children)</span><br><span class="line">                inDegree.put(child, inDegree.get(child) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder doesn't contain all tasks, either we've a cyclic dependency between tasks, or </span></span><br><span class="line">    <span class="comment">// we have not processed all the tasks in this recursive call</span></span><br><span class="line">    <span class="keyword">if</span> (sortedOrder.size() == inDegree.size())</span><br><span class="line">        System.out.println(sortedOrder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makes a deep copy of the queue</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;Integer&gt; <span class="title">cloneQueue</span><span class="params">(Queue&lt;Integer&gt; queue)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; clone = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer num : queue)</span><br><span class="line">        clone.add(num);</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Alien-Dictionary-hard"><a href="#Alien-Dictionary-hard" class="headerlink" title="Alien Dictionary (hard)"></a>Alien Dictionary (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: Words: [&quot;ba&quot;, &quot;bc&quot;, &quot;ac&quot;, &quot;cab&quot;]</span><br><span class="line">Output: bac</span><br><span class="line">Explanation: Given that the words are sorted lexicographically by the rules of the alien language, so</span><br><span class="line">from the given words we can conclude the following ordering among its characters:</span><br><span class="line"></span><br><span class="line">1. From &quot;ba&quot; and &quot;bc&quot;, we can conclude that &#39;a&#39; comes before &#39;c&#39;.</span><br><span class="line">2. From &quot;bc&quot; and &quot;ac&quot;, we can conclude that &#39;b&#39; comes before &#39;a&#39;</span><br><span class="line"></span><br><span class="line">From the above two points, we can conclude that the correct character order is: &quot;bac&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Character, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Character, List&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> character : word.toCharArray()) &#123;</span><br><span class="line">            inDegree.put(character, <span class="number">0</span>);</span><br><span class="line">            graph.put(character, <span class="keyword">new</span> ArrayList&lt;Character&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        String w1 = words[i], w2 = words[i + <span class="number">1</span>]; <span class="comment">// find ordering of characters from adjacent words</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Math.min(w1.length(), w2.length()); j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> parent = w1.charAt(j), child = w2.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (parent != child) &#123; <span class="comment">// if the two characters are different</span></span><br><span class="line">                graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">                inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// only the first different character between the two words will help us find the order</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Character&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">    <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">    StringBuilder sortedOrder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        Character vertex = sources.poll();</span><br><span class="line">        sortedOrder.append(vertex);</span><br><span class="line">        List&lt;Character&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">        <span class="keyword">for</span> (Character child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                sources.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder doesn't contain all characters, there is a cyclic dependency between characters, therefore, we</span></span><br><span class="line">    <span class="comment">// will not be able to find the correct ordering of the characters</span></span><br><span class="line">    <span class="keyword">if</span> (sortedOrder.length() != inDegree.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedOrder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-269-Alien-Dictionary🎂✨"><a href="#🌕Unsolved-269-Alien-Dictionary🎂✨" class="headerlink" title="🌕Unsolved 269.Alien Dictionary🎂✨"></a><a href="https://leetcode.com/problems/alien-dictionary/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">🌕Unsolved 269.Alien Dictionary🎂✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 0: Create data structures and find all unique letters.</span></span><br><span class="line">    Map&lt;Character, List&lt;Character&gt;&gt; adjList = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            counts.put(c, <span class="number">0</span>);</span><br><span class="line">            adjList.put(c, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: Find all edges.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        String word1 = words[i];</span><br><span class="line">        String word2 = words[i + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// Check that word2 is not a prefix of word1.</span></span><br><span class="line">        <span class="keyword">if</span> (word1.length() &gt; word2.length() &amp;&amp; word1.startsWith(word2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Find the first non match and insert the corresponding relation.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Math.min(word1.length(), word2.length()); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(j) != word2.charAt(j)) &#123;</span><br><span class="line">                adjList.get(word1.charAt(j)).add(word2.charAt(j));</span><br><span class="line">                counts.put(word2.charAt(j), counts.get(word2.charAt(j)) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Breadth-first search.</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Character c : counts.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counts.get(c).equals(<span class="number">0</span>)) &#123;</span><br><span class="line">            queue.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Character c = queue.remove();</span><br><span class="line">        sb.append(c);</span><br><span class="line">        <span class="keyword">for</span> (Character next : adjList.get(c)) &#123;</span><br><span class="line">            counts.put(next, counts.get(next) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (counts.get(next).equals(<span class="number">0</span>)) &#123;</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sb.length() &lt; counts.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-1-Reconstructing-a-Sequence-hard"><a href="#Challenge-1-Reconstructing-a-Sequence-hard" class="headerlink" title="Challenge 1 Reconstructing a Sequence (hard)"></a>Challenge 1 Reconstructing a Sequence (hard)</h2><p>The above explanation tells us that we are actually asked to find the topological ordering of all the numbers and also to verify that there is only one topological ordering of the numbers possible from the given array of the sequences.</p>
<p>This makes the current problem similar to <a href="https://www.educative.io/collection/page/5668639101419520/5671464854355968/5066018374287360/" target="_blank" rel="noopener">Tasks Scheduling Order</a> with two differences:</p>
<ol>
<li>We need to build the graph of the numbers by comparing each pair of numbers in the given array of sequences.</li>
<li>We must perform the topological sort for the graph to determine two things:<ul>
<li>Can the topological ordering construct the <code>originalSeq</code>?</li>
<li>That there is only one topological ordering of the numbers possible. This can be confirmed if we do not have more than one source at any time while finding the topological ordering of numbers.</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(<span class="keyword">int</span>[] originalSeq, <span class="keyword">int</span>[][] sequences)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (originalSeq.length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] seq : sequences) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seq.length; i++) &#123;</span><br><span class="line">            inDegree.putIfAbsent(seq[i], <span class="number">0</span>);</span><br><span class="line">            graph.putIfAbsent(seq[i], <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] seq : sequences) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; seq.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = seq[i - <span class="number">1</span>], child = seq[i];</span><br><span class="line">            graph.get(parent).add(child);</span><br><span class="line">            inDegree.put(child, inDegree.get(child) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we don't have ordering rules for all the numbers we'll not able to uniquely construct the sequence</span></span><br><span class="line">    <span class="keyword">if</span> (inDegree.size() != originalSeq.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">    <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">    <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sources.size() &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// more than one sources mean, there is more than one way to reconstruct the sequence</span></span><br><span class="line">        <span class="keyword">if</span> (originalSeq[sortedOrder.size()] != sources.peek())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// the next source (or number) is different from the original sequence</span></span><br><span class="line">        <span class="keyword">int</span> vertex = sources.poll();</span><br><span class="line">        sortedOrder.add(vertex);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                sources.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder's size is not equal to original sequence's size, there is no unique way to construct  </span></span><br><span class="line">    <span class="keyword">return</span> sortedOrder.size() == originalSeq.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Challenge-2-Minimum-Height-Trees-hard"><a href="#🌕Unsolved-Challenge-2-Minimum-Height-Trees-hard" class="headerlink" title="🌕Unsolved Challenge 2 Minimum Height Trees (hard)"></a>🌕Unsolved Challenge 2 Minimum Height Trees (hard)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findTrees</span><span class="params">(<span class="keyword">int</span> nodes, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; minHeightTrees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nodes &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> minHeightTrees;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one node, since its in-degree will be 0, therefore, we need to handle it separately</span></span><br><span class="line">    <span class="keyword">if</span> (nodes == <span class="number">1</span>) &#123;</span><br><span class="line">        minHeightTrees.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> minHeightTrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = edges[i][<span class="number">0</span>], n2 = edges[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// since this is an undirected graph, therefore, add a link for both the nodes</span></span><br><span class="line">        graph.get(n1).add(n2);</span><br><span class="line">        graph.get(n2).add(n1);</span><br><span class="line">        <span class="comment">// increment the in-degrees of both the nodes</span></span><br><span class="line">        inDegree.put(n1, inDegree.get(n1) + <span class="number">1</span>);</span><br><span class="line">        inDegree.put(n2, inDegree.get(n2) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all leaves i.e., all nodes with only 1 in-degree</span></span><br><span class="line">    Queue&lt;Integer&gt; leaves = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">1</span>)</span><br><span class="line">            leaves.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. Remove leaves level by level and subtract each leave's children's in-degrees.</span></span><br><span class="line">    <span class="comment">// Repeat this until we are left with 1 or 2 nodes, which will be our answer.</span></span><br><span class="line">    <span class="comment">// Any node that has already been a leaf cannot be the root of a minimum height tree, because </span></span><br><span class="line">    <span class="comment">// its adjacent non-leaf node will always be a better candidate.</span></span><br><span class="line">    <span class="keyword">int</span> totalNodes = nodes;</span><br><span class="line">    <span class="keyword">while</span> (totalNodes &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> leavesSize = leaves.size();</span><br><span class="line">        totalNodes -= leavesSize;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leavesSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> vertex = leaves.poll();</span><br><span class="line">            List&lt;Integer&gt; children = graph.get(vertex);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">                inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(child) == <span class="number">1</span>) <span class="comment">// if the child has become a leaf</span></span><br><span class="line">                    leaves.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    minHeightTrees.addAll(leaves);</span><br><span class="line">    <span class="keyword">return</span> minHeightTrees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-310-Minimum-Height-Trees🎂✨"><a href="#Unsolved-310-Minimum-Height-Trees🎂✨" class="headerlink" title="Unsolved 310. Minimum Height Trees🎂✨"></a><a href="https://leetcode.com/problems/minimum-height-trees/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 310. Minimum Height Trees🎂✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        ans.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = e[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> j = e[<span class="number">1</span>];</span><br><span class="line">        graph.get(i).add(j);</span><br><span class="line">        graph.get(j).add(i);</span><br><span class="line">        inDegree.put(i, inDegree.get(i) + <span class="number">1</span>);</span><br><span class="line">        inDegree.put(j, inDegree.get(j) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> node : inDegree.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree.get(node) == <span class="number">1</span>) &#123;</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nodeNum = n;</span><br><span class="line">    <span class="keyword">while</span>(nodeNum &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        nodeNum -= size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leaf = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : graph.get(leaf)) &#123;</span><br><span class="line">                inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(child) == <span class="number">1</span>) &#123;</span><br><span class="line">                    queue.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Coderust-Hacking-the-Coding-Interview"><a href="#Coderust-Hacking-the-Coding-Interview" class="headerlink" title="Coderust: Hacking the Coding Interview"></a>Coderust: Hacking the Coding Interview</h1><h2 id="Clone-a-Directed-Graph"><a href="#Clone-a-Directed-Graph" class="headerlink" title="Clone a Directed Graph"></a>Clone a Directed Graph</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;data = d;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">clone_rec</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Node root, </span></span></span><br><span class="line"><span class="function"><span class="params">        HashMap&lt;Node, Node&gt; nodes_completed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node pNew = <span class="keyword">new</span> Node(root.data);</span><br><span class="line">        nodes_completed.put(root, pNew);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node p : root.neighbors) &#123;</span><br><span class="line">            Node x = nodes_completed.get(p);</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="keyword">null</span>)&#123;</span><br><span class="line">                pNew.neighbors.add(clone_rec(p, nodes_completed));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pNew.neighbors.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-133-Clone-Graph🎂✨"><a href="#Unsolved-133-Clone-Graph🎂✨" class="headerlink" title="Unsolved 133. Clone Graph🎂✨"></a><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">Unsolved 133. Clone Graph🎂✨</a></h2><p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. OJ’s undirected graph serialization: Nodes are labeled uniquely.</p>
<p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node. As an example, consider the serialized graph {0,1,2#1,2#2,2}. The graph has a total of three nodes, and therefore contains three parts as separated by #. </p>
<ol>
<li>First node is labeled as 0. Connect node 0 to both nodes 1 and 2. </li>
<li>Second node is labeled as 1. Connect node 1 to node 2. </li>
<li>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle. Visually, the graph looks like the following:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span></span><br><span class="line">  / \</span><br><span class="line"> /   \</span><br><span class="line"><span class="number">0</span> --- <span class="number">2</span></span><br><span class="line">    / \</span><br><span class="line">    \_/</span><br><span class="line">Definition <span class="keyword">for</span> a Node.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">        neighbors = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, ArrayList&lt;Node&gt; _neighbors)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路 1：BFS，每次把新结点放入将访问队列，通过 Map 记录已访问结点，避免重复访问。</li>
<li>O(nk)，n 结点数， k 邻居数。前提：结点中的值唯一。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node root = <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(node, root);</span><br><span class="line">    queue.add(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (Node neighbor : cur.neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(neighbor)) &#123;</span><br><span class="line">                map.put(neighbor, <span class="keyword">new</span> Node(neighbor.val, <span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">                queue.add(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(cur).neighbors.add(map.get(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路 2：DFS，思路同思路 1，只不过深度优先，好处是结点访问次数减少。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> dfs(node, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">dfs</span><span class="params">(Node node, Map&lt;Node, Node&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Node copyNode = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">    map.put(node, copyNode);</span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : node.neighbors) &#123;</span><br><span class="line">        Node next = map.get(neighbor);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            copyNode.neighbors.add(dfs(neighbor, map));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            copyNode.neighbors.add(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copyNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="🌕Minimum-Spanning-Tree"><a href="#🌕Minimum-Spanning-Tree" class="headerlink" title="🌕Minimum Spanning Tree"></a>🌕Minimum Spanning Tree</h1><h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><h2 id="Depth-first-Search-AE"><a href="#Depth-first-Search-AE" class="headerlink" title="Depth first Search(AE)"></a>Depth first Search(AE)</h2><h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>traverse the tree-like graph</li>
<li>V-vertex nodes, E-edges the line between node, call a bunch of stack</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(V+E) T</span></span><br><span class="line"><span class="comment">//O(V) S</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do not edit the class below except</span></span><br><span class="line">    <span class="comment">// for the depthFirstSearch method.</span></span><br><span class="line">    <span class="comment">// Feel free to add new properties</span></span><br><span class="line">    <span class="comment">// and methods to the class.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        List&lt;Node&gt; children = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">depthFirstSearch</span><span class="params">(List&lt;String&gt; array)</span> </span>&#123;</span><br><span class="line">            array.add(<span class="keyword">this</span>.name);  <span class="comment">//add the node to result</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chileren.size(); ++i) &#123;  <span class="comment">//traverse each children node and call DFS function recursively</span></span><br><span class="line">                children.get(i).depthFirstSearch(array);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">addChild</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            Node child = <span class="keyword">new</span> Node(name);</span><br><span class="line">            children.add(child);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="863-All-Nodes-Distance-K-in-Binary-Tree⭐"><a href="#863-All-Nodes-Distance-K-in-Binary-Tree⭐" class="headerlink" title="863. All Nodes Distance K in Binary Tree⭐"></a><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener">863. All Nodes Distance K in Binary Tree⭐</a></h2><p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2018/06/863-ep202.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">7</span>,<span class="number">4</span>], target = <span class="number">5</span>, K = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">The nodes that are a distance <span class="number">2</span> <span class="function">from the target <span class="title">node</span> <span class="params">(with value <span class="number">5</span>)</span></span></span><br><span class="line"><span class="function">have values 7, 4, and 1.</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt=""></p>
<h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Build graph, BFS/DFS traverse</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method 1: use HashMap</span></span><br><span class="line"><span class="comment">//1. build a undirected graph using treenodes as vertices, and the parent-child relation as edges</span></span><br><span class="line"><span class="comment">//2. do BFS with source vertice (target) to find all vertices with distance K to it.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//here can also use Map&lt;TreeNode, TreeNode&gt; to only store the child - parent mapping, since parent-child mapping is inherent in the tree structure</span></span><br><span class="line"></span><br><span class="line">Map&lt;TreeNode, List&lt;TreeNode&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || K &lt; <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    buildGraph(root, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (!graph.containsKey(target)) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    Set&lt;TreeNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(target);</span><br><span class="line">    visited.add(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="comment">//if distance is K, add this level to the ans list</span></span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                ans.add(queue.poll().val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode neighbor : graph.get(cur)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited.contains(neighbor)) <span class="keyword">continue</span>;</span><br><span class="line">                queue.add(neighbor);</span><br><span class="line">                visited.add(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        K--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(TreeNode root, TreeNode parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!graph.containsKey(root)) &#123;</span><br><span class="line">        graph.put(root, <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;());</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            graph.get(root).add(parent);</span><br><span class="line">            graph.get(parent).add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        buildGraph(root.left, root);</span><br><span class="line">        buildGraph(root.right, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check:</span></span><br><span class="line"><span class="comment">1. If root == null</span></span><br><span class="line"><span class="comment">2. K &lt; 0</span></span><br><span class="line"><span class="comment">3. traget inside the tree</span></span><br><span class="line"><span class="comment">return empty list</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">BFS,start from target</span></span><br><span class="line"><span class="comment">Step1: Build a graph use adjacency list,</span></span><br><span class="line"><span class="comment">Step2: BFS with a queue</span></span><br><span class="line"><span class="comment">    1.add taregt to queue</span></span><br><span class="line"><span class="comment">    2.level by level, utilize the neighbor list in the graph</span></span><br><span class="line"><span class="comment">    3.in K th level which means K distance from target, add all element in this level to a list and retrun it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2</span></span><br><span class="line"><span class="comment">adjacency list:</span></span><br><span class="line"><span class="comment">3 -&gt; [5,1]</span></span><br><span class="line"><span class="comment">5 -&gt; [6,2,3]</span></span><br><span class="line"><span class="comment">6 -&gt; [5]</span></span><br><span class="line"><span class="comment">2 -&gt; [5,7,4]</span></span><br><span class="line"><span class="comment">7 -&gt; [2]</span></span><br><span class="line"><span class="comment">4 -&gt; [2]</span></span><br><span class="line"><span class="comment">1 -&gt; [3,0,8]</span></span><br><span class="line"><span class="comment">0 -&gt; [1]</span></span><br><span class="line"><span class="comment">8 -&gt; [1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Go through an example:</span></span><br><span class="line"><span class="comment">target:5, K = 2</span></span><br><span class="line"><span class="comment">queue: 7,4,1</span></span><br><span class="line"><span class="comment">level:2</span></span><br><span class="line"><span class="comment">ans: 7,4,1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method 2: No HashMap</span></span><br><span class="line"><span class="comment">//kind of like clone the tree, in the meanwhile add a parent link to the node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GNode targetGNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">GNode</span> </span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        GNode parent, left, right;</span><br><span class="line">        GNode (TreeNode node) &#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;           </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || K &lt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        cloneGraph(root, <span class="keyword">null</span>, target);</span><br><span class="line">        <span class="keyword">if</span> (targetGNode == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Set&lt;GNode&gt; visited = <span class="keyword">new</span> HashSet&lt;GNode&gt;();</span><br><span class="line">        Queue&lt;GNode&gt; q = <span class="keyword">new</span> LinkedList&lt;GNode&gt;();</span><br><span class="line">        q.add(targetGNode);</span><br><span class="line">        visited.add(targetGNode);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size ; i++) res.add(q.poll().node.val);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                GNode gNode = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (gNode.left != <span class="keyword">null</span> &amp;&amp; !visited.contains(gNode.left)) &#123; visited.add(gNode.left); q.add(gNode.left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (gNode.right != <span class="keyword">null</span> &amp;&amp; !visited.contains(gNode.right)) &#123; visited.add(gNode.right); q.add(gNode.right); &#125;</span><br><span class="line">                <span class="keyword">if</span> (gNode.parent != <span class="keyword">null</span> &amp;&amp; !visited.contains(gNode.parent)) &#123; visited.add(gNode.parent); q.add(gNode.parent); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            K--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> GNode <span class="title">cloneGraph</span><span class="params">(TreeNode node, GNode parent, TreeNode target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        GNode gNode = <span class="keyword">new</span> GNode(node);</span><br><span class="line">        <span class="keyword">if</span> (node == target) targetGNode = gNode;</span><br><span class="line">        gNode.parent = parent;</span><br><span class="line">        gNode.left = cloneGraph(node.left, gNode, target);</span><br><span class="line">        gNode.right = cloneGraph(node.right, gNode, target);</span><br><span class="line">        <span class="keyword">return</span> gNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Boggle-Board-AE-⭐"><a href="#🌕Unsolved-Boggle-Board-AE-⭐" class="headerlink" title="🌕Unsolved Boggle Board(AE)⭐"></a>🌕Unsolved Boggle Board(AE)⭐</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[t,h,i,s,i,s,a],</span><br><span class="line"> [s,i,m,p,l,e,x],</span><br><span class="line"> [b,x,x,x,x,e,b],</span><br><span class="line"> [x,o,g,g,l,x,o],</span><br><span class="line"> [x,x,x,D,T,r,a],</span><br><span class="line"> [R,E,P,E,A,d,x],</span><br><span class="line"> [x,x,x,x,x,x,x],</span><br><span class="line"> [N,O,T,R,E,-,P],</span><br><span class="line"> [x,x,D,E,T,A,E],]</span><br><span class="line"></span><br><span class="line">output:[<span class="keyword">this</span>, is, a, simple, boggle, board, NOTRE-PEATED]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Use a trie data structure to store the strings</li>
<li>getNeightbors</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(nm * 8^s + ws(build trie)) (8 neighbor, s mean length of longest string)</span></span><br><span class="line"><span class="comment">//O(nm + ws)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">boggleBoard</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">    Trie trie = <span class="keyword">new</span> Trie();  <span class="comment">//create our trie</span></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;  <span class="comment">//pass in all string</span></span><br><span class="line">        trie.add(word);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//words may appear multiple times, so use hash table every word can only appear once</span></span><br><span class="line">    Set&lt;String&gt; finalWords = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//visited matrix keep track wheather the node has been visited</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="comment">//helper function which we will write in a second</span></span><br><span class="line">            explore(i, j, board, trie.root, visited, finalWords);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; finalWordsArray = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    finalWordsArray.addAll(finalWords);</span><br><span class="line">    <span class="keyword">return</span> finalWordsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//take a position, a trie node, board, trie, visited and final words</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">explore</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[][] board, TrieNode trieNode, <span class="keyword">boolean</span>[][] visited, Set&lt;String&gt; finalWords)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[i][j]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> letter = board[i][j];</span><br><span class="line">    <span class="comment">//if not we are done with this part branch</span></span><br><span class="line">    <span class="keyword">if</span> (!trieNode.children.containsKey(letter)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if it is the letter, we mark it visited and futher depth firsr seaech this path</span></span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    trieNode = trieNode.children.get(letter);  <span class="comment">//updat the trieNode, trie level</span></span><br><span class="line">    <span class="keyword">if</span> (trieNode.children.containsKey(<span class="string">'*'</span>)) &#123;  <span class="comment">//if meet '*', we get a actual string add it to finalwords</span></span><br><span class="line">        finalWords.add(trieNode.word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get all neighbors and explore all neighbors</span></span><br><span class="line">    List&lt;Integer[]&gt; neighbors = getNeighbors(i, j, board);</span><br><span class="line">    <span class="keyword">for</span> (Integer[] neighbor : neighbors) &#123;</span><br><span class="line">        explore(neighbor[<span class="number">0</span>], neighbor[<span class="number">1</span>], board, trieNode, visited, finalWords);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//unvisited the current node, like backtracking, for other branch traverse</span></span><br><span class="line">    visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer[]&gt; getNeighbors(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[][] board) &#123;</span><br><span class="line">    List&lt;Integer[]&gt; neighbors = <span class="keyword">new</span> ArrayList&lt;Integer[]&gt;();</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i - <span class="number">1</span>, j - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i - <span class="number">1</span>, j + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; board.length - <span class="number">1</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; board.length - <span class="number">1</span> &amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i + <span class="number">1</span>, j - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i - <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; board.length - <span class="number">1</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i + <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i, j - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i, j + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> neighbors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,TrieNode&gt; children = <span class="keyword">new</span> HashMap&lt;Character, TrieNode&gt;();</span><br><span class="line">    String word = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    TrieNode root;</span><br><span class="line">    <span class="keyword">char</span> endSymbol;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="keyword">this</span>.endSymbol = <span class="string">'*'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        TrieNode node = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> letter = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.children.containsKey(letter)) &#123;</span><br><span class="line">                TrieNode newNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                node.children.put(letter, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children.get(letter);</span><br><span class="line">        &#125;</span><br><span class="line">        node.children.put(<span class="keyword">this</span>.endSymbol, <span class="keyword">null</span>);</span><br><span class="line">        node.word = strCourse Schedule II;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-1258-Synonymous-Sentences⭐"><a href="#🌕Unsolved-1258-Synonymous-Sentences⭐" class="headerlink" title="🌕Unsolved 1258. Synonymous Sentences⭐"></a><a href="https://leetcode.com/problems/synonymous-sentences/" target="_blank" rel="noopener">🌕Unsolved 1258. Synonymous Sentences⭐</a></h2><p>Given a list of pairs of equivalent words <code>synonyms</code> and a sentence <code>text</code>, Return all possible synonymous sentences <strong>sorted lexicographically</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">synonyms = [[<span class="string">"happy"</span>,<span class="string">"joy"</span>],[<span class="string">"sad"</span>,<span class="string">"sorrow"</span>],[<span class="string">"joy"</span>,<span class="string">"cheerful"</span>]],</span><br><span class="line">text = <span class="string">"I am happy today but was sad yesterday"</span></span><br><span class="line">Output:</span><br><span class="line">[<span class="string">"I am cheerful today but was sad yesterday"</span>,</span><br><span class="line"><span class="string">"I am cheerful today but was sorrow yesterday"</span>,</span><br><span class="line"><span class="string">"I am happy today but was sad yesterday"</span>,</span><br><span class="line"><span class="string">"I am happy today but was sorrow yesterday"</span>,</span><br><span class="line"><span class="string">"I am joy today but was sad yesterday"</span>,</span><br><span class="line"><span class="string">"I am joy today but was sorrow yesterday"</span>]</span><br><span class="line"></span><br><span class="line">synonyms = [[<span class="string">"happy"</span>,<span class="string">"joy"</span>],[<span class="string">"strong"</span>,<span class="string">"healthy"</span>],[<span class="string">"joy"</span>,<span class="string">"cheerful"</span>]],</span><br><span class="line">text = <span class="string">"I am happy and strong"</span></span><br><span class="line">This solution will work like below picture</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/users/hiepit/image_1573965953.png" alt=""></p>
<h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateSentences</span><span class="params">(List&lt;List&lt;String&gt;&gt; synonyms, String text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//build graph</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; pair : synonyms) &#123;</span><br><span class="line">        String s1 = pair.get(<span class="number">0</span>);</span><br><span class="line">        String s2 = pair.get(<span class="number">1</span>);</span><br><span class="line">        connect(graph, s1, s2);</span><br><span class="line">        connect(graph, s2, s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    Set&lt;String&gt; ans = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(text);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        ans.add(cur);</span><br><span class="line">        String[] words = cur.split(<span class="string">"\\s"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph.get(words[i]) == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// Replace words[i] with its synonym</span></span><br><span class="line">            <span class="keyword">for</span> (String neighbor : graph.get(words[i])) &#123;</span><br><span class="line">                words[i] = neighbor;</span><br><span class="line">                String next = String.join(<span class="string">" "</span>, words);</span><br><span class="line">                <span class="keyword">if</span> (!ans.contains(next)) &#123;</span><br><span class="line">                    queue.add(next);  <span class="comment">//pay attention to here</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; graph, String s1, String s2)</span> </span>&#123;</span><br><span class="line">    graph.putIfAbsent(s1, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    graph.get(s1).add(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateSentences</span><span class="params">(List&lt;List&lt;String&gt;&gt; synonyms, String text)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; ans = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    buildGraph(graph, synonyms);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(text);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        ans.add(cur);</span><br><span class="line">        String[] strs = cur.split(<span class="string">"\\s+"</span>);  <span class="comment">//note</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            List&lt;String&gt; list = graph.get(strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String neighbor : list) &#123;</span><br><span class="line">                    strs[i] = neighbor;</span><br><span class="line">                    String next = String.join(<span class="string">" "</span>, strs);  <span class="comment">//note</span></span><br><span class="line">                    <span class="keyword">if</span> (!ans.contains(next)) &#123;</span><br><span class="line">                        queue.add(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; graph, List&lt;List&lt;String&gt;&gt; synonyms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; list : synonyms) &#123;</span><br><span class="line">        String s1 = list.get(<span class="number">0</span>);</span><br><span class="line">        String s2 = list.get(<span class="number">1</span>);</span><br><span class="line">        graph.putIfAbsent(s1, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        graph.get(s1).add(s2);</span><br><span class="line">        graph.putIfAbsent(s2, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        graph.get(s2).add(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Single-Cycle-Check-AE"><a href="#Single-Cycle-Check-AE" class="headerlink" title="Single Cycle Check(AE)"></a>Single Cycle Check(AE)</h2><ol>
<li>Give a list of Integer, determine whether is there exist a single cycle, a loop visit every element only once</li>
<li>jump</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,-<span class="number">4</span>,-<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,<span class="number">1</span>] visit number</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(1) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSingleCycle</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numElementsVisits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curIdx = <span class="number">0</span>;  <span class="comment">//keep track the element we at the array, not necessary to be 0</span></span><br><span class="line">    <span class="keyword">while</span> (numElementsVisits &lt; array.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numElementsVisits &gt; <span class="number">0</span> &amp;&amp; curIdx == <span class="number">0</span>) &#123;  <span class="comment">//if we pass the first element before whole loop, the size of cycle not array.length</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        numElementsVisits++;  <span class="comment">//increase the element we have visited</span></span><br><span class="line">        curIdx = getNextIdx(curIdx, array);  <span class="comment">//jump wo next elements</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curIdx == <span class="number">0</span>;  <span class="comment">//aftr one whole loop, if it back to the start pointer, return true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextIdx</span><span class="params">(<span class="keyword">int</span> curIdx, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> jump = array[curIdx];  <span class="comment">//jump distance is the value of element</span></span><br><span class="line">    <span class="keyword">int</span> nextIdx = (curIdx + jump) % array.length;  <span class="comment">//apply mod operation if idx over the bound</span></span><br><span class="line">    <span class="keyword">return</span> nextIdx &gt;= <span class="number">0</span> ? nextIdx : nextIdx + array.length;  <span class="comment">//consider the negetave idx case</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Breadth-First-Search-AE"><a href="#Breadth-First-Search-AE" class="headerlink" title="Breadth First Search(AE)"></a>Breadth First Search(AE)</h2><ol>
<li><p>Target graph is a tree like graph traverse in a BFS way</p>
</li>
<li><p>DFS : branch by branch ; BFS : level by level</p>
</li>
<li><p>use queue (FIFO) will helpful to track the same level node</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">current: A</span><br><span class="line">Final array [A]  when we add A to <span class="keyword">final</span> array add all children BCD to queue</span><br><span class="line">Queue [B, C, D]</span><br><span class="line">    </span><br><span class="line">current: B</span><br><span class="line">Final array [A, B] when we add B to <span class="keyword">final</span> array add all children EF to queue</span><br><span class="line">Queue [C, D, E, F]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Problem</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        List&lt;Node&gt; children = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//O(v + e) time | O(v) space queue may be A have all children BCDEF in queue</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">breadthFirstSearch</span><span class="params">(List&lt;String&gt; array)</span> </span>&#123;</span><br><span class="line">            Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">            queue.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                Node current = queue.poll();</span><br><span class="line">                array.add(current.name);</span><br><span class="line">                queue.addAll(current.children);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">addChild</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            Node child = <span class="keyword">new</span> Node(name);</span><br><span class="line">            children.add(child);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="River-Sizes-AE-Number-of-Island-with-Area-follow-up⭐"><a href="#River-Sizes-AE-Number-of-Island-with-Area-follow-up⭐" class="headerlink" title="River Sizes(AE) || Number of Island with Area follow up⭐"></a>River Sizes(AE) || Number of Island with Area follow up⭐</h2><h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Classical graph traversal question, given a matrix, 0 -&gt; land, 1 -&gt;river. River size is the 1 that are adjacent, right next to each other either horizontally or vertically. Write  function to return an array of all pf the sizes of rivers in the matrix</li>
<li>Treat the matrix element as node, each has neighbor node. Use BFS or DFS to all neighbor node to do so. Technique: keep track of all the node we visited. Traverse all the node in sequence and keep track the size of river and visited</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(wh) time | O(wh) space width and height of matix</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">riverSizes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sizes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  <span class="comment">//initialize the size of rivers</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length][matrix[<span class="number">0</span>].length];  <span class="comment">//declare a boolean matrix that determines if the node has been visited</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; ++i) &#123;  <span class="comment">//row and column may different number</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i][j]) &#123;  <span class="comment">//is this node is already visited</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            traverseNode(i, j, matrix, visited, sizes);  <span class="comment">//call a tarverse helper function</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sizes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseNode</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] matrix, <span class="keyword">boolean</span>[][] visited, List&lt;Integer&gt; sizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentRiverSize = <span class="number">0</span>;  <span class="comment">//declare a polential river size varaible</span></span><br><span class="line">    Stack&lt;Integer[]&gt; nodesToExplore = <span class="keyword">new</span> Stack&lt;Integer[]&gt;();  <span class="comment">//apply DFS iteratively</span></span><br><span class="line">    nodesToExplore.push(<span class="keyword">new</span> Integer[]&#123;i, j&#125;);  <span class="comment">//the first need to explore is [i, j]</span></span><br><span class="line">    <span class="keyword">while</span> (!nodesToExplore.empty()) &#123;  <span class="comment">//pushing th neighbors to stack, and pop one by one, and BFS will use a queue instead of a stack</span></span><br><span class="line">        Integer[] currentNode = nodesToExplore.pop();</span><br><span class="line">        i = currentNode[<span class="number">0</span>];</span><br><span class="line">        j = currentNode[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (visited[i][j]) &#123;  <span class="comment">//when apply DFS if the node has been visited, skip continue</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;  <span class="comment">//else, set it has been visited</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;  <span class="comment">//if it is a piece of land, skip continue</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currentRiverSize++;  <span class="comment">//riversize++</span></span><br><span class="line">        <span class="comment">//we are doing with prevous unvisited one, go throuth the all unvisited neighbors, append them to the stack</span></span><br><span class="line">        List&lt;Integer[]&gt; unvisitedNeighbors = getUnvisitedNeighbors(i, j, matrix, visited);</span><br><span class="line">        <span class="keyword">for</span> (Integer[] neighbor : unvisitedNeighbors) &#123;</span><br><span class="line">            nodesToExplore.add(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentRiverSize &gt; <span class="number">0</span>) &#123;  <span class="comment">//if we have a actual river, add the size</span></span><br><span class="line">        sizes.add(currentRiverSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer[]&gt; getUnvisitedNeighbors(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] matrix, <span class="keyword">boolean</span>[][] visited) &#123;</span><br><span class="line">    List&lt;Integer[]&gt; unvisitedNeighbors = <span class="keyword">new</span> ArrayList&lt;Integer[]&gt;();  <span class="comment">//declare unvisited neighbors to an empty array , check the four neighbors are actually potentially valid neighbors</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !visited[i - <span class="number">1</span>][j]) &#123;  <span class="comment">//if there exist neighbor above us and unvisited, only add unvisited neighbors</span></span><br><span class="line">        unvisitedNeighbors.add(<span class="keyword">new</span> Integer[] &#123;i - <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; matrix.length - <span class="number">1</span> &amp;&amp; !visited[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">        unvisitedNeighbors.add(<span class="keyword">new</span> Integer[] &#123;i + <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; !visited[i][j - <span class="number">1</span>]) &#123;  <span class="comment">//if there left column neighbor and unvisited</span></span><br><span class="line">        unvisitedNeighbors.add(<span class="keyword">new</span> Integer[] &#123;i, j - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; matrix[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; !visited[i][j + <span class="number">1</span>]) &#123;  <span class="comment">//if there right column neighbor and unvisited</span></span><br><span class="line">        unvisitedNeighbors.add(<span class="keyword">new</span> Integer[] &#123;i, j + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unvisitedNeighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Youngest-Common-Ancestor-AE"><a href="#Youngest-Common-Ancestor-AE" class="headerlink" title="Youngest Common Ancestor(AE)"></a>Youngest Common Ancestor(AE)</h2><ol>
<li>Ancestor property, deal with the situation two children in the different level, equalize the two node depth check if they are same, if same return ancestor</li>
<li>else, go back together to find the same ancestor</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(D) time depth of two descendant | O(1) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AncestralTree <span class="title">getYoungestCommonAncestor</span><span class="params">(AncestoralTree topAncestor, AncestoralTree descendantOne, AncestoralTree descendantTwo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depthOne = getDescendantDepth(descendantOne, topAncestor);  <span class="comment">//use helper function to get the depth of both node</span></span><br><span class="line">    <span class="keyword">int</span> depthTwo = getDescendantDepth(descendantTwo, topAncestor);</span><br><span class="line">    <span class="keyword">if</span> (depthOne &gt; depthTwo) &#123;  <span class="comment">//first descendant is lower, bring it up</span></span><br><span class="line">        <span class="keyword">return</span> backtrackAncestralTree(descendantOne, descendantTwo, depthOne - depthTwo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> backtrackAncestralTree(descendantTwo, descendantOne, depthTwo - depthOne);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDescendantDepth</span><span class="params">(AncestralTree descendant, AncestralTree topAncestor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;  <span class="comment">//initialize deoth to 0 and update it</span></span><br><span class="line">    <span class="keyword">while</span> (descendant != topAncestor) &#123;</span><br><span class="line">        depth++;</span><br><span class="line">        descendant = descendant.ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AncestralTree <span class="title">backtrackAncestralTree</span><span class="params">(AncestralTree lowerDescendant, AncestralTree  higherDescendant, <span class="keyword">int</span> diff)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (diff &gt; <span class="number">0</span>) &#123;  <span class="comment">//bring up the lower descendant to the same level with higher descendant</span></span><br><span class="line">        lowerDescendant = lowerDescendant.ancestor;</span><br><span class="line">        diff--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (lowerDescendant != higherDescendant) &#123;  <span class="comment">//backtrack both until find the same ancestor</span></span><br><span class="line">        lowerDescendant = lowerDescendant.ancestor;</span><br><span class="line">        higherDescendant = higherDescendant.ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lowerDescendant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Rectangle-Mania-AE"><a href="#Unsolved-Rectangle-Mania-AE" class="headerlink" title="Unsolved Rectangle Mania(AE)"></a>Unsolved Rectangle Mania(AE)</h2><h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String UP = <span class="string">"up"</span>;</span><br><span class="line">    <span class="keyword">static</span> String DOWN = <span class="string">"down"</span>;</span><br><span class="line">    <span class="keyword">static</span> String LEFT = <span class="string">"left"</span>;</span><br><span class="line">    <span class="keyword">static</span> String RIGHT = <span class="string">"right"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rectangleMania</span><span class="params">(Point[] coords)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, List&lt;Point&gt;&gt;&gt; coordsTable = getCoordsTable(coords);</span><br><span class="line">        <span class="keyword">return</span> getRectangleCount(coords, coordsTable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Map&lt;String, List&lt;Point&gt;&gt;&gt; getCoordsTable(Point[] coords) &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, List&lt;Point&gt;&gt;&gt; coordsTable = <span class="keyword">new</span> HashMap&lt;String, List&lt;Point&gt;&gt;();</span><br><span class="line">        coord1Directions.put(UP, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">        coord1Directions.put(DOWN, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">        coord1Directions.put(LEFT, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">        coord1Directions.put(RIGHT, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">        <span class="keyword">for</span> (Point coord2 : coords) &#123;</span><br><span class="line">            String coords2Direction = getCoordDirection(coord1, coord2);</span><br><span class="line">            <span class="keyword">if</span> (coord1Directions.containsKey(coords2Direction)) &#123;</span><br><span class="line">                coord1Directions.get(coords2Direction).add(coord2);</span><br><span class="line">            &#125;</span><br><span class="line">            String coords1String = coordToString(coord1);</span><br><span class="line">            coordsTable.put(coord1String, coord1Directions);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coordsTable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCoordDirection</span><span class="params">(Point coord1, Point coord2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coord2.y == coord1.y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coord2.x == coord1.x) &#123;</span><br><span class="line">                <span class="keyword">return</span> RIGHT;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coord2.x &lt; coord1.x)&#123;</span><br><span class="line">                <span class="keyword">return</span> LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coord2.x == coord1.x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coord2.y &gt; coord1.y) &#123;</span><br><span class="line">                <span class="keyword">return</span> UP;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coord2.y &lt; coords1.y) &#123;</span><br><span class="line">                <span class="keyword">return</span> DOWN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRectangleCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">clockwiseCountRectangles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNextClockwiseDirection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">coordToString</span><span class="params">(Point coord)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.x = x;</span><br><span class="line">      <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-1042-Flower-Planting-With-No-Adjacent🎂"><a href="#Unsolved-1042-Flower-Planting-With-No-Adjacent🎂" class="headerlink" title="Unsolved 1042.Flower Planting With No Adjacent🎂"></a><a href="https://leetcode.com/problems/flower-planting-with-no-adjacent/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 1042.Flower Planting With No Adjacent🎂</a></h2><h2 id="Unsolved-990-Satisfiability-of-Equality-Equations🎂✨"><a href="#Unsolved-990-Satisfiability-of-Equality-Equations🎂✨" class="headerlink" title="Unsolved 990. Satisfiability of Equality Equations🎂✨"></a><a href="https://leetcode.com/problems/satisfiability-of-equality-equations/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 990. Satisfiability of Equality Equations🎂✨</a></h2><h1 id="二分图Bipartite"><a href="#二分图Bipartite" class="headerlink" title="二分图Bipartite"></a>二分图Bipartite</h1><p>如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么这个图就是二分图。</p>
<h2 id="🌕Unsolved-785-Is-Graph-Bipartite"><a href="#🌕Unsolved-785-Is-Graph-Bipartite" class="headerlink" title="🌕Unsolved 785.Is Graph Bipartite?"></a><a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener">🌕Unsolved 785.Is Graph Bipartite?</a></h2><p>Given an undirected <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p>
<p>A graph is <em>bipartite</em> if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">Output: <span class="keyword">true</span></span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like <span class="keyword">this</span>:</span><br><span class="line"><span class="number">0</span>----<span class="number">1</span></span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line"><span class="number">3</span>----<span class="number">2</span></span><br><span class="line">We can divide the vertices into two groups: &#123;<span class="number">0</span>, <span class="number">2</span>&#125; and &#123;<span class="number">1</span>, <span class="number">3</span>&#125;.</span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line">Input: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like <span class="keyword">this</span>:</span><br><span class="line"><span class="number">0</span>----<span class="number">1</span></span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line"><span class="number">3</span>----<span class="number">2</span></span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><p><code>Our goal</code> is trying to use two colors to color the graph and see if there are any adjacent nodes having the same color.<br>Initialize a color[] array for each node. Here are three states for <code>colors[]</code> array:<br><code>0: Haven&#39;t been colored yet.</code><br><code>1: Blue.</code><br><code>-1: Red.</code><br>For each node,</p>
<ol>
<li>If it hasn’t been colored, use a color to color it. Then use the other color to color all its adjacent nodes (DFS).</li>
<li>If it has been colored, check if the current color is the same as the color that is going to be used to color it. </li>
</ol>
<p>DFS Solution:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    Arrays.fill(colors, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;  <span class="comment">//This graph might be a disconnected graph. So check each unvisited node.</span></span><br><span class="line">        <span class="keyword">if</span> (colors[i] == -<span class="number">1</span> &amp;&amp; !isBipartite(i, <span class="number">0</span>, colors, graph)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span> curNode, <span class="keyword">int</span> curColor, <span class="keyword">int</span>[] colors, <span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (colors[curNode] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> colors[curNode] == curColor;</span><br><span class="line">    &#125;</span><br><span class="line">    colors[curNode] = curColor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nextNode : graph[curNode]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isBipartite(nextNode, <span class="number">1</span> - curColor, colors, graph)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS Solution:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="comment">// 0(not meet), 1(black), 2(white)</span></span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[i].length != <span class="number">0</span> &amp;&amp; visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                q.offer(i);</span><br><span class="line">                <span class="keyword">while</span>(! q.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> current = q.poll();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> c: graph[current]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (visited[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                            visited[c] = (visited[current] == <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">                            q.offer(c);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (visited[c] == visited[current]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;                        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = graph.length;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(i);</span><br><span class="line">        colors[i] = <span class="number">1</span>;   <span class="comment">// Blue: 1; Red: -1.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (colors[next] == <span class="number">0</span>) &#123;          <span class="comment">// If this node hasn't been colored;</span></span><br><span class="line">                    colors[next] = -colors[cur];  <span class="comment">// Color it with a different color;</span></span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colors[next] != -colors[cur]) &#123;   <span class="comment">// If it is colored and its color is different, return false;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。</p>
<h2 id="Minimize-Hamming-Distance-After-Swap-Operations🎃"><a href="#Minimize-Hamming-Distance-After-Swap-Operations🎃" class="headerlink" title="Minimize Hamming Distance After Swap Operations🎃"></a>Minimize Hamming Distance After Swap Operations🎃</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: source = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], target = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>], allowedSwaps = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: source can be transformed the following way:</span><br><span class="line">- Swap indices <span class="number">0</span> and <span class="number">1</span>: source = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">- Swap indices <span class="number">2</span> and <span class="number">3</span>: source = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">The Hamming distance of source and target is <span class="number">1</span> as they differ in <span class="number">1</span> position: index <span class="number">3</span>.</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>[] id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumHammingDistance</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] target, <span class="keyword">int</span>[][] allowedSwaps)</span> </span>&#123;</span><br><span class="line">    n = target.length;</span><br><span class="line">    id = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] a : allowedSwaps) &#123;</span><br><span class="line">        union(a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        map.putIfAbsent(getRoot(i), <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;());</span><br><span class="line">        map.get(getRoot(i)).put(source[i], map.get(getRoot(i)).getOrDefault(map.get(getRoot(i)).get(source[i])));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans= <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.get(getRoot(i)).contains(target[i])) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = getRoot(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = getRoot(q);</span><br><span class="line">    id[rootQ] = rootP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRoot(p) == getRoot(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRoot</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i != id[i]) &#123;</span><br><span class="line">        i = id[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Unsolved-684-Redundant-Connection"><a href="#Unsolved-684-Redundant-Connection" class="headerlink" title="Unsolved 684. Redundant Connection"></a><a href="https://leetcode.com/problems/redundant-connection/description/" target="_blank" rel="noopener">Unsolved 684. Redundant Connection</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">Output: [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Explanation: The given undirected graph will be like <span class="keyword">this</span>:</span><br><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span> - <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>题目描述：有一系列的边连成的图，找出一条边，移除它之后该图能够成为一棵树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="keyword">int</span> N = edges.length;</span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[<span class="number">0</span>], v = e[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (uf.connect(u, v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        uf.union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    UF(<span class="keyword">int</span> N) &#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> uID = find(u);</span><br><span class="line">        <span class="keyword">int</span> vID = find(v);</span><br><span class="line">        <span class="keyword">if</span> (uID == vID) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == uID) &#123;</span><br><span class="line">                id[i] = vID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(u) == find(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Graph-Algorithms-One-Place-Dijkstra-Bellman-Ford-Floyd-Warshall-Prims-Kruskals-DSU"><a href="#Graph-Algorithms-One-Place-Dijkstra-Bellman-Ford-Floyd-Warshall-Prims-Kruskals-DSU" class="headerlink" title="Graph Algorithms One Place | Dijkstra | Bellman Ford | Floyd Warshall | Prims | Kruskals | DSU"></a><a href="https://leetcode.com/discuss/general-discussion/969327/graph-algorithms-one-place-dijkstra-bellman-ford-floyd-warshall-prims-kruskals-dsu" target="_blank" rel="noopener">Graph Algorithms One Place | Dijkstra | Bellman Ford | Floyd Warshall | Prims | Kruskals | DSU</a></h2><h1 id="Data-Structures-for-Coding-Interviews-in-Java"><a href="#Data-Structures-for-Coding-Interviews-in-Java" class="headerlink" title="Data Structures for Coding Interviews in Java"></a><a href="https://www.educative.io/courses/data-structures-coding-interviews-java/gxQ283421q9" target="_blank" rel="noopener">Data Structures for Coding Interviews in Java</a></h1><blockquote>
<p>A graph is a set of <strong>vertices</strong> (nodes) that are connected to each other via <strong>edges</strong> in the form of a network.</p>
<p>The structures for storing data in a graph, represented in the form of <em>Nodes</em> (1,3,7…), are also called <strong>Vertices</strong></p>
<p>A <strong>pair(x,y)</strong> is called an <strong>edge</strong>, which indicates that vertex <strong>x</strong> is connected to vertex <strong>y</strong>. An edge may contain weight/cost, showing how much cost is required to traverse from vertex <strong>x</strong> to <strong>y</strong>.</p>
</blockquote>
<h2 id="There-are-two-common-types-of-graphs"><a href="#There-are-two-common-types-of-graphs" class="headerlink" title="There are two common types of graphs:"></a>There are two common types of graphs:</h2><ol>
<li>Undirected</li>
<li>Directed</li>
</ol>
<p><strong>Degree of Vertex</strong>: Total Number of edges connected to a vertex.</p>
<p>The <strong>adjacency matrix</strong> is a two-dimensional matrix where each cell can contain a <strong>0</strong> or <strong>1</strong>. The row and column headings represent the vertices.</p>
<p>If a cell contains <strong>1</strong>, there exists an edge between the corresponding vertices, e.g., Matrix[0][1]=1<em>M<strong>a</strong>t<strong>r</strong>i**x</em>[0][1]=1 shows that an edge exists between vertex <strong>0</strong> and <strong>1</strong>.</p>
<h2 id="Implement-a-Directed-Graph-in-java-using-an-Adjacency-List"><a href="#Implement-a-Directed-Graph-in-java-using-an-Adjacency-List" class="headerlink" title="Implement a Directed Graph in java using an Adjacency List"></a>Implement a <strong>Directed Graph</strong> in java using an Adjacency List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> vertices;</span><br><span class="line">    <span class="keyword">public</span> DoublyLinkedList&lt;Integer&gt; adjacencyList[];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> vertices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertices = vertices;</span><br><span class="line">        <span class="keyword">this</span>.adjacencyList = <span class="keyword">new</span> DoublyLinkedList[vertices];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">            adjacencyList[i] = <span class="keyword">new</span> DoublyLinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source &lt; vertices &amp;&amp; destination &lt; vertices) &#123;</span><br><span class="line">            <span class="keyword">this</span>.adjacencyList[source].insertEnd(destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;Adjacency List of Directed Graph&lt;&lt;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(adjacencyList[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">"|"</span> + i + <span class="string">"| =&gt; "</span>);</span><br><span class="line"></span><br><span class="line">                DoublyLinkedList&lt;Integer&gt;.Node temp = adjacencyList[i].getHeadNode();</span><br><span class="line">                <span class="keyword">while</span> (temp != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print(<span class="string">"["</span> + temp.data + <span class="string">"] -&gt; "</span>);</span><br><span class="line">                    temp = temp.nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"|"</span> + i + <span class="string">"| =&gt; "</span>+ <span class="string">"null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"><strong>Operation</strong></th>
<th align="center"><strong>Adjacency List</strong></th>
<th align="center"><strong>Adjacency Matrix</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Add Vertex</td>
<td align="center">O(1)</td>
<td align="center">O(V^2)</td>
</tr>
<tr>
<td align="center">Remove Vertex</td>
<td align="center">O(V+E)</td>
<td align="center">O(V^2)</td>
</tr>
<tr>
<td align="center">Add Edge</td>
<td align="center">O(1)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">Remove Edge</td>
<td align="center">O(E)</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong><em>A Bipartite Graph</em></strong> is a special kind of Graph, in which the vertices can be divided into two disjoint sets <em>U</em> and <em>V</em> such that no vertex of <em>U</em> is adjacent to any other vertex in <em>U</em> and no vertex of <em>V</em> is adjacent to any other vertex in <em>V</em>. Vertices in <em>U</em> have edges that connect it to vertices in <em>V</em>.</p>
</blockquote>
<h2 id="Types-of-bipartite-graphs"><a href="#Types-of-bipartite-graphs" class="headerlink" title="Types of bipartite graphs"></a>Types of bipartite graphs</h2><p>Some other types of Bipartite graphs are listed below:</p>
<ul>
<li><strong>Complete Bipartite Graphs:</strong> A complete Bipartite graph connects each vertex from set V1 to each vertex from set V2.</li>
<li><strong>Star Graphs:</strong> A star graph is a complete bipartite graph if a single vertex belongs to one set, and all the remaining vertices belong to the other set.</li>
<li><strong>Acyclic Graphs:</strong> A graph with no cycles is called an acyclic graph.</li>
</ul>
<h2 id="Challenge1-Breadth-First-Search-or-BFS-for-a-Graph"><a href="#Challenge1-Breadth-First-Search-or-BFS-for-a-Graph" class="headerlink" title="Challenge1: Breadth First Search or BFS for a Graph"></a>Challenge1: Breadth First Search or BFS for a Graph</h2><h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>The <code>bfs()</code> function is a wrapper for the <code>bfsVisit()</code> function which actually performs the traversal on one <code>source</code> vertex at a time and outputs all vertices reachable from the <code>source</code>. The reason for using the wrapper function is to make sure we traverse all vertices even when they are not reachable from any other vertex in the graph.</p>
<p>In the <code>bfs()</code> function, we insert the vertices into the queue, starting from the <code>source</code> vertex. To keep track of the nodes that have been traversed, every node inserted into the queue is marked visited in the <code>visited</code> array.</p>
<p>The <code>result</code> string is our output variable. The value of a node is appended to <code>result</code> when it is dequeued from the queue. For each node that is dequeued, its adjacent nodes are added to the queue if they have not been visited.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckBFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bfs</span><span class="params">(Graph g)</span></span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//Checking if the graph has no vertices</span></span><br><span class="line">        <span class="keyword">if</span> (g.vertices &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertices; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//Checking whether the node is visited or not </span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) </span><br><span class="line">            &#123; </span><br><span class="line">                result = result + bfsVisit(g, i, visited); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bfsVisit</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//Create Queue for Breadth First Traversal and enqueue source in it</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;(g.vertices);</span><br><span class="line">        queue.enqueue(source);</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while queue is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current_node = queue.dequeue();</span><br><span class="line">            result += String.valueOf(current_node);</span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array, and if they are not already visited then enqueue them in the Queue</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    queue.enqueue(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>; <span class="comment">//Visit the current Node</span></span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"Graph1:"</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"BFS traversal of Graph1 : "</span> + bfs(g));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"Graph2:"</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"BFS traversal of Graph2 : "</span> + bfs(g2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to print BFS traversal from a given source vertex.</span></span><br><span class="line"><span class="comment">// BFS(int s) traverses vertices reachable from s.</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This class represents a directed graph using adjacency list</span></span><br><span class="line"><span class="comment">// representation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// No. of vertices</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">//Adjacency Lists</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    Graph(<span class="keyword">int</span> v)</span><br><span class="line">    &#123;</span><br><span class="line">        V = v;</span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i)</span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function to add an edge into the graph</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prints BFS traversal from a given source s</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Mark all the vertices as not visited(By default</span></span><br><span class="line">        <span class="comment">// set as false)</span></span><br><span class="line">        <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a queue for BFS</span></span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mark the current node as visited and enqueue it</span></span><br><span class="line">        visited[s] = <span class="keyword">true</span>;</span><br><span class="line">        queue.add(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Dequeue a vertex from queue and print it</span></span><br><span class="line">            s = queue.poll();</span><br><span class="line">            System.out.print(s+<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get all adjacent vertices of the dequeued vertex s If a adjacent has not been visited, then mark it visited and enqueue it</span></span><br><span class="line">            Iterator&lt;Integer&gt; i = adj[s].listIterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> n = i.next();</span><br><span class="line">                <span class="keyword">if</span> (!visited[n])</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[n] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method to</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Following is Breadth First Traversal "</span>+</span><br><span class="line">                           <span class="string">"(starting from vertex 2)"</span>);</span><br><span class="line"></span><br><span class="line">        g.BFS(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge2-Iterative-Depth-First-Traversal-of-Graph"><a href="#Challenge2-Iterative-Depth-First-Traversal-of-Graph" class="headerlink" title="Challenge2: Iterative Depth First Traversal of Graph"></a>Challenge2: Iterative Depth First Traversal of Graph</h2><h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckDFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dfs</span><span class="params">(Graph g)</span></span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//Checking if the graph has no vertices</span></span><br><span class="line">        <span class="keyword">if</span> (g.vertices &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertices; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//Checking whether the node is visited or not </span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) </span><br><span class="line">            &#123; </span><br><span class="line">                result = result + dfsVisit(g, i, visited); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dfsVisit</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//Create Stack(Implemented in previous lesson) for Depth First Traversal and Push source in it</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;(g.vertices);</span><br><span class="line">        stack.push(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current_node = stack.pop();</span><br><span class="line">            result += String.valueOf(current_node);</span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array, and if they are not already visited then push them in the stack</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] !=<span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    stack.push(temp.data);</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Visit the node</span></span><br><span class="line">            visited[current_node] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"Graph1:"</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"DFS traversal of Graph1 : "</span> + dfs(g));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"Graph2:"</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"DFS traversal of Graph2 : "</span> + dfs(g2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//An Iterative Java program to do DFS traversal from</span></span><br><span class="line"><span class="comment">//a given source vertex. DFS(int s) traverses vertices</span></span><br><span class="line"><span class="comment">//reachable from s.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GFG</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// This class represents a directed graph using adjacency</span></span><br><span class="line">    <span class="comment">// list representation</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V; <span class="comment">//Number of Vertices</span></span><br><span class="line">        LinkedList&lt;Integer&gt;[] adj; <span class="comment">// adjacency lists</span></span><br><span class="line">        <span class="comment">//Constructor</span></span><br><span class="line">        Graph(<span class="keyword">int</span> V)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.V = V;</span><br><span class="line">            adj = <span class="keyword">new</span> LinkedList[V];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++)</span><br><span class="line">                adj[i] = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//To add an edge to graph</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            adj[v].add(w); <span class="comment">// Add w to v’s list.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prints all not yet visited vertices reachable from s</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// Initially mark all vertices as not visited</span></span><br><span class="line">            Vector&lt;Boolean&gt; visited = <span class="keyword">new</span> Vector&lt;Boolean&gt;(V);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">                visited.add(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a stack for DFS</span></span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            stack.push(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(stack.empty() == <span class="keyword">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s = stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">// Stack may contain same vertex twice. So we need to print the popped item only if it is not visited.</span></span><br><span class="line">                <span class="keyword">if</span>(visited.get(s) == <span class="keyword">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">                    visited.set(s, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Get all adjacent vertices of the popped vertex s If a adjacent has not been visited, then push it to the stack.</span></span><br><span class="line">                Iterator&lt;Integer&gt; itr = adj[s].iterator();</span><br><span class="line">                <span class="keyword">while</span> (itr.hasNext()) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> v = itr.next();</span><br><span class="line">                    <span class="keyword">if</span>(!visited.get(v))</span><br><span class="line">                        stack.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver program to test methods of graph class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Total 5 vertices in graph</span></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Following is the Depth First Traversal"</span>);</span><br><span class="line">        g.DFS(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="⭐Challenge3-Detect-Cycle-in-a-Directed-Graph-Cycle-in-Graph-AE"><a href="#⭐Challenge3-Detect-Cycle-in-a-Directed-Graph-Cycle-in-Graph-AE" class="headerlink" title="⭐Challenge3: Detect Cycle in a Directed Graph || Cycle in Graph(AE)"></a>⭐Challenge3: Detect Cycle in a Directed Graph || Cycle in Graph(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cycleInGraph</span><span class="params">(<span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">    <span class="keyword">int</span> n = edges.length;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    buildGraph(graph, edges);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">boolean</span>[] stackFlag = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCyclic(i, graph, visited, stackFlag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCyclic</span><span class="params">(<span class="keyword">int</span> node, Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">boolean</span>[] visited, <span class="keyword">boolean</span>[] stackFlag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stackFlag[node]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[node]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    stackFlag[node] = <span class="keyword">true</span>;</span><br><span class="line">    visited[node] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.get(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCyclic(neighbor, graph, visited, stackFlag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stackFlag[node] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] e = edges[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : e) &#123;</span><br><span class="line">            graph.get(i).add(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>The solution might look confusing at first, but the logic behind it is pretty straight forward.</li>
<li>We start by using two boolean arrays, <code>visited</code> and <code>stackFlag</code>. <code>visited</code> keeps a record of all the nodes that have been traversed regardless of the recursive call. <code>stackFlag</code> keeps track of the nodes that have been traversed in the current recursion.</li>
<li>Then we apply a variation of <code>DFS</code> on each node of the graph in a recursive manner. On each call of the method <code>cyclic</code> if we encounter any node which is already in the stack, then we return <code>true</code>. Because this means that we have found a path from that node back to itself!</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckCycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">detectCycle</span><span class="params">(Graph g)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span> [num_of_vertices];</span><br><span class="line">        <span class="comment">//Holds a flag if the node is currently in Stack or not (by default- false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] stackFlag = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_of_vertices; i++)&#123;</span><br><span class="line">            <span class="comment">//Check cyclic on each node</span></span><br><span class="line">            <span class="keyword">if</span> (cyclic(g, i, visited, stackFlag))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cyclic</span><span class="params">(Graph g, <span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited, <span class="keyword">boolean</span>[] stackFlag)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case, if node is currently in stack that means we have found a cycle</span></span><br><span class="line">        <span class="keyword">if</span> (stackFlag[v])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//if it is already visited (and not in Stack) then there is no cycle</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line">        stackFlag[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check adjacency list of the node</span></span><br><span class="line">        DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.adjacencyList[v] != <span class="keyword">null</span>)</span><br><span class="line">            temp = g.adjacencyList[v].headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//run cyclic function recursively on each outgowing path</span></span><br><span class="line">            <span class="keyword">if</span> (cyclic(g, temp.data, visited, stackFlag))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//backtracking, undo the stackFlag for other dfs path</span></span><br><span class="line">        stackFlag[v] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Graph g1 = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g1.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g1.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g1.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g1.addEdge(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">        g1.printGraph();</span><br><span class="line">        System.out.println(detectCycle(g1));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(detectCycle(g2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-Detect-Cycle-in-a-Directed-Graph-using-BFS"><a href="#Solution2-Detect-Cycle-in-a-Directed-Graph-using-BFS" class="headerlink" title="Solution2: Detect Cycle in a Directed Graph using BFS"></a>Solution2: Detect Cycle in a Directed Graph using BFS</h3><p><a href="https://www.geeksforgeeks.org/detect-cycle-in-a-directed-graph-using-bfs/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/detect-cycle-in-a-directed-graph-using-bfs/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to check if there is a cycle in directed graph using BFS.</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFG</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Class to represent a graph</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V; <span class="comment">// No. of vertices</span></span><br><span class="line">        <span class="comment">//adjacency list</span></span><br><span class="line">        Vector&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Graph(<span class="keyword">int</span> V)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Constructor</span></span><br><span class="line">            <span class="keyword">this</span>.V = V;</span><br><span class="line">            <span class="keyword">this</span>.adj = <span class="keyword">new</span> Vector[V];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">                adj[i] = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// function to add an edge to graph</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            adj[u].add(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This function returns true if there is a cycle in directed graph, else returns false.</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isCycle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a vector to store indegrees of all vertices. Initialize all indegrees as 0.</span></span><br><span class="line">            <span class="keyword">int</span>[] in_degree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.V];</span><br><span class="line">            Arrays.fill(in_degree, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Traverse adjacency lists to fill indegrees of vertices. This step takes O(V+E) time</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v : adj[u])</span><br><span class="line">                    in_degree[v]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create an queue and enqueue all vertices with indegree 0</span></span><br><span class="line">            Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">                <span class="keyword">if</span> (in_degree[i] == <span class="number">0</span>)</span><br><span class="line">                    q.add(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize count of visited vertices</span></span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a vector to store result (A topological ordering of the vertices)</span></span><br><span class="line">            Vector&lt;Integer&gt; top_order = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// One by one dequeue vertices from queue and enqueue adjacents if indegree of adjacent becomes 0</span></span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Extract front of queue (or perform dequeue) and add it to topological order</span></span><br><span class="line">                <span class="keyword">int</span> u = q.poll();</span><br><span class="line">                top_order.add(u);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Iterate through all its neighbouring nodes of dequeued node u and decrease their in-degree by 1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> itr : adj[u])</span><br><span class="line">                    <span class="keyword">if</span> (--in_degree[itr] == <span class="number">0</span>)</span><br><span class="line">                        q.add(itr);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if there was a cycle</span></span><br><span class="line">            <span class="keyword">if</span> (cnt != <span class="keyword">this</span>.V)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test Code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a graph given in the above diagram</span></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.isCycle())</span><br><span class="line">            System.out.println(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cycle-detection-in-an-undirected-graph"><a href="#Cycle-detection-in-an-undirected-graph" class="headerlink" title="Cycle detection in an undirected graph"></a>Cycle detection in an undirected graph</h3><ol>
<li>Run a DFS from every unvisited node.</li>
<li>If visited node, check if it is parent or not.</li>
</ol>
<p><a href="https://www.geeksforgeeks.org/detect-cycle-undirected-graph/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/detect-cycle-undirected-graph/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true if the graph contains a cycle, else false. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">isCyclic</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Mark all the vertices as not visited and not part of recursion stack </span></span><br><span class="line">    Boolean visited[] = <span class="keyword">new</span> Boolean[V]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">        visited[i] = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the recursive helper function to detect cycle in different DFS trees </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Don't recur for u if already visited </span></span><br><span class="line">        <span class="keyword">if</span> (!visited[u]) </span><br><span class="line">            <span class="keyword">if</span> (isCyclicUtil(u, visited, -<span class="number">1</span>)) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//DFS, recursive function that uses visited[] and parent to detect cycle in subgraph reachable from vertex v.</span></span><br><span class="line"><span class="function">Boolean <span class="title">isCyclicUtil</span><span class="params">(<span class="keyword">int</span> v, Boolean visited[], <span class="keyword">int</span> parent)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Mark the current node as visited </span></span><br><span class="line">    visited[v] = <span class="keyword">true</span>; </span><br><span class="line">    Integer i; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recur for all the vertices adjacent to this vertex </span></span><br><span class="line">    Iterator&lt;Integer&gt; it = adj[v].iterator(); </span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) </span><br><span class="line">    &#123; </span><br><span class="line">        i = it.next(); </span><br><span class="line">        <span class="comment">// If an adjacent is not visited, then recur for that adjacent </span></span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (isCyclicUtil(i, visited, v)) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If an adjacent is visited and not parent of current vertex, then there is a cycle. </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != parent) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge4-Find-“Mother-Vertex”-in-a-Directed-Graph"><a href="#Challenge4-Find-“Mother-Vertex”-in-a-Directed-Graph" class="headerlink" title="Challenge4: Find “Mother Vertex” in a Directed Graph"></a>Challenge4: Find “Mother Vertex” in a Directed Graph</h2><h3 id="Mother-Vertex"><a href="#Mother-Vertex" class="headerlink" title="Mother Vertex?"></a>Mother Vertex?</h3><p>A mother vertex in a graph <code>G = (v,e)</code> is a vertex v, such that all other vertices in G can be reached by a path from v.</p>
<h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckMotherVertex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMotherVertex</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// visited[] is used for DFS. Initially all are initialized as not visited</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line">        Arrays.fill(visited, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To store last finished vertex (or mother vertex)</span></span><br><span class="line">        <span class="keyword">int</span> lastV = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do a DFS traversal and find the last finished vertex</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertices; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                DFS(g, i, visited);</span><br><span class="line">                lastV = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there exist mother vertex (or vetices) in given</span></span><br><span class="line">        <span class="comment">// graph, then lastV must be one (or one of them)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now check if lastV is actually a mother vertex (or graph</span></span><br><span class="line">        <span class="comment">// has a mother vertex). We basically check if every vertex</span></span><br><span class="line">        <span class="comment">// is reachable from lastV or not.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset all values in visited[] as false and do</span></span><br><span class="line">        <span class="comment">// DFS beginning from lastV to check if all vertices are</span></span><br><span class="line">        <span class="comment">// reachable from it or not.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Double check lastV is a valid mother vertice</span></span><br><span class="line">        Arrays.fill(visited, <span class="keyword">false</span>);</span><br><span class="line">        DFS(g, lastV, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; visited.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A recursive function to print DFS starting from v</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph g, <span class="keyword">int</span> node, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        visited[node] = <span class="keyword">true</span>;</span><br><span class="line">        DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.adjacencyList[node] !=<span class="keyword">null</span>)</span><br><span class="line">            temp = g.adjacencyList[node].headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[temp.data]) &#123;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited[temp.data] = <span class="keyword">true</span>;</span><br><span class="line">                DFS(g, temp.data, visited);</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Mother Vertex is: "</span> + findMotherVertex(g));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to find a mother vertex in O(V+E) time </span></span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFG</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        adj.get(u).add(v); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// A recursive function to print DFS starting from v </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DFSUtil</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; g, <span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Mark the current node as visited and print it </span></span><br><span class="line">        visited[v] = <span class="keyword">true</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recur for all the vertices adjacent to this vertex </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : g.get(v)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (!visited[x]) </span><br><span class="line">            &#123; </span><br><span class="line">                DFSUtil(g, x, visited); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns a mother vertex if exists. Otherwise returns -1 </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">motherVertex</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt;g, <span class="keyword">int</span> V)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// visited[] is used for DFS. Initially all are initialized as not visited </span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// To store last finished vertex (or mother vertex) </span></span><br><span class="line">        <span class="keyword">int</span> mother = -<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) </span><br><span class="line">            &#123; </span><br><span class="line">                DFSUtil(g, i, visited); </span><br><span class="line">                mother = i; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there exist mother vertex (or vetices) in given graph, then v must be one (or one of them) Now check if v is actually a mother vertex (or graph has a mother vertex). </span></span><br><span class="line">        <span class="comment">// We basically check if every vertex is reachable from v or not. Reset all values in visited[] as false and do DFS beginning from v to check </span></span><br><span class="line">        <span class="comment">// if all vertices are reachable from it or not. </span></span><br><span class="line">        <span class="keyword">boolean</span>[] check = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; </span><br><span class="line">        DFSUtil(g, mother, check); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">boolean</span> val : check) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (!val) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> mother; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test code </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> V = <span class="number">7</span>; </span><br><span class="line">        <span class="keyword">int</span> E = <span class="number">8</span>; </span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            adj.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;()); </span><br><span class="line">        &#125; </span><br><span class="line">        addEdge(<span class="number">0</span>, <span class="number">1</span>,adj); </span><br><span class="line">        addEdge(<span class="number">0</span>, <span class="number">2</span>,adj); </span><br><span class="line">        addEdge(<span class="number">1</span>, <span class="number">3</span>,adj); </span><br><span class="line">        addEdge(<span class="number">4</span>, <span class="number">1</span>,adj); </span><br><span class="line">        addEdge(<span class="number">6</span>, <span class="number">4</span>,adj); </span><br><span class="line">        addEdge(<span class="number">5</span>, <span class="number">6</span>,adj); </span><br><span class="line">        addEdge(<span class="number">5</span>, <span class="number">2</span>,adj); </span><br><span class="line">        addEdge(<span class="number">6</span>, <span class="number">0</span>,adj); </span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"The mother vertex is "</span> + motherVertex(adj, V)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge5-Count-number-of-edges-in-an-undirected-graph"><a href="#Challenge5-Count-number-of-edges-in-an-undirected-graph" class="headerlink" title="Challenge5: Count number of edges in an undirected graph"></a>Challenge5: Count number of edges in an undirected graph</h2><p>Given an adjacency list representation undirected graph. Write a function to count the number of edges in the undirected graph.</p>
<p>Expected time complexity : O(V)</p>
<h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckNumEdges</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numEdges</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// For undirected graph, just sum up the size of</span></span><br><span class="line">        <span class="comment">// all the adjacency lists for each vertex and then divide it by 2.</span></span><br><span class="line">        <span class="comment">// It will give us total number of edges in the graph.</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertices; i++) &#123;</span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[i] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[i].headNode;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">9</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">        g.addEdge(<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line">        g.addEdge(<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Number of edges: "</span> + numEdges(g));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">7</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        g2.addEdge(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">6</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Number of edges: "</span> + numEdges(g2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to count number of edge in undirected graph </span></span><br><span class="line"><span class="keyword">import</span> java.io.*; </span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Adjacency list representation of graph </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> V; </span><br><span class="line">    Vector&lt;Integer&gt;[] adj; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//@SuppressWarnings("unchecked") </span></span><br><span class="line">    Graph(<span class="keyword">int</span> V) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">this</span>.V = V; </span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> Vector[V]; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">            adj[i] = <span class="keyword">new</span> Vector&lt;Integer&gt;(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// add edge to graph </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        adj[u].add(v); </span><br><span class="line">        adj[v].add(u); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns count of edge in undirected graph </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countEdges</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// traverse all vertex </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line"></span><br><span class="line">            <span class="comment">// add all edge that are linked to the current vertex </span></span><br><span class="line">            sum += adj[i].size(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// The count of edge is always even because in undirected graph every edge is connected twice between two vertices </span></span><br><span class="line">        <span class="keyword">return</span> sum / <span class="number">2</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFG</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// Test Code </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> V = <span class="number">9</span>; </span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(V); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// making above uhown graph </span></span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">7</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">7</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">8</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">5</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">5</span>); </span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line">        g.addEdge(<span class="number">5</span>, <span class="number">6</span>); </span><br><span class="line">        g.addEdge(<span class="number">6</span>, <span class="number">7</span>); </span><br><span class="line">        g.addEdge(<span class="number">6</span>, <span class="number">8</span>); </span><br><span class="line">        g.addEdge(<span class="number">7</span>, <span class="number">8</span>); </span><br><span class="line"></span><br><span class="line">        System.out.println(g.countEdges()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge6-Find-if-there-is-a-path-between-two-vertices-in-a-directed-graph"><a href="#Challenge6-Find-if-there-is-a-path-between-two-vertices-in-a-directed-graph" class="headerlink" title="Challenge6:  Find if there is a path between two vertices in a directed graph"></a>Challenge6:  Find if there is a path between two vertices in a directed graph</h2><h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckPaths</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkPath</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (source == destination)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(g.vertices);</span><br><span class="line">        stack.push(source);</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while stack is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//Pop a vertex/node from stack</span></span><br><span class="line">            <span class="keyword">int</span> current_node = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array,</span></span><br><span class="line">            <span class="comment">//and if only push unvisited adjacent vertices into stack</span></span><br><span class="line">            <span class="comment">//Before pushing into stack, check if it's the destination.</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (temp.data == destination) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g1 = <span class="keyword">new</span> Graph(<span class="number">9</span>);</span><br><span class="line">        g1.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g1.addEdge(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        g1.addEdge(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        g1.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        g1.addEdge(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">        g1.addEdge(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        g1.addEdge(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">        g1.addEdge(<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">        g1.addEdge(<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line">        g1.addEdge(<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">        g1.addEdge(<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">        g1.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Path exists: "</span> + checkPath(g1, <span class="number">0</span>, <span class="number">7</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Path exists: "</span> + checkPath(g2, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-10"><a href="#Solution2-10" class="headerlink" title="Solution2:"></a>Solution2:</h3><p><a href="https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-a-given-graph/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-a-given-graph/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to check if there is exist a path between two vertices of a graph. </span></span><br><span class="line"><span class="keyword">import</span> java.io.*; </span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList; </span><br><span class="line"></span><br><span class="line"><span class="comment">// This class represents a directed graph using adjacency list representation </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// No. of vertices </span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">//Adjacency List </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Constructor </span></span><br><span class="line">    Graph(<span class="keyword">int</span> v) </span><br><span class="line">    &#123; </span><br><span class="line">        V = v; </span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[v]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) </span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//Function to add an edge into the graph </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123; adj[v].add(w); &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//prints BFS traversal from a given source s </span></span><br><span class="line">    <span class="function">Boolean <span class="title">isReachable</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        LinkedList&lt;Integer&gt; temp; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mark all the vertices as not visited(By default set </span></span><br><span class="line">        <span class="comment">// as false) </span></span><br><span class="line">        <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a queue for BFS </span></span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(); </span><br><span class="line">        visited[s] = <span class="keyword">true</span>; </span><br><span class="line">        queue.add(s); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 'i' will be used to get all adjacent vertices of a vertex </span></span><br><span class="line">        Iterator&lt;Integer&gt; i; </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// Dequeue a vertex from queue and print it </span></span><br><span class="line">            s = queue.poll(); </span><br><span class="line">            <span class="keyword">int</span> n; </span><br><span class="line">            i = adj[s].listIterator(); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get all adjacent vertices of the dequeued vertex s If a adjacent has not been visited, then mark it visited and enqueue it </span></span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) </span><br><span class="line">            &#123; </span><br><span class="line">                n = i.next(); </span><br><span class="line"></span><br><span class="line">                <span class="comment">// If this adjacent node is the destination node, </span></span><br><span class="line">                <span class="comment">// then return true </span></span><br><span class="line">                <span class="keyword">if</span> (n == d) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// Else, continue to do BFS </span></span><br><span class="line">                <span class="keyword">if</span> (!visited[n]) </span><br><span class="line">                &#123; </span><br><span class="line">                    visited[n] = <span class="keyword">true</span>; </span><br><span class="line">                    queue.add(n); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// If BFS is complete without visited d </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test code </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Create a graph given in the above diagram </span></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">4</span>); </span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">0</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">3</span>); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">3</span>; </span><br><span class="line">        <span class="keyword">if</span> (g.isReachable(u, v)) </span><br><span class="line">            System.out.println(<span class="string">"There is a path from "</span> + u +<span class="string">" to "</span> + v); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"There is no path from "</span> + u +<span class="string">" to "</span> + v);; </span><br><span class="line"></span><br><span class="line">        u = <span class="number">3</span>; </span><br><span class="line">        v = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (g.isReachable(u, v)) </span><br><span class="line">            System.out.println(<span class="string">"There is a path from "</span> + u +<span class="string">" to "</span> + v); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"There is no path from "</span> + u +<span class="string">" to "</span> + v);; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph"><a href="#Find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph" class="headerlink" title="Find if there is a path between two vertices in an undirected graph"></a>Find if there is a path between two vertices in an undirected graph</h3><p><a href="https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ program to check if there is exist a path between</span></span><br><span class="line"><span class="comment">// two vertices of an undirected graph.</span></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This class represents an undirected graph using adjacency list representation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> V; <span class="comment">// No. of vertices</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pointer to an array containing adjacency lists</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; adj; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V); <span class="comment">// Constructor</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// function to add an edge to graph</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>; </span><br><span class="line">	<span class="function">bool <span class="title">isReachable</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> list&lt;<span class="keyword">int</span>&gt;[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w);</span><br><span class="line">	adj[w].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A BFS based function to check whether d is reachable from s.</span></span><br><span class="line">bool Graph::isReachable(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Base case</span></span><br><span class="line">	<span class="keyword">if</span> (s == d)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark all the vertices as not visited</span></span><br><span class="line">	bool* visited = <span class="keyword">new</span> bool[V];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a queue for BFS</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; queue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark the current node as visited and enqueue it</span></span><br><span class="line">	visited[s] = <span class="keyword">true</span>;</span><br><span class="line">	queue.push_back(s);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// it will be used to get all adjacent vertices of a vertex</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!queue.empty()) &#123;</span><br><span class="line">		<span class="comment">// Dequeue a vertex from queue and print it</span></span><br><span class="line">		s = queue.front();</span><br><span class="line">		queue.pop_front();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get all adjacent vertices of the dequeued vertex s</span></span><br><span class="line">		<span class="comment">// If a adjacent has not been visited, then mark it</span></span><br><span class="line">		<span class="comment">// visited and enqueue it</span></span><br><span class="line">		<span class="keyword">for</span> (i = adj[s].begin(); i != adj[s].end(); ++i) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// If this adjacent node is the destination node, </span></span><br><span class="line">			<span class="comment">// then return true</span></span><br><span class="line">			<span class="keyword">if</span> (*i == d)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Else, continue to do BFS</span></span><br><span class="line">			<span class="keyword">if</span> (!visited[*i]) &#123;</span><br><span class="line">				visited[*i] = <span class="keyword">true</span>;</span><br><span class="line">				queue.push_back(*i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If BFS is complete without visiting d</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver program to test methods of graph class</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Create a graph given in the above diagram</span></span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">1</span>, v = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (g.isReachable(u, v))</span><br><span class="line">		cout &lt;&lt; <span class="string">"\n There is a path from "</span> &lt;&lt; u &lt;&lt; <span class="string">" to "</span> &lt;&lt; v;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">"\n There is no path from "</span> &lt;&lt; u &lt;&lt; <span class="string">" to "</span> &lt;&lt; v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge7-Check-if-a-Directed-graph-is-Tree-or-not"><a href="#Challenge7-Check-if-a-Directed-graph-is-Tree-or-not" class="headerlink" title="Challenge7: Check if a Directed graph is Tree or not"></a>Challenge7: Check if a Directed graph is Tree or not</h2><h3 id="Solution0"><a href="#Solution0" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li><p>Using Cycle Detection</p>
</li>
<li><p>To check whether a directed graph is a tree or not, we’ll check the following :</p>
<ol>
<li>Each node (except root) has exactly one parent</li>
<li>There is no cycle in the graph.</li>
<li>The graph is connected.</li>
</ol>
</li>
<li><p>We check the first condition in <code>checkOneParent</code> method by traversing the adjacency list of the graph. If the first condition is not satisfied, we return <code>false</code> and don’t check further.</p>
<p>For a directed graph, We can use DFS to detect the next two conditions.</p>
<p>To check for cycles, we use the same <code>detectCycle</code> function that was used in <a href="https://www.educative.io/collection/page/5642554087309312/5724822843686912/5748660113506304/" target="_blank" rel="noopener">challenge <strong>3</strong></a>. If we come across any vertex that has already been visited then there is a cycle. If we do not find such an adjacent for any vertex, we say that there is no cycle.</p>
<p>Then we check for connectivity in the <code>checkConnected</code> method and traverse all the vertices on the graph to check if they have been visited from the source. If we find any vertex that is not visited, we conclude that vertex is not reachable from the source. Therefore, the graph is not connected and hence, is not a tree.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTree</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. Check for Cycle</span></span><br><span class="line">        <span class="keyword">if</span> (detectCycle(g))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. Check each node other than root has exactly one parent.</span></span><br><span class="line">        <span class="keyword">if</span> (!checkOneParent(g))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. Check for connectivity</span></span><br><span class="line">        <span class="keyword">if</span> (!checkConnected(g, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. DFS check for Cycle</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">detectCycle</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line">        <span class="comment">//Holds a flag if the node is currently in Stack or not (by default- false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] stackFlag = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_of_vertices; i++) &#123;</span><br><span class="line">            <span class="comment">//Check cyclic on each node</span></span><br><span class="line">            <span class="keyword">if</span> (cyclic(g, i, visited, stackFlag)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cyclic</span><span class="params">(Graph g, <span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited, <span class="keyword">boolean</span>[] stackFlag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if node is currently in stack that means we have found a cycle</span></span><br><span class="line">        <span class="keyword">if</span> (stackFlag[v])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if it is already visited (and not in Stack) then there is no cycle</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line">        stackFlag[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check adjacency list of the node</span></span><br><span class="line">        DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.adjacencyList[v] != <span class="keyword">null</span>)</span><br><span class="line">            temp = g.adjacencyList[v].headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//run cyclic function recursively on each outgowing path</span></span><br><span class="line">            <span class="keyword">if</span> (cyclic(g, temp.data, visited, stackFlag)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        stackFlag[v] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. Check each node other than root has exactly one parent.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkOneParent</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line">        <span class="keyword">boolean</span>[] hasOneParent = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//traverse adjacency list and mark the nodes which have a parent</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_of_vertices; i++) &#123;</span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node tmp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tmp = g.adjacencyList[i].headNode;</span><br><span class="line">                <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hasOneParent[tmp.data]) <span class="comment">//if a node has more than one parent</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;            <span class="comment">//then return false</span></span><br><span class="line">                    hasOneParent[tmp.data] = <span class="keyword">true</span>;</span><br><span class="line">                    tmp = tmp.nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//double check the root and not children node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_of_vertices; i++) &#123;</span><br><span class="line">            <span class="comment">//System.out.print(hasOneParent[i]);</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; hasOneParent[i] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// root should not have parent</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; hasOneParent[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="comment">//will be false if the node had no parent.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. Check for connectivity</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkConnected</span><span class="params">(Graph g, <span class="keyword">int</span> source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line">        <span class="keyword">int</span> vertices_reached = <span class="number">0</span>; <span class="comment">//Store vertices reachable through source</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="comment">//Make a node visited whenever you push it into stack</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create Stack(Implemented in previous section) for Depth First Traversal and Push source in it</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(num_of_vertices);</span><br><span class="line"></span><br><span class="line">        stack.push(source);</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while stack is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Pop a vertex/node from stack</span></span><br><span class="line">            <span class="keyword">int</span> current_node = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array,</span></span><br><span class="line">            <span class="comment">//and push unvisited vertices in stack and also increment vertices_reached</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    stack.push(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>;</span><br><span class="line">                    vertices_reached++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//+1 for source, and if number of vertices reachable from source are equal</span></span><br><span class="line">        <span class="comment">//to the total number of vertices in graph then return true else false.</span></span><br><span class="line">        <span class="keyword">return</span> (vertices_reached + <span class="number">1</span>) == g.vertices;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g));</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g2));</span><br><span class="line"></span><br><span class="line">        Graph g3 = <span class="keyword">new</span> Graph(<span class="number">6</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g3.addEdge(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        g3.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-1-Using-BFS-Traversal"><a href="#Solution-1-Using-BFS-Traversal" class="headerlink" title="Solution 1: Using BFS Traversal"></a>Solution 1: Using BFS Traversal</h3><ol>
<li>We maintain a count of the visited nodes in the variable <code>numberOfVisited</code>. During traversal, if an already visited vertex is encountered, we return <code>false</code> as it means that the graph fails the <strong>tree</strong> conditions. In fact, this condition also encompasses the <strong>check cyclic</strong> condition and <strong>check one parent</strong> condition from the solution given above. Hence, it removes redundancy. Finally, when the <strong>BFS</strong> loop ends, we check the <code>numberOfVisited</code> variable to see if all vertices were visited. This condition takes care of the <strong>graph is connected</strong> check that we performed previously. If the condition fails, <code>false</code> is returned. Otherwise, the function <code>isTree</code> returns <code>true</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTree</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="comment">//Make a node visited whenever you enqueue it into queue</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create Queue for Breadth First Traversal and enqueue root in it</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;(g.vertices);</span><br><span class="line">        queue.enqueue(root);</span><br><span class="line">        visited[root] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Store the number of visited nodes to check at end if all are visited</span></span><br><span class="line">        <span class="keyword">int</span> numberOfVisited = <span class="number">1</span>; <span class="comment">//root is already visited</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while queue is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current_node = queue.dequeue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array,</span></span><br><span class="line">            <span class="comment">//and if they are not already visited then enqueue them in the Queue</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    queue.enqueue(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>; <span class="comment">//Visit the current Node</span></span><br><span class="line">                    numberOfVisited++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//If all vertices are visited then return true</span></span><br><span class="line">        <span class="keyword">if</span> (numberOfVisited == g.vertices)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g));</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g2));</span><br><span class="line"></span><br><span class="line">        Graph g3 = <span class="keyword">new</span> Graph(<span class="number">6</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g3.addEdge(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        g3.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-11"><a href="#Solution2-11" class="headerlink" title="Solution2:"></a>Solution2:</h3><p><a href="https://codereview.stackexchange.com/questions/120165/check-directed-graph-is-tree-or-not" target="_blank" rel="noopener">https://codereview.stackexchange.com/questions/120165/check-directed-graph-is-tree-or-not</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTree</span><span class="params">(<span class="keyword">int</span>[][] adjMat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numVertex = adjMat.length;</span><br><span class="line">    State[] isVisited = <span class="keyword">new</span> State[numVertex];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;</span><br><span class="line">        isVisited[i] = State.UNVISITED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use BFS</span></span><br><span class="line">    Queue q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(<span class="number">0</span>);</span><br><span class="line">    isVisited[<span class="number">0</span>] = State.VISITING;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = (<span class="keyword">int</span>) q.poll();</span><br><span class="line">        <span class="keyword">if</span> (isVisited[current] == State.VISITED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isVisited[current] = State.VISITING;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adjMat[current][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isVisited[current] = State.VISITED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isVisited[i] == State.UNVISITED)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    UNVISITED, VISITING, VISITED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Check if a given undirected graph is tree or not</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Java Program to check whether a graph is tree or not </span></span><br><span class="line"><span class="keyword">import</span> java.io.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="comment">// This class represents a directed graph using adjacency list representation </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// No. of vertices </span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">//Adjacency List </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor </span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) </span><br><span class="line">    Graph(<span class="keyword">int</span> v) </span><br><span class="line">    &#123; </span><br><span class="line">        V = v; </span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[V]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) </span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function to add an edge into the graph </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        adj[v].add(w); </span><br><span class="line">        adj[w].add(v); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// A recursive function that uses visited[] and parent to detect cycle in subgraph reachable from vertex v. </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCyclicUtil</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">boolean</span> visited[], <span class="keyword">int</span> parent)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Mark the current node as visited </span></span><br><span class="line">        visited[v] = <span class="keyword">true</span>; </span><br><span class="line">        Integer i; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recur for all the vertices adjacent to this vertex </span></span><br><span class="line">        Iterator&lt;Integer&gt; it = adj[v].iterator(); </span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) </span><br><span class="line">        &#123; </span><br><span class="line">            i = it.next(); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// If an adjacent is not visited, then recur for </span></span><br><span class="line">            <span class="comment">// that adjacent </span></span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (isCyclicUtil(i, visited, v)) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// If an adjacent is visited and not parent of </span></span><br><span class="line">            <span class="comment">// current vertex, then there is a cycle. </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i != parent) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true if the graph is a tree, else false. </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTree</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Mark all the vertices as not visited and not part </span></span><br><span class="line">        <span class="comment">// of recursion stack </span></span><br><span class="line">        <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">            visited[i] = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// The call to isCyclicUtil serves multiple purposes </span></span><br><span class="line">        <span class="comment">// It returns true if graph reachable from vertex 0 </span></span><br><span class="line">        <span class="comment">// is cyclcic. It also marks all vertices reachable </span></span><br><span class="line">        <span class="comment">// from 0. </span></span><br><span class="line">        <span class="keyword">if</span> (isCyclicUtil(<span class="number">0</span>, visited, -<span class="number">1</span>)) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find a vertex which is not reachable from 0 </span></span><br><span class="line">        <span class="comment">// (not marked by isCyclicUtil(), then we return false </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) </span><br><span class="line">            <span class="keyword">if</span> (!visited[u]) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test code </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Create a graph given in the above diagram </span></span><br><span class="line">        Graph g1 = <span class="keyword">new</span> Graph(<span class="number">5</span>); </span><br><span class="line">        g1.addEdge(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">        g1.addEdge(<span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">        g1.addEdge(<span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line">        g1.addEdge(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">        <span class="keyword">if</span> (g1.isTree()) </span><br><span class="line">            System.out.println(<span class="string">"Graph is Tree"</span>); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Graph is not Tree"</span>); </span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">5</span>); </span><br><span class="line">        g2.addEdge(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">        g2.addEdge(<span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">        g2.addEdge(<span class="number">2</span>, <span class="number">1</span>); </span><br><span class="line">        g2.addEdge(<span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line">        g2.addEdge(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g2.isTree()) </span><br><span class="line">            System.out.println(<span class="string">"Graph is Tree"</span>); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Graph is not Tree"</span>); </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-8-Find-Length-of-Shortest-Path-between-Two-Vertices"><a href="#Challenge-8-Find-Length-of-Shortest-Path-between-Two-Vertices" class="headerlink" title="Challenge 8: Find Length of Shortest Path between Two Vertices"></a>Challenge 8: Find Length of Shortest Path between Two Vertices</h2><h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>BFS Queue</p>
</li>
<li><p>Once again, Breadth First Search comes to the rescue. The <code>visited</code> list must be familiar to you by now. The crux of this algorithm, however, lies in the <code>distance</code> list. For each node, the indexed value in the <code>distance</code> shows the node’s distance from the <code>source</code> in terms of the number of edges.</p>
<p>The rest is a simple BFS traversal, where the <code>distance</code> is incremented by 1 each time.</p>
<p>We are guaranteed to find the shortest distance to <code>destination</code>, once it has already been visited through the longer path and consequently marked because it won’t be visited the same way again.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckMin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source == destination)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="comment">//Make a node visited whenever you enqueue it into queue</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//For keeping track of distance of current_node from source</span></span><br><span class="line">        <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create Queue for Breadth First Traversal and enqueue source in it</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;Integer&gt;(num_of_vertices);</span><br><span class="line"></span><br><span class="line">        queue.enqueue(source);</span><br><span class="line">        distance[source] = <span class="number">0</span>;</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while queue is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current_node = queue.dequeue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array,</span></span><br><span class="line">            <span class="comment">//and if they are not already visited then enqueue them in the Queue</span></span><br><span class="line">            <span class="comment">//and also update their distance from source by adding 1 in current_nodes's distance</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    queue.enqueue(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>;</span><br><span class="line">                    distance[temp.data] = distance[current_node] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.data == destination) &#123;</span><br><span class="line">                    <span class="keyword">return</span> distance[destination];</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Graph g=<span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">3</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">4</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(findMin(g, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-9-Remove-Edge-from-a-Directed-Graph"><a href="#Challenge-9-Remove-Edge-from-a-Directed-Graph" class="headerlink" title="Challenge 9: Remove Edge from a Directed Graph"></a>Challenge 9: Remove Edge from a Directed Graph</h2><h3 id="Solution1-19"><a href="#Solution1-19" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>This is a fairly simple challenge. Since our vertices are stored in the <code>adjacencyList</code>, we access the linked list at <code>source</code> index. Then we call the <code>deleteByValue</code> function and pass the value of <code>destination</code> vertex.</li>
<li>O(E)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveEdgeSolution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        g.adjacencyList[source].deleteByValue(destination);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">3</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">4</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Before:"</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line"></span><br><span class="line">        removeEdge(g, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"After:"</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AlgoTogether"><a href="#AlgoTogether" class="headerlink" title="AlgoTogether"></a>AlgoTogether</h1><h2 id="Problems-Required"><a href="#Problems-Required" class="headerlink" title="Problems (Required)"></a>Problems (Required)</h2><ol>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=4657dca274&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=a3bc7942d1&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=7d721a5def&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=8e656496df&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/pacific-atlantic-water-flow/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=f619dc7a12&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-ii/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=af9df8fef6&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/reconstruct-itinerary/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=1a339efa75&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/shortest-path-in-binary-matrix/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=d6489d091c&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/sliding-puzzle/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=4577b2098f&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/snakes-and-ladders/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=77c3194d5c&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/surrounded-regions/</a></li>
</ol>
<h2 id="Problems-Options"><a href="#Problems-Options" class="headerlink" title="Problems (Options)"></a>Problems (Options)</h2><ol>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=75f57ca10c&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/cat-and-mouse/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=22fcaca910&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/clone-graph/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=45fe4f3478&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game-iv/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=e54e525e1e&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=b20bb72cb8&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Given an array of n distinct elements. Find the minimum number of swaps required to sort the array in strictly increasing order.</span><br><span class="line"> </span><br><span class="line"> Problem: n different ele, targte -&gt; minimum number of swaps to make it strictly increasing order.</span><br><span class="line">   </span><br><span class="line"> nums &#x3D; &#123;2, 8, 5, 4&#125;</span><br><span class="line">Output: 1</span><br><span class="line"> &#123;2, 8, 5, 4&#125;</span><br><span class="line"></span><br><span class="line">  2-0</span><br><span class="line">  8-1</span><br><span class="line">  5-2</span><br><span class="line">  4-3</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">&#123;2, 8, 5, 4, 9&#125;</span><br><span class="line"></span><br><span class="line">2,4,5,8,9</span><br><span class="line">   ^   ^  ^</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   ^     </span><br><span class="line">Timecomplexity: O(nlogn)</span><br><span class="line">   </span><br><span class="line">Usually way: sorting algo</span><br><span class="line"></span><br><span class="line">sort array....</span><br><span class="line">  compare this sorted array with current array.........</span><br><span class="line">  </span><br><span class="line">class FindTheMinimumSwaoNum &#123;</span><br><span class="line">  public int findTheNumsOfSwaps(int[] array) &#123;</span><br><span class="line">    &#x2F;&#x2F;create a copy of this array -- unsorted</span><br><span class="line">    &#x2F;&#x2F; sort that copied array --- sorted</span><br><span class="line">    &#x2F;&#x2F;start loop till size of array</span><br><span class="line">    &#x2F;&#x2F;compare sorted array element with unsarted array element</span><br><span class="line">    &#x2F;&#x2F;check for equality -&gt; swap thm</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;minimum-number-swaps-required-sort-array&#x2F;</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;clone-graph&#x2F;</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;must-coding-questions-company-wise&#x2F;#amazon</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;practice.geeksforgeeks.org&#x2F;explore&#x2F;?company%5B%5D&#x3D;Amazon&amp;problemType&#x3D;functional&amp;page&#x3D;1&amp;sortBy&#x3D;submissions&amp;company%5B%5D&#x3D;Amazon</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;amazon-interview-preparation&#x2F;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/200/" rel="tag"># 200</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/17/Sorting/" rel="prev" title="Sorting">
      <i class="fa fa-chevron-left"></i> Sorting
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/17/Recursion/" rel="next" title="Recursion">
      Recursion <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Pattern-Topological-Sort-Graph"><span class="nav-number">1.</span> <span class="nav-text">Pattern: Topological Sort (Graph)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Topological-Sort-medium"><span class="nav-number">1.1.</span> <span class="nav-text">Topological Sort (medium)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tasks-Scheduling-medium"><span class="nav-number">1.2.</span> <span class="nav-text">Tasks Scheduling (medium)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#207-Course-Schedule⭐"><span class="nav-number">1.3.</span> <span class="nav-text">207. Course Schedule⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1"><span class="nav-number">1.3.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2"><span class="nav-number">1.3.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tasks-Scheduling-Order-medium"><span class="nav-number">1.4.</span> <span class="nav-text">Tasks Scheduling Order (medium)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Unsolved-210-Course-Schedule-II🎂💜⭐"><span class="nav-number">1.5.</span> <span class="nav-text">🌕Unsolved 210. Course Schedule II🎂💜⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-1"><span class="nav-number">1.5.2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-2"><span class="nav-number">1.5.3.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Unsolved-All-Tasks-Scheduling-Orders-hard"><span class="nav-number">1.6.</span> <span class="nav-text">🌕Unsolved All Tasks Scheduling Orders (hard)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Alien-Dictionary-hard"><span class="nav-number">1.7.</span> <span class="nav-text">Alien Dictionary (hard)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Unsolved-269-Alien-Dictionary🎂✨"><span class="nav-number">1.8.</span> <span class="nav-text">🌕Unsolved 269.Alien Dictionary🎂✨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-1-Reconstructing-a-Sequence-hard"><span class="nav-number">1.9.</span> <span class="nav-text">Challenge 1 Reconstructing a Sequence (hard)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Unsolved-Challenge-2-Minimum-Height-Trees-hard"><span class="nav-number">1.10.</span> <span class="nav-text">🌕Unsolved Challenge 2 Minimum Height Trees (hard)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsolved-310-Minimum-Height-Trees🎂✨"><span class="nav-number">1.10.1.</span> <span class="nav-text">Unsolved 310. Minimum Height Trees🎂✨</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Coderust-Hacking-the-Coding-Interview"><span class="nav-number">2.</span> <span class="nav-text">Coderust: Hacking the Coding Interview</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Clone-a-Directed-Graph"><span class="nav-number">2.1.</span> <span class="nav-text">Clone a Directed Graph</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-133-Clone-Graph🎂✨"><span class="nav-number">2.2.</span> <span class="nav-text">Unsolved 133. Clone Graph🎂✨</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-2"><span class="nav-number">2.2.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-3"><span class="nav-number">2.2.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🌕Minimum-Spanning-Tree"><span class="nav-number">3.</span> <span class="nav-text">🌕Minimum Spanning Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Graph"><span class="nav-number">4.</span> <span class="nav-text">Graph</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Depth-first-Search-AE"><span class="nav-number">4.1.</span> <span class="nav-text">Depth first Search(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-3"><span class="nav-number">4.1.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#863-All-Nodes-Distance-K-in-Binary-Tree⭐"><span class="nav-number">4.2.</span> <span class="nav-text">863. All Nodes Distance K in Binary Tree⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-4"><span class="nav-number">4.2.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-4"><span class="nav-number">4.2.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Unsolved-Boggle-Board-AE-⭐"><span class="nav-number">4.3.</span> <span class="nav-text">🌕Unsolved Boggle Board(AE)⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-5"><span class="nav-number">4.3.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Unsolved-1258-Synonymous-Sentences⭐"><span class="nav-number">4.4.</span> <span class="nav-text">🌕Unsolved 1258. Synonymous Sentences⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-6"><span class="nav-number">4.4.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Single-Cycle-Check-AE"><span class="nav-number">4.5.</span> <span class="nav-text">Single Cycle Check(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-7"><span class="nav-number">4.5.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Breadth-First-Search-AE"><span class="nav-number">4.6.</span> <span class="nav-text">Breadth First Search(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-8"><span class="nav-number">4.6.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#River-Sizes-AE-Number-of-Island-with-Area-follow-up⭐"><span class="nav-number">4.7.</span> <span class="nav-text">River Sizes(AE) || Number of Island with Area follow up⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-9"><span class="nav-number">4.7.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Youngest-Common-Ancestor-AE"><span class="nav-number">4.8.</span> <span class="nav-text">Youngest Common Ancestor(AE)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-Rectangle-Mania-AE"><span class="nav-number">4.9.</span> <span class="nav-text">Unsolved Rectangle Mania(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-10"><span class="nav-number">4.9.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-1042-Flower-Planting-With-No-Adjacent🎂"><span class="nav-number">4.10.</span> <span class="nav-text">Unsolved 1042.Flower Planting With No Adjacent🎂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-990-Satisfiability-of-Equality-Equations🎂✨"><span class="nav-number">4.11.</span> <span class="nav-text">Unsolved 990. Satisfiability of Equality Equations🎂✨</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二分图Bipartite"><span class="nav-number">5.</span> <span class="nav-text">二分图Bipartite</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#🌕Unsolved-785-Is-Graph-Bipartite"><span class="nav-number">5.1.</span> <span class="nav-text">🌕Unsolved 785.Is Graph Bipartite?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-11"><span class="nav-number">5.1.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-5"><span class="nav-number">5.1.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并查集"><span class="nav-number">6.</span> <span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Minimize-Hamming-Distance-After-Swap-Operations🎃"><span class="nav-number">6.1.</span> <span class="nav-text">Minimize Hamming Distance After Swap Operations🎃</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsolved-684-Redundant-Connection"><span class="nav-number">6.2.</span> <span class="nav-text">Unsolved 684. Redundant Connection</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他"><span class="nav-number">7.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Graph-Algorithms-One-Place-Dijkstra-Bellman-Ford-Floyd-Warshall-Prims-Kruskals-DSU"><span class="nav-number">7.1.</span> <span class="nav-text">Graph Algorithms One Place | Dijkstra | Bellman Ford | Floyd Warshall | Prims | Kruskals | DSU</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Data-Structures-for-Coding-Interviews-in-Java"><span class="nav-number">8.</span> <span class="nav-text">Data Structures for Coding Interviews in Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#There-are-two-common-types-of-graphs"><span class="nav-number">8.1.</span> <span class="nav-text">There are two common types of graphs:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implement-a-Directed-Graph-in-java-using-an-Adjacency-List"><span class="nav-number">8.2.</span> <span class="nav-text">Implement a Directed Graph in java using an Adjacency List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Types-of-bipartite-graphs"><span class="nav-number">8.3.</span> <span class="nav-text">Types of bipartite graphs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge1-Breadth-First-Search-or-BFS-for-a-Graph"><span class="nav-number">8.4.</span> <span class="nav-text">Challenge1: Breadth First Search or BFS for a Graph</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-12"><span class="nav-number">8.4.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-6"><span class="nav-number">8.4.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge2-Iterative-Depth-First-Traversal-of-Graph"><span class="nav-number">8.5.</span> <span class="nav-text">Challenge2: Iterative Depth First Traversal of Graph</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-13"><span class="nav-number">8.5.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-7"><span class="nav-number">8.5.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#⭐Challenge3-Detect-Cycle-in-a-Directed-Graph-Cycle-in-Graph-AE"><span class="nav-number">8.6.</span> <span class="nav-text">⭐Challenge3: Detect Cycle in a Directed Graph || Cycle in Graph(AE)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-14"><span class="nav-number">8.6.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-Detect-Cycle-in-a-Directed-Graph-using-BFS"><span class="nav-number">8.6.2.</span> <span class="nav-text">Solution2: Detect Cycle in a Directed Graph using BFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cycle-detection-in-an-undirected-graph"><span class="nav-number">8.6.3.</span> <span class="nav-text">Cycle detection in an undirected graph</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge4-Find-“Mother-Vertex”-in-a-Directed-Graph"><span class="nav-number">8.7.</span> <span class="nav-text">Challenge4: Find “Mother Vertex” in a Directed Graph</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mother-Vertex"><span class="nav-number">8.7.1.</span> <span class="nav-text">Mother Vertex?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-15"><span class="nav-number">8.7.2.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-8"><span class="nav-number">8.7.3.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge5-Count-number-of-edges-in-an-undirected-graph"><span class="nav-number">8.8.</span> <span class="nav-text">Challenge5: Count number of edges in an undirected graph</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-16"><span class="nav-number">8.8.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-9"><span class="nav-number">8.8.2.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge6-Find-if-there-is-a-path-between-two-vertices-in-a-directed-graph"><span class="nav-number">8.9.</span> <span class="nav-text">Challenge6:  Find if there is a path between two vertices in a directed graph</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-17"><span class="nav-number">8.9.1.</span> <span class="nav-text">Solution1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-10"><span class="nav-number">8.9.2.</span> <span class="nav-text">Solution2:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph"><span class="nav-number">8.9.3.</span> <span class="nav-text">Find if there is a path between two vertices in an undirected graph</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge7-Check-if-a-Directed-graph-is-Tree-or-not"><span class="nav-number">8.10.</span> <span class="nav-text">Challenge7: Check if a Directed graph is Tree or not</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution0"><span class="nav-number">8.10.1.</span> <span class="nav-text">Solution0:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution-1-Using-BFS-Traversal"><span class="nav-number">8.10.2.</span> <span class="nav-text">Solution 1: Using BFS Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution2-11"><span class="nav-number">8.10.3.</span> <span class="nav-text">Solution2:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-8-Find-Length-of-Shortest-Path-between-Two-Vertices"><span class="nav-number">8.11.</span> <span class="nav-text">Challenge 8: Find Length of Shortest Path between Two Vertices</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-18"><span class="nav-number">8.11.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenge-9-Remove-Edge-from-a-Directed-Graph"><span class="nav-number">8.12.</span> <span class="nav-text">Challenge 9: Remove Edge from a Directed Graph</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution1-19"><span class="nav-number">8.12.1.</span> <span class="nav-text">Solution1:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AlgoTogether"><span class="nav-number">9.</span> <span class="nav-text">AlgoTogether</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Problems-Required"><span class="nav-number">9.1.</span> <span class="nav-text">Problems (Required)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Problems-Options"><span class="nav-number">9.2.</span> <span class="nav-text">Problems (Options)</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dejavu"
      src="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
  <p class="site-author-name" itemprop="name">Dejavu</p>
  <div class="site-description" itemprop="description">Stay gold</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Dejavu-19" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Dejavu-19" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/liu.kunling19@gmail.com" title="E-Mail → liu.kunling19@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dejavu</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false});</script></body>
</html>
