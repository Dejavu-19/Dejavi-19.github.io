<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dejavi-19.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Stay gold">
<meta property="og:type" content="website">
<meta property="og:title" content="Dejavu&#39;s Notebook">
<meta property="og:url" content="https://dejavi-19.github.io/page/3/index.html">
<meta property="og:site_name" content="Dejavu&#39;s Notebook">
<meta property="og:description" content="Stay gold">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Dejavu">
<meta property="article:tag" content="python">
<meta property="article:tag" content="java">
<meta property="article:tag" content="hexo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dejavi-19.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dejavu's Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/Dejavu-19" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dejavu's Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Alea iacta est</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首&emsp;&emsp;页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于博主</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标&emsp;&emsp;签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分&emsp;&emsp;类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归&emsp;&emsp;档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/17/Recursion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/Recursion/" class="post-title-link" itemprop="url">Recursion</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 13:05:50" itemprop="dateCreated datePublished" datetime="2020-09-17T13:05:50+09:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 13:20:41" itemprop="dateModified" datetime="2021-03-08T13:20:41+09:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pattern-Subsets"><a href="#Pattern-Subsets" class="headerlink" title="Pattern: Subsets"></a>Pattern: Subsets</h1><p>\301. Remove Invalid Parentheses</p>
<p>\787. Cheapest Flights Within K Stops</p>
<h2 id="Subsets-easy-✨"><a href="#Subsets-easy-✨" class="headerlink" title="Subsets (easy)✨"></a>Subsets (easy)✨</h2><p>To generate all subsets of the given set, we can use the <strong>Breadth First Search (BFS)</strong> approach. We can start with an empty set, iterate through all numbers one-by-one, and add them to existing sets to create new subsets.</p>
<p>Let’s take the example-2 mentioned above to go through each step of our algorithm:</p>
<p>Given set: [1, 5, 3]</p>
<ol>
<li>Start with an empty set: [[]]</li>
<li>Add the first number (1) to all the existing subsets to create new subsets: [[], <strong>[1]]</strong>;</li>
<li>Add the second number (5) to all the existing subsets: [[], [1], <strong>[5], [1,5]</strong>];</li>
<li>Add the third number (3) to all the existing subsets: [[], [1], [5], [1,5], <strong>[3], [1,3], [5,3], [1,5,3]</strong>].</li>
</ol>
<p>Time complexity</p>
<p>Since, in each step, the number of subsets doubles as we add each element to all the existing subsets, therefore, we will have a total of O(2^N) subsets, where ‘N’ is the total number of elements in the input set. And since we construct a new subset from an existing set, therefore, the time complexity of the above algorithm will be O(N*2^N).</p>
<p>Space complexity</p>
<p>All the additional space used by our algorithm is for the output list. Since we will have a total of O(2^N)<em>O</em>(2<em>N</em>) subsets, and each subset can take up to O(N) space, therefore, the space complexity of our algorithm will be O(N*2^N).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; findSubsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// start by adding the empty subset</span></span><br><span class="line">    subsets.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> currentNumber : nums) &#123;</span><br><span class="line">        <span class="comment">// we will take all existing subsets and insert the current number in them to create new subsets</span></span><br><span class="line">        <span class="keyword">int</span> n = subsets.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// create a new subset from the existing subset and insert the current element to it</span></span><br><span class="line">            List&lt;Integer&gt; set = <span class="keyword">new</span> ArrayList&lt;&gt;(subsets.get(i));</span><br><span class="line">            set.add(currentNumber);</span><br><span class="line">            subsets.add(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Power-Set-AE-✨"><a href="#Power-Set-AE-✨" class="headerlink" title="Power Set(AE)✨"></a>Power Set(AE)✨</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">traverse:</span><br><span class="line">[[]] <span class="comment">//1</span></span><br><span class="line">[[],[<span class="number">1</span>]] <span class="comment">//2</span></span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]]  <span class="comment">//3</span></span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n*2^n^) time | O(n*2^n^) space</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; powerset(List&lt;Integer&gt; array) &#123;</span><br><span class="line">    <span class="keyword">return</span> powerset(array, array.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; powerset(List&lt;Integer&gt; array, <span class="keyword">int</span> idx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;  <span class="comment">//edge case</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; emptySet = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        emptySet.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> emptySet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ele = array.get(idx);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = powerset(array, idx - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//powerset of [1,2,3] -&gt; add 4 ele to all prev subsets -&gt; powerset of [1,2,3,4]</span></span><br><span class="line">    <span class="keyword">int</span> length = subsets.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        List&lt;Integer&gt; currentSubset = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(subsets.get(i));</span><br><span class="line">        currentSubset.add(ele);</span><br><span class="line">        subsets.add(currentSubset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>generate the subset based on the subsets we currently have</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n*2^n^) time | O(n*2^n^) space</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; powerset(List&lt;Integer&gt; array) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();  <span class="comment">//declare out subsets varaible</span></span><br><span class="line">    subsets.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());  <span class="comment">//add the empty array</span></span><br><span class="line">    <span class="keyword">for</span> (Integer ele : array) &#123;  <span class="comment">//tarverse the element in the array</span></span><br><span class="line">        <span class="keyword">int</span> length = subsets.size();  <span class="comment">//necessary</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;  <span class="comment">//each subset add the new ele create a new subset</span></span><br><span class="line">            List&lt;Integer&gt; currentSubset = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(subsets.get(i));</span><br><span class="line">            currentSubset.add(ele);</span><br><span class="line">            subsets.add(currentSubset);  <span class="comment">//add the new subset to the subsets</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="78-Subsets✨"><a href="#78-Subsets✨" class="headerlink" title="78. Subsets✨"></a><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">78. Subsets✨</a></h3><h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Backtracking 找出集合的所有子集，子集不能重复，[1, 2] 和 [2, 1] 这种子集算重复</li>
<li><a href="https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)" target="_blank" rel="noopener">https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pick a starting point.</span><br><span class="line"><span class="keyword">while</span>(Problem is not solved)</span><br><span class="line">    For each path from the starting point.</span><br><span class="line">        check <span class="keyword">if</span> selected path is safe, <span class="keyword">if</span> yes select it</span><br><span class="line">        and make recursive call to rest of the problem</span><br><span class="line">        before which undo the current move.</span><br><span class="line">    End For</span><br><span class="line">If none of the move works out, <span class="keyword">return</span> <span class="keyword">false</span>, NO SOLUTON.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(2n) | S O(n)</span></span><br><span class="line"><span class="comment">//shell function</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;Integer&gt; subset =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(results, subset, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//magic recursive function do the work</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, </span></span></span><br><span class="line"><span class="function"><span class="params">                       List&lt;Integer&gt; subset, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> [] nums, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    results.add(<span class="keyword">new</span> ArrayList&lt;&gt;(subset));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        subset.add(nums[i]);</span><br><span class="line">        backtrack(results, subset, nums, i + <span class="number">1</span>);</span><br><span class="line">        subset.remove(subset.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">return</span> powerset(nums, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; powerset(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;  <span class="comment">//base line</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; emptySet = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        emptySet.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> emptySet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ele = nums[idx];</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = powerset(nums, idx - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//powerset of [1,2,3] -&gt; add 4 ele to all prev subsets -&gt; powerset of [1,2,3,4]</span></span><br><span class="line">    <span class="keyword">int</span> length = subsets.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        List&lt;Integer&gt; currentSubset = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(subsets.get(i));</span><br><span class="line">        currentSubset.add(ele);</span><br><span class="line">        subsets.add(currentSubset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Subsets-With-Duplicates-easy-✨"><a href="#Subsets-With-Duplicates-easy-✨" class="headerlink" title="Subsets With Duplicates (easy)✨"></a>Subsets With Duplicates (easy)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; findSubsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// sort the numbers to handle duplicates</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    subsets.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>, endIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        startIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// if current and the previous elements are same, create new subsets only from the subsets </span></span><br><span class="line">        <span class="comment">// added in the previous step</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            startIndex = endIndex + <span class="number">1</span>;</span><br><span class="line">        endIndex = subsets.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = startIndex; j &lt;= endIndex; j++) &#123;</span><br><span class="line">            <span class="comment">// create a new subset from the existing subset and add the current element to it</span></span><br><span class="line">            List&lt;Integer&gt; set = <span class="keyword">new</span> ArrayList&lt;&gt;(subsets.get(j));</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            subsets.add(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="90-Subsets-II✨"><a href="#90-Subsets-II✨" class="headerlink" title="90. Subsets II✨"></a><a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">90. Subsets II✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">For example,</span><br><span class="line">If nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], a solution is:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">traverse:</span><br><span class="line">[[]] <span class="comment">//1</span></span><br><span class="line">[[],[<span class="number">1</span>]] <span class="comment">//2</span></span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]]  <span class="comment">//3</span></span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">handle the duplicate situation</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] -&gt; [<span class="number">1</span>,<span class="number">2</span><span class="string">'] [1,2'</span><span class="string">']</span></span><br><span class="line"><span class="string">[1,2'</span><span class="string">',2'</span>] is in correct,要紧挨着挑，不能跳着挑，先<span class="number">2</span><span class="string">''</span>再<span class="number">2</span><span class="string">'继续下去会出现重复</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; subset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    getSubsets(nums, <span class="number">0</span>, subset, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> start, </span></span></span><br><span class="line"><span class="function"><span class="params">                        List&lt;Integer&gt; subset, </span></span></span><br><span class="line"><span class="function"><span class="params">                        List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    ans.add(<span class="keyword">new</span> ArrayList(subset));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//skip the duplicate，怎么判断i-1没有放进来过？i != startIdx, i - 1 &gt;= startIdx + 1</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        subset.add(nums[i]);</span><br><span class="line">        getSubsets(nums, i + <span class="number">1</span>, subset, ans);</span><br><span class="line">        subset.remove(subset.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Permutations-medium-⭐"><a href="#Permutations-medium-⭐" class="headerlink" title="Permutations (medium)⭐"></a>Permutations (medium)⭐</h2><h3 id="Permutations-AE-⭐"><a href="#Permutations-AE-⭐" class="headerlink" title="Permutations(AE)⭐"></a>Permutations(AE)⭐</h3><h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(n! n^2^) | Space O(n n!)  n！n factorial</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getPermutations(List&lt;Integer&gt; array) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; permutations = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    getPermutations(array, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), permutations);</span><br><span class="line">    <span class="keyword">return</span> permutations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getPermutations</span><span class="params">(List&lt;Integer&gt; array, List&lt;Integer&gt; currentPermutations, List&lt;List&lt;Integer&gt;&gt; permutations)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line, run out the element in the array</span></span><br><span class="line">    <span class="keyword">if</span> (array.size() == <span class="number">0</span> &amp;&amp; currentPermutations.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        permutations.add(currentPermutations);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); ++i) &#123;  <span class="comment">//move one element in array to cur</span></span><br><span class="line">            List&lt;Integer&gt; newArray = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(array);</span><br><span class="line">            newArray.remove(i);</span><br><span class="line">            List&lt;Integer&gt; newPermutations = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(currentPermutations);</span><br><span class="line">            newPermutations.add(array.get(i));</span><br><span class="line">            getPermutations(newArray, newPermutations, permutations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getPermuations(List&lt;Integer&gt; array) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; permutations = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    getPermutations(<span class="number">0</span>, array, permutations);</span><br><span class="line">    <span class="keyword">return</span> permutations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getPermutations</span><span class="params">(<span class="keyword">int</span> i, List&lt;Integer&gt; array, List&lt;List&lt;Integer&gt;&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == array.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        permutations.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(array));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.size(); ++j) &#123;</span><br><span class="line">            swap(array, i, j);</span><br><span class="line">            getPermutations(i + <span class="number">1</span>, array, permutations);</span><br><span class="line">            swap(array, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;Integer&gt; array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Integer temp = array.get(i);</span><br><span class="line">    array.set(i, array.get(j));</span><br><span class="line">    array.set(j, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="46-Permutations⭐"><a href="#46-Permutations⭐" class="headerlink" title="46. Permutations⭐"></a><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">46. Permutations⭐</a></h3><p>Given a collection of distinct numbers, return all possible permutations. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：回溯法。O(n^n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans =  <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    getPermute(nums, visited, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPermute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (cur.size() == nums.length) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        cur.add(nums[i]);</span><br><span class="line">        visited[i] = <span class="keyword">true</span>;</span><br><span class="line">        getPermute(nums, visited, cur, ans);</span><br><span class="line">        cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        visited[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning)" target="_blank" rel="noopener">A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partioning)</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// Arrays.sort(nums); // not necessary</span></span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tempList.size() == nums.length)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(tempList.contains(nums[i])) <span class="keyword">continue</span>; <span class="comment">// element already exists, skip</span></span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(list, tempList, nums);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title=" 47. Permutations II"></a><a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener"> 47. Permutations II</a></h3><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>思路：回溯法。去重方法：使用数组记录某元素是否已经使用，已使用则重复；如果当前元素与前元素相等， 如果前面元素未被使用，则此元素也不应使用，即相同元素序列只使用第一个元素作为开始，这样可以避免相同元素造成的重复。O(n^n)</p>
</li>
<li><p>数组元素可能含有相同的元素，进行排列时就有可能出现重复的排列，要求重复的排列只返回一个。</p>
<p>在实现上，和 Permutations 不同的是要先排序，然后在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans =  <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    getPermute(nums, visited, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPermute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (cur.size() == nums.length) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !visited[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        cur.add(nums[i]);</span><br><span class="line">        visited[i] = <span class="keyword">true</span>;</span><br><span class="line">        getPermute(nums, visited, cur, ans);</span><br><span class="line">        cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        visited[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">boolean</span> [] used)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="keyword">true</span>; </span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(list, tempList, nums, used);</span><br><span class="line">            used[i] = <span class="keyword">false</span>; </span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🌕31-Next-Permutation✨💎🎶"><a href="#🌕31-Next-Permutation✨💎🎶" class="headerlink" title="🌕31.Next Permutation✨💎🎶"></a><a href="https://leetcode.com/problems/next-permutation/" target="_blank" rel="noopener">🌕31.Next Permutation✨💎🎶</a></h3><h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：找下一个排列中略大于现在subset数的数。如果这个数存在，则数组中一定有一个低位数大于某一高位数。从个位开始向高位逐一查找，看相邻两数是否高位的较小（注意相邻两数的关系已经决定了数列的单调性），如果是，那么需要找一个大于它的数和它置换。可以证明高位之后的数字是递减排列，所以从最低位找到第一个大于该高位的数与之置换，则新数一定大于当前数，且该高位后为递减排列，这时需要把这部分倒置为递增排列。如果这个数不存在，可以证明，整个数组是递减排列，整体倒置即可。</li>
<li>Time complexity : O(n). In worst case, only two scans of the whole array are needed.</li>
<li>Space complexity : O(1). No extra space is used. In place replacements are done.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//find first descending cur</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//find min greater num than cur in the behind part, exch(cur, num)</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, i-<span class="number">1</span>, j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reverse the order behind cur</span></span><br><span class="line">    reverse(nums, i, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        swap(nums, i++, j--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="556-Next-Greater-Element-III✨"><a href="#556-Next-Greater-Element-III✨" class="headerlink" title="556. Next Greater Element III✨"></a><a href="https://leetcode.com/problems/next-greater-element-iii/" target="_blank" rel="noopener">556. Next Greater Element III✨</a></h3><h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Brute Force</p>
</li>
<li><p>Time complexity : O(n!)<em>O</em>(<em>n</em>!). A total of n!<em>n</em>! permutations are possible for a number consisting of n<em>n</em> digits.</p>
</li>
<li><p>Space complexity : O(n!)<em>O</em>(<em>n</em>!). A total of n!<em>n</em>! permutations are possible for a number consisting of n<em>n</em> digits, with each permutation consisting of n<em>n</em> digits.</p>
</li>
<li><p>I) Traverse the given number from rightmost digit, keep traversing till you find a digit which is smaller than the previously traversed digit. For example, if the input number is “534976”, we stop at 4 because 4 is smaller than next digit 9. If we do not find such a digit, then output is “Not Possible”.</p>
</li>
</ol>
<p>   II) Now search the right side of above found digit ‘d’ for the smallest digit greater than ‘d’. For “53<strong>4</strong>976″, the right side of 4 contains “976”. The smallest digit greater than 4 is <strong>6</strong>.</p>
<p>   III) Swap the above found two digits, we get 53<strong>6</strong>97<strong>4</strong> in above example.</p>
<p>   IV) Now sort all digits from position next to ‘d’ to the end of number. The number that we get after sorting is the output. For above example, we sort digits in bold 536<strong>974</strong>. We get “536<strong>479</strong>” which is the next greater number for input 534976.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] numbers = (n+<span class="string">""</span>).toCharArray();</span><br><span class="line">    <span class="comment">// I) Start from the right most digit and find the first digit that is smaller than the digit next to it.</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = numbers.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &gt; numbers[i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If no such digit is found, its the edge case 1.</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// II) Find the smallest digit on right side of (i-1)'th digit that is greater than number[i-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = numbers.length - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[j] &gt; numbers[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            swap(numbers, i-<span class="number">1</span>, j);  <span class="comment">//Swap the above found smallest digit with number[i-1]</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IV) Sort the digits after (i-1) in ascending order</span></span><br><span class="line">    reverse(numbers, i, numbers.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> ans = Long.parseLong(<span class="keyword">new</span> String(numbers));</span><br><span class="line">    <span class="keyword">return</span> ans &lt;= Integer.MAX_VALUE? (<span class="keyword">int</span>) ans : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] numbers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp = numbers[i];</span><br><span class="line">    numbers[i] = numbers[j];</span><br><span class="line">    numbers[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] numbers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">        swap(numbers, i++, j--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String-Permutations-by-changing-case-medium-✨"><a href="#String-Permutations-by-changing-case-medium-✨" class="headerlink" title="String Permutations by changing case (medium)✨"></a>String Permutations by changing case (medium)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findLetterCaseStringPermutations</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; permutations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> permutations;</span><br><span class="line"></span><br><span class="line">    permutations.add(str);</span><br><span class="line">    <span class="comment">// process every character of the string one by one</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isLetter(str.charAt(i))) &#123; <span class="comment">// only process characters, skip digits</span></span><br><span class="line">            <span class="comment">// we will take all existing permutations and change the letter case appropriately</span></span><br><span class="line">            <span class="keyword">int</span> n = permutations.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] chs = permutations.get(j).toCharArray();</span><br><span class="line">                <span class="comment">// if the current character is in upper case change it to lower case or vice versa</span></span><br><span class="line">                <span class="keyword">if</span> (Character.isUpperCase(chs[i]))</span><br><span class="line">                    chs[i] = Character.toLowerCase(chs[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    chs[i] = Character.toUpperCase(chs[i]);</span><br><span class="line">                permutations.add(String.valueOf(chs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> permutations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="784-Letter-Case-Permutation✨"><a href="#784-Letter-Case-Permutation✨" class="headerlink" title="784. Letter Case Permutation✨"></a><a href="https://leetcode.com/problems/letter-case-permutation/" target="_blank" rel="noopener">784. Letter Case Permutation✨</a></h3><h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//call magic recursive function</span></span><br><span class="line">    findPermutations(<span class="number">0</span>, S.toCharArray(), ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPermutations</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">char</span>[] chars, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == chars.length) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Character.isLetter(chars[idx])) &#123;</span><br><span class="line">        chars[idx] = Character.toUpperCase(chars[idx]);</span><br><span class="line">        findPermutations(idx + <span class="number">1</span>, chars, ans);</span><br><span class="line">        chars[idx] = Character.toLowerCase(chars[idx]);</span><br><span class="line">        findPermutations(idx + <span class="number">1</span>, chars, ans);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        findPermutations(idx + <span class="number">1</span>, chars, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">            a1b2   i=0, when it's at a, since it's a letter, we have two branches: a, A</span></span><br><span class="line"><span class="comment">         /        \</span></span><br><span class="line"><span class="comment">       a1b2       A1b2 i=1 when it's at 1, we only have 1 branch which is itself</span></span><br><span class="line"><span class="comment">        |          |   </span></span><br><span class="line"><span class="comment">       a1b2       A1b2 i=2 when it's at b, we have two branches: b, B</span></span><br><span class="line"><span class="comment">       /  \        / \</span></span><br><span class="line"><span class="comment">      a1b2 a1B2  A1b2 A1B2 i=3  when it's at 2, we only have one branch.</span></span><br><span class="line"><span class="comment">       |    |     |     |</span></span><br><span class="line"><span class="comment">      a1b2 a1B2  A1b2  A1B2 i=4 = S.length(). End recursion, add permutation to ans. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      During this process, we are changing the S char array itself</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-22-Generate-Parentheses⭐"><a href="#🌕Unsolved-22-Generate-Parentheses⭐" class="headerlink" title="🌕Unsolved 22.Generate Parentheses⭐"></a><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">🌕Unsolved 22.Generate Parentheses⭐</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N&#x3D;2</span><br><span class="line">Output: (()), ()()</span><br><span class="line">Input: N&#x3D;3</span><br><span class="line">Output: ((())), (()()), (())(), ()(()), ()()()</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//backtracking</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    generate(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(String cur, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> n, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (open == n &amp;&amp; close == n) &#123;</span><br><span class="line">        res.add(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (open &lt; n) &#123;</span><br><span class="line">        generate(cur + <span class="string">"("</span>, open + <span class="number">1</span>, close, n, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">        generate(cur + <span class="string">")"</span>, open, close + <span class="number">1</span>, n, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParenthesesString</span> </span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">    <span class="keyword">int</span> openCount; <span class="comment">// open parentheses count</span></span><br><span class="line">    <span class="keyword">int</span> closeCount; <span class="comment">// close parentheses count</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParenthesesString</span><span class="params">(String s, <span class="keyword">int</span> openCount, <span class="keyword">int</span> closeCount)</span> </span>&#123;</span><br><span class="line">        str = s;</span><br><span class="line">        <span class="keyword">this</span>.openCount = openCount;</span><br><span class="line">        <span class="keyword">this</span>.closeCount = closeCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateParentheses</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateValidParentheses</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        Queue&lt;ParenthesesString&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> ParenthesesString(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            ParenthesesString ps = queue.poll();</span><br><span class="line">            <span class="comment">// if we've reached the maximum number of open and close parentheses, add to the result</span></span><br><span class="line">            <span class="keyword">if</span> (ps.openCount == num &amp;&amp; ps.closeCount == num) &#123;</span><br><span class="line">                result.add(ps.str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ps.openCount &lt; num) <span class="comment">// if we can add an open parentheses, add it</span></span><br><span class="line">                    queue.add(<span class="keyword">new</span> ParenthesesString(ps.str + <span class="string">"("</span>, ps.openCount + <span class="number">1</span>, ps.closeCount));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ps.openCount &gt; ps.closeCount) <span class="comment">// if we can add a close parentheses, add it</span></span><br><span class="line">                    queue.add(<span class="keyword">new</span> ParenthesesString(ps.str + <span class="string">")"</span>, ps.openCount, ps.closeCount + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Unique-Generalized-Abbreviations-hard"><a href="#Unsolved-Unique-Generalized-Abbreviations-hard" class="headerlink" title="Unsolved Unique Generalized Abbreviations (hard)"></a>Unsolved Unique Generalized Abbreviations (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;BAT&quot;</span><br><span class="line">Output: &quot;BAT&quot;, &quot;BA1&quot;, &quot;B1T&quot;, &quot;B2&quot;, &quot;1AT&quot;, &quot;1A1&quot;, &quot;2T&quot;, &quot;3&quot;</span><br><span class="line"></span><br><span class="line">Input: &quot;code&quot;</span><br><span class="line">Output: &quot;code&quot;, &quot;cod1&quot;, &quot;co1e&quot;, &quot;co2&quot;, &quot;c1de&quot;, &quot;c1d1&quot;, &quot;c2e&quot;, &quot;c3&quot;, &quot;1ode&quot;, &quot;1od1&quot;, &quot;1o1e&quot;, &quot;1o2&quot;, </span><br><span class="line">&quot;2de&quot;, &quot;2d1&quot;, &quot;3e&quot;, &quot;4&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateGeneralizedAbbreviation</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wordLen = word.length();</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Queue&lt;AbbreviatedWord&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> AbbreviatedWord(<span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        AbbreviatedWord abWord = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (abWord.start == wordLen) &#123;</span><br><span class="line">            <span class="keyword">if</span> (abWord.count != <span class="number">0</span>)</span><br><span class="line">                abWord.str.append(abWord.count);</span><br><span class="line">            result.add(abWord.str.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// continue abbreviating by incrementing the current abbreviation count</span></span><br><span class="line">            queue.add(<span class="keyword">new</span> AbbreviatedWord(<span class="keyword">new</span> StringBuilder(abWord.str), abWord.start + <span class="number">1</span>, abWord.count + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// restart abbreviating, append the count and the current character to the string</span></span><br><span class="line">            <span class="keyword">if</span> (abWord.count != <span class="number">0</span>)</span><br><span class="line">                abWord.str.append(abWord.count);</span><br><span class="line">            queue.add(</span><br><span class="line">                <span class="keyword">new</span> AbbreviatedWord(<span class="keyword">new</span> StringBuilder(abWord.str).append(word.charAt(abWord.start)), abWord.start + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Challenge-1-Evaluate-Expression-hard"><a href="#Unsolved-Challenge-1-Evaluate-Expression-hard" class="headerlink" title="Unsolved Challenge 1 Evaluate Expression (hard)"></a>Unsolved Challenge 1 Evaluate Expression (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1+2*3&quot;</span><br><span class="line">Output: 7, 9</span><br><span class="line">Explanation: 1+(2*3) &#x3D;&gt; 7 and (1+2)*3 &#x3D;&gt; 9</span><br><span class="line"></span><br><span class="line">Input: &quot;2*3-4-5&quot;</span><br><span class="line">Output: 8, -12, 7, -7, -3 </span><br><span class="line">Explanation: 2*(3-(4-5)) &#x3D;&gt; 8, 2*(3-4-5) &#x3D;&gt; -12, 2*3-(4-5) &#x3D;&gt; 7, 2*(3-4)-5 &#x3D;&gt; -7, (2*3)-4-5 &#x3D;&gt; -3</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">diffWaysToEvaluateExpression</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// base case: if the input string is a number, parse and add it to output.</span></span><br><span class="line">    <span class="keyword">if</span> (!input.contains(<span class="string">"+"</span>) &amp;&amp; !input.contains(<span class="string">"-"</span>) &amp;&amp; !input.contains(<span class="string">"*"</span>)) &#123;</span><br><span class="line">        result.add(Integer.parseInt(input));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> chr = input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(chr)) &#123;</span><br><span class="line">                <span class="comment">// break the equation here into two parts and make recursively calls</span></span><br><span class="line">                List&lt;Integer&gt; leftParts = diffWaysToEvaluateExpression(input.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; rightParts = diffWaysToEvaluateExpression(input.substring(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> part1 : leftParts) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> part2 : rightParts) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (chr == <span class="string">'+'</span>)</span><br><span class="line">                            result.add(part1 + part2);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (chr == <span class="string">'-'</span>)</span><br><span class="line">                            result.add(part1 - part2);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (chr == <span class="string">'*'</span>)</span><br><span class="line">                            result.add(part1 * part2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memoized-version"><a href="#Memoized-version" class="headerlink" title="Memoized version"></a>Memoized version</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memoization map</span></span><br><span class="line">Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToEvaluateExpression</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(input))</span><br><span class="line">        <span class="keyword">return</span> map.get(input);</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// base case: if the input string is a number, parse and return it.</span></span><br><span class="line">    <span class="keyword">if</span> (!input.contains(<span class="string">"+"</span>) &amp;&amp; !input.contains(<span class="string">"-"</span>) &amp;&amp; !input.contains(<span class="string">"*"</span>)) &#123;</span><br><span class="line">        result.add(Integer.parseInt(input));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> chr = input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(chr)) &#123;</span><br><span class="line">                List&lt;Integer&gt; leftParts = diffWaysToEvaluateExpression(input.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; rightParts = diffWaysToEvaluateExpression(input.substring(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> part1 : leftParts) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> part2 : rightParts) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (chr == <span class="string">'+'</span>)</span><br><span class="line">                            result.add(part1 + part2);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (chr == <span class="string">'-'</span>)</span><br><span class="line">                            result.add(part1 - part2);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (chr == <span class="string">'*'</span>)</span><br><span class="line">                            result.add(part1 * part2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(input, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Challenge-2-Structurally-Unique-Binary-Search-Trees-hard-✨"><a href="#Unsolved-Challenge-2-Structurally-Unique-Binary-Search-Trees-hard-✨" class="headerlink" title="Unsolved Challenge 2 Structurally Unique Binary Search Trees (hard)✨"></a>Unsolved Challenge 2 Structurally Unique Binary Search Trees (hard)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">findUniqueTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">return</span> findUniqueTreesRecursive(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">findUniqueTreesRecursive</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// base condition, return 'null' for an empty sub-tree</span></span><br><span class="line">    <span class="comment">// consider n=1, in this case we will have start=end=1, this means we should have only one tree</span></span><br><span class="line">    <span class="comment">// we will have two recursive calls, findUniqueTreesRecursive(1, 0) &amp; (2, 1)</span></span><br><span class="line">    <span class="comment">// both of these should return 'null' for the left and the right child</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        result.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="comment">// making 'i' root of the tree</span></span><br><span class="line">        List&lt;TreeNode&gt; leftSubtrees = findUniqueTreesRecursive(start, i - <span class="number">1</span>);</span><br><span class="line">        List&lt;TreeNode&gt; rightSubtrees = findUniqueTreesRecursive(i + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">for</span> (TreeNode leftTree : leftSubtrees) &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode rightTree : rightSubtrees) &#123;</span><br><span class="line">                TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                root.left = leftTree;</span><br><span class="line">                root.right = rightTree;</span><br><span class="line">                result.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="95-Unique-Binary-Search-Trees-II✨"><a href="#95-Unique-Binary-Search-Trees-II✨" class="headerlink" title="95. Unique Binary Search Trees II✨"></a><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. Unique Binary Search Trees II✨</a></h2><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n. For example, Given n = 3, your program should return all 5 unique BST’s shown below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&#39;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：回溯法。因结点是顺序排列的，所以头结点两侧分别为左右子树，所以左右子树和当前结点组成的树为答案。递归结束条件：start 与 end 指向同一点，则说明该点为叶子结点；start&gt;end，说明该子树不存在。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">return</span> genTreeList(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">genTreeList</span> <span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pick up a root</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx = start; idx &lt;= end; idx++) &#123;</span><br><span class="line">        <span class="comment">// all possible left subtrees if i is choosen to be a root</span></span><br><span class="line">        List&lt;TreeNode&gt; leftList = genTreeList(start, idx - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// all possible right subtrees if i is choosen to be a root</span></span><br><span class="line">        List&lt;TreeNode&gt; rightList = genTreeList(idx + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// connect left and right trees to the root i</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode left : leftList) &#123;</span><br><span class="line">            <span class="keyword">for</span>(TreeNode right: rightList) &#123;</span><br><span class="line">                TreeNode root = <span class="keyword">new</span> TreeNode(idx);</span><br><span class="line">                root.left = left;</span><br><span class="line">                root.right = right;</span><br><span class="line">                list.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Challenge-3-Count-of-Structurally-Unique-Binary-Search-Trees-hard"><a href="#Unsolved-Challenge-3-Count-of-Structurally-Unique-Binary-Search-Trees-hard" class="headerlink" title="Unsolved Challenge 3 Count of Structurally Unique Binary Search Trees (hard)"></a>Unsolved Challenge 3 Count of Structurally Unique Binary Search Trees (hard)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// making 'i' root of the tree</span></span><br><span class="line">        <span class="keyword">int</span> countOfLeftSubtrees = countTrees(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> countOfRightSubtrees = countTrees(n - i);</span><br><span class="line">        count += (countOfLeftSubtrees * countOfRightSubtrees);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memoized-version-1"><a href="#Memoized-version-1" class="headerlink" title="Memoized version"></a>Memoized version</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(n))</span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// making 'i' root of the tree</span></span><br><span class="line">        <span class="keyword">int</span> countOfLeftSubtrees = countTrees(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> countOfRightSubtrees = countTrees(n - i);</span><br><span class="line">        count += (countOfLeftSubtrees * countOfRightSubtrees);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(n, count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="96-Unique-Binary-Search-Trees✨"><a href="#96-Unique-Binary-Search-Trees✨" class="headerlink" title="96. Unique Binary Search Trees✨"></a><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. Unique Binary Search Trees✨</a></h2><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example, Given n = 3, there are a total of 5 unique BST’s.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n &#x3D; 3, there are a total of 5 unique BST&#39;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：动态规划。推导方程：每一结点（j）作为根的可能性=左面每一结点作为根的数量之和+右面每一结点 作为根的数量之和，即 c[n]=c[j-1]<em>c[n-j]，可以从 n=2 开始推导直到 n=n。<a href="https://leetcode.com/problems/unique-binary-search-trees/discuss/31666/DP-Solution-in-6-lines-with-explanation.-F(i-n)-G(i-1)--G(n-i" target="_blank" rel="noopener">详解</a></em></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] G = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Recursive with memorization</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> numTrees(n, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n, Map&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(n)) <span class="keyword">return</span> map.get(n);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//n - 1 - i, one node for root</span></span><br><span class="line">        sum += numTrees(i, map) * numTrees(n - <span class="number">1</span> - i, map);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(n, sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h1><blockquote>
<p>Recursion is an approach to solving problems using a function that calls itself as a subroutine.</p>
</blockquote>
<p>A recursive function should have the following properties so that it does not result in an infinite loop:</p>
<ol>
<li>A simple <code>base case</code> (or cases) — a terminating scenario that does not use recursion to produce an answer.</li>
<li>A set of rules, also known as <code>recurrence relation</code> that reduces all other cases towards the base case.</li>
</ol>
<h2 id="39-Combination-Sum⭐"><a href="#39-Combination-Sum⭐" class="headerlink" title="39. Combination Sum⭐"></a><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">39. Combination Sum⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span></span><br><span class="line">Output: [[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">7</span>]]</span><br><span class="line">Explanation:</span><br><span class="line"><span class="number">2</span> and <span class="number">3</span> are candidates, and <span class="number">2</span> + <span class="number">2</span> + <span class="number">3</span> = <span class="number">7</span>. Note that <span class="number">2</span> can be used multiple times.</span><br><span class="line"><span class="number">7</span> is a candidate, and <span class="number">7</span> = <span class="number">7</span>.</span><br><span class="line">These are the only two combinations.</span><br><span class="line">    </span><br><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">8</span></span><br><span class="line">Output: [[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">Input: candidates = [<span class="number">2</span>], target = <span class="number">1</span></span><br><span class="line">Output: []</span><br><span class="line"></span><br><span class="line">Input: candidates = [<span class="number">1</span>], target = <span class="number">2</span></span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>image worst case the solution is return n copies of the input (target = n), then space complexity should be O(N^target) as well</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    getCombinationSum(candidates, target, <span class="number">0</span>, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCombinationSum</span><span class="params">(<span class="keyword">int</span>[] candidates, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> remain, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> start, </span></span></span><br><span class="line"><span class="function"><span class="params">                               List&lt;Integer&gt; cur, </span></span></span><br><span class="line"><span class="function"><span class="params">                               List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//don't forget new ArrayList(cur), List is abstract class, need constructor</span></span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            cur.add(candidates[i]);</span><br><span class="line">            <span class="comment">// not i + 1 so that we can reuse same elements</span></span><br><span class="line">            getCombinationSum(candidates, remain - candidates[i], i, cur, ans);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="40-Combination-Sum-II✨"><a href="#40-Combination-Sum-II✨" class="headerlink" title="40. Combination Sum II✨"></a><a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. Combination Sum II✨</a></h3><p>can’t reuse same element</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>], target = <span class="number">8</span></span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>],</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],</span><br><span class="line">[<span class="number">1</span>,<span class="number">7</span>],</span><br><span class="line">[<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">5</span></span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">[<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    getCombinationSum2(candidates, target, <span class="number">0</span>, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCombinationSum2</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="comment">// skip duplicates</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            cur.add(candidates[i]);</span><br><span class="line">            getCombinationSum2(candidates, target - candidates[i], i + <span class="number">1</span>, cur, ans);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a><a href="https://leetcode.com/problems/combinations/description/" target="_blank" rel="noopener">77. Combinations</a></h3><h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">If n = <span class="number">4</span> and k = <span class="number">2</span>, a solution is:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; current = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getCombine(n, k, <span class="number">1</span>, current, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCombine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(current));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        current.add(i);</span><br><span class="line">        getCombine(n, k - <span class="number">1</span>, i + <span class="number">1</span>, current, ans);</span><br><span class="line">        current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="216-Combination-Sum-III✨"><a href="#216-Combination-Sum-III✨" class="headerlink" title="216. Combination Sum III✨"></a><a href="https://leetcode.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. Combination Sum III✨</a></h3><ul>
<li>Only numbers <code>1</code> through <code>9</code> are used.</li>
<li>Each number is used <strong>at most once</strong>.</li>
<li>从 1-9 数字中选出 k 个数不重复的数，使得它们的和为 n。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: k = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]]</span><br><span class="line">Explanation:</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> = <span class="number">7</span></span><br><span class="line">There are no other valid combinations.</span><br><span class="line">    </span><br><span class="line">Input: k = <span class="number">3</span>, n = <span class="number">9</span></span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">Explanation:</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">6</span> = <span class="number">9</span></span><br><span class="line"><span class="number">1</span> + <span class="number">3</span> + <span class="number">5</span> = <span class="number">9</span></span><br><span class="line"><span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">9</span></span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getCombinationSum3(k, n, <span class="number">1</span>, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCombinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> start, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (cur.size() &gt; k || n &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (cur.size() == k &amp;&amp; n == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        cur.add(i);</span><br><span class="line">        getCombinationSum3(k, n-i, i+<span class="number">1</span>, cur, ans);</span><br><span class="line">        cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-Letter-Combinations-of-a-Phone-Number⭐"><a href="#17-Letter-Combinations-of-a-Phone-Number⭐" class="headerlink" title="17. Letter Combinations of a Phone Number⭐"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener">17. Letter Combinations of a Phone Number⭐</a></h2><p>Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="https://camo.githubusercontent.com/a8fc38780ec458d1094ad58aea36666a8e818d37/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39383233373638632d323132622d346231612d623639612d6233663539653037623937372e6a7067" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:Digit string <span class="string">"23"</span></span><br><span class="line">Output: [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：回溯法，每键创建一个新的List，使用之前的组合添加每一个可能的字符，每一种新结果添加到新List 中。O(n^k)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    String[] mapping = <span class="keyword">new</span> String[] &#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    letterCombinationsRecursive(digits, <span class="string">""</span>, <span class="number">0</span>, mapping, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letterCombinationsRecursive</span><span class="params">(String digits, String current, <span class="keyword">int</span> idx, String[] mapping, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == digits.length()) &#123;</span><br><span class="line">        ans.add(current);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String letters = mapping[digits.charAt(idx) - <span class="string">'0'</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length(); i++) &#123;</span><br><span class="line">        letterCombinationsRecursive(digits, current + letters.charAt(i), idx + <span class="number">1</span>, mapping, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>single queue BFS solutions</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">if</span>(digits.isEmpty()) <span class="keyword">return</span> ans;</span><br><span class="line">		String[] mapping = <span class="keyword">new</span> String[] &#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">		ans.add(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;digits.length();i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x = Character.getNumericValue(digits.charAt(i));</span><br><span class="line">			<span class="keyword">while</span>(ans.peek().length()==i)&#123;</span><br><span class="line">				String t = ans.remove();</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">char</span> s : mapping[x].toCharArray())</span><br><span class="line">					ans.add(t+s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Restore-IP-Addresses✨"><a href="#Unsolved-Restore-IP-Addresses✨" class="headerlink" title="Unsolved Restore IP Addresses✨"></a><a href="https://leetcode.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">Unsolved Restore IP Addresses✨</a></h2><h2 id="Nth-Fibonacci-AE"><a href="#Nth-Fibonacci-AE" class="headerlink" title="Nth Fibonacci(AE)"></a>Nth Fibonacci(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>) </span><br><span class="line"><span class="comment">//bad O(2^n)T, cause do many unncessary compute</span></span><br><span class="line"><span class="comment">//eg. fib(6)-&gt; fib(5)+fib(4)-&gt;fib(4)+fib(3)+fib(3)+fib(2)   </span></span><br><span class="line"><span class="comment">//O(N) S call the stack</span></span><br><span class="line"><span class="comment">//eg.in the stack maximum </span></span><br><span class="line"><span class="comment">//fib(6)</span></span><br><span class="line"><span class="comment">//fib(5) </span></span><br><span class="line"><span class="comment">//fib(4)</span></span><br><span class="line"><span class="comment">//fib(3)</span></span><br><span class="line"><span class="comment">//fib(2)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. Fibonacci Number</a></p>
<h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>first fib = 0, second fib = 1…</li>
<li>However this solution may cause stack overflow</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(2^n) T O(n) S</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNthFib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNthFib(n - <span class="number">1</span>) + getNthFib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Using HashMap, do not have to recalculate many times, and get the calculated value in constant time</p>
</li>
<li><p><strong><code>Map&lt;Integer,Integer&gt; map = new HasMap&lt;Integer,Integer&gt;();</code></strong></p>
</li>
<li><p><strong><code>map.put(key,value)</code></strong></p>
<p><strong><code>map.get(key)</code></strong></p>
<p><strong><code>map.containsKey(key)</code></strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) T O(n) S</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNthFib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">//put the 1st Fib to map</span></span><br><span class="line">    map.put(<span class="number">2</span>, <span class="number">1</span>);  <span class="comment">//put the 2nd Fib to map</span></span><br><span class="line">    <span class="keyword">return</span> getNthFib(n, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//use a helper method pass in the index and map</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNthFib</span><span class="params">(<span class="keyword">int</span> n, Map&lt;Integer,Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(n)) &#123;  <span class="comment">//base line</span></span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> value = getNthFib(n - <span class="number">1</span>, map) + getNthFib(n - <span class="number">2</span>, map);</span><br><span class="line">        map.put(n, value);  <span class="comment">//nth Fib = (n-1)+(n-2),call it recursively</span></span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3:"></a>Solution3:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">0</span>, <span class="number">1</span>],<span class="number">1</span> ,<span class="number">2</span> -&gt; <span class="number">0</span>, [<span class="number">1</span>, <span class="number">1</span>], <span class="number">2</span> -&gt; <span class="number">0</span>,  <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>    </span><br><span class="line">  n = <span class="number">4</span></span><br><span class="line">  <span class="keyword">return</span> twoFib[<span class="number">1</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//slidint widow, lastTwo [0, 1]</span></span><br><span class="line"><span class="comment">//O(n) T O(1) S</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNthFib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] twoFib = &#123;<span class="number">0</span> , <span class="number">1</span>&#125;;  <span class="comment">//creat an array only track last two Fib</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">3</span>;  <span class="comment">//if n &gt;= 3, sliding the window, [0, 1],1 , 2 -&gt; 0, [1, 1], 2</span></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextFib = twoFib[<span class="number">0</span>] + twoFib[<span class="number">1</span>];</span><br><span class="line">        twoFib[<span class="number">0</span>] = twoFib[<span class="number">1</span>];</span><br><span class="line">        twoFib[<span class="number">1</span>] = nextFib;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">1</span> ? twoFib[<span class="number">1</span>] : twoFib[<span class="number">0</span>];  <span class="comment">//if n = 1, return the 1th element, else 2th element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Product-Sum-AE"><a href="#Product-Sum-AE" class="headerlink" title="Product Sum(AE)"></a>Product Sum(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">5</span>, <span class="number">2</span>, [<span class="number">7</span>, -<span class="number">1</span>], <span class="number">3</span>, [<span class="number">6</span>, [-<span class="number">13</span>, <span class="number">8</span>], <span class="number">4</span>]]</span><br><span class="line">output = <span class="number">12</span> = <span class="number">5</span> + <span class="number">2</span> + <span class="number">2</span> * (<span class="number">7</span> - <span class="number">1</span>) + <span class="number">3</span> + <span class="number">2</span> * (<span class="number">6</span> + <span class="number">3</span> * (-<span class="number">13</span> + <span class="number">8</span>) + <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Use <strong><code>recursion</code></strong> method product sum to deal with array in this question, return the sum multiplied by the current depth</p>
</li>
<li><p>O(N) T every elements in the array</p>
<p>O(D) S recursive call stack, maximum case of depth(D) 3</p>
<p>explain N, D meaning</p>
</li>
<li><p>If u forget the built in method, you can just say to your interviewer: there is a way to do this built in to my language, I forget it but I think is is <code>array.isarray</code>, point is make a voice </p>
<p>Stack Overflow or the documentation online</p>
<p><strong><code>instanceof</code></strong> 判断类型</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tip: You can use `element instanceof ArrayList` to check whether an item</span></span><br><span class="line"><span class="comment">// is an array or an integer.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">productSum</span><span class="params">(List&lt;Object&gt; array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">    <span class="keyword">return</span> productSumHelper(array, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">productSumHelper</span><span class="params">(List&lt;Object&gt; array, <span class="keyword">int</span> multiplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object el : array) &#123;  <span class="comment">//object represent List or Integer</span></span><br><span class="line">        <span class="keyword">if</span> (el <span class="keyword">instanceof</span> ArrayList) &#123;  <span class="comment">//if ele is ArrayList</span></span><br><span class="line">            ArrayList ls = (ArrayList)el;  <span class="comment">//Casting Object to ArrayList</span></span><br><span class="line">            sum += productSumHelper(ls, multiplier + <span class="number">1</span>);  <span class="comment">//recursively call method</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += (<span class="keyword">int</span>) el;  <span class="comment">//if is int casting plus to sum</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum * multiplier;  <span class="comment">//time the multiplier</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="339-Nested-List-Weight-Sum✨"><a href="#339-Nested-List-Weight-Sum✨" class="headerlink" title="339. Nested List Weight Sum✨"></a><a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener">339. Nested List Weight Sum✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nestedList = [<span class="number">1</span>,[<span class="number">4</span>,[<span class="number">6</span>]]]</span><br><span class="line">Output: <span class="number">27</span></span><br><span class="line">Explanation: One <span class="number">1</span> at depth <span class="number">1</span>, one <span class="number">4</span> at depth <span class="number">2</span>, and one <span class="number">6</span> at depth <span class="number">3</span>. <span class="number">1</span>*<span class="number">1</span> + <span class="number">4</span>*<span class="number">2</span> + <span class="number">6</span>*<span class="number">3</span> = <span class="number">27</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-19"><a href="#Solution1-19" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>DFS</li>
<li>Time O(n) Space O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculate(nestedList, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;NestedInteger&gt; nestedList, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (NestedInteger ele : nestedList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ele.isInteger()) &#123;</span><br><span class="line">            sum += ele.getInteger() * depth;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;NestedInteger&gt; list = ele.getList();</span><br><span class="line">            sum += calculate(list, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input: nestedList = [1,[4,[6]]]</span></span><br><span class="line"><span class="comment">Output: 27</span></span><br><span class="line"><span class="comment">Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 1*1 + 4*2 + 6*3 = 27.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int calculate(list, 1)</span></span><br><span class="line"><span class="comment">for ele in nestedList</span></span><br><span class="line"><span class="comment">    if (ele is int) &#123;</span></span><br><span class="line"><span class="comment">        sum += int * depth;</span></span><br><span class="line"><span class="comment">    &#125; else if (ele is list) &#123;</span></span><br><span class="line"><span class="comment">        sum += calculate(ele, depth + 1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    retrun depth;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">    Queue&lt;NestedInteger&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(NestedInteger n : nestedList)&#123;</span><br><span class="line">        q.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> deep = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            NestedInteger temp = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(temp.isInteger())&#123;</span><br><span class="line">                ans += deep * temp.getInteger();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(NestedInteger n : temp.getList())&#123;</span><br><span class="line">                    q.add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        deep++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Flatten-a-Dictionary💜💙"><a href="#Flatten-a-Dictionary💜💙" class="headerlink" title="Flatten a Dictionary💜💙"></a>Flatten a Dictionary💜💙</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">input:  dict = &#123;</span><br><span class="line">            <span class="string">"Key1"</span> : <span class="string">"1"</span>,</span><br><span class="line">            <span class="string">"Key2"</span> : &#123;</span><br><span class="line">                <span class="string">"a"</span> : <span class="string">"2"</span>,</span><br><span class="line">                <span class="string">"b"</span> : <span class="string">"3"</span>,</span><br><span class="line">                <span class="string">"c"</span> : &#123;</span><br><span class="line">                    <span class="string">"d"</span> : <span class="string">"3"</span>,</span><br><span class="line">                    <span class="string">"e"</span> : &#123;</span><br><span class="line">                        <span class="string">""</span> : <span class="string">"1"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">output: &#123;</span><br><span class="line">            <span class="string">"Key1"</span> : <span class="string">"1"</span>,</span><br><span class="line">            <span class="string">"Key2.a"</span> : <span class="string">"2"</span>,</span><br><span class="line">            <span class="string">"Key2.b"</span> : <span class="string">"3"</span>,</span><br><span class="line">            <span class="string">"Key2.c.d"</span> : <span class="string">"3"</span>,</span><br><span class="line">            <span class="string">"Key2.c.e"</span> : <span class="string">"1"</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>Beat language, Java work on writing code faster. </li>
<li>Go through test before coding. </li>
<li>Time Space analyze wrong </li>
<li>Read stuff like map, list and set in java. </li>
</ol>
<h3 id="Solution1-20"><a href="#Solution1-20" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time O(n) | Space O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> HashMap&lt;String, String&gt; <span class="title">flattenDictionary</span><span class="params">(HashMap&lt;String, Object&gt; dict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// your code goes here</span></span><br><span class="line">    HashMap&lt;String, String&gt; ans = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    flattenTheHashMap(<span class="string">""</span>, dict, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flattenTheHashMap</span><span class="params">(String key, HashMap&lt;String,Object&gt; dict, HashMap&lt;String, String&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String cur : dict.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dict.get(cur) <span class="keyword">instanceof</span> String) &#123;  <span class="comment">//first round</span></span><br><span class="line">            <span class="keyword">if</span> (key.equals(<span class="string">""</span>)) &#123;  <span class="comment">//use s.equals() compare string</span></span><br><span class="line">                ans.put(cur, (String) dict.get(cur));  <span class="comment">//&lt;cur, value(String)&gt; -&gt; ans</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                ans.put(key, (String) dict.get(cur));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                ans.put(key + <span class="string">"."</span> + cur, (String) dict.get(cur));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//Object -&gt; hashmap</span></span><br><span class="line">            <span class="comment">//Map&lt;xx, xx&gt;</span></span><br><span class="line">            <span class="comment">//String &lt;- key1.key2.key3 -&gt; value</span></span><br><span class="line">            HashMap&lt;String, Object&gt; newDict = (HashMap&lt;String, Object&gt;) dict.get(cur);</span><br><span class="line">            <span class="keyword">if</span> (key.equals(<span class="string">""</span>)) &#123;   <span class="comment">//first round</span></span><br><span class="line">                flattenTheHashMap(cur, newDict, ans);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                flattenTheHashMap(key, newDict, ans);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                key += <span class="string">"."</span> + cur;</span><br><span class="line">                flattenTheHashMap(key, newDict, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters"><a href="#1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters" class="headerlink" title="1239. Maximum Length of a Concatenated String with Unique Characters"></a><a href="https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/" target="_blank" rel="noopener">1239. Maximum Length of a Concatenated String with Unique Characters</a></h2><h3 id="Solution1-21"><a href="#Solution1-21" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(List&lt;String&gt; arr)</span> </span>&#123;</span><br><span class="line">    dfs(arr, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; arr, <span class="keyword">int</span> index, String concatenatStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isUnique(concatenatStr)) max = Math.max(max, concatenatStr.length());</span><br><span class="line">    <span class="keyword">if</span> (index == arr.size() || !isUnique(concatenatStr))  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; arr.size(); i++) &#123;</span><br><span class="line">        dfs(arr, i + <span class="number">1</span>, concatenatStr + arr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] alpha = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) alpha[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; alpha.length; i++) <span class="keyword">if</span> (alpha[i] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(List&lt;String&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dfs(arr, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; arr, String current, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isUnique = isUniqueChar(current);</span><br><span class="line">    <span class="keyword">if</span> (isUnique) &#123;</span><br><span class="line">        result = Math.max(result, current.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start == arr.size() || !isUnique) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; arr.size(); i++) &#123;</span><br><span class="line">        dfs(arr, current + arr.get(i), i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUniqueChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(c)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1641-Count-Sorted-Vowel-Strings"><a href="#1641-Count-Sorted-Vowel-Strings" class="headerlink" title="1641. Count Sorted Vowel Strings"></a><a href="https://leetcode.com/problems/count-sorted-vowel-strings/" target="_blank" rel="noopener">1641. Count Sorted Vowel Strings</a></h2><h3 id="Solution1-22"><a href="#Solution1-22" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Brute Force Using Backtracking</li>
<li>Time Complexity : \mathcal{O}(n^{5})O(<em>n</em>5). We have to calculate the size of the recursion tree. Let’s analyze the number of nodes generated at each level. The following figure illustrates the number of enumerations at level 22.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] vowels = &#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>&#125;;</span><br><span class="line">    countVowels(n, vowels,<span class="string">""</span>, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countVowels</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span>[] vowels, String cur, <span class="keyword">int</span> start, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.add(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; vowels.length; i++) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(cur);</span><br><span class="line">        <span class="keyword">char</span> c = vowels[i];</span><br><span class="line">        sb.append(c);</span><br><span class="line">        countVowels(n - <span class="number">1</span>,vowels, sb.toString(), i, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> countVowelStringUtil(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countVowelStringUtil</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> vowels)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vowels; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        result += countVowelStringUtil(n - <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-10"><a href="#Solution2-10" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>dp</p>
</li>
<li><p><code>dp[n][k]</code> means the number of strings constructed by at most <code>k</code> different characters.</p>
<p>If <code>k = 1</code>, use only <code>u</code><br>If <code>k = 2</code>, use only <code>o,u</code><br>If <code>k = 3</code>, use only <code>i,o,u</code><br>If <code>k = 4</code>, use only <code>e,i,o,u</code><br>If <code>k = 5</code>, use only <code>a,e,i,o,u</code></p>
<p> Bottom Up</p>
<p>Time <code>O(nk)</code><br>Space <code>O(nk)</code><br>where k = 5</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">5</span>; ++k)</span><br><span class="line">            dp[i][k] = dp[i][k - <span class="number">1</span>] + (i &gt; <span class="number">1</span> ? dp[i - <span class="number">1</span>][k] : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//                a  e  i  o  u</span></span><br><span class="line">    <span class="comment">//     initialy: &#123;1, 1, 1, 1, 1&#125;   </span></span><br><span class="line">    <span class="comment">//      n == 1 : &#123;5, 4, 3, 2, 1&#125;   </span></span><br><span class="line">    <span class="comment">//      n == 2 : &#123;15,10,6, 3, 1&#125;   </span></span><br><span class="line">    <span class="comment">//      n == 3 : &#123;35,20,10,4, 1&#125;   </span></span><br><span class="line">    <span class="comment">//        </span></span><br><span class="line">    <span class="keyword">int</span> []permutation = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = permutation.length-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">            permutation[j] = permutation[j] + sum;</span><br><span class="line">            sum = permutation[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> permutation[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lowest-Common-Manager-AE"><a href="#Lowest-Common-Manager-AE" class="headerlink" title="Lowest Common Manager(AE)"></a>Lowest Common Manager(AE)</h2><h3 id="Solution1-23"><a href="#Solution1-23" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OrgChart <span class="title">getLowestCommonManager</span><span class="params">(OrgChart topManager, OrgChart reportOne, OrgChart reportTwo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getOrgInfo(topManager, reportOne, reportTwo).lowestCommonManager; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OrgInfo <span class="title">getOrgInfo</span><span class="params">(OrgChart manager, OrgChart reportOne, OrgChart reportTwo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numImportantReports = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (OrgChart directReport : manager.directReports) &#123;</span><br><span class="line">        OrgInfo orgInfo = getOrgInfo(directReport, reportOne, reportTwo);</span><br><span class="line">        <span class="keyword">if</span> (orgInfo.lowestCommonManager != <span class="keyword">null</span>) <span class="keyword">return</span> orgInfo;</span><br><span class="line">        numImportantReports += orgInfo.numImportantReports;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (manager == reportOne || manager == reportTwo) numImportantReports++;</span><br><span class="line">    OrgChart lowestCommonManager = numImportantReports == <span class="number">2</span> ? manager : <span class="keyword">null</span>;</span><br><span class="line">    OrgInfo newOrgInfo = <span class="keyword">new</span> OrgInfo(lowestCommonManager, numImportantReports);</span><br><span class="line">    <span class="keyword">return</span> newOrgInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrgInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> OrgChart lowestCommonManager;</span><br><span class="line">    <span class="keyword">int</span> numImportantReports;</span><br><span class="line"></span><br><span class="line">    OrgInfo(OrgChart lowestCommonManager, <span class="keyword">int</span> numImportantReports) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lowestCommonManager = lowestCommonManager;</span><br><span class="line">        <span class="keyword">this</span>.numImportantReports = numImportantReports;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrgChart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> name;</span><br><span class="line">    <span class="keyword">public</span> List&lt;OrgChart&gt; directReports;</span><br><span class="line"></span><br><span class="line">    OrgChart(<span class="keyword">char</span> name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.directReports = <span class="keyword">new</span> ArrayList&lt;OrgChart&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This method is for testing only.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDirectReports</span><span class="params">(OrgChart[] directReports)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (OrgChart directReport : directReports) &#123;</span><br><span class="line">            <span class="keyword">this</span>.directReports.add(directReport);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Interweaving-Strings-AE"><a href="#Unsolved-Interweaving-Strings-AE" class="headerlink" title="Unsolved Interweaving Strings(AE)"></a>Unsolved Interweaving Strings(AE)</h2><h3 id="Solution1-24"><a href="#Solution1-24" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>O(2^(m + n)) time | O(m + n)  space</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interweavingStrings</span><span class="params">(String one, String two, String three)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (three.length() != one.length() + two.length()) &#123;  <span class="comment">//edge case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> areInterwoven(one, two, three, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areInterwoven</span><span class="params">(String one, String two, String three, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = i + j;</span><br><span class="line">    <span class="keyword">if</span> (k == three.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//which letter we choose to be the letter in three String</span></span><br><span class="line">    <span class="comment">//choose it come from String one and recursive call</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; one.length() &amp;&amp; one.charAt(i) == three.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (areInterwoven(one, two, three, i+<span class="number">1</span>, j)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//choose it come from String two and recursive call</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; two.length() &amp;&amp; two.charAt(j) == three.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (areInterwoven(one, two, three, i, j+<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-11"><a href="#Solution2-11" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interweavingStrings</span><span class="params">(String one, String two, String three)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (three.length() != one.length() + two.length()) &#123;  <span class="comment">//edge case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean[][] cache = <span class="keyword">new</span> Boolean[one.length() + <span class="number">1</span>][two.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> areInterwoven(one, two, three, <span class="number">0</span>, <span class="number">0</span>, cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areInterwoven</span><span class="params">(String one, String two, String three, <span class="keyword">int</span> i, <span class="keyword">int</span> j, Boolean[][] cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[i][j] != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> cache[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = i + j;</span><br><span class="line">    <span class="keyword">if</span> (k == three.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; one.length() &amp;&amp; one.charAt(i) == three.charAt(k)) &#123;</span><br><span class="line">        cache[i][j] = areInterwoven(one, two, three, i + <span class="number">1</span>, j, cache);</span><br><span class="line">        <span class="keyword">if</span> (cache[i][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j &lt; two.length() &amp;&amp; two.charAt(j) == three.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">var</span> result = areInterwoven(one, two, three, i, j + <span class="number">1</span>, cache);</span><br><span class="line">        cache[i][j] = result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache[i][j] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-97-Interleaving-String"><a href="#Unsolved-97-Interleaving-String" class="headerlink" title="Unsolved 97. Interleaving String"></a><a href="https://leetcode.com/problems/interleaving-string/" target="_blank" rel="noopener">Unsolved 97. Interleaving String</a></h3><h3 id="Solution1-25"><a href="#Solution1-25" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Recursion with memoization</li>
<li>Time complexity: \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>), where m<em>m</em> is the length of s1<em>s</em>1 and n<em>n</em> is the length of s2<em>s</em>2. That’s a consequence of the fact that each <code>(i, j)</code> combination is computed only once.</li>
<li>Space complexity: \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>) to keep double array <code>memo</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">is_Interleave</span><span class="params">(String s1, <span class="keyword">int</span> i, String s2, <span class="keyword">int</span> j, String s3, <span class="keyword">int</span> k, <span class="keyword">int</span>[][] memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == s1.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.substring(j).equals(s3.substring(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.substring(i).equals(s3.substring(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (memo[i][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j] == <span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s3.charAt(k) == s1.charAt(i) &amp;&amp; is_Interleave(s1, i + <span class="number">1</span>, s2, j, s3, k + <span class="number">1</span>, memo)</span><br><span class="line">        || s3.charAt(k) == s2.charAt(j) &amp;&amp; is_Interleave(s1, i, s2, j + <span class="number">1</span>, s3, k + <span class="number">1</span>, memo)) &#123;</span><br><span class="line">        ans = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[i][j] = ans ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> memo[][] = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length()][s2.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">            memo[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_Interleave(s1, <span class="number">0</span>, s2, <span class="number">0</span>, s3, <span class="number">0</span>, memo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-12"><a href="#Solution2-12" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Brute Force</li>
<li>The most basic idea is to find every string possible by all interleavings of the two given strings s1<em>s</em>1 and s2<em>s</em>2. In order to implement this method, we are using recursion. </li>
<li>Time complexity : O(2^{m+n}). m<em>m</em> is the length of s1<em>s</em>1 and n<em>n</em> is the length of s2<em>s</em>2.</li>
<li>Space complexity : O(m+n). The size of stack for recursive calls can go upto m+n<em>m</em>+<em>n</em>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">is_Interleave</span><span class="params">(String s1,<span class="keyword">int</span> i,String s2,<span class="keyword">int</span> j,String res,String s3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.equals(s3) &amp;&amp; i==s1.length() &amp;&amp; j==s2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> ans=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;s1.length())</span><br><span class="line">        ans|=is_Interleave(s1,i+<span class="number">1</span>,s2,j,res+s1.charAt(i),s3);</span><br><span class="line">    <span class="keyword">if</span>(j&lt;s2.length())</span><br><span class="line">        ans|=is_Interleave(s1,i,s2,j+<span class="number">1</span>,res+s2.charAt(j),s3);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> is_Interleave(s1,<span class="number">0</span>,s2,<span class="number">0</span>,<span class="string">""</span>,s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Number-Of-Binary-Tree-Topologies-AE"><a href="#Number-Of-Binary-Tree-Topologies-AE" class="headerlink" title="Number Of Binary Tree Topologies(AE)"></a>Number Of Binary Tree Topologies(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume n node</span><br><span class="line">left: <span class="number">0</span> node right: n - <span class="number">1</span> <span class="function">node <span class="title">f</span><span class="params">(n - <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">left: 1 node right: n - 2 node <span class="title">f</span><span class="params">(n - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">left: x node <span class="title">f</span><span class="params">(x)</span> right: n - x - 1 node <span class="title">f</span><span class="params">(n - x - <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">eg:</span></span><br><span class="line"><span class="function">n </span>= <span class="number">6</span> nodes</span><br><span class="line">   o</span><br><span class="line"><span class="number">3</span>     <span class="number">2</span></span><br><span class="line"><span class="number">5</span>*<span class="number">2</span> f(<span class="number">3</span>) = <span class="number">5</span> f(<span class="number">2</span>) = <span class="number">2</span></span><br><span class="line">   o</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span></span><br><span class="line">   o</span><br><span class="line"><span class="number">1</span>     <span class="number">4</span></span><br><span class="line">   o</span><br><span class="line"><span class="number">0</span>     <span class="number">5</span>   etc.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pseudocode code</span><br><span class="line"><span class="function"><span class="keyword">for</span> L in <span class="title">range</span> <span class="params">(<span class="number">0</span>, n)</span> : <span class="comment">//left subtree size</span></span></span><br><span class="line"><span class="function">	R </span>= n - <span class="number">1</span> - L <span class="comment">// right subtree size</span></span><br><span class="line">	nL = f(L)  <span class="comment">//left tree topologies</span></span><br><span class="line">	nR = f(R)</span><br><span class="line">	T += nL * nR  <span class="comment">//total</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-26"><a href="#Solution1-26" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>O((n*(2n)!)/(n!(n + 1)!)) time, O(n) space</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfBinaryTreeTopologies</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> numberOfTrees = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> leftTrees = <span class="number">0</span>; leftTrees &lt; n; leftTrees++) &#123;</span><br><span class="line">        <span class="keyword">int</span> rightTrees = n - <span class="number">1</span> - leftTrees;</span><br><span class="line">        <span class="comment">//recursively call method to calculate the BT left and right side topologies</span></span><br><span class="line">        <span class="keyword">int</span> numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTrees);</span><br><span class="line">        <span class="keyword">int</span> numberOfRightTrees = numberOfBinaryTreeTopologies(rightTrees);</span><br><span class="line">        <span class="comment">//total topologies = how many types in left * how many types in right</span></span><br><span class="line">        numberOfTrees += numberOfLeftTrees * numberOfRightTrees;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numberOfTrees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-13"><a href="#Solution2-13" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>O(n^2) time, O(n) space</li>
<li>recursively</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfBinaryTreeTopologies</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    cache.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> numberOfBinaryTreeTopologies(n, cache);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfBinaryTreeTopologies</span><span class="params">(<span class="keyword">int</span> n, Map&lt;Integer, Integer&gt; cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(n))  <span class="comment">//base line</span></span><br><span class="line">        <span class="keyword">return</span> cache.get(n);</span><br><span class="line">    <span class="keyword">int</span> numberOfTrees = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> leftTrees = <span class="number">0</span>; leftTrees &lt; n; leftTrees++) &#123;</span><br><span class="line">        <span class="keyword">int</span> rightTrees = n - <span class="number">1</span> - leftTrees;</span><br><span class="line">        <span class="keyword">int</span> numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTrees, cache);</span><br><span class="line">        <span class="keyword">int</span> numberOfRightTrees = numberOfBinaryTreeTopologies(rightTrees, cahce);</span><br><span class="line">        numberOfTrees += numberOfLeftTrees * numberOfRightTrees;</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(n, numberOfTrees);</span><br><span class="line">    <span class="keyword">return</span> numberOfTrees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3-1"><a href="#Solution3-1" class="headerlink" title="Solution3:"></a>Solution3:</h3><ol>
<li>O(n^2) time, O(n) space</li>
<li>iteratively</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfBinaryTreeTopologies</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    cache.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n + <span class="number">1</span>; m++) &#123;</span><br><span class="line">        <span class="keyword">int</span> numberOfTrees = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> leftTrees = <span class="number">0</span>; leftTrees &lt; m; leftTrees++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rightTrees = m - <span class="number">1</span> - leftTrees;</span><br><span class="line">            <span class="keyword">int</span> numberOfLeftTrees = cache.get(leftTrees);</span><br><span class="line">            <span class="keyword">int</span> numberOfRightTrees = cache.get(rightTrees);</span><br><span class="line">            numberOfTrees += numberOfLeftTrees * numberOfRightTrees;</span><br><span class="line">        &#125;</span><br><span class="line">        cache.add(numberOfTrees)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache.get(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-779-K-th-Symbol-in-Grammar✨"><a href="#Unsolved-779-K-th-Symbol-in-Grammar✨" class="headerlink" title="Unsolved 779. K-th Symbol in Grammar✨"></a><a href="https://leetcode.com/problems/k-th-symbol-in-grammar/" target="_blank" rel="noopener">Unsolved 779. K-th Symbol in Grammar✨</a></h2><h3 id="Solution1-27"><a href="#Solution1-27" class="headerlink" title="Solution1:"></a>Solution1:</h3><p><a href="https://leetcode.com/problems/k-th-symbol-in-grammar/discuss/113736/PythonJavaC%2B%2B-Easy-1-line-Solution-with-detailed-explanation" target="_blank" rel="noopener">Explaination</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.bitCount(K - <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">kthGrammar</span><span class="params">(self, N, K)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># Think of the base <span class="keyword">case</span>, already given here though</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> N </span>== <span class="number">1</span> and K == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    # We need to do some observation here:</span><br><span class="line"># 1 - Calculate the length of every row which is as below</span><br><span class="line">    mid = (<span class="number">2</span> ** (N-<span class="number">1</span>))<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    # If the K lies in the first half, it is actually same as prev row</span><br><span class="line">    <span class="keyword">if</span> K &lt;= mid:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(self.kthGrammar(N-<span class="number">1</span>, K))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"># Else it subtract the first half and then it is same as </span><br><span class="line">    # complement of the prev row</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">int</span>(not self.kthGrammar(N-<span class="number">1</span>, K-mid))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/17/Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/Graph/" class="post-title-link" itemprop="url">Graph</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 13:03:03" itemprop="dateCreated datePublished" datetime="2020-09-17T13:03:03+09:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-13 15:52:40" itemprop="dateModified" datetime="2021-03-13T15:52:40+09:00">2021-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pattern-Topological-Sort-Graph"><a href="#Pattern-Topological-Sort-Graph" class="headerlink" title="Pattern: Topological Sort (Graph)"></a>Pattern: Topological Sort (Graph)</h1><h2 id="Topological-Sort-medium"><a href="#Topological-Sort-medium" class="headerlink" title="Topological Sort (medium)"></a>Topological Sort (medium)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: Vertices&#x3D;4, Edges&#x3D;[3, 2], [3, 0], [2, 0], [2, 1]</span><br><span class="line">Output: Following are the two valid topological sorts for the given graph:</span><br><span class="line">1) 3, 2, 0, 1</span><br><span class="line">2) 3, 2, 1, 0</span><br><span class="line"></span><br><span class="line">Input: Vertices&#x3D;5, Edges&#x3D;[4, 2], [4, 3], [2, 0], [2, 1], [3, 1]</span><br><span class="line">Output: Following are all valid topological sorts for the given graph:</span><br><span class="line">1) 4, 2, 3, 0, 1</span><br><span class="line">2) 4, 3, 2, 0, 1</span><br><span class="line">3) 4, 3, 2, 1, 0</span><br><span class="line">4) 4, 2, 3, 1, 0</span><br><span class="line">5) 4, 2, 0, 3, 1</span><br><span class="line"></span><br><span class="line">A topological ordering is possible only when the graph has no directed cycles, i.e. if the graph is a Directed Acyclic Graph (DAG). </span><br><span class="line">If the graph has a cycle, some vertices will have cyclic dependencies which makes it impossible to find a linear ordering among vertices.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">sort</span><span class="params">(<span class="keyword">int</span> vertices, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (vertices &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sortedOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = edges[i][<span class="number">0</span>], child = edges[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">    <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">    <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> vertex = sources.poll();</span><br><span class="line">        sortedOrder.add(vertex);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                sources.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sortedOrder.size() != vertices) <span class="comment">// topological sort is not possible as the graph has a cycle</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tasks-Scheduling-medium"><a href="#Tasks-Scheduling-medium" class="headerlink" title="Tasks Scheduling (medium)"></a>Tasks Scheduling (medium)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSchedulingPossible</span><span class="params">(<span class="keyword">int</span> tasks, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (tasks &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = prerequisites[i][<span class="number">0</span>], child = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">        <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">        <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> vertex = sources.poll();</span><br><span class="line">            sortedOrder.add(vertex);</span><br><span class="line">            List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">                inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                    sources.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder doesn't contain all tasks, there is a cyclic dependency between tasks, therefore, we</span></span><br><span class="line">    <span class="comment">// will not be able to schedule all tasks</span></span><br><span class="line">    <span class="keyword">return</span> sortedOrder.size() == tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="207-Course-Schedule⭐🎶"><a href="#207-Course-Schedule⭐🎶" class="headerlink" title="207. Course Schedule⭐🎶"></a><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">207. Course Schedule⭐🎶</a></h2><p>There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2, [[1,0]]</span><br><span class="line">return true</span><br><span class="line">2, [[1,0],[0,1]]</span><br><span class="line">return false</span><br></pre></td></tr></table></figure>

<p>题目描述：一个课程可能会先修课程，判断给定的先修课程规定是否合法。</p>
<p>本题不需要使用拓扑排序，只需要检测有向图是否存在环即可。</p>
<p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2017/10/207-ep93.png" alt=""></p>
<p><img src="http://zxi.mytechroad.com/blog/wp-content/uploads/2017/10/207-ep93-1.png" alt=""></p>
<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//initial graph</span></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> child = p[<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child);</span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initial queue for source vertice</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> node : inDegree.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree.get(node) == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">        sortedList.add(cur);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedList.size() == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Topological Sort</li>
<li>思路：用一个 Map 记录课程的后续课程，用一个数组记录每门课前提课程的门数。把前提门数为零的放入一个队列，然后 逐个元素看能达到的所有课程，如果达到某课，则该课的前提减 1，如果该课前提为零，则加入队列。重复直到队列为空， 如果队列中累计弹出的课程数=总课程数，则表示可以完成。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> course = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pre = p[<span class="number">1</span>];</span><br><span class="line">        graph.get(course).add(pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">boolean</span>[] visiting = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, i, visited, visiting)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs for detect cycle</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> cur, <span class="keyword">boolean</span>[] visited, <span class="keyword">boolean</span>[] visiting)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (visiting[cur]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[cur]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    visiting[cur] = <span class="keyword">true</span>;</span><br><span class="line">    visited[cur] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(cur)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, next, visited, visiting)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visiting[cur] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Author: Huahua</span></span><br><span class="line"><span class="comment">// Runtime: 6 ms</span></span><br><span class="line"><span class="comment">// HashMap is slower than ArrayList in this problem.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;        </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> course = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> prerequisite = prerequisites[i][<span class="number">1</span>];            </span><br><span class="line">            graph.get(course).add(prerequisite);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span> (dfs(i, graph, visited)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        visited[curr] = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(curr))</span><br><span class="line">            <span class="keyword">if</span> (dfs(next, graph, visited)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        visited[curr] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tasks-Scheduling-Order-medium"><a href="#Tasks-Scheduling-Order-medium" class="headerlink" title="Tasks Scheduling Order (medium)"></a>Tasks Scheduling Order (medium)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> tasks, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (tasks &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sortedOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = prerequisites[i][<span class="number">0</span>], child = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">    <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">    <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> vertex = sources.poll();</span><br><span class="line">        sortedOrder.add(vertex);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                sources.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder doesn't contain all tasks, there is a cyclic dependency between tasks, therefore, we</span></span><br><span class="line">    <span class="comment">// will not be able to schedule all tasks</span></span><br><span class="line">    <span class="keyword">if</span> (sortedOrder.size() != tasks)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-210-Course-Schedule-II🎂💜⭐"><a href="#🌕Unsolved-210-Course-Schedule-II🎂💜⭐" class="headerlink" title="🌕Unsolved 210. Course Schedule II🎂💜⭐"></a><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">🌕Unsolved 210. Course Schedule II🎂💜⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>]]</span><br><span class="line">There are a total of <span class="number">4</span> courses to take. To take course <span class="number">3</span> you should have finished both courses <span class="number">1</span> and <span class="number">2</span>. Both courses <span class="number">1</span> and <span class="number">2</span> should be taken after you finished course <span class="number">0</span>. So one correct course order is [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]. Another correct ordering is[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>].</span><br></pre></td></tr></table></figure>

<p>There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. For example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>

<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>

<p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p>
<p>Note: </p>
<ol>
<li>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. </li>
<li>You may assume that there are no duplicate edges in the input prerequisites. Hints:</li>
<li>This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses. </li>
<li>Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort. </li>
<li>Topological sort could also be done via BFS</li>
</ol>
<p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2017/12/210-ep133.png" alt=""></p>
<p><a href="http://zxi.mytechroad.com/blog/graph/leetcode-210-course-schedule-ii/" target="_blank" rel="noopener">http://zxi.mytechroad.com/blog/graph/leetcode-210-course-schedule-ii/</a></p>
<h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">    List&lt;Integer&gt; sortedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initial graph inDegree -&gt; count in coming edges for vertice</span></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = p[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> child = p[<span class="number">0</span>];</span><br><span class="line">        graph.get(parent).add(child);</span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//prepare queue, add current source into it</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> node : inDegree.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree.get(node) == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//treverse left part add the node to sotedlist followe the releationship</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">        sortedList.add(cur);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//check cycle</span></span><br><span class="line">    <span class="keyword">if</span> (sortedList.size() != numCourses) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//list -&gt; array</span></span><br><span class="line">    <span class="keyword">return</span> sortedList.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Topological Sorting</p>
<p>Time complexity: O(V+E)</p>
<p>Space complexity: O(V+E)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> course = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pre = p[<span class="number">1</span>];</span><br><span class="line">        graph.get(course).add(pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">boolean</span>[] visiting = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, i, visited, visiting, ans)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> cur, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span>[] visited, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span>[] visiting,</span></span></span><br><span class="line"><span class="function"><span class="params">                   List&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (visiting[cur]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[cur]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    visiting[cur] = <span class="keyword">true</span>;</span><br><span class="line">    visited[cur] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(cur)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, next, visited, visiting, ans)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans.add(cur);</span><br><span class="line">    visiting[cur] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Author: Huahua</span></span><br><span class="line"><span class="comment">// Runtime: 83 ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> course = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> prerequisite = prerequisites[i][<span class="number">1</span>];            </span><br><span class="line">            graph.get(course).add(prerequisite);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Integer index = numCourses;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span> (dfs(i, graph, visited, ans)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[] visited, List&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        visited[curr] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(curr))</span><br><span class="line">            <span class="keyword">if</span> (dfs(next, graph, visited, ans)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        visited[curr] = <span class="number">2</span>;</span><br><span class="line">        ans.add(curr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-All-Tasks-Scheduling-Orders-hard"><a href="#🌕Unsolved-All-Tasks-Scheduling-Orders-hard" class="headerlink" title="🌕Unsolved All Tasks Scheduling Orders (hard)"></a>🌕Unsolved All Tasks Scheduling Orders (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Input: Tasks&#x3D;4, Prerequisites&#x3D;[3, 2], [3, 0], [2, 0], [2, 1]</span><br><span class="line">Output: </span><br><span class="line">1) [3, 2, 0, 1]</span><br><span class="line">2) [3, 2, 1, 0]</span><br><span class="line">Explanation: There are two possible orderings of the tasks meeting all prerequisites.</span><br><span class="line"></span><br><span class="line">Input: Tasks&#x3D;6, Prerequisites&#x3D;[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]</span><br><span class="line">Output: </span><br><span class="line">1) [0, 1, 4, 3, 2, 5]</span><br><span class="line">2) [0, 1, 3, 4, 2, 5]</span><br><span class="line">3) [0, 1, 3, 2, 4, 5]</span><br><span class="line">4) [0, 1, 3, 2, 5, 4]</span><br><span class="line">5) [1, 0, 3, 4, 2, 5]</span><br><span class="line">6) [1, 0, 3, 2, 4, 5]</span><br><span class="line">7) [1, 0, 3, 2, 5, 4]</span><br><span class="line">8) [1, 0, 4, 3, 2, 5]</span><br><span class="line">9) [1, 3, 0, 2, 4, 5]</span><br><span class="line">10) [1, 3, 0, 2, 5, 4]</span><br><span class="line">11) [1, 3, 0, 4, 2, 5]</span><br><span class="line">12) [1, 3, 2, 0, 5, 4]</span><br><span class="line">13) [1, 3, 2, 0, 4, 5]</span><br><span class="line"></span><br><span class="line">This problem is similar to Tasks Scheduling Order, the only difference is that we need to find all the topological orderings of the tasks.</span><br><span class="line"></span><br><span class="line">At any stage, if we have more than one source available and since we can choose any source, therefore, in this case, we will have multiple orderings of the tasks. We can use a recursive approach with Backtracking to consider all sources at any step.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOrders</span><span class="params">(<span class="keyword">int</span> tasks, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (tasks &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = prerequisites[i][<span class="number">0</span>], child = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printAllTopologicalSorts(graph, inDegree, sources, sortedOrder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllTopologicalSorts</span><span class="params">(HashMap&lt;Integer, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             List&lt;Integer&gt;&gt; graph,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             HashMap&lt;Integer, Integer&gt; inDegree, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             Queue&lt;Integer&gt; sources, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             List&lt;Integer&gt; sortedOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer vertex : sources) &#123;</span><br><span class="line">            sortedOrder.add(vertex);</span><br><span class="line">            Queue&lt;Integer&gt; sourcesForNextCall = cloneQueue(sources);</span><br><span class="line">            <span class="comment">// only remove the current source, all other sources should remain in the queue for the next call</span></span><br><span class="line">            sourcesForNextCall.remove(vertex);</span><br><span class="line">            List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">                inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                    sourcesForNextCall.add(child); <span class="comment">// save the new source for the next call</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// dfs, recursive call to print other orderings from the remaining (and new) sources</span></span><br><span class="line">            printAllTopologicalSorts(graph, inDegree, sourcesForNextCall, sortedOrder);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// backtrack, remove the vertex from the sorted order and put all of its children back to consider the next source instead of the current vertex</span></span><br><span class="line">            sortedOrder.remove(vertex);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children)</span><br><span class="line">                inDegree.put(child, inDegree.get(child) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="comment">// if sortedOrder doesn't contain all tasks, either we've a cyclic dependency between tasks, or </span></span><br><span class="line">    <span class="comment">// we have not processed all the tasks in this recursive call</span></span><br><span class="line">    <span class="keyword">if</span> (sortedOrder.size() == inDegree.size())</span><br><span class="line">        System.out.println(sortedOrder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makes a deep copy of the queue</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;Integer&gt; <span class="title">cloneQueue</span><span class="params">(Queue&lt;Integer&gt; queue)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; clone = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer num : queue)</span><br><span class="line">        clone.add(num);</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Alien-Dictionary-hard"><a href="#Alien-Dictionary-hard" class="headerlink" title="Alien Dictionary (hard)"></a>Alien Dictionary (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: Words: [&quot;ba&quot;, &quot;bc&quot;, &quot;ac&quot;, &quot;cab&quot;]</span><br><span class="line">Output: bac</span><br><span class="line">Explanation: Given that the words are sorted lexicographically by the rules of the alien language, so</span><br><span class="line">from the given words we can conclude the following ordering among its characters:</span><br><span class="line"></span><br><span class="line">1. From &quot;ba&quot; and &quot;bc&quot;, we can conclude that &#39;a&#39; comes before &#39;c&#39;.</span><br><span class="line">2. From &quot;bc&quot; and &quot;ac&quot;, we can conclude that &#39;b&#39; comes before &#39;a&#39;</span><br><span class="line"></span><br><span class="line">From the above two points, we can conclude that the correct character order is: &quot;bac&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Character, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Character, List&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> character : word.toCharArray()) &#123;</span><br><span class="line">            inDegree.put(character, <span class="number">0</span>);</span><br><span class="line">            graph.put(character, <span class="keyword">new</span> ArrayList&lt;Character&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        String w1 = words[i], w2 = words[i + <span class="number">1</span>]; <span class="comment">// find ordering of characters from adjacent words</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Math.min(w1.length(), w2.length()); j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> parent = w1.charAt(j), child = w2.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (parent != child) &#123; <span class="comment">// if the two characters are different</span></span><br><span class="line">                graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">                inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// only the first different character between the two words will help us find the order</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Character&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">    <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">    StringBuilder sortedOrder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        Character vertex = sources.poll();</span><br><span class="line">        sortedOrder.append(vertex);</span><br><span class="line">        List&lt;Character&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">        <span class="keyword">for</span> (Character child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                sources.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder doesn't contain all characters, there is a cyclic dependency between characters, therefore, we</span></span><br><span class="line">    <span class="comment">// will not be able to find the correct ordering of the characters</span></span><br><span class="line">    <span class="keyword">if</span> (sortedOrder.length() != inDegree.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedOrder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-269-Alien-Dictionary🎂✨"><a href="#🌕Unsolved-269-Alien-Dictionary🎂✨" class="headerlink" title="🌕Unsolved 269.Alien Dictionary🎂✨"></a><a href="https://leetcode.com/problems/alien-dictionary/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">🌕Unsolved 269.Alien Dictionary🎂✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 0: Create data structures and find all unique letters.</span></span><br><span class="line">    Map&lt;Character, List&lt;Character&gt;&gt; adjList = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            counts.put(c, <span class="number">0</span>);</span><br><span class="line">            adjList.put(c, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: Find all edges.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        String word1 = words[i];</span><br><span class="line">        String word2 = words[i + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// Check that word2 is not a prefix of word1.</span></span><br><span class="line">        <span class="keyword">if</span> (word1.length() &gt; word2.length() &amp;&amp; word1.startsWith(word2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Find the first non match and insert the corresponding relation.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Math.min(word1.length(), word2.length()); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(j) != word2.charAt(j)) &#123;</span><br><span class="line">                adjList.get(word1.charAt(j)).add(word2.charAt(j));</span><br><span class="line">                counts.put(word2.charAt(j), counts.get(word2.charAt(j)) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Breadth-first search.</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Character c : counts.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counts.get(c).equals(<span class="number">0</span>)) &#123;</span><br><span class="line">            queue.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Character c = queue.remove();</span><br><span class="line">        sb.append(c);</span><br><span class="line">        <span class="keyword">for</span> (Character next : adjList.get(c)) &#123;</span><br><span class="line">            counts.put(next, counts.get(next) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (counts.get(next).equals(<span class="number">0</span>)) &#123;</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sb.length() &lt; counts.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Challenge-1-Reconstructing-a-Sequence-hard"><a href="#🌕Challenge-1-Reconstructing-a-Sequence-hard" class="headerlink" title="🌕Challenge 1 Reconstructing a Sequence (hard)"></a>🌕Challenge 1 Reconstructing a Sequence (hard)</h2><p>The above explanation tells us that we are actually asked to find the topological ordering of all the numbers and also to verify that there is only one topological ordering of the numbers possible from the given array of the sequences.</p>
<p>This makes the current problem similar to <a href="https://www.educative.io/collection/page/5668639101419520/5671464854355968/5066018374287360/" target="_blank" rel="noopener">Tasks Scheduling Order</a> with two differences:</p>
<ol>
<li>We need to build the graph of the numbers by comparing each pair of numbers in the given array of sequences.</li>
<li>We must perform the topological sort for the graph to determine two things:<ul>
<li>Can the topological ordering construct the <code>originalSeq</code>?</li>
<li>That there is only one topological ordering of the numbers possible. This can be confirmed if we do not have more than one source at any time while finding the topological ordering of numbers.</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(<span class="keyword">int</span>[] originalSeq, <span class="keyword">int</span>[][] sequences)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (originalSeq.length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] seq : sequences) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seq.length; i++) &#123;</span><br><span class="line">            inDegree.putIfAbsent(seq[i], <span class="number">0</span>);</span><br><span class="line">            graph.putIfAbsent(seq[i], <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] seq : sequences) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; seq.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = seq[i - <span class="number">1</span>], child = seq[i];</span><br><span class="line">            graph.get(parent).add(child);</span><br><span class="line">            inDegree.put(child, inDegree.get(child) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we don't have ordering rules for all the numbers we'll not able to uniquely construct the sequence</span></span><br><span class="line">    <span class="keyword">if</span> (inDegree.size() != originalSeq.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">    <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">    <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sources.size() &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// more than one sources mean, there is more than one way to reconstruct the sequence</span></span><br><span class="line">        <span class="keyword">if</span> (originalSeq[sortedOrder.size()] != sources.peek())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// the next source (or number) is different from the original sequence</span></span><br><span class="line">        <span class="keyword">int</span> vertex = sources.poll();</span><br><span class="line">        sortedOrder.add(vertex);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                sources.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder's size is not equal to original sequence's size, there is no unique way to construct  </span></span><br><span class="line">    <span class="keyword">return</span> sortedOrder.size() == originalSeq.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Challenge-2-Minimum-Height-Trees-hard"><a href="#🌕Unsolved-Challenge-2-Minimum-Height-Trees-hard" class="headerlink" title="🌕Unsolved Challenge 2 Minimum Height Trees (hard)"></a>🌕Unsolved Challenge 2 Minimum Height Trees (hard)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findTrees</span><span class="params">(<span class="keyword">int</span> nodes, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; minHeightTrees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nodes &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> minHeightTrees;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one node, since its in-degree will be 0, therefore, we need to handle it separately</span></span><br><span class="line">    <span class="keyword">if</span> (nodes == <span class="number">1</span>) &#123;</span><br><span class="line">        minHeightTrees.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> minHeightTrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = edges[i][<span class="number">0</span>], n2 = edges[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// since this is an undirected graph, therefore, add a link for both the nodes</span></span><br><span class="line">        graph.get(n1).add(n2);</span><br><span class="line">        graph.get(n2).add(n1);</span><br><span class="line">        <span class="comment">// increment the in-degrees of both the nodes</span></span><br><span class="line">        inDegree.put(n1, inDegree.get(n1) + <span class="number">1</span>);</span><br><span class="line">        inDegree.put(n2, inDegree.get(n2) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all leaves i.e., all nodes with only 1 in-degree</span></span><br><span class="line">    Queue&lt;Integer&gt; leaves = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">1</span>)</span><br><span class="line">            leaves.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. Remove leaves level by level and subtract each leave's children's in-degrees.</span></span><br><span class="line">    <span class="comment">// Repeat this until we are left with 1 or 2 nodes, which will be our answer.</span></span><br><span class="line">    <span class="comment">// Any node that has already been a leaf cannot be the root of a minimum height tree, because </span></span><br><span class="line">    <span class="comment">// its adjacent non-leaf node will always be a better candidate.</span></span><br><span class="line">    <span class="keyword">int</span> totalNodes = nodes;</span><br><span class="line">    <span class="keyword">while</span> (totalNodes &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> leavesSize = leaves.size();</span><br><span class="line">        totalNodes -= leavesSize;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leavesSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> vertex = leaves.poll();</span><br><span class="line">            List&lt;Integer&gt; children = graph.get(vertex);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">                inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(child) == <span class="number">1</span>) <span class="comment">// if the child has become a leaf</span></span><br><span class="line">                    leaves.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    minHeightTrees.addAll(leaves);</span><br><span class="line">    <span class="keyword">return</span> minHeightTrees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-310-Minimum-Height-Trees🎂✨"><a href="#Unsolved-310-Minimum-Height-Trees🎂✨" class="headerlink" title="Unsolved 310. Minimum Height Trees🎂✨"></a><a href="https://leetcode.com/problems/minimum-height-trees/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 310. Minimum Height Trees🎂✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        ans.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = e[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> j = e[<span class="number">1</span>];</span><br><span class="line">        graph.get(i).add(j);</span><br><span class="line">        graph.get(j).add(i);</span><br><span class="line">        inDegree.put(i, inDegree.get(i) + <span class="number">1</span>);</span><br><span class="line">        inDegree.put(j, inDegree.get(j) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> node : inDegree.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree.get(node) == <span class="number">1</span>) &#123;</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nodeNum = n;</span><br><span class="line">    <span class="keyword">while</span>(nodeNum &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        nodeNum -= size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leaf = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : graph.get(leaf)) &#123;</span><br><span class="line">                inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(child) == <span class="number">1</span>) &#123;</span><br><span class="line">                    queue.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Coderust-Hacking-the-Coding-Interview"><a href="#Coderust-Hacking-the-Coding-Interview" class="headerlink" title="Coderust: Hacking the Coding Interview"></a>Coderust: Hacking the Coding Interview</h1><h2 id="Clone-a-Directed-Graph"><a href="#Clone-a-Directed-Graph" class="headerlink" title="Clone a Directed Graph"></a>Clone a Directed Graph</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;data = d;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">clone_rec</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Node root, </span></span></span><br><span class="line"><span class="function"><span class="params">        HashMap&lt;Node, Node&gt; nodes_completed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node pNew = <span class="keyword">new</span> Node(root.data);</span><br><span class="line">        nodes_completed.put(root, pNew);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node p : root.neighbors) &#123;</span><br><span class="line">            Node x = nodes_completed.get(p);</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="keyword">null</span>)&#123;</span><br><span class="line">                pNew.neighbors.add(clone_rec(p, nodes_completed));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pNew.neighbors.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-133-Clone-Graph🎂✨"><a href="#🌕Unsolved-133-Clone-Graph🎂✨" class="headerlink" title="🌕Unsolved 133. Clone Graph🎂✨"></a><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">🌕Unsolved 133. Clone Graph🎂✨</a></h2><p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. OJ’s undirected graph serialization: Nodes are labeled uniquely.</p>
<p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node. As an example, consider the serialized graph {0,1,2#1,2#2,2}. The graph has a total of three nodes, and therefore contains three parts as separated by #. </p>
<ol>
<li>First node is labeled as 0. Connect node 0 to both nodes 1 and 2. </li>
<li>Second node is labeled as 1. Connect node 1 to node 2. </li>
<li>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle. Visually, the graph looks like the following:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span></span><br><span class="line">  / \</span><br><span class="line"> /   \</span><br><span class="line"><span class="number">0</span> --- <span class="number">2</span></span><br><span class="line">    / \</span><br><span class="line">    \_/</span><br><span class="line">Definition <span class="keyword">for</span> a Node.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">        neighbors = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, ArrayList&lt;Node&gt; _neighbors)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路 1：BFS，每次把新结点放入将访问队列，通过 Map 记录已访问结点，避免重复访问。</li>
<li>O(nk)，n 结点数， k 邻居数。前提：结点中的值唯一。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node root = <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(node, root);</span><br><span class="line">    queue.add(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (Node neighbor : cur.neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(neighbor)) &#123;</span><br><span class="line">                map.put(neighbor, <span class="keyword">new</span> Node(neighbor.val, <span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">                queue.add(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(cur).neighbors.add(map.get(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路 2：DFS，思路同思路 1，只不过深度优先，好处是结点访问次数减少。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> dfs(node, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">dfs</span><span class="params">(Node node, Map&lt;Node, Node&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Node copyNode = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">    map.put(node, copyNode);</span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : node.neighbors) &#123;</span><br><span class="line">        Node next = map.get(neighbor);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            copyNode.neighbors.add(dfs(neighbor, map));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            copyNode.neighbors.add(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copyNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Minimum-Spanning-Tree"><a href="#🌕Minimum-Spanning-Tree" class="headerlink" title="🌕Minimum Spanning Tree"></a>🌕Minimum Spanning Tree</h2><h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><h2 id="Depth-first-Search-AE"><a href="#Depth-first-Search-AE" class="headerlink" title="Depth first Search(AE)"></a>Depth first Search(AE)</h2><h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>traverse the tree-like graph</li>
<li>V-vertex nodes, E-edges the line between node, call a bunch of stack</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(V+E) T</span></span><br><span class="line"><span class="comment">//O(V) S</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do not edit the class below except</span></span><br><span class="line">    <span class="comment">// for the depthFirstSearch method.</span></span><br><span class="line">    <span class="comment">// Feel free to add new properties</span></span><br><span class="line">    <span class="comment">// and methods to the class.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        List&lt;Node&gt; children = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">depthFirstSearch</span><span class="params">(List&lt;String&gt; array)</span> </span>&#123;</span><br><span class="line">            array.add(<span class="keyword">this</span>.name);  <span class="comment">//add the node to result</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chileren.size(); ++i) &#123;  <span class="comment">//traverse each children node and call DFS function recursively</span></span><br><span class="line">                children.get(i).depthFirstSearch(array);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">addChild</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            Node child = <span class="keyword">new</span> Node(name);</span><br><span class="line">            children.add(child);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="863-All-Nodes-Distance-K-in-Binary-Tree⭐"><a href="#863-All-Nodes-Distance-K-in-Binary-Tree⭐" class="headerlink" title="863. All Nodes Distance K in Binary Tree⭐"></a><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener">863. All Nodes Distance K in Binary Tree⭐</a></h2><p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2018/06/863-ep202.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">7</span>,<span class="number">4</span>], target = <span class="number">5</span>, K = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">The nodes that are a distance <span class="number">2</span> <span class="function">from the target <span class="title">node</span> <span class="params">(with value <span class="number">5</span>)</span></span></span><br><span class="line"><span class="function">have values 7, 4, and 1.</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt=""></p>
<h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Build graph, BFS/DFS traverse</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method 1: use HashMap</span></span><br><span class="line"><span class="comment">//1. build a undirected graph using treenodes as vertices, and the parent-child relation as edges</span></span><br><span class="line"><span class="comment">//2. do BFS with source vertice (target) to find all vertices with distance K to it.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//here can also use Map&lt;TreeNode, TreeNode&gt; to only store the child - parent mapping, since parent-child mapping is inherent in the tree structure</span></span><br><span class="line"></span><br><span class="line">Map&lt;TreeNode, List&lt;TreeNode&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || K &lt; <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    buildGraph(root, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (!graph.containsKey(target)) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    Set&lt;TreeNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(target);</span><br><span class="line">    visited.add(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="comment">//if distance is K, add this level to the ans list</span></span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                ans.add(queue.poll().val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode neighbor : graph.get(cur)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited.contains(neighbor)) <span class="keyword">continue</span>;</span><br><span class="line">                queue.add(neighbor);</span><br><span class="line">                visited.add(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        K--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(TreeNode root, TreeNode parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!graph.containsKey(root)) &#123;</span><br><span class="line">        graph.put(root, <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;());</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            graph.get(root).add(parent);</span><br><span class="line">            graph.get(parent).add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        buildGraph(root.left, root);</span><br><span class="line">        buildGraph(root.right, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check:</span></span><br><span class="line"><span class="comment">1. If root == null</span></span><br><span class="line"><span class="comment">2. K &lt; 0</span></span><br><span class="line"><span class="comment">3. traget inside the tree</span></span><br><span class="line"><span class="comment">return empty list</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">BFS,start from target</span></span><br><span class="line"><span class="comment">Step1: Build a graph use adjacency list,</span></span><br><span class="line"><span class="comment">Step2: BFS with a queue</span></span><br><span class="line"><span class="comment">    1.add taregt to queue</span></span><br><span class="line"><span class="comment">    2.level by level, utilize the neighbor list in the graph</span></span><br><span class="line"><span class="comment">    3.in K th level which means K distance from target, add all element in this level to a list and retrun it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2</span></span><br><span class="line"><span class="comment">adjacency list:</span></span><br><span class="line"><span class="comment">3 -&gt; [5,1]</span></span><br><span class="line"><span class="comment">5 -&gt; [6,2,3]</span></span><br><span class="line"><span class="comment">6 -&gt; [5]</span></span><br><span class="line"><span class="comment">2 -&gt; [5,7,4]</span></span><br><span class="line"><span class="comment">7 -&gt; [2]</span></span><br><span class="line"><span class="comment">4 -&gt; [2]</span></span><br><span class="line"><span class="comment">1 -&gt; [3,0,8]</span></span><br><span class="line"><span class="comment">0 -&gt; [1]</span></span><br><span class="line"><span class="comment">8 -&gt; [1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Go through an example:</span></span><br><span class="line"><span class="comment">target:5, K = 2</span></span><br><span class="line"><span class="comment">queue: 7,4,1</span></span><br><span class="line"><span class="comment">level:2</span></span><br><span class="line"><span class="comment">ans: 7,4,1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method 2: No HashMap</span></span><br><span class="line"><span class="comment">//kind of like clone the tree, in the meanwhile add a parent link to the node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GNode targetGNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">GNode</span> </span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        GNode parent, left, right;</span><br><span class="line">        GNode (TreeNode node) &#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;           </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || K &lt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        cloneGraph(root, <span class="keyword">null</span>, target);</span><br><span class="line">        <span class="keyword">if</span> (targetGNode == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Set&lt;GNode&gt; visited = <span class="keyword">new</span> HashSet&lt;GNode&gt;();</span><br><span class="line">        Queue&lt;GNode&gt; q = <span class="keyword">new</span> LinkedList&lt;GNode&gt;();</span><br><span class="line">        q.add(targetGNode);</span><br><span class="line">        visited.add(targetGNode);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size ; i++) res.add(q.poll().node.val);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                GNode gNode = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (gNode.left != <span class="keyword">null</span> &amp;&amp; !visited.contains(gNode.left)) &#123; visited.add(gNode.left); q.add(gNode.left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (gNode.right != <span class="keyword">null</span> &amp;&amp; !visited.contains(gNode.right)) &#123; visited.add(gNode.right); q.add(gNode.right); &#125;</span><br><span class="line">                <span class="keyword">if</span> (gNode.parent != <span class="keyword">null</span> &amp;&amp; !visited.contains(gNode.parent)) &#123; visited.add(gNode.parent); q.add(gNode.parent); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            K--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> GNode <span class="title">cloneGraph</span><span class="params">(TreeNode node, GNode parent, TreeNode target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        GNode gNode = <span class="keyword">new</span> GNode(node);</span><br><span class="line">        <span class="keyword">if</span> (node == target) targetGNode = gNode;</span><br><span class="line">        gNode.parent = parent;</span><br><span class="line">        gNode.left = cloneGraph(node.left, gNode, target);</span><br><span class="line">        gNode.right = cloneGraph(node.right, gNode, target);</span><br><span class="line">        <span class="keyword">return</span> gNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Single-Cycle-Check-AE"><a href="#Single-Cycle-Check-AE" class="headerlink" title="Single Cycle Check(AE)"></a>Single Cycle Check(AE)</h2><ol>
<li>Give a list of Integer, determine whether is there exist a single cycle, a loop visit every element only once</li>
<li>jump</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,-<span class="number">4</span>,-<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,<span class="number">1</span>] visit number</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(1) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSingleCycle</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numElementsVisits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curIdx = <span class="number">0</span>;  <span class="comment">//keep track the element we at the array, not necessary to be 0</span></span><br><span class="line">    <span class="keyword">while</span> (numElementsVisits &lt; array.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numElementsVisits &gt; <span class="number">0</span> &amp;&amp; curIdx == <span class="number">0</span>) &#123;  <span class="comment">//if we pass the first element before whole loop, the size of cycle not array.length</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        numElementsVisits++;  <span class="comment">//increase the element we have visited</span></span><br><span class="line">        curIdx = getNextIdx(curIdx, array);  <span class="comment">//jump wo next elements</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curIdx == <span class="number">0</span>;  <span class="comment">//aftr one whole loop, if it back to the start pointer, return true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextIdx</span><span class="params">(<span class="keyword">int</span> curIdx, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> jump = array[curIdx];  <span class="comment">//jump distance is the value of element</span></span><br><span class="line">    <span class="keyword">int</span> nextIdx = (curIdx + jump) % array.length;  <span class="comment">//apply mod operation if idx over the bound</span></span><br><span class="line">    <span class="keyword">return</span> nextIdx &gt;= <span class="number">0</span> ? nextIdx : nextIdx + array.length;  <span class="comment">//consider the negetave idx case</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Breadth-First-Search-AE"><a href="#Breadth-First-Search-AE" class="headerlink" title="Breadth First Search(AE)"></a>Breadth First Search(AE)</h2><ol>
<li><p>Target graph is a tree like graph traverse in a BFS way</p>
</li>
<li><p>DFS : branch by branch ; BFS : level by level</p>
</li>
<li><p>use queue (FIFO) will helpful to track the same level node</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">current: A</span><br><span class="line">Final array [A]  when we add A to <span class="keyword">final</span> array add all children BCD to queue</span><br><span class="line">Queue [B, C, D]</span><br><span class="line">    </span><br><span class="line">current: B</span><br><span class="line">Final array [A, B] when we add B to <span class="keyword">final</span> array add all children EF to queue</span><br><span class="line">Queue [C, D, E, F]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Problem</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        List&lt;Node&gt; children = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//O(v + e) time | O(v) space queue may be A have all children BCDEF in queue</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">breadthFirstSearch</span><span class="params">(List&lt;String&gt; array)</span> </span>&#123;</span><br><span class="line">            Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">            queue.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                Node current = queue.poll();</span><br><span class="line">                array.add(current.name);</span><br><span class="line">                queue.addAll(current.children);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">addChild</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            Node child = <span class="keyword">new</span> Node(name);</span><br><span class="line">            children.add(child);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="River-Sizes-AE-Number-of-Island-with-Area-follow-up⭐"><a href="#River-Sizes-AE-Number-of-Island-with-Area-follow-up⭐" class="headerlink" title="River Sizes(AE) || Number of Island with Area follow up⭐"></a>River Sizes(AE) || Number of Island with Area follow up⭐</h2><h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Classical graph traversal question, given a matrix, 0 -&gt; land, 1 -&gt;river. River size is the 1 that are adjacent, right next to each other either horizontally or vertically. Write  function to return an array of all pf the sizes of rivers in the matrix</li>
<li>Treat the matrix element as node, each has neighbor node. Use BFS or DFS to all neighbor node to do so. Technique: keep track of all the node we visited. Traverse all the node in sequence and keep track the size of river and visited</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(wh) time | O(wh) space width and height of matix</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">riverSizes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sizes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  <span class="comment">//initialize the size of rivers</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length][matrix[<span class="number">0</span>].length];  <span class="comment">//declare a boolean matrix that determines if the node has been visited</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; ++i) &#123;  <span class="comment">//row and column may different number</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i][j]) &#123;  <span class="comment">//is this node is already visited</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            traverseNode(i, j, matrix, visited, sizes);  <span class="comment">//call a tarverse helper function</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sizes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseNode</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] matrix, <span class="keyword">boolean</span>[][] visited, List&lt;Integer&gt; sizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentRiverSize = <span class="number">0</span>;  <span class="comment">//declare a polential river size varaible</span></span><br><span class="line">    Stack&lt;Integer[]&gt; nodesToExplore = <span class="keyword">new</span> Stack&lt;Integer[]&gt;();  <span class="comment">//apply DFS iteratively</span></span><br><span class="line">    nodesToExplore.push(<span class="keyword">new</span> Integer[]&#123;i, j&#125;);  <span class="comment">//the first need to explore is [i, j]</span></span><br><span class="line">    <span class="keyword">while</span> (!nodesToExplore.empty()) &#123;  <span class="comment">//pushing th neighbors to stack, and pop one by one, and BFS will use a queue instead of a stack</span></span><br><span class="line">        Integer[] currentNode = nodesToExplore.pop();</span><br><span class="line">        i = currentNode[<span class="number">0</span>];</span><br><span class="line">        j = currentNode[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (visited[i][j]) &#123;  <span class="comment">//when apply DFS if the node has been visited, skip continue</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;  <span class="comment">//else, set it has been visited</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;  <span class="comment">//if it is a piece of land, skip continue</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currentRiverSize++;  <span class="comment">//riversize++</span></span><br><span class="line">        <span class="comment">//we are doing with prevous unvisited one, go throuth the all unvisited neighbors, append them to the stack</span></span><br><span class="line">        List&lt;Integer[]&gt; unvisitedNeighbors = getUnvisitedNeighbors(i, j, matrix, visited);</span><br><span class="line">        <span class="keyword">for</span> (Integer[] neighbor : unvisitedNeighbors) &#123;</span><br><span class="line">            nodesToExplore.add(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentRiverSize &gt; <span class="number">0</span>) &#123;  <span class="comment">//if we have a actual river, add the size</span></span><br><span class="line">        sizes.add(currentRiverSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer[]&gt; getUnvisitedNeighbors(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] matrix, <span class="keyword">boolean</span>[][] visited) &#123;</span><br><span class="line">    List&lt;Integer[]&gt; unvisitedNeighbors = <span class="keyword">new</span> ArrayList&lt;Integer[]&gt;();  <span class="comment">//declare unvisited neighbors to an empty array , check the four neighbors are actually potentially valid neighbors</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !visited[i - <span class="number">1</span>][j]) &#123;  <span class="comment">//if there exist neighbor above us and unvisited, only add unvisited neighbors</span></span><br><span class="line">        unvisitedNeighbors.add(<span class="keyword">new</span> Integer[] &#123;i - <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; matrix.length - <span class="number">1</span> &amp;&amp; !visited[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">        unvisitedNeighbors.add(<span class="keyword">new</span> Integer[] &#123;i + <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; !visited[i][j - <span class="number">1</span>]) &#123;  <span class="comment">//if there left column neighbor and unvisited</span></span><br><span class="line">        unvisitedNeighbors.add(<span class="keyword">new</span> Integer[] &#123;i, j - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; matrix[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; !visited[i][j + <span class="number">1</span>]) &#123;  <span class="comment">//if there right column neighbor and unvisited</span></span><br><span class="line">        unvisitedNeighbors.add(<span class="keyword">new</span> Integer[] &#123;i, j + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unvisitedNeighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Youngest-Common-Ancestor-AE"><a href="#Youngest-Common-Ancestor-AE" class="headerlink" title="Youngest Common Ancestor(AE)"></a>Youngest Common Ancestor(AE)</h2><ol>
<li>Ancestor property, deal with the situation two children in the different level, equalize the two node depth check if they are same, if same return ancestor</li>
<li>else, go back together to find the same ancestor</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(D) time depth of two descendant | O(1) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AncestralTree <span class="title">getYoungestCommonAncestor</span><span class="params">(AncestoralTree topAncestor, AncestoralTree descendantOne, AncestoralTree descendantTwo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depthOne = getDescendantDepth(descendantOne, topAncestor);  <span class="comment">//use helper function to get the depth of both node</span></span><br><span class="line">    <span class="keyword">int</span> depthTwo = getDescendantDepth(descendantTwo, topAncestor);</span><br><span class="line">    <span class="keyword">if</span> (depthOne &gt; depthTwo) &#123;  <span class="comment">//first descendant is lower, bring it up</span></span><br><span class="line">        <span class="keyword">return</span> backtrackAncestralTree(descendantOne, descendantTwo, depthOne - depthTwo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> backtrackAncestralTree(descendantTwo, descendantOne, depthTwo - depthOne);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDescendantDepth</span><span class="params">(AncestralTree descendant, AncestralTree topAncestor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;  <span class="comment">//initialize deoth to 0 and update it</span></span><br><span class="line">    <span class="keyword">while</span> (descendant != topAncestor) &#123;</span><br><span class="line">        depth++;</span><br><span class="line">        descendant = descendant.ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AncestralTree <span class="title">backtrackAncestralTree</span><span class="params">(AncestralTree lowerDescendant, AncestralTree  higherDescendant, <span class="keyword">int</span> diff)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (diff &gt; <span class="number">0</span>) &#123;  <span class="comment">//bring up the lower descendant to the same level with higher descendant</span></span><br><span class="line">        lowerDescendant = lowerDescendant.ancestor;</span><br><span class="line">        diff--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (lowerDescendant != higherDescendant) &#123;  <span class="comment">//backtrack both until find the same ancestor</span></span><br><span class="line">        lowerDescendant = lowerDescendant.ancestor;</span><br><span class="line">        higherDescendant = higherDescendant.ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lowerDescendant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Rectangle-Mania-AE"><a href="#Unsolved-Rectangle-Mania-AE" class="headerlink" title="Unsolved Rectangle Mania(AE)"></a>Unsolved Rectangle Mania(AE)</h2><h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String UP = <span class="string">"up"</span>;</span><br><span class="line">    <span class="keyword">static</span> String DOWN = <span class="string">"down"</span>;</span><br><span class="line">    <span class="keyword">static</span> String LEFT = <span class="string">"left"</span>;</span><br><span class="line">    <span class="keyword">static</span> String RIGHT = <span class="string">"right"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rectangleMania</span><span class="params">(Point[] coords)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, List&lt;Point&gt;&gt;&gt; coordsTable = getCoordsTable(coords);</span><br><span class="line">        <span class="keyword">return</span> getRectangleCount(coords, coordsTable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Map&lt;String, List&lt;Point&gt;&gt;&gt; getCoordsTable(Point[] coords) &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, List&lt;Point&gt;&gt;&gt; coordsTable = <span class="keyword">new</span> HashMap&lt;String, List&lt;Point&gt;&gt;();</span><br><span class="line">        coord1Directions.put(UP, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">        coord1Directions.put(DOWN, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">        coord1Directions.put(LEFT, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">        coord1Directions.put(RIGHT, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">        <span class="keyword">for</span> (Point coord2 : coords) &#123;</span><br><span class="line">            String coords2Direction = getCoordDirection(coord1, coord2);</span><br><span class="line">            <span class="keyword">if</span> (coord1Directions.containsKey(coords2Direction)) &#123;</span><br><span class="line">                coord1Directions.get(coords2Direction).add(coord2);</span><br><span class="line">            &#125;</span><br><span class="line">            String coords1String = coordToString(coord1);</span><br><span class="line">            coordsTable.put(coord1String, coord1Directions);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coordsTable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCoordDirection</span><span class="params">(Point coord1, Point coord2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coord2.y == coord1.y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coord2.x == coord1.x) &#123;</span><br><span class="line">                <span class="keyword">return</span> RIGHT;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coord2.x &lt; coord1.x)&#123;</span><br><span class="line">                <span class="keyword">return</span> LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coord2.x == coord1.x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coord2.y &gt; coord1.y) &#123;</span><br><span class="line">                <span class="keyword">return</span> UP;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coord2.y &lt; coords1.y) &#123;</span><br><span class="line">                <span class="keyword">return</span> DOWN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRectangleCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">clockwiseCountRectangles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNextClockwiseDirection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">coordToString</span><span class="params">(Point coord)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.x = x;</span><br><span class="line">      <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-1042-Flower-Planting-With-No-Adjacent🎂"><a href="#Unsolved-1042-Flower-Planting-With-No-Adjacent🎂" class="headerlink" title="Unsolved 1042.Flower Planting With No Adjacent🎂"></a><a href="https://leetcode.com/problems/flower-planting-with-no-adjacent/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 1042.Flower Planting With No Adjacent🎂</a></h2><h2 id="Unsolved-990-Satisfiability-of-Equality-Equations🎂✨"><a href="#Unsolved-990-Satisfiability-of-Equality-Equations🎂✨" class="headerlink" title="Unsolved 990. Satisfiability of Equality Equations🎂✨"></a><a href="https://leetcode.com/problems/satisfiability-of-equality-equations/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 990. Satisfiability of Equality Equations🎂✨</a></h2><h1 id="二分图Bipartite"><a href="#二分图Bipartite" class="headerlink" title="二分图Bipartite"></a>二分图Bipartite</h1><p>如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么这个图就是二分图。</p>
<h2 id="🌕Unsolved-785-Is-Graph-Bipartite"><a href="#🌕Unsolved-785-Is-Graph-Bipartite" class="headerlink" title="🌕Unsolved 785.Is Graph Bipartite?"></a><a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener">🌕Unsolved 785.Is Graph Bipartite?</a></h2><p>Given an undirected <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p>
<p>A graph is <em>bipartite</em> if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">Output: <span class="keyword">true</span></span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like <span class="keyword">this</span>:</span><br><span class="line"><span class="number">0</span>----<span class="number">1</span></span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line"><span class="number">3</span>----<span class="number">2</span></span><br><span class="line">We can divide the vertices into two groups: &#123;<span class="number">0</span>, <span class="number">2</span>&#125; and &#123;<span class="number">1</span>, <span class="number">3</span>&#125;.</span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line">Input: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like <span class="keyword">this</span>:</span><br><span class="line"><span class="number">0</span>----<span class="number">1</span></span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line"><span class="number">3</span>----<span class="number">2</span></span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><p><code>Our goal</code> is trying to use two colors to color the graph and see if there are any adjacent nodes having the same color.<br>Initialize a color[] array for each node. Here are three states for <code>colors[]</code> array:<br><code>0: Haven&#39;t been colored yet.</code><br><code>1: Blue.</code><br><code>-1: Red.</code><br>For each node,</p>
<ol>
<li>If it hasn’t been colored, use a color to color it. Then use the other color to color all its adjacent nodes (DFS).</li>
<li>If it has been colored, check if the current color is the same as the color that is going to be used to color it. </li>
</ol>
<p>DFS Solution:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    Arrays.fill(colors, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;  <span class="comment">//This graph might be a disconnected graph. So check each unvisited node.</span></span><br><span class="line">        <span class="keyword">if</span> (colors[i] == -<span class="number">1</span> &amp;&amp; !isBipartite(i, <span class="number">0</span>, colors, graph)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span> curNode, <span class="keyword">int</span> curColor, <span class="keyword">int</span>[] colors, <span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (colors[curNode] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> colors[curNode] == curColor;</span><br><span class="line">    &#125;</span><br><span class="line">    colors[curNode] = curColor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nextNode : graph[curNode]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isBipartite(nextNode, <span class="number">1</span> - curColor, colors, graph)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS Solution:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="comment">// 0(not meet), 1(black), 2(white)</span></span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[i].length != <span class="number">0</span> &amp;&amp; visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                q.offer(i);</span><br><span class="line">                <span class="keyword">while</span>(! q.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> current = q.poll();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> c: graph[current]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (visited[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                            visited[c] = (visited[current] == <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">                            q.offer(c);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (visited[c] == visited[current]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;                        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = graph.length;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(i);</span><br><span class="line">        colors[i] = <span class="number">1</span>;   <span class="comment">// Blue: 1; Red: -1.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (colors[next] == <span class="number">0</span>) &#123;          <span class="comment">// If this node hasn't been colored;</span></span><br><span class="line">                    colors[next] = -colors[cur];  <span class="comment">// Color it with a different color;</span></span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colors[next] != -colors[cur]) &#123;   <span class="comment">// If it is colored and its color is different, return false;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。</p>
<h2 id="🌕Unsolved-721-Accounts-Merge"><a href="#🌕Unsolved-721-Accounts-Merge" class="headerlink" title="🌕Unsolved 721. Accounts Merge"></a><a href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener">🌕Unsolved 721. Accounts Merge</a></h2><p><a href="https://leetcode.com/problems/accounts-merge/discuss/109158/Java-Solution-(Build-graph-%2B-DFS-search)" target="_blank" rel="noopener">https://leetcode.com/problems/accounts-merge/discuss/109158/Java-Solution-(Build-graph-%2B-DFS-search)</a></p>
<p><a href="https://leetcode.com/problems/accounts-merge/discuss/109157/JavaC%2B%2B-Union-Find" target="_blank" rel="noopener">https://leetcode.com/problems/accounts-merge/discuss/109157/JavaC%2B%2B-Union-Find</a></p>
<h2 id="🌕128-Longest-Consecutive-Sequence✨"><a href="#🌕128-Longest-Consecutive-Sequence✨" class="headerlink" title="🌕128. Longest Consecutive Sequence✨"></a><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">🌕128. Longest Consecutive Sequence✨</a></h2><h3 id="Solution0"><a href="#Solution0" class="headerlink" title="Solution0:"></a>Solution0:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n^3) S O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">arrayContains</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentNum = num;</span><br><span class="line">            <span class="keyword">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (arrayContains(nums, currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                currentNum += <span class="number">1</span>;</span><br><span class="line">                currentStreak += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longestStreak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n) S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">        set.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.remove(num)) &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> l = num - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = num + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(set.remove(l--)) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(set.remove(r++)) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Minimize-Hamming-Distance-After-Swap-Operations🎃"><a href="#Minimize-Hamming-Distance-After-Swap-Operations🎃" class="headerlink" title="Minimize Hamming Distance After Swap Operations🎃"></a>Minimize Hamming Distance After Swap Operations🎃</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: source = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], target = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>], allowedSwaps = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: source can be transformed the following way:</span><br><span class="line">- Swap indices <span class="number">0</span> and <span class="number">1</span>: source = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">- Swap indices <span class="number">2</span> and <span class="number">3</span>: source = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">The Hamming distance of source and target is <span class="number">1</span> as they differ in <span class="number">1</span> position: index <span class="number">3</span>.</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>[] id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumHammingDistance</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] target, <span class="keyword">int</span>[][] allowedSwaps)</span> </span>&#123;</span><br><span class="line">    n = target.length;</span><br><span class="line">    id = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] a : allowedSwaps) &#123;</span><br><span class="line">        union(a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        map.putIfAbsent(getRoot(i), <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;());</span><br><span class="line">        map.get(getRoot(i)).put(source[i], map.get(getRoot(i)).getOrDefault(map.get(getRoot(i)).get(source[i])));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans= <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.get(getRoot(i)).contains(target[i])) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = getRoot(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = getRoot(q);</span><br><span class="line">    id[rootQ] = rootP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRoot(p) == getRoot(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRoot</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i != id[i]) &#123;</span><br><span class="line">        i = id[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="🌕Unsolved-684-Redundant-Connection✨"><a href="#🌕Unsolved-684-Redundant-Connection✨" class="headerlink" title="🌕Unsolved 684. Redundant Connection✨"></a><a href="https://leetcode.com/problems/redundant-connection/description/" target="_blank" rel="noopener">🌕Unsolved 684. Redundant Connection✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">Output: [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Explanation: The given undirected graph will be like <span class="keyword">this</span>:</span><br><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span> - <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>题目描述：有一系列的边连成的图，找出一条边，移除它之后该图能够成为一棵树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="keyword">int</span> N = edges.length;</span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[<span class="number">0</span>], v = e[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (uf.connect(u, v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        uf.union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    UF(<span class="keyword">int</span> N) &#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> uID = find(u);</span><br><span class="line">        <span class="keyword">int</span> vID = find(v);</span><br><span class="line">        <span class="keyword">if</span> (uID == vID) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == uID) &#123;</span><br><span class="line">                id[i] = vID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(u) == find(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-685-Redundant-Connection-II"><a href="#🌕Unsolved-685-Redundant-Connection-II" class="headerlink" title="🌕Unsolved 685. Redundant Connection II"></a><a href="https://leetcode.com/problems/redundant-connection-ii/description/" target="_blank" rel="noopener">🌕Unsolved 685. Redundant Connection II</a></h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Graph-Algorithms-One-Place-Dijkstra-Bellman-Ford-Floyd-Warshall-Prims-Kruskals-DSU"><a href="#Graph-Algorithms-One-Place-Dijkstra-Bellman-Ford-Floyd-Warshall-Prims-Kruskals-DSU" class="headerlink" title="Graph Algorithms One Place | Dijkstra | Bellman Ford | Floyd Warshall | Prims | Kruskals | DSU"></a><a href="https://leetcode.com/discuss/general-discussion/969327/graph-algorithms-one-place-dijkstra-bellman-ford-floyd-warshall-prims-kruskals-dsu" target="_blank" rel="noopener">Graph Algorithms One Place | Dijkstra | Bellman Ford | Floyd Warshall | Prims | Kruskals | DSU</a></h2><h1 id="Data-Structures-for-Coding-Interviews-in-Java"><a href="#Data-Structures-for-Coding-Interviews-in-Java" class="headerlink" title="Data Structures for Coding Interviews in Java"></a><a href="https://www.educative.io/courses/data-structures-coding-interviews-java/gxQ283421q9" target="_blank" rel="noopener">Data Structures for Coding Interviews in Java</a></h1><blockquote>
<p>A graph is a set of <strong>vertices</strong> (nodes) that are connected to each other via <strong>edges</strong> in the form of a network.</p>
<p>The structures for storing data in a graph, represented in the form of <em>Nodes</em> (1,3,7…), are also called <strong>Vertices</strong></p>
<p>A <strong>pair(x,y)</strong> is called an <strong>edge</strong>, which indicates that vertex <strong>x</strong> is connected to vertex <strong>y</strong>. An edge may contain weight/cost, showing how much cost is required to traverse from vertex <strong>x</strong> to <strong>y</strong>.</p>
</blockquote>
<h2 id="There-are-two-common-types-of-graphs"><a href="#There-are-two-common-types-of-graphs" class="headerlink" title="There are two common types of graphs:"></a>There are two common types of graphs:</h2><ol>
<li>Undirected</li>
<li>Directed</li>
</ol>
<p><strong>Degree of Vertex</strong>: Total Number of edges connected to a vertex.</p>
<p>The <strong>adjacency matrix</strong> is a two-dimensional matrix where each cell can contain a <strong>0</strong> or <strong>1</strong>. The row and column headings represent the vertices.</p>
<p>If a cell contains <strong>1</strong>, there exists an edge between the corresponding vertices, e.g., Matrix[0][1]=1<em>M<strong>a</strong>t<strong>r</strong>i**x</em>[0][1]=1 shows that an edge exists between vertex <strong>0</strong> and <strong>1</strong>.</p>
<h2 id="Implement-a-Directed-Graph-in-java-using-an-Adjacency-List"><a href="#Implement-a-Directed-Graph-in-java-using-an-Adjacency-List" class="headerlink" title="Implement a Directed Graph in java using an Adjacency List"></a>Implement a <strong>Directed Graph</strong> in java using an Adjacency List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> vertices;</span><br><span class="line">    <span class="keyword">public</span> DoublyLinkedList&lt;Integer&gt; adjacencyList[];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> vertices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertices = vertices;</span><br><span class="line">        <span class="keyword">this</span>.adjacencyList = <span class="keyword">new</span> DoublyLinkedList[vertices];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">            adjacencyList[i] = <span class="keyword">new</span> DoublyLinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source &lt; vertices &amp;&amp; destination &lt; vertices) &#123;</span><br><span class="line">            <span class="keyword">this</span>.adjacencyList[source].insertEnd(destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;Adjacency List of Directed Graph&lt;&lt;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(adjacencyList[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">"|"</span> + i + <span class="string">"| =&gt; "</span>);</span><br><span class="line"></span><br><span class="line">                DoublyLinkedList&lt;Integer&gt;.Node temp = adjacencyList[i].getHeadNode();</span><br><span class="line">                <span class="keyword">while</span> (temp != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print(<span class="string">"["</span> + temp.data + <span class="string">"] -&gt; "</span>);</span><br><span class="line">                    temp = temp.nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"|"</span> + i + <span class="string">"| =&gt; "</span>+ <span class="string">"null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"><strong>Operation</strong></th>
<th align="center"><strong>Adjacency List</strong></th>
<th align="center"><strong>Adjacency Matrix</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Add Vertex</td>
<td align="center">O(1)</td>
<td align="center">O(V^2)</td>
</tr>
<tr>
<td align="center">Remove Vertex</td>
<td align="center">O(V+E)</td>
<td align="center">O(V^2)</td>
</tr>
<tr>
<td align="center">Add Edge</td>
<td align="center">O(1)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">Remove Edge</td>
<td align="center">O(E)</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong><em>A Bipartite Graph</em></strong> is a special kind of Graph, in which the vertices can be divided into two disjoint sets <em>U</em> and <em>V</em> such that no vertex of <em>U</em> is adjacent to any other vertex in <em>U</em> and no vertex of <em>V</em> is adjacent to any other vertex in <em>V</em>. Vertices in <em>U</em> have edges that connect it to vertices in <em>V</em>.</p>
</blockquote>
<h2 id="Types-of-bipartite-graphs"><a href="#Types-of-bipartite-graphs" class="headerlink" title="Types of bipartite graphs"></a>Types of bipartite graphs</h2><p>Some other types of Bipartite graphs are listed below:</p>
<ul>
<li><strong>Complete Bipartite Graphs:</strong> A complete Bipartite graph connects each vertex from set V1 to each vertex from set V2.</li>
<li><strong>Star Graphs:</strong> A star graph is a complete bipartite graph if a single vertex belongs to one set, and all the remaining vertices belong to the other set.</li>
<li><strong>Acyclic Graphs:</strong> A graph with no cycles is called an acyclic graph.</li>
</ul>
<h2 id="Challenge1-Breadth-First-Search-or-BFS-for-a-Graph"><a href="#Challenge1-Breadth-First-Search-or-BFS-for-a-Graph" class="headerlink" title="Challenge1: Breadth First Search or BFS for a Graph"></a>Challenge1: Breadth First Search or BFS for a Graph</h2><h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>The <code>bfs()</code> function is a wrapper for the <code>bfsVisit()</code> function which actually performs the traversal on one <code>source</code> vertex at a time and outputs all vertices reachable from the <code>source</code>. The reason for using the wrapper function is to make sure we traverse all vertices even when they are not reachable from any other vertex in the graph.</p>
<p>In the <code>bfs()</code> function, we insert the vertices into the queue, starting from the <code>source</code> vertex. To keep track of the nodes that have been traversed, every node inserted into the queue is marked visited in the <code>visited</code> array.</p>
<p>The <code>result</code> string is our output variable. The value of a node is appended to <code>result</code> when it is dequeued from the queue. For each node that is dequeued, its adjacent nodes are added to the queue if they have not been visited.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckBFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bfs</span><span class="params">(Graph g)</span></span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//Checking if the graph has no vertices</span></span><br><span class="line">        <span class="keyword">if</span> (g.vertices &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertices; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//Checking whether the node is visited or not </span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) </span><br><span class="line">            &#123; </span><br><span class="line">                result = result + bfsVisit(g, i, visited); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bfsVisit</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//Create Queue for Breadth First Traversal and enqueue source in it</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;(g.vertices);</span><br><span class="line">        queue.enqueue(source);</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while queue is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current_node = queue.dequeue();</span><br><span class="line">            result += String.valueOf(current_node);</span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array, and if they are not already visited then enqueue them in the Queue</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    queue.enqueue(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>; <span class="comment">//Visit the current Node</span></span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"Graph1:"</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"BFS traversal of Graph1 : "</span> + bfs(g));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"Graph2:"</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"BFS traversal of Graph2 : "</span> + bfs(g2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to print BFS traversal from a given source vertex.</span></span><br><span class="line"><span class="comment">// BFS(int s) traverses vertices reachable from s.</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This class represents a directed graph using adjacency list</span></span><br><span class="line"><span class="comment">// representation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// No. of vertices</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">//Adjacency Lists</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    Graph(<span class="keyword">int</span> v)</span><br><span class="line">    &#123;</span><br><span class="line">        V = v;</span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i)</span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function to add an edge into the graph</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prints BFS traversal from a given source s</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Mark all the vertices as not visited(By default</span></span><br><span class="line">        <span class="comment">// set as false)</span></span><br><span class="line">        <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a queue for BFS</span></span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mark the current node as visited and enqueue it</span></span><br><span class="line">        visited[s] = <span class="keyword">true</span>;</span><br><span class="line">        queue.add(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Dequeue a vertex from queue and print it</span></span><br><span class="line">            s = queue.poll();</span><br><span class="line">            System.out.print(s+<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get all adjacent vertices of the dequeued vertex s If a adjacent has not been visited, then mark it visited and enqueue it</span></span><br><span class="line">            Iterator&lt;Integer&gt; i = adj[s].listIterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> n = i.next();</span><br><span class="line">                <span class="keyword">if</span> (!visited[n])</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[n] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method to</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Following is Breadth First Traversal "</span>+</span><br><span class="line">                           <span class="string">"(starting from vertex 2)"</span>);</span><br><span class="line"></span><br><span class="line">        g.BFS(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Challenge2-Iterative-Depth-First-Traversal-of-Graph"><a href="#🌕Challenge2-Iterative-Depth-First-Traversal-of-Graph" class="headerlink" title="🌕Challenge2: Iterative Depth First Traversal of Graph"></a>🌕Challenge2: Iterative Depth First Traversal of Graph</h2><h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckDFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dfs</span><span class="params">(Graph g)</span></span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//Checking if the graph has no vertices</span></span><br><span class="line">        <span class="keyword">if</span> (g.vertices &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertices; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//Checking whether the node is visited or not </span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) </span><br><span class="line">            &#123; </span><br><span class="line">                result = result + dfsVisit(g, i, visited); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dfsVisit</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//Create Stack(Implemented in previous lesson) for Depth First Traversal and Push source in it</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;(g.vertices);</span><br><span class="line">        stack.push(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current_node = stack.pop();</span><br><span class="line">            result += String.valueOf(current_node);</span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array, and if they are not already visited then push them in the stack</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] !=<span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    stack.push(temp.data);</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Visit the node</span></span><br><span class="line">            visited[current_node] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"Graph1:"</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"DFS traversal of Graph1 : "</span> + dfs(g));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"Graph2:"</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"DFS traversal of Graph2 : "</span> + dfs(g2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//An Iterative Java program to do DFS traversal from</span></span><br><span class="line"><span class="comment">//a given source vertex. DFS(int s) traverses vertices</span></span><br><span class="line"><span class="comment">//reachable from s.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GFG</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// This class represents a directed graph using adjacency</span></span><br><span class="line">    <span class="comment">// list representation</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V; <span class="comment">//Number of Vertices</span></span><br><span class="line">        LinkedList&lt;Integer&gt;[] adj; <span class="comment">// adjacency lists</span></span><br><span class="line">        <span class="comment">//Constructor</span></span><br><span class="line">        Graph(<span class="keyword">int</span> V)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.V = V;</span><br><span class="line">            adj = <span class="keyword">new</span> LinkedList[V];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++)</span><br><span class="line">                adj[i] = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//To add an edge to graph</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            adj[v].add(w); <span class="comment">// Add w to v’s list.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prints all not yet visited vertices reachable from s</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// Initially mark all vertices as not visited</span></span><br><span class="line">            Vector&lt;Boolean&gt; visited = <span class="keyword">new</span> Vector&lt;Boolean&gt;(V);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">                visited.add(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a stack for DFS</span></span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            stack.push(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(stack.empty() == <span class="keyword">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s = stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">// Stack may contain same vertex twice. So we need to print the popped item only if it is not visited.</span></span><br><span class="line">                <span class="keyword">if</span>(visited.get(s) == <span class="keyword">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">                    visited.set(s, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Get all adjacent vertices of the popped vertex s If a adjacent has not been visited, then push it to the stack.</span></span><br><span class="line">                Iterator&lt;Integer&gt; itr = adj[s].iterator();</span><br><span class="line">                <span class="keyword">while</span> (itr.hasNext()) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> v = itr.next();</span><br><span class="line">                    <span class="keyword">if</span>(!visited.get(v))</span><br><span class="line">                        stack.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver program to test methods of graph class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Total 5 vertices in graph</span></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Following is the Depth First Traversal"</span>);</span><br><span class="line">        g.DFS(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="⭐Challenge3-Detect-Cycle-in-a-Directed-Graph-Cycle-in-Graph-AE"><a href="#⭐Challenge3-Detect-Cycle-in-a-Directed-Graph-Cycle-in-Graph-AE" class="headerlink" title="⭐Challenge3: Detect Cycle in a Directed Graph || Cycle in Graph(AE)"></a>⭐Challenge3: Detect Cycle in a Directed Graph || Cycle in Graph(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cycleInGraph</span><span class="params">(<span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">    <span class="keyword">int</span> n = edges.length;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    buildGraph(graph, edges);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">boolean</span>[] stackFlag = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCyclic(i, graph, visited, stackFlag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCyclic</span><span class="params">(<span class="keyword">int</span> node, Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">boolean</span>[] visited, <span class="keyword">boolean</span>[] stackFlag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stackFlag[node]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[node]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    stackFlag[node] = <span class="keyword">true</span>;</span><br><span class="line">    visited[node] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.get(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCyclic(neighbor, graph, visited, stackFlag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stackFlag[node] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] e = edges[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : e) &#123;</span><br><span class="line">            graph.get(i).add(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>The solution might look confusing at first, but the logic behind it is pretty straight forward.</li>
<li>We start by using two boolean arrays, <code>visited</code> and <code>stackFlag</code>. <code>visited</code> keeps a record of all the nodes that have been traversed regardless of the recursive call. <code>stackFlag</code> keeps track of the nodes that have been traversed in the current recursion.</li>
<li>Then we apply a variation of <code>DFS</code> on each node of the graph in a recursive manner. On each call of the method <code>cyclic</code> if we encounter any node which is already in the stack, then we return <code>true</code>. Because this means that we have found a path from that node back to itself!</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckCycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">detectCycle</span><span class="params">(Graph g)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span> [num_of_vertices];</span><br><span class="line">        <span class="comment">//Holds a flag if the node is currently in Stack or not (by default- false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] stackFlag = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_of_vertices; i++)&#123;</span><br><span class="line">            <span class="comment">//Check cyclic on each node</span></span><br><span class="line">            <span class="keyword">if</span> (cyclic(g, i, visited, stackFlag))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cyclic</span><span class="params">(Graph g, <span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited, <span class="keyword">boolean</span>[] stackFlag)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case, if node is currently in stack that means we have found a cycle</span></span><br><span class="line">        <span class="keyword">if</span> (stackFlag[v])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//if it is already visited (and not in Stack) then there is no cycle</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line">        stackFlag[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check adjacency list of the node</span></span><br><span class="line">        DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.adjacencyList[v] != <span class="keyword">null</span>)</span><br><span class="line">            temp = g.adjacencyList[v].headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//run cyclic function recursively on each outgowing path</span></span><br><span class="line">            <span class="keyword">if</span> (cyclic(g, temp.data, visited, stackFlag))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//backtracking, undo the stackFlag for other dfs path</span></span><br><span class="line">        stackFlag[v] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Graph g1 = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g1.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g1.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g1.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g1.addEdge(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">        g1.printGraph();</span><br><span class="line">        System.out.println(detectCycle(g1));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(detectCycle(g2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-Detect-Cycle-in-a-Directed-Graph-using-BFS"><a href="#Solution2-Detect-Cycle-in-a-Directed-Graph-using-BFS" class="headerlink" title="Solution2: Detect Cycle in a Directed Graph using BFS"></a>Solution2: Detect Cycle in a Directed Graph using BFS</h3><p><a href="https://www.geeksforgeeks.org/detect-cycle-in-a-directed-graph-using-bfs/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/detect-cycle-in-a-directed-graph-using-bfs/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to check if there is a cycle in directed graph using BFS.</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFG</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Class to represent a graph</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V; <span class="comment">// No. of vertices</span></span><br><span class="line">        <span class="comment">//adjacency list</span></span><br><span class="line">        Vector&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Graph(<span class="keyword">int</span> V)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Constructor</span></span><br><span class="line">            <span class="keyword">this</span>.V = V;</span><br><span class="line">            <span class="keyword">this</span>.adj = <span class="keyword">new</span> Vector[V];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">                adj[i] = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// function to add an edge to graph</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            adj[u].add(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This function returns true if there is a cycle in directed graph, else returns false.</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isCycle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a vector to store indegrees of all vertices. Initialize all indegrees as 0.</span></span><br><span class="line">            <span class="keyword">int</span>[] in_degree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.V];</span><br><span class="line">            Arrays.fill(in_degree, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Traverse adjacency lists to fill indegrees of vertices. This step takes O(V+E) time</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v : adj[u])</span><br><span class="line">                    in_degree[v]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create an queue and enqueue all vertices with indegree 0</span></span><br><span class="line">            Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">                <span class="keyword">if</span> (in_degree[i] == <span class="number">0</span>)</span><br><span class="line">                    q.add(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize count of visited vertices</span></span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a vector to store result (A topological ordering of the vertices)</span></span><br><span class="line">            Vector&lt;Integer&gt; top_order = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// One by one dequeue vertices from queue and enqueue adjacents if indegree of adjacent becomes 0</span></span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Extract front of queue (or perform dequeue) and add it to topological order</span></span><br><span class="line">                <span class="keyword">int</span> u = q.poll();</span><br><span class="line">                top_order.add(u);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Iterate through all its neighbouring nodes of dequeued node u and decrease their in-degree by 1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> itr : adj[u])</span><br><span class="line">                    <span class="keyword">if</span> (--in_degree[itr] == <span class="number">0</span>)</span><br><span class="line">                        q.add(itr);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if there was a cycle</span></span><br><span class="line">            <span class="keyword">if</span> (cnt != <span class="keyword">this</span>.V)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test Code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a graph given in the above diagram</span></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.isCycle())</span><br><span class="line">            System.out.println(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cycle-detection-in-an-undirected-graph"><a href="#Cycle-detection-in-an-undirected-graph" class="headerlink" title="Cycle detection in an undirected graph"></a>Cycle detection in an undirected graph</h3><ol>
<li>Run a DFS from every unvisited node.</li>
<li>If visited node, check if it is parent or not.</li>
</ol>
<p><a href="https://www.geeksforgeeks.org/detect-cycle-undirected-graph/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/detect-cycle-undirected-graph/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true if the graph contains a cycle, else false. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">isCyclic</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Mark all the vertices as not visited and not part of recursion stack </span></span><br><span class="line">    Boolean visited[] = <span class="keyword">new</span> Boolean[V]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">        visited[i] = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the recursive helper function to detect cycle in different DFS trees </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Don't recur for u if already visited </span></span><br><span class="line">        <span class="keyword">if</span> (!visited[u]) </span><br><span class="line">            <span class="keyword">if</span> (isCyclicUtil(u, visited, -<span class="number">1</span>)) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//DFS, recursive function that uses visited[] and parent to detect cycle in subgraph reachable from vertex v.</span></span><br><span class="line"><span class="function">Boolean <span class="title">isCyclicUtil</span><span class="params">(<span class="keyword">int</span> v, Boolean visited[], <span class="keyword">int</span> parent)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Mark the current node as visited </span></span><br><span class="line">    visited[v] = <span class="keyword">true</span>; </span><br><span class="line">    Integer i; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recur for all the vertices adjacent to this vertex </span></span><br><span class="line">    Iterator&lt;Integer&gt; it = adj[v].iterator(); </span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) </span><br><span class="line">    &#123; </span><br><span class="line">        i = it.next(); </span><br><span class="line">        <span class="comment">// If an adjacent is not visited, then recur for that adjacent </span></span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (isCyclicUtil(i, visited, v)) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If an adjacent is visited and not parent of current vertex, then there is a cycle. </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != parent) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Challenge4-Find-“Mother-Vertex”-in-a-Directed-Graph"><a href="#🌕Challenge4-Find-“Mother-Vertex”-in-a-Directed-Graph" class="headerlink" title="🌕Challenge4: Find “Mother Vertex” in a Directed Graph"></a>🌕Challenge4: Find “Mother Vertex” in a Directed Graph</h2><p>like find celebrity another version</p>
<h3 id="Mother-Vertex"><a href="#Mother-Vertex" class="headerlink" title="Mother Vertex?"></a>Mother Vertex?</h3><p>A mother vertex in a graph <code>G = (v,e)</code> is a vertex v, such that all other vertices in G can be reached by a path from v.</p>
<h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckMotherVertex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMotherVertex</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// visited[] is used for DFS. Initially all are initialized as not visited</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line">        Arrays.fill(visited, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To store last finished vertex (or mother vertex)</span></span><br><span class="line">        <span class="keyword">int</span> lastV = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do a DFS traversal and find the last finished vertex</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertices; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                DFS(g, i, visited);</span><br><span class="line">                lastV = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there exist mother vertex (or vetices) in given</span></span><br><span class="line">        <span class="comment">// graph, then lastV must be one (or one of them)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now check if lastV is actually a mother vertex (or graph</span></span><br><span class="line">        <span class="comment">// has a mother vertex). We basically check if every vertex</span></span><br><span class="line">        <span class="comment">// is reachable from lastV or not.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset all values in visited[] as false and do</span></span><br><span class="line">        <span class="comment">// DFS beginning from lastV to check if all vertices are</span></span><br><span class="line">        <span class="comment">// reachable from it or not.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Double check lastV is a valid mother vertice</span></span><br><span class="line">        Arrays.fill(visited, <span class="keyword">false</span>);</span><br><span class="line">        DFS(g, lastV, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; visited.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A recursive function to print DFS starting from v</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph g, <span class="keyword">int</span> node, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        visited[node] = <span class="keyword">true</span>;</span><br><span class="line">        DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.adjacencyList[node] !=<span class="keyword">null</span>)</span><br><span class="line">            temp = g.adjacencyList[node].headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[temp.data]) &#123;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited[temp.data] = <span class="keyword">true</span>;</span><br><span class="line">                DFS(g, temp.data, visited);</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Mother Vertex is: "</span> + findMotherVertex(g));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to find a mother vertex in O(V+E) time </span></span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFG</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        adj.get(u).add(v); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// A recursive function to print DFS starting from v </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DFSUtil</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; g, <span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Mark the current node as visited and print it </span></span><br><span class="line">        visited[v] = <span class="keyword">true</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recur for all the vertices adjacent to this vertex </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : g.get(v)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (!visited[x]) </span><br><span class="line">            &#123; </span><br><span class="line">                DFSUtil(g, x, visited); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns a mother vertex if exists. Otherwise returns -1 </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">motherVertex</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt;g, <span class="keyword">int</span> V)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// visited[] is used for DFS. Initially all are initialized as not visited </span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// To store last finished vertex (or mother vertex) </span></span><br><span class="line">        <span class="keyword">int</span> mother = -<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) </span><br><span class="line">            &#123; </span><br><span class="line">                DFSUtil(g, i, visited); </span><br><span class="line">                mother = i; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there exist mother vertex (or vetices) in given graph, then v must be one (or one of them) Now check if v is actually a mother vertex (or graph has a mother vertex). </span></span><br><span class="line">        <span class="comment">// We basically check if every vertex is reachable from v or not. Reset all values in visited[] as false and do DFS beginning from v to check </span></span><br><span class="line">        <span class="comment">// if all vertices are reachable from it or not. </span></span><br><span class="line">        <span class="keyword">boolean</span>[] check = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; </span><br><span class="line">        DFSUtil(g, mother, check); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">boolean</span> val : check) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (!val) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> mother; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test code </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> V = <span class="number">7</span>; </span><br><span class="line">        <span class="keyword">int</span> E = <span class="number">8</span>; </span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            adj.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;()); </span><br><span class="line">        &#125; </span><br><span class="line">        addEdge(<span class="number">0</span>, <span class="number">1</span>,adj); </span><br><span class="line">        addEdge(<span class="number">0</span>, <span class="number">2</span>,adj); </span><br><span class="line">        addEdge(<span class="number">1</span>, <span class="number">3</span>,adj); </span><br><span class="line">        addEdge(<span class="number">4</span>, <span class="number">1</span>,adj); </span><br><span class="line">        addEdge(<span class="number">6</span>, <span class="number">4</span>,adj); </span><br><span class="line">        addEdge(<span class="number">5</span>, <span class="number">6</span>,adj); </span><br><span class="line">        addEdge(<span class="number">5</span>, <span class="number">2</span>,adj); </span><br><span class="line">        addEdge(<span class="number">6</span>, <span class="number">0</span>,adj); </span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"The mother vertex is "</span> + motherVertex(adj, V)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge5-Count-number-of-edges-in-an-undirected-graph"><a href="#Challenge5-Count-number-of-edges-in-an-undirected-graph" class="headerlink" title="Challenge5: Count number of edges in an undirected graph"></a>Challenge5: Count number of edges in an undirected graph</h2><p>Given an adjacency list representation undirected graph. Write a function to count the number of edges in the undirected graph.</p>
<p>Expected time complexity : O(V)</p>
<h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckNumEdges</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numEdges</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// For undirected graph, just sum up the size of</span></span><br><span class="line">        <span class="comment">// all the adjacency lists for each vertex and then divide it by 2.</span></span><br><span class="line">        <span class="comment">// It will give us total number of edges in the graph.</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertices; i++) &#123;</span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[i] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[i].headNode;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">9</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">        g.addEdge(<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line">        g.addEdge(<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Number of edges: "</span> + numEdges(g));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">7</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        g2.addEdge(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">6</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Number of edges: "</span> + numEdges(g2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to count number of edge in undirected graph </span></span><br><span class="line"><span class="keyword">import</span> java.io.*; </span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Adjacency list representation of graph </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> V; </span><br><span class="line">    Vector&lt;Integer&gt;[] adj; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//@SuppressWarnings("unchecked") </span></span><br><span class="line">    Graph(<span class="keyword">int</span> V) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">this</span>.V = V; </span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> Vector[V]; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">            adj[i] = <span class="keyword">new</span> Vector&lt;Integer&gt;(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// add edge to graph </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        adj[u].add(v); </span><br><span class="line">        adj[v].add(u); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns count of edge in undirected graph </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countEdges</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// traverse all vertex </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line"></span><br><span class="line">            <span class="comment">// add all edge that are linked to the current vertex </span></span><br><span class="line">            sum += adj[i].size(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// The count of edge is always even because in undirected graph every edge is connected twice between two vertices </span></span><br><span class="line">        <span class="keyword">return</span> sum / <span class="number">2</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFG</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// Test Code </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> V = <span class="number">9</span>; </span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(V); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// making above uhown graph </span></span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">7</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">7</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">8</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">5</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">5</span>); </span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line">        g.addEdge(<span class="number">5</span>, <span class="number">6</span>); </span><br><span class="line">        g.addEdge(<span class="number">6</span>, <span class="number">7</span>); </span><br><span class="line">        g.addEdge(<span class="number">6</span>, <span class="number">8</span>); </span><br><span class="line">        g.addEdge(<span class="number">7</span>, <span class="number">8</span>); </span><br><span class="line"></span><br><span class="line">        System.out.println(g.countEdges()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge6-Find-if-there-is-a-path-between-two-vertices-in-a-directed-graph"><a href="#Challenge6-Find-if-there-is-a-path-between-two-vertices-in-a-directed-graph" class="headerlink" title="Challenge6:  Find if there is a path between two vertices in a directed graph"></a>Challenge6:  Find if there is a path between two vertices in a directed graph</h2><h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckPaths</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkPath</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (source == destination)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(g.vertices);</span><br><span class="line">        stack.push(source);</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while stack is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//Pop a vertex/node from stack</span></span><br><span class="line">            <span class="keyword">int</span> current_node = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array,</span></span><br><span class="line">            <span class="comment">//and if only push unvisited adjacent vertices into stack</span></span><br><span class="line">            <span class="comment">//Before pushing into stack, check if it's the destination.</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (temp.data == destination) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g1 = <span class="keyword">new</span> Graph(<span class="number">9</span>);</span><br><span class="line">        g1.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g1.addEdge(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        g1.addEdge(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        g1.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        g1.addEdge(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">        g1.addEdge(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        g1.addEdge(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">        g1.addEdge(<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">        g1.addEdge(<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line">        g1.addEdge(<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">        g1.addEdge(<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">        g1.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Path exists: "</span> + checkPath(g1, <span class="number">0</span>, <span class="number">7</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Path exists: "</span> + checkPath(g2, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-10"><a href="#Solution2-10" class="headerlink" title="Solution2:"></a>Solution2:</h3><p><a href="https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-a-given-graph/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-a-given-graph/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to check if there is exist a path between two vertices of a graph. </span></span><br><span class="line"><span class="keyword">import</span> java.io.*; </span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList; </span><br><span class="line"></span><br><span class="line"><span class="comment">// This class represents a directed graph using adjacency list representation </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// No. of vertices </span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">//Adjacency List </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Constructor </span></span><br><span class="line">    Graph(<span class="keyword">int</span> v) </span><br><span class="line">    &#123; </span><br><span class="line">        V = v; </span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[v]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) </span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//Function to add an edge into the graph </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123; adj[v].add(w); &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//prints BFS traversal from a given source s </span></span><br><span class="line">    <span class="function">Boolean <span class="title">isReachable</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        LinkedList&lt;Integer&gt; temp; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mark all the vertices as not visited(By default set </span></span><br><span class="line">        <span class="comment">// as false) </span></span><br><span class="line">        <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a queue for BFS </span></span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(); </span><br><span class="line">        visited[s] = <span class="keyword">true</span>; </span><br><span class="line">        queue.add(s); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 'i' will be used to get all adjacent vertices of a vertex </span></span><br><span class="line">        Iterator&lt;Integer&gt; i; </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// Dequeue a vertex from queue and print it </span></span><br><span class="line">            s = queue.poll(); </span><br><span class="line">            <span class="keyword">int</span> n; </span><br><span class="line">            i = adj[s].listIterator(); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get all adjacent vertices of the dequeued vertex s If a adjacent has not been visited, then mark it visited and enqueue it </span></span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) </span><br><span class="line">            &#123; </span><br><span class="line">                n = i.next(); </span><br><span class="line"></span><br><span class="line">                <span class="comment">// If this adjacent node is the destination node, </span></span><br><span class="line">                <span class="comment">// then return true </span></span><br><span class="line">                <span class="keyword">if</span> (n == d) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// Else, continue to do BFS </span></span><br><span class="line">                <span class="keyword">if</span> (!visited[n]) </span><br><span class="line">                &#123; </span><br><span class="line">                    visited[n] = <span class="keyword">true</span>; </span><br><span class="line">                    queue.add(n); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// If BFS is complete without visited d </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test code </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Create a graph given in the above diagram </span></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">4</span>); </span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">0</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">3</span>); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">3</span>; </span><br><span class="line">        <span class="keyword">if</span> (g.isReachable(u, v)) </span><br><span class="line">            System.out.println(<span class="string">"There is a path from "</span> + u +<span class="string">" to "</span> + v); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"There is no path from "</span> + u +<span class="string">" to "</span> + v);; </span><br><span class="line"></span><br><span class="line">        u = <span class="number">3</span>; </span><br><span class="line">        v = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (g.isReachable(u, v)) </span><br><span class="line">            System.out.println(<span class="string">"There is a path from "</span> + u +<span class="string">" to "</span> + v); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"There is no path from "</span> + u +<span class="string">" to "</span> + v);; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph"><a href="#Find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph" class="headerlink" title="Find if there is a path between two vertices in an undirected graph"></a>Find if there is a path between two vertices in an undirected graph</h3><p><a href="https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ program to check if there is exist a path between</span></span><br><span class="line"><span class="comment">// two vertices of an undirected graph.</span></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This class represents an undirected graph using adjacency list representation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> V; <span class="comment">// No. of vertices</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pointer to an array containing adjacency lists</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; adj; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V); <span class="comment">// Constructor</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// function to add an edge to graph</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>; </span><br><span class="line">	<span class="function">bool <span class="title">isReachable</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> list&lt;<span class="keyword">int</span>&gt;[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w);</span><br><span class="line">	adj[w].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A BFS based function to check whether d is reachable from s.</span></span><br><span class="line">bool Graph::isReachable(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Base case</span></span><br><span class="line">	<span class="keyword">if</span> (s == d)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark all the vertices as not visited</span></span><br><span class="line">	bool* visited = <span class="keyword">new</span> bool[V];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a queue for BFS</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; queue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark the current node as visited and enqueue it</span></span><br><span class="line">	visited[s] = <span class="keyword">true</span>;</span><br><span class="line">	queue.push_back(s);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// it will be used to get all adjacent vertices of a vertex</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!queue.empty()) &#123;</span><br><span class="line">		<span class="comment">// Dequeue a vertex from queue and print it</span></span><br><span class="line">		s = queue.front();</span><br><span class="line">		queue.pop_front();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get all adjacent vertices of the dequeued vertex s</span></span><br><span class="line">		<span class="comment">// If a adjacent has not been visited, then mark it</span></span><br><span class="line">		<span class="comment">// visited and enqueue it</span></span><br><span class="line">		<span class="keyword">for</span> (i = adj[s].begin(); i != adj[s].end(); ++i) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// If this adjacent node is the destination node, </span></span><br><span class="line">			<span class="comment">// then return true</span></span><br><span class="line">			<span class="keyword">if</span> (*i == d)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Else, continue to do BFS</span></span><br><span class="line">			<span class="keyword">if</span> (!visited[*i]) &#123;</span><br><span class="line">				visited[*i] = <span class="keyword">true</span>;</span><br><span class="line">				queue.push_back(*i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If BFS is complete without visiting d</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver program to test methods of graph class</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Create a graph given in the above diagram</span></span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">1</span>, v = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (g.isReachable(u, v))</span><br><span class="line">		cout &lt;&lt; <span class="string">"\n There is a path from "</span> &lt;&lt; u &lt;&lt; <span class="string">" to "</span> &lt;&lt; v;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">"\n There is no path from "</span> &lt;&lt; u &lt;&lt; <span class="string">" to "</span> &lt;&lt; v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕⭐Challenge7-Check-if-a-Directed-graph-is-Tree-or-not"><a href="#🌕⭐Challenge7-Check-if-a-Directed-graph-is-Tree-or-not" class="headerlink" title="🌕⭐Challenge7: Check if a Directed graph is Tree or not"></a>🌕⭐Challenge7: Check if a Directed graph is Tree or not</h2><h3 id="Unsolved-261-Graph-Valid-Tree⭐"><a href="#Unsolved-261-Graph-Valid-Tree⭐" class="headerlink" title="Unsolved 261. Graph Valid Tree⭐"></a><a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="noopener">Unsolved 261. Graph Valid Tree⭐</a></h3><p>“Given <em><code>n</code></em> nodes labeled from <em><code>0</code></em> to <em><code>n-1</code></em> and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.” </p>
<p><a href="https://leetcode.com/problems/graph-valid-tree/discuss/69018/AC-Java-Union-Find-solution" target="_blank" rel="noopener">https://leetcode.com/problems/graph-valid-tree/discuss/69018/AC-Java-Union-Find-solution</a></p>
<h3 id="Solution0-1"><a href="#Solution0-1" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li><p>Using Cycle Detection</p>
</li>
<li><p>To check whether a directed graph is a tree or not, we’ll check the following :</p>
<ol>
<li>Each node (except root) has exactly one parent</li>
<li>There is no cycle in the graph.</li>
<li>The graph is connected.</li>
</ol>
</li>
<li><p>We check the first condition in <code>checkOneParent</code> method by traversing the adjacency list of the graph. If the first condition is not satisfied, we return <code>false</code> and don’t check further.</p>
<p>For a directed graph, We can use DFS to detect the next two conditions.</p>
<p>To check for cycles, we use the same <code>detectCycle</code> function that was used in <a href="https://www.educative.io/collection/page/5642554087309312/5724822843686912/5748660113506304/" target="_blank" rel="noopener">challenge <strong>3</strong></a>. If we come across any vertex that has already been visited then there is a cycle. If we do not find such an adjacent for any vertex, we say that there is no cycle.</p>
<p>Then we check for connectivity in the <code>checkConnected</code> method and traverse all the vertices on the graph to check if they have been visited from the source. If we find any vertex that is not visited, we conclude that vertex is not reachable from the source. Therefore, the graph is not connected and hence, is not a tree.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTree</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. Check for Cycle</span></span><br><span class="line">        <span class="keyword">if</span> (detectCycle(g))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. Check each node other than root has exactly one parent.</span></span><br><span class="line">        <span class="keyword">if</span> (!checkOneParent(g))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. Check for connectivity</span></span><br><span class="line">        <span class="keyword">if</span> (!checkConnected(g, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. DFS check for Cycle</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">detectCycle</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line">        <span class="comment">//Holds a flag if the node is currently in Stack or not (by default- false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] stackFlag = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_of_vertices; i++) &#123;</span><br><span class="line">            <span class="comment">//Check cyclic on each node</span></span><br><span class="line">            <span class="keyword">if</span> (cyclic(g, i, visited, stackFlag)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cyclic</span><span class="params">(Graph g, <span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited, <span class="keyword">boolean</span>[] stackFlag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if node is currently in stack that means we have found a cycle</span></span><br><span class="line">        <span class="keyword">if</span> (stackFlag[v])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if it is already visited (and not in Stack) then there is no cycle</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line">        stackFlag[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check adjacency list of the node</span></span><br><span class="line">        DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.adjacencyList[v] != <span class="keyword">null</span>)</span><br><span class="line">            temp = g.adjacencyList[v].headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//run cyclic function recursively on each outgowing path</span></span><br><span class="line">            <span class="keyword">if</span> (cyclic(g, temp.data, visited, stackFlag)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        stackFlag[v] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. Check each node other than root has exactly one parent.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkOneParent</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line">        <span class="keyword">boolean</span>[] hasOneParent = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//traverse adjacency list and mark the nodes which have a parent</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_of_vertices; i++) &#123;</span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node tmp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tmp = g.adjacencyList[i].headNode;</span><br><span class="line">                <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hasOneParent[tmp.data]) <span class="comment">//if a node has more than one parent</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;            <span class="comment">//then return false</span></span><br><span class="line">                    hasOneParent[tmp.data] = <span class="keyword">true</span>;</span><br><span class="line">                    tmp = tmp.nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//double check the root and not children node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_of_vertices; i++) &#123;</span><br><span class="line">            <span class="comment">//System.out.print(hasOneParent[i]);</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; hasOneParent[i] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// root should not have parent</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; hasOneParent[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="comment">//will be false if the node had no parent.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. Check for connectivity</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkConnected</span><span class="params">(Graph g, <span class="keyword">int</span> source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line">        <span class="keyword">int</span> vertices_reached = <span class="number">0</span>; <span class="comment">//Store vertices reachable through source</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="comment">//Make a node visited whenever you push it into stack</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create Stack(Implemented in previous section) for Depth First Traversal and Push source in it</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(num_of_vertices);</span><br><span class="line"></span><br><span class="line">        stack.push(source);</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while stack is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Pop a vertex/node from stack</span></span><br><span class="line">            <span class="keyword">int</span> current_node = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array,</span></span><br><span class="line">            <span class="comment">//and push unvisited vertices in stack and also increment vertices_reached</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    stack.push(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>;</span><br><span class="line">                    vertices_reached++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//+1 for source, and if number of vertices reachable from source are equal</span></span><br><span class="line">        <span class="comment">//to the total number of vertices in graph then return true else false.</span></span><br><span class="line">        <span class="keyword">return</span> (vertices_reached + <span class="number">1</span>) == g.vertices;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g));</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g2));</span><br><span class="line"></span><br><span class="line">        Graph g3 = <span class="keyword">new</span> Graph(<span class="number">6</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g3.addEdge(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        g3.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-1-Using-BFS-Traversal"><a href="#Solution-1-Using-BFS-Traversal" class="headerlink" title="Solution 1: Using BFS Traversal"></a>Solution 1: Using BFS Traversal</h3><ol>
<li>We maintain a count of the visited nodes in the variable <code>numberOfVisited</code>. During traversal, if an already visited vertex is encountered, we return <code>false</code> as it means that the graph fails the <strong>tree</strong> conditions. In fact, this condition also encompasses the <strong>check cyclic</strong> condition and <strong>check one parent</strong> condition from the solution given above. Hence, it removes redundancy. Finally, when the <strong>BFS</strong> loop ends, we check the <code>numberOfVisited</code> variable to see if all vertices were visited. This condition takes care of the <strong>graph is connected</strong> check that we performed previously. If the condition fails, <code>false</code> is returned. Otherwise, the function <code>isTree</code> returns <code>true</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTree</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="comment">//Make a node visited whenever you enqueue it into queue</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create Queue for Breadth First Traversal and enqueue root in it</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;(g.vertices);</span><br><span class="line">        queue.enqueue(root);</span><br><span class="line">        visited[root] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Store the number of visited nodes to check at end if all are visited</span></span><br><span class="line">        <span class="keyword">int</span> numberOfVisited = <span class="number">1</span>; <span class="comment">//root is already visited</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while queue is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current_node = queue.dequeue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array,</span></span><br><span class="line">            <span class="comment">//and if they are not already visited then enqueue them in the Queue</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    queue.enqueue(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>; <span class="comment">//Visit the current Node</span></span><br><span class="line">                    numberOfVisited++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//If all vertices are visited then return true</span></span><br><span class="line">        <span class="keyword">if</span> (numberOfVisited == g.vertices)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g));</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g2));</span><br><span class="line"></span><br><span class="line">        Graph g3 = <span class="keyword">new</span> Graph(<span class="number">6</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g3.addEdge(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        g3.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-11"><a href="#Solution2-11" class="headerlink" title="Solution2:"></a>Solution2:</h3><p><a href="https://codereview.stackexchange.com/questions/120165/check-directed-graph-is-tree-or-not" target="_blank" rel="noopener">https://codereview.stackexchange.com/questions/120165/check-directed-graph-is-tree-or-not</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTree</span><span class="params">(<span class="keyword">int</span>[][] adjMat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numVertex = adjMat.length;</span><br><span class="line">    State[] isVisited = <span class="keyword">new</span> State[numVertex];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;</span><br><span class="line">        isVisited[i] = State.UNVISITED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use BFS</span></span><br><span class="line">    Queue q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(<span class="number">0</span>);</span><br><span class="line">    isVisited[<span class="number">0</span>] = State.VISITING;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = (<span class="keyword">int</span>) q.poll();</span><br><span class="line">        <span class="keyword">if</span> (isVisited[current] == State.VISITED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isVisited[current] = State.VISITING;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adjMat[current][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isVisited[current] = State.VISITED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isVisited[i] == State.UNVISITED)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    UNVISITED, VISITING, VISITED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Check if a given undirected graph is tree or not</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Java Program to check whether a graph is tree or not </span></span><br><span class="line"><span class="keyword">import</span> java.io.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="comment">// This class represents a directed graph using adjacency list representation </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// No. of vertices </span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">//Adjacency List </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor </span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) </span><br><span class="line">    Graph(<span class="keyword">int</span> v) </span><br><span class="line">    &#123; </span><br><span class="line">        V = v; </span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[V]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) </span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function to add an edge into the graph </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        adj[v].add(w); </span><br><span class="line">        adj[w].add(v); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// A recursive function that uses visited[] and parent to detect cycle in subgraph reachable from vertex v. </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCyclicUtil</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">boolean</span> visited[], <span class="keyword">int</span> parent)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Mark the current node as visited </span></span><br><span class="line">        visited[v] = <span class="keyword">true</span>; </span><br><span class="line">        Integer i; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recur for all the vertices adjacent to this vertex </span></span><br><span class="line">        Iterator&lt;Integer&gt; it = adj[v].iterator(); </span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) </span><br><span class="line">        &#123; </span><br><span class="line">            i = it.next(); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// If an adjacent is not visited, then recur for </span></span><br><span class="line">            <span class="comment">// that adjacent </span></span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (isCyclicUtil(i, visited, v)) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// If an adjacent is visited and not parent of </span></span><br><span class="line">            <span class="comment">// current vertex, then there is a cycle. </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i != parent) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true if the graph is a tree, else false. </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTree</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Mark all the vertices as not visited and not part </span></span><br><span class="line">        <span class="comment">// of recursion stack </span></span><br><span class="line">        <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">            visited[i] = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// The call to isCyclicUtil serves multiple purposes </span></span><br><span class="line">        <span class="comment">// It returns true if graph reachable from vertex 0 </span></span><br><span class="line">        <span class="comment">// is cyclcic. It also marks all vertices reachable </span></span><br><span class="line">        <span class="comment">// from 0. </span></span><br><span class="line">        <span class="keyword">if</span> (isCyclicUtil(<span class="number">0</span>, visited, -<span class="number">1</span>)) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find a vertex which is not reachable from 0 </span></span><br><span class="line">        <span class="comment">// (not marked by isCyclicUtil(), then we return false </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) </span><br><span class="line">            <span class="keyword">if</span> (!visited[u]) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test code </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Create a graph given in the above diagram </span></span><br><span class="line">        Graph g1 = <span class="keyword">new</span> Graph(<span class="number">5</span>); </span><br><span class="line">        g1.addEdge(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">        g1.addEdge(<span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">        g1.addEdge(<span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line">        g1.addEdge(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">        <span class="keyword">if</span> (g1.isTree()) </span><br><span class="line">            System.out.println(<span class="string">"Graph is Tree"</span>); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Graph is not Tree"</span>); </span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">5</span>); </span><br><span class="line">        g2.addEdge(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">        g2.addEdge(<span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">        g2.addEdge(<span class="number">2</span>, <span class="number">1</span>); </span><br><span class="line">        g2.addEdge(<span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line">        g2.addEdge(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g2.isTree()) </span><br><span class="line">            System.out.println(<span class="string">"Graph is Tree"</span>); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Graph is not Tree"</span>); </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Challenge-8-Find-Length-of-Shortest-Path-between-Two-Vertices"><a href="#🌕Challenge-8-Find-Length-of-Shortest-Path-between-Two-Vertices" class="headerlink" title="🌕Challenge 8: Find Length of Shortest Path between Two Vertices"></a>🌕Challenge 8: Find Length of Shortest Path between Two Vertices</h2><h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>BFS Queue</p>
</li>
<li><p>Once again, Breadth First Search comes to the rescue. The <code>visited</code> list must be familiar to you by now. The crux of this algorithm, however, lies in the <code>distance</code> list. For each node, the indexed value in the <code>distance</code> shows the node’s distance from the <code>source</code> in terms of the number of edges.</p>
<p>The rest is a simple BFS traversal, where the <code>distance</code> is incremented by 1 each time.</p>
<p>We are guaranteed to find the shortest distance to <code>destination</code>, once it has already been visited through the longer path and consequently marked because it won’t be visited the same way again.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckMin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source == destination)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="comment">//Make a node visited whenever you enqueue it into queue</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//For keeping track of distance of current_node from source</span></span><br><span class="line">        <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create Queue for Breadth First Traversal and enqueue source in it</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;Integer&gt;(num_of_vertices);</span><br><span class="line"></span><br><span class="line">        queue.enqueue(source);</span><br><span class="line">        distance[source] = <span class="number">0</span>;</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while queue is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current_node = queue.dequeue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array,</span></span><br><span class="line">            <span class="comment">//and if they are not already visited then enqueue them in the Queue</span></span><br><span class="line">            <span class="comment">//and also update their distance from source by adding 1 in current_nodes's distance</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    queue.enqueue(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>;</span><br><span class="line">                    distance[temp.data] = distance[current_node] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.data == destination) &#123;</span><br><span class="line">                    <span class="keyword">return</span> distance[destination];</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Graph g=<span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">3</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">4</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(findMin(g, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-9-Remove-Edge-from-a-Directed-Graph"><a href="#Challenge-9-Remove-Edge-from-a-Directed-Graph" class="headerlink" title="Challenge 9: Remove Edge from a Directed Graph"></a>Challenge 9: Remove Edge from a Directed Graph</h2><h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>This is a fairly simple challenge. Since our vertices are stored in the <code>adjacencyList</code>, we access the linked list at <code>source</code> index. Then we call the <code>deleteByValue</code> function and pass the value of <code>destination</code> vertex.</li>
<li>O(E)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveEdgeSolution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        g.adjacencyList[source].deleteByValue(destination);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">3</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">4</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Before:"</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line"></span><br><span class="line">        removeEdge(g, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"After:"</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AlgoTogether"><a href="#AlgoTogether" class="headerlink" title="AlgoTogether"></a>AlgoTogether</h1><h2 id="Problems-Required"><a href="#Problems-Required" class="headerlink" title="Problems (Required)"></a>Problems (Required)</h2><ol>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=4657dca274&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=a3bc7942d1&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=7d721a5def&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=8e656496df&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/pacific-atlantic-water-flow/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=f619dc7a12&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-ii/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=af9df8fef6&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/reconstruct-itinerary/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=1a339efa75&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/shortest-path-in-binary-matrix/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=d6489d091c&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/sliding-puzzle/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=4577b2098f&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/snakes-and-ladders/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=77c3194d5c&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/surrounded-regions/</a></li>
</ol>
<h2 id="Problems-Options"><a href="#Problems-Options" class="headerlink" title="Problems (Options)"></a>Problems (Options)</h2><ol>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=75f57ca10c&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/cat-and-mouse/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=22fcaca910&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/clone-graph/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=45fe4f3478&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game-iv/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=e54e525e1e&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=b20bb72cb8&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/</a></li>
</ol>
<h1 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Given an array of n distinct elements. Find the minimum number of swaps required to sort the array in strictly increasing order.</span><br><span class="line"> </span><br><span class="line"> Problem: n different ele, targte -&gt; minimum number of swaps to make it strictly increasing order.</span><br><span class="line">   </span><br><span class="line"> nums &#x3D; &#123;2, 8, 5, 4&#125;</span><br><span class="line">Output: 1</span><br><span class="line"> &#123;2, 8, 5, 4&#125;</span><br><span class="line"></span><br><span class="line">  2-0</span><br><span class="line">  8-1</span><br><span class="line">  5-2</span><br><span class="line">  4-3</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">&#123;2, 8, 5, 4, 9&#125;</span><br><span class="line"></span><br><span class="line">2,4,5,8,9</span><br><span class="line">   ^   ^  ^</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   ^     </span><br><span class="line">Timecomplexity: O(nlogn)</span><br><span class="line">   </span><br><span class="line">Usually way: sorting algo</span><br><span class="line"></span><br><span class="line">sort array....</span><br><span class="line">  compare this sorted array with current array.........</span><br><span class="line">  </span><br><span class="line">class FindTheMinimumSwaoNum &#123;</span><br><span class="line">  public int findTheNumsOfSwaps(int[] array) &#123;</span><br><span class="line">    &#x2F;&#x2F;create a copy of this array -- unsorted</span><br><span class="line">    &#x2F;&#x2F; sort that copied array --- sorted</span><br><span class="line">    &#x2F;&#x2F;start loop till size of array</span><br><span class="line">    &#x2F;&#x2F;compare sorted array element with unsarted array element</span><br><span class="line">    &#x2F;&#x2F;check for equality -&gt; swap thm</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;minimum-number-swaps-required-sort-array&#x2F;</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;clone-graph&#x2F;</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;must-coding-questions-company-wise&#x2F;#amazon</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;practice.geeksforgeeks.org&#x2F;explore&#x2F;?company%5B%5D&#x3D;Amazon&amp;problemType&#x3D;functional&amp;page&#x3D;1&amp;sortBy&#x3D;submissions&amp;company%5B%5D&#x3D;Amazon</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;amazon-interview-preparation&#x2F;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/17/Sorting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/Sorting/" class="post-title-link" itemprop="url">Sorting</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 12:59:11" itemprop="dateCreated datePublished" datetime="2020-09-17T12:59:11+09:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-13 11:14:53" itemprop="dateModified" datetime="2021-03-13T11:14:53+09:00">2021-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pattern-Merge-Intervals"><a href="#Pattern-Merge-Intervals" class="headerlink" title="Pattern : Merge Intervals"></a>Pattern : Merge Intervals</h1><h2 id="🌕Merge-Intervals-medium-⭐"><a href="#🌕Merge-Intervals-medium-⭐" class="headerlink" title="🌕Merge Intervals (medium)⭐"></a>🌕Merge Intervals (medium)⭐</h2><ol>
<li>The time complexity of the above algorithm is O(N * logN)<em>O</em>(<em>N</em>∗<em>l<strong>o</strong>g**N</em>), where ‘N’ is the total number of intervals. We are iterating the intervals only once which will take O(N)<em>O</em>(<em>N</em>), in the beginning though, since we need to sort the intervals, our algorithm will take O(N * logN)<em>O</em>(<em>N</em>∗<em>l<strong>o</strong>g**N</em>).</li>
<li>The space complexity of the above algorithm will be O(N)<em>O</em>(<em>N</em>) as we need to return a list containing all the merged intervals. We will also need O(N)<em>O</em>(<em>N</em>) space for sorting. For Java, depending on its version, <code>Collection.sort()</code> either uses <a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">Merge sort</a> or <a href="https://en.wikipedia.org/wiki/Timsort" target="_blank" rel="noopener">Timsort</a>, and both these algorithms need O(N)<em>O</em>(<em>N</em>) space. Overall, our algorithm has a space complexity of O(N)<em>O</em>(<em>N</em>)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (intervals.size() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the intervals by start time</span></span><br><span class="line">    Collections.sort(intervals, (a, b) -&gt; Integer.compare(a.start, b.start));</span><br><span class="line"></span><br><span class="line">    List&lt;Interval&gt; mergedIntervals = <span class="keyword">new</span> LinkedList&lt;Interval&gt;();</span><br><span class="line">    Iterator&lt;Interval&gt; intervalItr = intervals.iterator();</span><br><span class="line">    Interval interval = intervalItr.next();</span><br><span class="line">    <span class="keyword">int</span> start = interval.start;</span><br><span class="line">    <span class="keyword">int</span> end = interval.end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (intervalItr.hasNext()) &#123;</span><br><span class="line">        interval = intervalItr.next();</span><br><span class="line">        <span class="keyword">if</span> (interval.start &lt;= end) &#123; <span class="comment">// overlapping intervals, adjust the 'end'</span></span><br><span class="line">            end = Math.max(interval.end, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// non-overlapping interval, add the previous interval and reset</span></span><br><span class="line">            mergedIntervals.add(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">            start = interval.start;</span><br><span class="line">            end = interval.end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// add the last interval</span></span><br><span class="line">    mergedIntervals.add(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mergedIntervals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="56-Merge-Intervals⭐"><a href="#56-Merge-Intervals⭐" class="headerlink" title="56. Merge Intervals⭐"></a><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">56. Merge Intervals⭐</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">Explanation: Since intervals [<span class="number">1</span>,<span class="number">3</span>] and [<span class="number">2</span>,<span class="number">6</span>] overlaps, merge them into [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>

<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><a href="https://leetcode.com/problems/merge-intervals/discuss/21222/A-simple-Java-solution" target="_blank" rel="noopener">explanation</a></li>
<li>The idea is to sort the intervals by their starting points. Then, we take the first interval and compare its end with the next intervals starts. As long as they overlap, we update the end to be the max end of the overlapping intervals. Once we find a non overlapping interval, we can add the previous “extended” interval and start over.</li>
<li>Sorting takes O(n log(n)) and merging the intervals takes O(n). So, the resulting algorithm takes O(n log(n)).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span> || intervals[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// Sort by ascending starting point</span></span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] cur = intervals[<span class="number">0</span>];</span><br><span class="line">    ans.add(cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">        <span class="comment">// Overlapping intervals, move the end if needed</span></span><br><span class="line">        <span class="keyword">if</span> (cur[<span class="number">1</span>] &gt;= interval[<span class="number">0</span>]) &#123;</span><br><span class="line">            cur[<span class="number">1</span>] = Math.max(cur[<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// Disjoint intervals, add the new interval to the list</span></span><br><span class="line">            cur = interval;</span><br><span class="line">            ans.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Insert-Interval-medium-✨"><a href="#Insert-Interval-medium-✨" class="headerlink" title="Insert Interval (medium)✨"></a>Insert Interval (medium)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(newInterval);</span><br><span class="line"></span><br><span class="line">    List&lt;Interval&gt; mergedIntervals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// skip (and add to output) all intervals that come before the 'newInterval'</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.size() &amp;&amp; intervals.get(i).end &lt; newInterval.start)</span><br><span class="line">        mergedIntervals.add(intervals.get(i++));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge all intervals that overlap with 'newInterval'</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.size() &amp;&amp; intervals.get(i).start &lt;= newInterval.end) &#123;</span><br><span class="line">        newInterval.start = Math.min(intervals.get(i).start, newInterval.start);</span><br><span class="line">        newInterval.end = Math.max(intervals.get(i).end, newInterval.end);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert the newInterval</span></span><br><span class="line">    mergedIntervals.add(newInterval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add all the remaining intervals to the output</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; intervals.size())</span><br><span class="line">        mergedIntervals.add(intervals.get(i++));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mergedIntervals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="57-Insert-Interval✨"><a href="#57-Insert-Interval✨" class="headerlink" title="57. Insert Interval✨"></a><a href="https://leetcode.com/problems/insert-interval/" target="_blank" rel="noopener">57. Insert Interval✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">9</span>]], newInterval = [<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">Input: intervals = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">12</span>,<span class="number">16</span>]], newInterval = [<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">10</span>],[<span class="number">12</span>,<span class="number">16</span>]]</span><br><span class="line">Explanation: Because the <span class="keyword">new</span> interval [<span class="number">4</span>,<span class="number">8</span>] overlaps with [<span class="number">3</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">10</span>].</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || newInterval == <span class="keyword">null</span>) <span class="keyword">return</span> intervals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//skip all non overlap intervals</span></span><br><span class="line">    <span class="keyword">while</span>(idx &lt; intervals.length &amp;&amp; intervals[idx][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]) &#123;</span><br><span class="line">        ans.add(intervals[idx]);</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//merge the overlapping intervels</span></span><br><span class="line">    <span class="keyword">while</span>(idx &lt; intervals.length &amp;&amp; intervals[idx][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">        newInterval[<span class="number">0</span>] = Math.min(newInterval[<span class="number">0</span>], intervals[idx][<span class="number">0</span>]);</span><br><span class="line">        newInterval[<span class="number">1</span>] = Math.max(newInterval[<span class="number">1</span>], intervals[idx][<span class="number">1</span>]);</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.add(newInterval);</span><br><span class="line">    <span class="comment">//add the remain part</span></span><br><span class="line">    <span class="keyword">while</span>(idx &lt; intervals.length) &#123;</span><br><span class="line">        ans.add(intervals[idx]);</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Intervals-Intersection-medium-✨"><a href="#🌕Intervals-Intersection-medium-✨" class="headerlink" title="🌕Intervals Intersection (medium)✨"></a>🌕Intervals Intersection (medium)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Interval[] merge(Interval[] arr1, Interval[] arr2) &#123;</span><br><span class="line">    List&lt;Interval&gt; ans = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">        <span class="comment">// check if the interval arr[i] intersects with arr2[j]</span></span><br><span class="line">        <span class="comment">// check if one of the interval's start time lies within the other interval</span></span><br><span class="line">        <span class="keyword">int</span> left = Math.max(arr1[i].start, arr2[j].start);</span><br><span class="line">        <span class="keyword">int</span> right = Math.min(arr1[i].end, arr2[j].end);</span><br><span class="line">        <span class="keyword">if</span> (right &gt;= left) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> Interval(left, right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// move next from the interval which is finishing first</span></span><br><span class="line">        <span class="keyword">if</span> (arr1[i].end &lt; arr2[j].end)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> Interval[ans.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="986-Interval-List-Intersections✨"><a href="#986-Interval-List-Intersections✨" class="headerlink" title="986. Interval List Intersections✨"></a><a href="https://leetcode.com/problems/interval-list-intersections/" target="_blank" rel="noopener">986. Interval List Intersections✨</a></h3><p><img src="https://assets.leetcode.com/uploads/2019/01/30/interval1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">10</span>],[<span class="number">13</span>,<span class="number">23</span>],[<span class="number">24</span>,<span class="number">25</span>]], B = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">12</span>],[<span class="number">15</span>,<span class="number">24</span>],[<span class="number">25</span>,<span class="number">26</span>]]</span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">23</span>],[<span class="number">24</span>,<span class="number">24</span>],[<span class="number">25</span>,<span class="number">25</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.length == <span class="number">0</span> || B == <span class="keyword">null</span> || B.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; A.length &amp;&amp; j &lt; B.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = Math.max(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> end = Math.min(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// find the overlap... if there is any...</span></span><br><span class="line">        <span class="keyword">if</span> (end &gt;= start) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//update the pointer with smaller end value...</span></span><br><span class="line">        <span class="keyword">if</span> (A[i][<span class="number">1</span>] == end) i++;</span><br><span class="line">        <span class="keyword">if</span> (B[j][<span class="number">1</span>] == end) j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        int[][] res = new int[ans.size()][2];</span></span><br><span class="line"><span class="comment">        for (int k = 0; k &lt; ans.size(); k++) &#123;</span></span><br><span class="line"><span class="comment">            res[k] = ans.get(k);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return res;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Meeting-Rooms-amp-amp-Conflicting-Appointments-medium-✨"><a href="#Meeting-Rooms-amp-amp-Conflicting-Appointments-medium-✨" class="headerlink" title="Meeting Rooms &amp;&amp; Conflicting Appointments (medium)✨"></a>Meeting Rooms &amp;&amp; Conflicting Appointments (medium)✨</h2><p>Given an array of intervals representing ‘N’ appointments, find out if a person can <strong>attend all the appointments</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Appointments: [[<span class="number">1</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">5</span>], [<span class="number">7</span>,<span class="number">9</span>]]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation: Since [<span class="number">1</span>,<span class="number">4</span>] and [<span class="number">2</span>,<span class="number">5</span>] overlap, a person cannot attend both of these appointments.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canAttendAllAppointments</span><span class="params">(Interval[] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sort the intervals by start time</span></span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a.start, b.start));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find any overlapping appointment</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i].start &lt; intervals[i - <span class="number">1</span>].end) &#123;</span><br><span class="line">            <span class="comment">// please note the comparison above, it is "&lt;" and not "&lt;="</span></span><br><span class="line">            <span class="comment">// while merging we needed "&lt;=" comparison, as we will be merging the two</span></span><br><span class="line">            <span class="comment">// intervals having condition "intervals[i].start == intervals[i - 1].end" but</span></span><br><span class="line">            <span class="comment">// such intervals don't represent conflicting appointments as one starts right</span></span><br><span class="line">            <span class="comment">// after the other</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="252-Meeting-Rooms✨"><a href="#252-Meeting-Rooms✨" class="headerlink" title="252. Meeting Rooms✨"></a><a href="https://leetcode.com/problems/meeting-rooms/" target="_blank" rel="noopener">252. Meeting Rooms✨</a></h3><h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAttendMeetings</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAttendMeetings</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</span><br><span class="line">    <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        start[i] = intervals[i][<span class="number">0</span>];</span><br><span class="line">        end[i] = intervals[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(start);</span><br><span class="line">    Arrays.sort(end);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(start[i + <span class="number">1</span>] &lt; end[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Meeting-Rooms-II-amp-amp-Problem-Challenge-1-Minimum-Meeting-Rooms-hard-✨"><a href="#Meeting-Rooms-II-amp-amp-Problem-Challenge-1-Minimum-Meeting-Rooms-hard-✨" class="headerlink" title="Meeting Rooms II &amp;&amp; Problem Challenge 1 Minimum Meeting Rooms (hard)✨"></a>Meeting Rooms II &amp;&amp; Problem Challenge 1 Minimum Meeting Rooms (hard)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMinimumMeetingRooms</span><span class="params">(List&lt;Meeting&gt; meetings)</span> </span>&#123;</span><br><span class="line">    .<span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (meetings == <span class="keyword">null</span> || meetings.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the meetings by start time</span></span><br><span class="line">    Collections.sort(meetings, (a, b) -&gt; Integer.compare(a.start, b.start));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minRooms = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;Meeting&gt; minHeap = </span><br><span class="line">        <span class="keyword">new</span> PriorityQueue&lt;&gt;(meetings.size(), (a, b) -&gt; Integer.compare(a.end, b.end));</span><br><span class="line">    <span class="keyword">for</span> (Meeting meeting : meetings) &#123;</span><br><span class="line">        <span class="comment">// remove all meetings that have ended</span></span><br><span class="line">        <span class="keyword">while</span> (!minHeap.isEmpty() &amp;&amp; meeting.start &gt;= minHeap.peek().end)</span><br><span class="line">            minHeap.poll();</span><br><span class="line">        <span class="comment">// add the current meeting into the minHeap</span></span><br><span class="line">        minHeap.offer(meeting);</span><br><span class="line">        <span class="comment">// all active meeting are in the minHeap, so we need rooms for all of them.</span></span><br><span class="line">        minRooms = Math.max(minRooms, minHeap.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minRooms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="253-Meeting-Rooms-II✨"><a href="#253-Meeting-Rooms-II✨" class="headerlink" title="253. Meeting Rooms II✨"></a><a href="https://leetcode.com/problems/meeting-rooms-ii/" target="_blank" rel="noopener">253. Meeting Rooms II✨</a></h3><p><img src="https://leetcode.com/problems/meeting-rooms-ii/Figures/253/253_Meeting_Rooms_II_Diag_1.png" alt=""></p>
<p><img src="https://leetcode.com/problems/meeting-rooms-ii/Figures/253/253_Meeting_Rooms_II_Diag_2.png" alt=""></p>
<h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Priority Queues</li>
<li>Sort the given meetings by their <code>start time</code>.</li>
<li>Initialize a new <code>min-heap</code> and add the first meeting’s ending time to the heap. We simply need to keep track of the ending times as that tells us when a meeting room will get free.</li>
<li>For every meeting room check if the minimum element of the heap i.e. the room at the top of the heap is free or not.</li>
<li>If the room is free, then we extract the topmost element and add it back with the ending time of the current meeting we are processing.</li>
<li>If not, then we allocate a new room and add it to the heap.</li>
<li>After processing all the meetings, the size of the heap will tell us the number of rooms allocated. This will be the minimum number of rooms needed to accommodate all the meetings.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sort meeting by start time</span></span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    heap.add(intervals[<span class="number">0</span>]);  <span class="comment">//add the earliest start meeting</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] current = intervals[i];</span><br><span class="line">        <span class="keyword">int</span>[] earliest = heap.poll();</span><br><span class="line">        <span class="keyword">if</span> (current[<span class="number">0</span>] &gt;= earliest[<span class="number">1</span>]) &#123;  <span class="comment">//next meeting start later than earliest one</span></span><br><span class="line">            earliest[<span class="number">1</span>] = current[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            heap.add(current);</span><br><span class="line">        &#125;</span><br><span class="line">        heap.add(earliest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort the intervals by start time</span></span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval a, Interval b)</span> </span>&#123; <span class="keyword">return</span> a.start - b.start; &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use a min heap to track the minimum end time of merged intervals</span></span><br><span class="line">    PriorityQueue&lt;Interval&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Interval&gt;(intervals.length, <span class="keyword">new</span> Comparator&lt;Interval&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval a, Interval b)</span> </span>&#123; <span class="keyword">return</span> a.end - b.end; &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start with the first meeting, put it to a meeting room</span></span><br><span class="line">    heap.offer(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="comment">// get the meeting room that finishes earliest</span></span><br><span class="line">        Interval interval = heap.poll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (intervals[i].start &gt;= interval.end) &#123;</span><br><span class="line">            <span class="comment">// if the current meeting starts right after </span></span><br><span class="line">            <span class="comment">// there's no need for a new room, merge the interval</span></span><br><span class="line">            interval.end = intervals[i].end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// otherwise, this meeting needs a new room</span></span><br><span class="line">            heap.offer(intervals[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't forget to put the meeting room back</span></span><br><span class="line">        heap.offer(interval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> heap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Problem-Challenge-2-amp-amp-Maximum-CPU-Load-hard"><a href="#🌕Unsolved-Problem-Challenge-2-amp-amp-Maximum-CPU-Load-hard" class="headerlink" title="🌕Unsolved Problem Challenge 2 &amp;&amp; Maximum CPU Load (hard)"></a>🌕Unsolved Problem Challenge 2 &amp;&amp; Maximum CPU Load (hard)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaxCPULoad</span><span class="params">(List&lt;Job&gt; jobs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sort the jobs by start time</span></span><br><span class="line">    Collections.sort(jobs, (a, b) -&gt; Integer.compare(a.start, b.start));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxCPULoad = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currentCPULoad = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;Job&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(jobs.size(), (a, b) -&gt; Integer.compare(a.end, b.end));</span><br><span class="line">    <span class="keyword">for</span> (Job job : jobs) &#123;</span><br><span class="line">        <span class="comment">// remove all jobs that have ended</span></span><br><span class="line">        <span class="keyword">while</span> (!minHeap.isEmpty() &amp;&amp; job.start &gt; minHeap.peek().end)</span><br><span class="line">            currentCPULoad -= minHeap.poll().cpuLoad;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the current job into the minHeap</span></span><br><span class="line">        minHeap.offer(job);</span><br><span class="line">        currentCPULoad += job.cpuLoad;</span><br><span class="line">        maxCPULoad = Math.max(maxCPULoad, currentCPULoad);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCPULoad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Challenge-3-Employee-Free-Time-hard"><a href="#🌕Unsolved-Challenge-3-Employee-Free-Time-hard" class="headerlink" title="🌕Unsolved Challenge 3 Employee Free Time (hard)"></a>🌕Unsolved Challenge 3 Employee Free Time (hard)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Interval&gt; <span class="title">findEmployeeFreeTime</span><span class="params">(List&lt;List&lt;Interval&gt;&gt; schedule)</span> </span>&#123;</span><br><span class="line">    List&lt;Interval&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// PriorityQueue to store one interval from each employee</span></span><br><span class="line">    PriorityQueue&lt;EmployeeInterval&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (a, b) -&gt; Integer.compare(a.interval.start, b.interval.start));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert the first interval of each employee to the queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; schedule.size(); i++)</span><br><span class="line">        minHeap.offer(<span class="keyword">new</span> EmployeeInterval(schedule.get(i).get(<span class="number">0</span>), i, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Interval previousInterval = minHeap.peek().interval;</span><br><span class="line">    <span class="keyword">while</span> (!minHeap.isEmpty()) &#123;</span><br><span class="line">        EmployeeInterval queueTop = minHeap.poll();</span><br><span class="line">        <span class="comment">// if previousInterval is not overlapping with the next interval, insert a free interval</span></span><br><span class="line">        <span class="keyword">if</span> (previousInterval.end &lt; queueTop.interval.start) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> Interval(previousInterval.end, queueTop.interval.start));</span><br><span class="line">            previousInterval = queueTop.interval;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// overlapping intervals, update the previousInterval if needed</span></span><br><span class="line">            <span class="keyword">if</span> (previousInterval.end &lt; queueTop.interval.end)</span><br><span class="line">                previousInterval = queueTop.interval;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if there are more intervals available for the same employee, add their next interval</span></span><br><span class="line">        List&lt;Interval&gt; employeeSchedule = schedule.get(queueTop.employeeIndex);</span><br><span class="line">        <span class="keyword">if</span> (employeeSchedule.size() &gt; queueTop.intervalIndex + <span class="number">1</span>) &#123;</span><br><span class="line">            minHeap.offer(<span class="keyword">new</span> EmployeeInterval(employeeSchedule.get(queueTop.intervalIndex + <span class="number">1</span>), queueTop.employeeIndex, queueTop.intervalIndex + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pattern-Two-Heaps"><a href="#Pattern-Two-Heaps" class="headerlink" title="Pattern: Two Heaps"></a>Pattern: Two Heaps</h1><h2 id="🌕Find-the-Median-of-a-Number-Stream-medium-⭐"><a href="#🌕Find-the-Median-of-a-Number-Stream-medium-⭐" class="headerlink" title="🌕Find the Median of a Number Stream (medium)⭐"></a>🌕Find the Median of a Number Stream (medium)⭐</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianOfAStream</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap; <span class="comment">//containing first half of numbers</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap; <span class="comment">//containing second half of numbers</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianOfAStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a - b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.isEmpty() || maxHeap.peek() &gt;= num)</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minHeap.add(num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// either both the heaps will have equal number of elements or max-heap will have one </span></span><br><span class="line">        <span class="comment">// more element than the min-heap</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() &gt; minHeap.size() + <span class="number">1</span>)</span><br><span class="line">            minHeap.add(maxHeap.poll());</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (maxHeap.size() &lt; minHeap.size())</span><br><span class="line">            maxHeap.add(minHeap.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == minHeap.size()) &#123;</span><br><span class="line">            <span class="comment">// we have even number of elements, take the average of middle two elements</span></span><br><span class="line">            <span class="keyword">return</span> maxHeap.peek() / <span class="number">2.0</span> + minHeap.peek() / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// because max-heap will have one more element than the min-heap</span></span><br><span class="line">        <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="295-Find-Median-from-Data-Stream⭐"><a href="#295-Find-Median-from-Data-Stream⭐" class="headerlink" title="295. Find Median from Data Stream⭐"></a><a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. Find Median from Data Stream⭐</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In java, we can implement max heap in this neat way:</span><br><span class="line">Queue&lt;Integer&gt; pq &#x3D; new PriorityQueue&lt;&gt;((a, b) -&gt; (b - a));</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>I keep two heaps (or priority queues):</p>
<ul>
<li>Max-heap <code>small</code> has the smaller half of the numbers.</li>
<li>Min-heap <code>large</code> has the larger half of the numbers.</li>
</ul>
<p>This gives me direct access to the one or two middle values (they’re the tops of the heaps), so getting the median takes O(1) time. And adding a number takes O(log n) time.</p>
</li>
<li><p>The invariant of the algorithm is two heaps, small and large, each represent half of the current list. The length of smaller half is kept to be n / 2 at all time and the length of the larger half is either n / 2 or n / 2 + 1 depend on n’s parity.</p>
</li>
<li><p>This way we only need to peek the two heaps’ top number to calculate median.</p>
<p>Any time before we add a new number, there are two scenarios, (total n numbers, k = n / 2):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1) length of (small, large) &#x3D;&#x3D; (k, k)</span><br><span class="line">(2) length of (small, large) &#x3D;&#x3D; (k, k + 1)</span><br></pre></td></tr></table></figure>

<p>After adding the number, total (n + 1) numbers, they will become:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1) length of (small, large) &#x3D;&#x3D; (k, k + 1)</span><br><span class="line">(2) length of (small, large) &#x3D;&#x3D; (k + 1, k + 1)</span><br></pre></td></tr></table></figure>

<p>Here we take the first scenario for example, we know the large will gain one more item and small will remain the same size, but we cannot just push the item into large. </p>
<p>What we should do is we push the new number into small and pop the maximum item from small then push it into large (all the pop and push here are heappop and heappush). </p>
<p>By doing this kind of operations for the two scenarios we can keep our invariant.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> even = <span class="keyword">true</span>;</span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (b - a));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (even) &#123;</span><br><span class="line">        minHeap.add(num);</span><br><span class="line">        maxHeap.add(minHeap.poll());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        maxHeap.add(num);</span><br><span class="line">        minHeap.add(maxHeap.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    even = !even;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (even) &#123;</span><br><span class="line">        <span class="keyword">return</span> (minHeap.peek() + maxHeap.peek())/<span class="number">2.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[2,3,4]</span></span><br><span class="line"><span class="comment">return 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2,3]</span></span><br><span class="line"><span class="comment">return (2+3)/2 = 2.5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">odd:</span></span><br><span class="line"><span class="comment">even:</span></span><br><span class="line"><span class="comment">[1,2,3,4]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">minHeap []</span></span><br><span class="line"><span class="comment">maxHeap []</span></span><br><span class="line"><span class="comment">case1: even number</span></span><br><span class="line"><span class="comment">        minHeap k</span></span><br><span class="line"><span class="comment">        maxHeap k</span></span><br><span class="line"><span class="comment">        add ele into minHeap, and poll the min minHeap, add it to maxHeap</span></span><br><span class="line"><span class="comment">case2: odd number</span></span><br><span class="line"><span class="comment">        minHeap k</span></span><br><span class="line"><span class="comment">        maxHeap k+1</span></span><br><span class="line"><span class="comment">        add ele into maxHeap, and poll the max maxHeap , add it to minHeap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="🌕Sliding-Window-Median-hard-✨"><a href="#🌕Sliding-Window-Median-hard-✨" class="headerlink" title="🌕Sliding Window Median (hard)✨"></a>🌕Sliding Window Median (hard)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] findSlidingWindowMedian(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == <span class="number">0</span> || maxHeap.peek() &gt;= nums[i]) &#123;</span><br><span class="line">            maxHeap.add(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minHeap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        rebalanceHeaps();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123; <span class="comment">// if we have at least 'k' elements in the sliding window</span></span><br><span class="line">            <span class="comment">// add the median to the the result array</span></span><br><span class="line">            <span class="keyword">if</span> (maxHeap.size() == minHeap.size()) &#123;</span><br><span class="line">                <span class="comment">// we have even number of elements, take the average of middle two elements</span></span><br><span class="line">                result[i - k + <span class="number">1</span>] = maxHeap.peek() / <span class="number">2.0</span> + minHeap.peek() / <span class="number">2.0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// because max-heap will have one more element than the min-heap</span></span><br><span class="line">                result[i - k + <span class="number">1</span>] = maxHeap.peek();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remove the element going out of the sliding window</span></span><br><span class="line">            <span class="keyword">int</span> elementToBeRemoved = nums[i - k + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (elementToBeRemoved &lt;= maxHeap.peek()) &#123;</span><br><span class="line">                maxHeap.remove(elementToBeRemoved);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                minHeap.remove(elementToBeRemoved);</span><br><span class="line">            &#125;</span><br><span class="line">            rebalanceHeaps();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalanceHeaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// either both the heaps will have equal number of elements or max-heap will have </span></span><br><span class="line">    <span class="comment">// one more element than the min-heap</span></span><br><span class="line">    <span class="keyword">if</span> (maxHeap.size() &gt; minHeap.size() + <span class="number">1</span>)</span><br><span class="line">        minHeap.add(maxHeap.poll());</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (maxHeap.size() &lt; minHeap.size())</span><br><span class="line">        maxHeap.add(minHeap.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-480-Sliding-Window-Median✨"><a href="#Unsolved-480-Sliding-Window-Median✨" class="headerlink" title="Unsolved 480. Sliding Window Median✨"></a><a href="https://leetcode.com/problems/sliding-window-median/" target="_blank" rel="noopener">Unsolved 480. Sliding Window Median✨</a></h3><h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">//For those of you who made the same mistake: PriorityQueue maxHeap = new PriorityQueue&lt;&gt;((a,b)-&gt;(b-a)) won't pass test cases that involve comparing Integer MAX and MIN, change it to: PriorityQueue maxHeap = new PriorityQueue&lt;&gt;((a,b)-&gt;(b.compareTo(a)));</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());  <span class="comment">//note</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.size() == right.size()) &#123;</span><br><span class="line">            right.add(nums[i]);</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left.add(nums[i]);</span><br><span class="line">            right.add(left.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left.size() + right.size() == k) &#123;</span><br><span class="line">            <span class="keyword">double</span> median;</span><br><span class="line">            <span class="keyword">if</span> (left.size() == right.size()) &#123;</span><br><span class="line">                median = (<span class="keyword">double</span>)((<span class="keyword">long</span>)left.peek() + (<span class="keyword">long</span>)right.peek())/<span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                median = (<span class="keyword">double</span>) left.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            result[idx] = median;</span><br><span class="line">            <span class="comment">//heap.remove() method return boolean value</span></span><br><span class="line">            <span class="keyword">if</span> (!left.remove(nums[idx])) &#123;</span><br><span class="line">                right.remove(nums[idx]);</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>TreeSet </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[a] != nums[b]) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(nums[a], nums[b]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a - b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    TreeSet&lt;Integer&gt; left = <span class="keyword">new</span> TreeSet&lt;&gt;(comparator.reversed());</span><br><span class="line">    TreeSet&lt;Integer&gt; right = <span class="keyword">new</span> TreeSet&lt;&gt;(comparator);</span><br><span class="line">    <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        left.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// balance lefts size and rights size (if not equal then right will be larger by one)</span></span><br><span class="line">    balance(left, right);</span><br><span class="line">    res[<span class="number">0</span>] = getMedian(k, nums, left, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// remove tail of window from either left or right</span></span><br><span class="line">        <span class="keyword">if</span>(!left.remove(i - k)) &#123;</span><br><span class="line">            right.remove(i - k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add next num, this will always increase left size</span></span><br><span class="line">        right.add(i); </span><br><span class="line">        left.add(right.pollFirst());</span><br><span class="line">        <span class="comment">// rebalance left and right, then get median from them</span></span><br><span class="line">        balance(left, right); </span><br><span class="line">        res[r] = getMedian(k, nums, left, right);</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">balance</span><span class="params">(TreeSet&lt;Integer&gt; left, TreeSet&lt;Integer&gt; right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left.size() &gt; right.size()) &#123;</span><br><span class="line">        right.add(left.pollFirst());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getMedian</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums, TreeSet&lt;Integer&gt; left, TreeSet&lt;Integer&gt; right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">double</span>) nums[left.first()] + nums[right.first()]) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) nums[right.first()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Maximize-Capital-hard"><a href="#🌕Unsolved-Maximize-Capital-hard" class="headerlink" title="🌕Unsolved Maximize Capital (hard)"></a>🌕Unsolved Maximize Capital (hard)</h2><ol>
<li><p>Time complexity</p>
<p>Since, at the most, all the projects will be pushed to both the heaps once, the time complexity of our algorithm is O(NlogN + KlogN),<em>O</em>(<em>N<strong>l</strong>o<strong>g</strong>N</em>+<em>K<strong>l</strong>o<strong>g</strong>N</em>), where ‘N’ is the total number of projects and ‘K’ is the number of projects we are selecting.</p>
<p>Space complexity</p>
<p>The space complexity will be O(N)<em>O</em>(<em>N</em>) because we will be storing all the projects in the heaps.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaximumCapital</span><span class="params">(<span class="keyword">int</span>[] capital, <span class="keyword">int</span>[] profits, <span class="keyword">int</span> numberOfProjects, <span class="keyword">int</span> initialCapital)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = profits.length;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minCapitalHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(n, (i1, i2) -&gt; capital[i1] - capital[i2]);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxProfitHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(n, (i1, i2) -&gt; profits[i2] - profits[i1]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert all project capitals to a min-heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        minCapitalHeap.offer(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let's try to find a total of 'numberOfProjects' best projects</span></span><br><span class="line">    <span class="keyword">int</span> availableCapital = initialCapital;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfProjects; i++) &#123;</span><br><span class="line">        <span class="comment">// find all projects that can be selected within the available capital and insert them in a max-heap</span></span><br><span class="line">        <span class="keyword">while</span> (!minCapitalHeap.isEmpty() &amp;&amp; capital[minCapitalHeap.peek()] &lt;= availableCapital)</span><br><span class="line">            maxProfitHeap.add(minCapitalHeap.poll());</span><br><span class="line">        <span class="comment">// terminate if we are not able to find any project that can be completed within the available capital</span></span><br><span class="line">        <span class="keyword">if</span> (maxProfitHeap.isEmpty())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// select the project with the maximum profit</span></span><br><span class="line">        availableCapital += profits[maxProfitHeap.poll()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> availableCapital;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Challenge-1-Next-Interval-hard"><a href="#🌕Unsolved-Challenge-1-Next-Interval-hard" class="headerlink" title="🌕Unsolved Challenge 1 Next Interval (hard)"></a>🌕Unsolved Challenge 1 Next Interval (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: Intervals [[2,3], [3,4], [5,6]]</span><br><span class="line">Output: [1, 2, -1]</span><br><span class="line">Explanation: The next interval of [2,3] is [3,4] having index ‘1’. Similarly, the next interval of [3,4] is [5,6] having index ‘2’. There is no next interval for [5,6] hence we have ‘-1’.</span><br><span class="line"></span><br><span class="line">Input: Intervals [[3,4], [1,5], [4,6]]</span><br><span class="line">Output: [2, -1, -1]</span><br><span class="line">Explanation: The next interval of [3,4] is [4,6] which has index ‘2’. There is no next interval for [1,5] and [4,6].</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findNextInterval(Interval[] intervals) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">    <span class="comment">// heap for finding the maximum start</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxStartHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(n, (i1, i2) -&gt; intervals[i2].start - intervals[i1].start);</span><br><span class="line">    <span class="comment">// heap for finding the minimum end</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxEndHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(n, (i1, i2) -&gt; intervals[i2].end - intervals[i1].end);</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        maxStartHeap.offer(i);</span><br><span class="line">        maxEndHeap.offer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// go through all the intervals to find each interval's next interval</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> topEnd = maxEndHeap.poll(); <span class="comment">// let's find the next interval of the interval which has the highest 'end' </span></span><br><span class="line">        result[topEnd] = -<span class="number">1</span>; <span class="comment">// defaults to -1</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[maxStartHeap.peek()].start &gt;= intervals[topEnd].end) &#123;</span><br><span class="line">            <span class="keyword">int</span> topStart = maxStartHeap.poll();</span><br><span class="line">            <span class="comment">// find the the interval that has the closest 'start'</span></span><br><span class="line">            <span class="keyword">while</span> (!maxStartHeap.isEmpty() &amp;&amp; intervals[maxStartHeap.peek()].start &gt;= intervals[topEnd].end) &#123;</span><br><span class="line">                topStart = maxStartHeap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            result[topEnd] = topStart;</span><br><span class="line">            maxStartHeap.add(topStart); <span class="comment">// put the interval back as it could be the next interval of other intervals</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="436-Find-Right-Interval"><a href="#436-Find-Right-Interval" class="headerlink" title="436. Find Right Interval"></a><a href="https://leetcode.com/problems/find-right-interval/" target="_blank" rel="noopener">436. Find Right Interval</a></h3><h3 id="Sulution1"><a href="#Sulution1" class="headerlink" title="Sulution1:"></a>Sulution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRightInterval(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span> || intervals[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</span><br><span class="line">    Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">    Queue&lt;Integer&gt; latestStart = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; intervals[b][<span class="number">0</span>] - intervals[a][<span class="number">0</span>]);</span><br><span class="line">    Queue&lt;Integer&gt; latestEnd = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; intervals[b][<span class="number">1</span>] - intervals[a][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        latestStart.add(i);</span><br><span class="line">        latestEnd.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!latestEnd.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = latestEnd.poll();</span><br><span class="line">        <span class="keyword">if</span> (intervals[latestStart.peek()][<span class="number">0</span>] &gt;= intervals[cur][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = latestStart.poll();</span><br><span class="line">            <span class="keyword">while</span>(!latestStart.isEmpty() &amp;&amp; intervals[latestStart.peek()][<span class="number">0</span>] &gt;= intervals[cur][<span class="number">1</span>]) &#123;</span><br><span class="line">                temp = latestStart.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[cur] = temp;</span><br><span class="line">            latestStart.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pattern-Top-‘K’-Elements"><a href="#Pattern-Top-‘K’-Elements" class="headerlink" title="Pattern: Top ‘K’ Elements"></a>Pattern: Top ‘K’ Elements</h1><h2 id="Top-‘K’-Numbers-easy"><a href="#Top-‘K’-Numbers-easy" class="headerlink" title="Top ‘K’ Numbers (easy)"></a>Top ‘K’ Numbers (easy)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findKLargestNumbers</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; n1 - n2);</span><br><span class="line">    <span class="comment">// put first 'K' numbers in the min heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        minHeap.add(nums[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// go through the remaining numbers of the array, if the number from the array is bigger than the</span></span><br><span class="line">    <span class="comment">// top (smallest) number of the min-heap, remove the top number from heap and add the number from array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; minHeap.peek()) &#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">            minHeap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the heap has the top 'K' numbers, return them in a list</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(minHeap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kth-Smallest-Number-easy"><a href="#Kth-Smallest-Number-easy" class="headerlink" title="Kth Smallest Number (easy)"></a>Kth Smallest Number (easy)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallestNumber</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; n2 - n1);</span><br><span class="line">    <span class="comment">// put first k numbers in the max heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        maxHeap.add(nums[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// go through the remaining numbers of the array, if the number from the array is smaller than the</span></span><br><span class="line">    <span class="comment">// top (biggest) number of the heap, remove the top number from heap and add the number from array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; maxHeap.peek()) &#123;</span><br><span class="line">            maxHeap.poll();</span><br><span class="line">            maxHeap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the root of the heap has the Kth smallest number</span></span><br><span class="line">    <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="‘K’-Closest-Points-to-the-Origin-easy"><a href="#‘K’-Closest-Points-to-the-Origin-easy" class="headerlink" title="‘K’ Closest Points to the Origin (easy)"></a>‘K’ Closest Points to the Origin (easy)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ignoring sqrt</span></span><br><span class="line">        <span class="keyword">return</span> (x * x) + (y * y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KClosestPointsToOrigin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Point&gt; <span class="title">findClosestPoints</span><span class="params">(Point[] points, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Point&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((p1, p2) -&gt; p2.distFromOrigin() - p1.distFromOrigin());</span><br><span class="line">        <span class="comment">// put first 'k' points in the max heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            maxHeap.add(points[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// go through the remaining points of the input array, if a point is closer to the origin than the top point </span></span><br><span class="line">        <span class="comment">// of the max-heap, remove the top point from heap and add the point from the input array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i].distFromOrigin() &lt; maxHeap.peek().distFromOrigin()) &#123;</span><br><span class="line">                maxHeap.poll();</span><br><span class="line">                maxHeap.add(points[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the heap has 'k' points closest to the origin, return them in a list</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(maxHeap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Connect-Ropes-easy"><a href="#Connect-Ropes-easy" class="headerlink" title="Connect Ropes (easy)"></a>Connect Ropes (easy)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minimumCostToConnectRopes</span><span class="params">(<span class="keyword">int</span>[] ropeLengths)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; n1 - n2);</span><br><span class="line">    <span class="comment">// add all ropes to the min heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ropeLengths.length; i++)</span><br><span class="line">        minHeap.add(ropeLengths[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// go through the values of the heap, in each step take top (lowest) rope lengths from the min heap</span></span><br><span class="line">    <span class="comment">// connect them and push the result back to the min heap. </span></span><br><span class="line">    <span class="comment">// keep doing this until the heap is left with only one rope</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (minHeap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        temp = minHeap.poll() + minHeap.poll();</span><br><span class="line">        result += temp;</span><br><span class="line">        minHeap.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Top-‘K’-Frequent-Numbers-medium"><a href="#Top-‘K’-Frequent-Numbers-medium" class="headerlink" title="Top ‘K’ Frequent Numbers (medium)"></a>Top ‘K’ Frequent Numbers (medium)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findTopKFrequentNumbers</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// find the frequency of each number</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; numFrequencyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">        numFrequencyMap.put(n, numFrequencyMap.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(</span><br><span class="line">        (e1, e2) -&gt; e1.getValue() - e2.getValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// go through all numbers of the numFrequencyMap and push them in the minHeap, which will have </span></span><br><span class="line">    <span class="comment">// top k frequent numbers. If the heap size is more than k, we remove the smallest (top) number </span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : numFrequencyMap.entrySet()) &#123;</span><br><span class="line">        minHeap.add(entry);</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() &gt; k) &#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a list of top k numbers</span></span><br><span class="line">    List&lt;Integer&gt; topNumbers = <span class="keyword">new</span> ArrayList&lt;&gt;(k);</span><br><span class="line">    <span class="keyword">while</span> (!minHeap.isEmpty()) &#123;</span><br><span class="line">        topNumbers.add(minHeap.poll().getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> topNumbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Frequency-Sort-medium"><a href="#Frequency-Sort-medium" class="headerlink" title="Frequency Sort (medium)"></a>Frequency Sort (medium)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sortCharacterByFrequency</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// find the frequency of each character</span></span><br><span class="line">    Map&lt;Character, Integer&gt; characterFrequencyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> chr : str.toCharArray()) &#123;</span><br><span class="line">        characterFrequencyMap.put(chr, characterFrequencyMap.getOrDefault(chr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt;((e1, e2) -&gt; e2.getValue() - e1.getValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add all characters to the max heap</span></span><br><span class="line">    maxHeap.addAll(characterFrequencyMap.entrySet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build a string, appending the most occurring characters first</span></span><br><span class="line">    StringBuilder sortedString = <span class="keyword">new</span> StringBuilder(str.length());</span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.isEmpty()) &#123;</span><br><span class="line">        Map.Entry&lt;Character, Integer&gt; entry = maxHeap.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entry.getValue(); i++)</span><br><span class="line">            sortedString.append(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedString.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kth-Largest-Number-in-a-Stream-medium"><a href="#Kth-Largest-Number-in-a-Stream-medium" class="headerlink" title="Kth Largest Number in a Stream (medium)"></a>Kth Largest Number in a Stream (medium)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargestNumberInStream</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; n1 - n2);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargestNumberInStream</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="comment">// add the numbers in the min heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// add the new number in the min heap</span></span><br><span class="line">        minHeap.add(num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if heap has more than 'k' numbers, remove one number</span></span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() &gt; <span class="keyword">this</span>.k)</span><br><span class="line">            minHeap.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the 'Kth largest number</span></span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="‘K’-Closest-Numbers-medium"><a href="#‘K’-Closest-Numbers-medium" class="headerlink" title="‘K’ Closest Numbers (medium)"></a>‘K’ Closest Numbers (medium)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KClosestElements</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findClosestElements</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> K, Integer X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = binarySearch(arr, X);</span><br><span class="line">        <span class="keyword">int</span> low = index - K, high = index + K;</span><br><span class="line">        low = Math.max(low, <span class="number">0</span>); <span class="comment">// 'low' should not be less than zero</span></span><br><span class="line">        high = Math.min(high, arr.length - <span class="number">1</span>); <span class="comment">// 'high' should not be greater the size of the array</span></span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Entry&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((n1, n2) -&gt; n1.key - n2.key);</span><br><span class="line">        <span class="comment">// add all candidate elements to the min heap, sorted by their absolute difference from 'X'</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt;= high; i++)</span><br><span class="line">            minHeap.add(<span class="keyword">new</span> Entry(Math.abs(arr[i] - X), i));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we need the top 'K' elements having smallest difference from 'X'</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++)</span><br><span class="line">            result.add(arr[minHeap.poll().value]);</span><br><span class="line"></span><br><span class="line">        Collections.sort(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> </span><br><span class="line">        <span class="keyword">if</span> (low &gt; <span class="number">0</span>) &#123;  <span class="comment">//arr.length - 1</span></span><br><span class="line">            <span class="keyword">return</span> low - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="658-Find-K-Closest-Elements💎"><a href="#658-Find-K-Closest-Elements💎" class="headerlink" title="658. Find K Closest Elements💎"></a><a href="https://leetcode.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. Find K Closest Elements💎</a></h3><h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findClosestElements</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (Math.abs(a.key) == Math.abs(b.key) ? a.key - b.key : Math.abs(a.key) - Math.abs(b.key)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(arr[i] - x, i);</span><br><span class="line">            heap.add(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ans.add(arr[heap.poll().value]);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Maximum-Distinct-Elements-medium"><a href="#Maximum-Distinct-Elements-medium" class="headerlink" title="Maximum Distinct Elements (medium)"></a>Maximum Distinct Elements (medium)</h2><p>Given an array of numbers and a number ‘K’, we need to remove ‘K’ numbers from the array such that we are left with maximum distinct numbers.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaximumDistinctElements</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> distinctElementsCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= k)</span><br><span class="line">        <span class="keyword">return</span> distinctElementsCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the frequency of each number</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; numFrequencyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums)</span><br><span class="line">        numFrequencyMap.put(i, numFrequencyMap.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(</span><br><span class="line">        (e1, e2) -&gt; e1.getValue() - e2.getValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert all numbers with frequency greater than '1' into the min-heap</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : numFrequencyMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">1</span>)</span><br><span class="line">            distinctElementsCount++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minHeap.add(entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// following a greedy approach, try removing the least frequent numbers first from the min-heap</span></span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !minHeap.isEmpty()) &#123;</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; entry = minHeap.poll();</span><br><span class="line">        <span class="comment">// to make an element distinct, we need to remove all of its occurrences except one</span></span><br><span class="line">        k -= entry.getValue() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">            distinctElementsCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if k &gt; 0, this means we have to remove some distinct numbers</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">0</span>)</span><br><span class="line">        distinctElementsCount -= k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distinctElementsCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sum-of-Elements-medium"><a href="#Sum-of-Elements-medium" class="headerlink" title="Sum of Elements (medium)"></a>Sum of Elements (medium)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSumOfElements</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k1, <span class="keyword">int</span> k2)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; n1 - n2);</span><br><span class="line">    <span class="comment">// insert all numbers to the min heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        minHeap.add(nums[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove k1 small numbers from the min heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k1; i++)</span><br><span class="line">        minHeap.poll();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> elementSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// sum next k2-k1-1 numbers</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k2 - k1 - <span class="number">1</span>; i++)</span><br><span class="line">        elementSum += minHeap.poll();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Rearrange-String-hard"><a href="#🌕Rearrange-String-hard" class="headerlink" title="🌕Rearrange String (hard)"></a>🌕Rearrange String (hard)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">rearrangeString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; charFrequencyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> chr : str.toCharArray())</span><br><span class="line">        charFrequencyMap.put(chr, charFrequencyMap.getOrDefault(chr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt;(</span><br><span class="line">        (e1, e2) -&gt; e2.getValue() - e1.getValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add all characters to the max heap</span></span><br><span class="line">    maxHeap.addAll(charFrequencyMap.entrySet());</span><br><span class="line"></span><br><span class="line">    Map.Entry&lt;Character, Integer&gt; previousEntry = <span class="keyword">null</span>;</span><br><span class="line">    StringBuilder resultString = <span class="keyword">new</span> StringBuilder(str.length());</span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.isEmpty()) &#123;</span><br><span class="line">        Map.Entry&lt;Character, Integer&gt; currentEntry = maxHeap.poll();</span><br><span class="line">        <span class="comment">// add the previous entry back in the heap if its frequency is greater than zero</span></span><br><span class="line">        <span class="keyword">if</span> (previousEntry != <span class="keyword">null</span> &amp;&amp; previousEntry.getValue() &gt; <span class="number">0</span>)</span><br><span class="line">            maxHeap.offer(previousEntry);</span><br><span class="line">        <span class="comment">// append the current character to the result string and decrement its count</span></span><br><span class="line">        resultString.append(currentEntry.getKey());</span><br><span class="line">        currentEntry.setValue(currentEntry.getValue() - <span class="number">1</span>);</span><br><span class="line">        previousEntry = currentEntry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we were successful in appending all the characters to the result string, return it</span></span><br><span class="line">    <span class="keyword">return</span> resultString.length() == str.length() ? resultString.toString() : <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Challenge-1-Rearrange-String-K-Distance-Apart-hard"><a href="#🌕Challenge-1-Rearrange-String-K-Distance-Apart-hard" class="headerlink" title="🌕Challenge 1 Rearrange String K Distance Apart (hard)"></a>🌕Challenge 1 Rearrange String K Distance Apart (hard)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reorganizeString</span><span class="params">(String str, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, Integer&gt; charFrequencyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> chr : str.toCharArray())</span><br><span class="line">        charFrequencyMap.put(chr, charFrequencyMap.getOrDefault(chr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt;(</span><br><span class="line">        (e1, e2) -&gt; e2.getValue() - e1.getValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add all characters to the max heap</span></span><br><span class="line">    maxHeap.addAll(charFrequencyMap.entrySet());</span><br><span class="line"></span><br><span class="line">    Queue&lt;Map.Entry&lt;Character, Integer&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    StringBuilder resultString = <span class="keyword">new</span> StringBuilder(str.length());</span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.isEmpty()) &#123;</span><br><span class="line">        Map.Entry&lt;Character, Integer&gt; currentEntry = maxHeap.poll();</span><br><span class="line">        <span class="comment">// append the current character to the result string and decrement its count</span></span><br><span class="line">        resultString.append(currentEntry.getKey());</span><br><span class="line">        currentEntry.setValue(currentEntry.getValue() - <span class="number">1</span>);</span><br><span class="line">        queue.offer(currentEntry);</span><br><span class="line">        <span class="keyword">if</span> (queue.size() == k) &#123;</span><br><span class="line">            Map.Entry&lt;Character, Integer&gt; entry = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() &gt; <span class="number">0</span>)</span><br><span class="line">                maxHeap.add(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we were successful in appending all the characters to the result string, return it</span></span><br><span class="line">    <span class="keyword">return</span> resultString.length() == str.length() ? resultString.toString() : <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="358-Rearrange-String-k-Distance-Apart"><a href="#358-Rearrange-String-k-Distance-Apart" class="headerlink" title="358. Rearrange String k Distance Apart"></a><a href="https://leetcode.com/problems/rearrange-string-k-distance-apart/" target="_blank" rel="noopener">358. Rearrange String k Distance Apart</a></h3><h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">rearrangeString</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        countMap.put(c, countMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use a max heap to do the greedy part</span></span><br><span class="line">    PriorityQueue&lt;Character&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (c1, c2) -&gt; countMap.get(c2) - countMap.get(c1));</span><br><span class="line">    maxHeap.addAll(countMap.keySet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use wait queue for each iteration of k elements</span></span><br><span class="line">    Queue&lt;Character&gt; waitQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    StringBuilder rearranged = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.isEmpty()) &#123;</span><br><span class="line">        Character current = maxHeap.poll();</span><br><span class="line">        rearranged.append(current);</span><br><span class="line">        countMap.put(current, countMap.get(current) - <span class="number">1</span>);</span><br><span class="line">        waitQueue.offer(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waitQueue.size() &lt; k) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Release from waitQueue if char is already k apart</span></span><br><span class="line">        Character front = waitQueue.poll();</span><br><span class="line">        <span class="keyword">if</span> (countMap.get(front) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxHeap.offer(front);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rearranged.length() == s.length() ? rearranged.toString() : <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="🌕Challenge-2-Scheduling-Tasks-hard-✨"><a href="#🌕Challenge-2-Scheduling-Tasks-hard-✨" class="headerlink" title="🌕Challenge 2 Scheduling Tasks (hard)✨"></a>🌕Challenge 2 Scheduling Tasks (hard)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scheduleTasks</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intervalCount = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character, Integer&gt; taskFrequencyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> chr : tasks)</span><br><span class="line">        taskFrequencyMap.put(chr, taskFrequencyMap.getOrDefault(chr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt;((e1, e2) -&gt; e2.getValue() - e1.getValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add all tasks to the max heap</span></span><br><span class="line">    maxHeap.addAll(taskFrequencyMap.entrySet());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.isEmpty()) &#123;</span><br><span class="line">        List&lt;Map.Entry&lt;Character, Integer&gt;&gt; waitList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = k + <span class="number">1</span>; <span class="comment">// try to execute as many as 'k+1' tasks from the max-heap</span></span><br><span class="line">        <span class="keyword">for</span> (; n &gt; <span class="number">0</span> &amp;&amp; !maxHeap.isEmpty(); n--) &#123;</span><br><span class="line">            intervalCount++;</span><br><span class="line">            Map.Entry&lt;Character, Integer&gt; currentEntry = maxHeap.poll();</span><br><span class="line">            <span class="keyword">if</span> (currentEntry.getValue() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                currentEntry.setValue(currentEntry.getValue() - <span class="number">1</span>);</span><br><span class="line">                waitList.add(currentEntry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxHeap.addAll(waitList); <span class="comment">// put all the waiting list back on the heap</span></span><br><span class="line">        <span class="keyword">if</span> (!maxHeap.isEmpty())</span><br><span class="line">            intervalCount += n; <span class="comment">// we'll be having 'n' idle intervals for the next iteration</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intervalCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="621-Task-Scheduler✨"><a href="#621-Task-Scheduler✨" class="headerlink" title="621. Task Scheduler✨"></a><a href="https://leetcode.com/problems/task-scheduler/" target="_blank" rel="noopener">621. Task Scheduler✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: tasks = [<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>], n = <span class="number">2</span></span><br><span class="line">Output: <span class="number">8</span></span><br><span class="line">Explanation: </span><br><span class="line">A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B</span><br><span class="line">There is at least <span class="number">2</span> units of time between any two same tasks.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Greedy</li>
<li>We need to arrange the characters in string such that each same character is K distance apart, where distance in this problems is time b/w two similar task execution.</li>
<li>Idea is to add them to a priority Q and sort based on the highest frequency.<br>And pick the task in each round of ‘n’ with highest frequency. As you pick the task, decrease the frequency, and put them back after the round.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">        map.put(tasks[i], map.getOrDefault(tasks[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (b - a));</span><br><span class="line">    maxHeap.addAll(map.values());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = n + <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !maxHeap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> top = maxHeap.poll();  <span class="comment">// most frequency task</span></span><br><span class="line">            top--;</span><br><span class="line">            temp.add(top);</span><br><span class="line">            k--;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span>) maxHeap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//is no element in temp need to be add to heap to process, break</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//otherwise wait for cool down (k) for next process</span></span><br><span class="line">        count += k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">        map.put(tasks[i], map.getOrDefault(tasks[i], <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">// map key is TaskName, and value is number of times to be executed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;( <span class="comment">//frequency sort</span></span><br><span class="line">        (a,b) -&gt; a.getValue() != b.getValue() ? b.getValue() - a.getValue() : a.getKey() - b.getKey());</span><br><span class="line"></span><br><span class="line">    q.addAll(map.entrySet());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = n + <span class="number">1</span>;</span><br><span class="line">        List&lt;Map.Entry&gt; tempList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !q.isEmpty()) &#123;</span><br><span class="line">            Map.Entry&lt;Character, Integer&gt; top = q.poll(); <span class="comment">// most frequency task</span></span><br><span class="line">            top.setValue(top.getValue() - <span class="number">1</span>); <span class="comment">// decrease frequency, meaning it got executed</span></span><br><span class="line">            tempList.add(top); <span class="comment">// collect task to add back to queue</span></span><br><span class="line">            k--;</span><br><span class="line">            count++; <span class="comment">//successfully executed task</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; e : tempList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getValue() &gt; <span class="number">0</span>) q.add(e); <span class="comment">// add valid tasks </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">        count = count + k; <span class="comment">// if k &gt; 0, then it means we need to be idle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Challenge-3-Frequency-Stack-hard-✨"><a href="#🌕Unsolved-Challenge-3-Frequency-Stack-hard-✨" class="headerlink" title="🌕Unsolved Challenge 3 Frequency Stack (hard)✨"></a>🌕Unsolved Challenge 3 Frequency Stack (hard)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">int</span> frequency;</span><br><span class="line">    <span class="keyword">int</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">int</span> frequency, <span class="keyword">int</span> sequenceNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.frequency = frequency;</span><br><span class="line">        <span class="keyword">this</span>.sequenceNumber = sequenceNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElementComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Element e1, Element e2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e1.frequency != e2.frequency)</span><br><span class="line">            <span class="keyword">return</span> e2.frequency - e1.frequency;</span><br><span class="line">        <span class="comment">// if both elements have same frequency, return the one that was pushed later </span></span><br><span class="line">        <span class="keyword">return</span> e2.sequenceNumber - e1.sequenceNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrequencyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sequenceNumber = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;Element&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Element&gt;(<span class="keyword">new</span> ElementComparator());</span><br><span class="line">    Map&lt;Integer, Integer&gt; frequencyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        frequencyMap.put(num, frequencyMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        maxHeap.offer(<span class="keyword">new</span> Element(num, frequencyMap.get(num), sequenceNumber++));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = maxHeap.poll().number;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// decrement the frequency or remove if this is the last number</span></span><br><span class="line">        <span class="keyword">if</span> (frequencyMap.get(num) &gt; <span class="number">1</span>)</span><br><span class="line">            frequencyMap.put(num, frequencyMap.get(num) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            frequencyMap.remove(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="895-Maximum-Frequency-Stack✨"><a href="#895-Maximum-Frequency-Stack✨" class="headerlink" title="895. Maximum Frequency Stack✨"></a><a href="https://leetcode.com/problems/maximum-frequency-stack/" target="_blank" rel="noopener">895. Maximum Frequency Stack✨</a></h3><h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreqStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sequenceNumber;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    Queue&lt;Element&gt; maxHeap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FreqStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sequenceNumber = <span class="number">0</span>;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Element&gt;(<span class="keyword">new</span> ElementComparator());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        map.put(x, map.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        maxHeap.add(<span class="keyword">new</span> Element(x, map.get(x), sequenceNumber++));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = maxHeap.poll().value;</span><br><span class="line">        <span class="keyword">if</span> (map.get(cur) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            map.put(cur, map.get(cur) - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.remove(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> frequency;</span><br><span class="line">    <span class="keyword">int</span> sequeceNumber;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> frequency, <span class="keyword">int</span> sequeceNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.frequency = frequency;</span><br><span class="line">        <span class="keyword">this</span>.sequeceNumber = sequeceNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElementComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Element e1, Element e2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e1.frequency != e2.frequency) &#123;</span><br><span class="line">            <span class="keyword">return</span> e2.frequency - e1.frequency;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> e2.sequeceNumber - e1.sequeceNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FreqStack obj = new FreqStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> [5,1,0],[7,1,1], </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> [5,3,5]</span></span><br><span class="line"><span class="comment"> [7,2,3]</span></span><br><span class="line"><span class="comment"> [5,2,2]</span></span><br><span class="line"><span class="comment"> [4,1,4]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="Pattern-K-way-merge"><a href="#Pattern-K-way-merge" class="headerlink" title="Pattern: K-way merge"></a>Pattern: K-way merge</h1><h2 id="Merge-K-Sorted-Lists-medium-⭐🎶"><a href="#Merge-K-Sorted-Lists-medium-⭐🎶" class="headerlink" title="Merge K Sorted Lists (medium)⭐🎶"></a>Merge K Sorted Lists (medium)⭐🎶</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;((n1, n2) -&gt; n1.value - n2.value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put the root of each list in the min heap</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode root : lists)</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>)</span><br><span class="line">            minHeap.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// take the smallest (top) element form the min-heap and add it to the result; </span></span><br><span class="line">    <span class="comment">// if the top element has a next element add it to the heap</span></span><br><span class="line">    ListNode resultHead = <span class="keyword">null</span>, resultTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!minHeap.isEmpty()) &#123;</span><br><span class="line">        ListNode node = minHeap.poll();</span><br><span class="line">        <span class="keyword">if</span> (resultHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultHead = resultTail = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resultTail.next = node;</span><br><span class="line">            resultTail = resultTail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)</span><br><span class="line">            minHeap.add(node.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-Merge-k-Sorted-Lists⭐🎶"><a href="#23-Merge-k-Sorted-Lists⭐🎶" class="headerlink" title="23. Merge k Sorted Lists⭐🎶"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. Merge k Sorted Lists⭐🎶</a></h3><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">Explanation: The linked-lists are:</span><br><span class="line">[ <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span>    ]</span><br><span class="line">merging them into one sorted list:</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution0"><a href="#Solution0" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute Force</li>
<li>Time complexity: O(n log n)</li>
<li>Space complexity: O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Intuition &amp; Algorithm</span><br><span class="line">Traverse all the linked lists and collect the values of the nodes into an array.</span><br><span class="line">Sort and iterate over <span class="keyword">this</span> array to get the proper value of nodes.</span><br><span class="line">Create a <span class="keyword">new</span> sorted linked list and extend it with the <span class="keyword">new</span> nodes.</span><br><span class="line">    </span><br><span class="line">Time complexity : O(NlogN) where N is the total number of nodes.</span><br><span class="line"><span class="function">Collecting all the values costs <span class="title">O</span><span class="params">(N)</span> time.</span></span><br><span class="line"><span class="function">A stable sorting algorithm costs <span class="title">O</span><span class="params">(NlogN)</span> time.</span></span><br><span class="line"><span class="function">Iterating <span class="keyword">for</span> creating the linked list costs <span class="title">O</span><span class="params">(N)</span> time.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Space complexity : <span class="title">O</span><span class="params">(N)</span>.</span></span><br><span class="line"><span class="function">Sorting cost <span class="title">O</span><span class="params">(N)</span> <span class="title">space</span> <span class="params">(depends on the algorithm you choose)</span>.</span></span><br><span class="line"><span class="function">Creating a new linked list costs <span class="title">O</span><span class="params">(N)</span> space.</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2019/06/23-ep252.png" alt=""></p>
<ol>
<li>Priority Queue这个方法merge k sorted array 也是work的</li>
<li>Time complexity: O(n logk)</li>
<li>Space complexity: O(k)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Complexity Analysis</span><br><span class="line">Time complexity : O(N logk) where k is the number of linked lists.</span><br><span class="line"><span class="function">The comparison cost will be reduced to <span class="title">O</span><span class="params">(logk)</span> <span class="keyword">for</span> every pop and insertion to priority queue. </span></span><br><span class="line"><span class="function">But finding the node with the smallest value just costs <span class="title">O</span><span class="params">(<span class="number">1</span>)</span> time.</span></span><br><span class="line"><span class="function">There are N nodes in the <span class="keyword">final</span> linked list.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Space complexity :</span></span><br><span class="line"><span class="function"><span class="title">O</span><span class="params">(n)</span> Creating a new linked list costs <span class="title">O</span><span class="params">(n)</span> space.</span></span><br><span class="line"><span class="function"><span class="title">O</span><span class="params">(k)</span> The code above present applies in-place method which cost <span class="title">O</span><span class="params">(<span class="number">1</span>)</span> space. And the priority <span class="title">queue</span> <span class="params">(often implemented with heaps)</span> costs <span class="title">O</span><span class="params">(k)</span> <span class="title">space</span> <span class="params">(it is far less than N in most situations)</span>.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n log k heap size -&gt; k</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(List&lt;ListNode&gt; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists==<span class="keyword">null</span>||lists.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;(lists.length, (a,b)-&gt; a.val-b.val);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    PriorityQueue&lt;ListNode&gt; heap = new PriorityQueue&lt;ListNode&gt;(lists.size(), new Comparator&lt;ListNode&gt;()&#123;</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public int compare(ListNode o1,ListNode o2)&#123;</span></span><br><span class="line"><span class="comment">            if (o1.val &lt; o2.val)</span></span><br><span class="line"><span class="comment">                return -1;</span></span><br><span class="line"><span class="comment">            else if (o1.val == o2.val)</span></span><br><span class="line"><span class="comment">                return 0;</span></span><br><span class="line"><span class="comment">            else </span></span><br><span class="line"><span class="comment">                return 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ListNode node : lists)</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">            heap.add(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty())&#123;</span><br><span class="line">        cur.next = heap.poll();</span><br><span class="line">        cur = cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.next != <span class="keyword">null</span>)</span><br><span class="line">            queue.add(cur.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n log n heap size -&gt; n</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ListNode list : lists) &#123;</span><br><span class="line">        <span class="keyword">while</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heap.add(list.val);</span><br><span class="line">            list = list.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode head = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">        head.next = <span class="keyword">new</span> ListNode(heap.poll());</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-Solution2"><a href="#Unsolved-Solution2" class="headerlink" title="Unsolved Solution2:"></a>Unsolved Solution2:</h3><ol>
<li><p>思路：分治法。把所有链表分成一对一对的，两两组合，然后再把新的链表队列两两组合，直到只 剩 1 条链表。 另：不进行分组，直接顺序两两组合也能通过，不过慢很多，因为比较次数增加了很多。</p>
</li>
<li><p>Merge Sort</p>
<p>Time complexity: O(nklogk)<br>Space complexity: O(logk)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeSort</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists[start];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &lt; end) &#123; <span class="comment">//recursively call to left &amp; right</span></span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        ListNode l1 = mergeSort(lists, start, mid);</span><br><span class="line">        ListNode l2 = mergeSort(lists, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);  <span class="comment">//merge together</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeHelper(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeHelper(l2.next, l1);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kth-Smallest-Number-in-M-Sorted-Lists-Medium"><a href="#Kth-Smallest-Number-in-M-Sorted-Lists-Medium" class="headerlink" title="Kth Smallest Number in M Sorted Lists (Medium)"></a>Kth Smallest Number in M Sorted Lists (Medium)</h2><p>A big difference from <a href="https://www.educative.io/collection/page/5668639101419520/5671464854355968/4611799594827776/" target="_blank" rel="noopener">Merge K Sorted Lists</a> is that in this problem, the input is a list of arrays compared to LinkedLists. This means that when we want to push the next number in the heap we need to know what the index of the current number in the current array was. To handle this, we will need to keep track of the array and the element indices.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> elementIndex;</span><br><span class="line">    <span class="keyword">int</span> arrayIndex;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> elementIndex, <span class="keyword">int</span> arrayIndex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementIndex = elementIndex;</span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthSmallestInMSortedArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallest</span><span class="params">(List&lt;Integer[]&gt; lists, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Node&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;(</span><br><span class="line">            (n1, n2) -&gt; lists.get(n1.arrayIndex)[n1.elementIndex] - lists.get(n2.arrayIndex)[n2.elementIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put the 1st element of each array in the min heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++)</span><br><span class="line">            <span class="keyword">if</span> (lists.get(i) != <span class="keyword">null</span>)</span><br><span class="line">                minHeap.add(<span class="keyword">new</span> Node(<span class="number">0</span>, i));</span><br><span class="line">        <span class="comment">// take the smallest (top) element form the min heap, if the running count is equal to k return the number</span></span><br><span class="line">        <span class="comment">// if the array of the top element has more elements, add the next element to the heap</span></span><br><span class="line">        <span class="keyword">int</span> numberCount = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!minHeap.isEmpty()) &#123;</span><br><span class="line">            Node node = minHeap.poll();</span><br><span class="line">            result = lists.get(node.arrayIndex)[node.elementIndex];</span><br><span class="line">            <span class="keyword">if</span> (++numberCount == k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            node.elementIndex++;</span><br><span class="line">            <span class="keyword">if</span> (lists.get(node.arrayIndex).length &gt; node.elementIndex)</span><br><span class="line">                minHeap.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems #"></a>Similar Problems <a href="https://www.educative.io/courses/grokking-the-coding-interview/myAqDMyRXn3#similar-problems" target="_blank" rel="noopener">#</a></h3><p><strong>Problem 1:</strong> Given ‘M’ sorted arrays, find the median number among all arrays.</p>
<p><strong>Solution:</strong> This problem is similar to our parent problem with K=Median. So if there are ‘N’ total numbers in all the arrays we need to find the K’th minimum number where K=N/2<em>K</em>=<em>N</em>/2.</p>
<p><strong>Problem 2:</strong> Given a list of ‘K’ sorted arrays, merge them into one sorted list.</p>
<p><strong>Solution:</strong> This problem is similar to <a href="https://www.educative.io/collection/page/5668639101419520/5671464854355968/4611799594827776/" target="_blank" rel="noopener">Merge K Sorted Lists</a> except that the input is a list of arrays compared to <strong>LinkedLists</strong>. To handle this, we can use a similar approach as discussed in our parent problem by keeping a track of the array and the element indices.</p>
<h2 id="🌕Kth-Smallest-Number-in-a-Sorted-Matrix-Hard"><a href="#🌕Kth-Smallest-Number-in-a-Sorted-Matrix-Hard" class="headerlink" title="🌕Kth Smallest Number in a Sorted Matrix (Hard)"></a>🌕Kth Smallest Number in a Sorted Matrix (Hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: Matrix&#x3D;[</span><br><span class="line">    [2, 6, 8], </span><br><span class="line">    [3, 7, 10],</span><br><span class="line">    [5, 8, 11]</span><br><span class="line">  ], </span><br><span class="line">  K&#x3D;5</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: The 5th smallest number in the matrix is 7.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> row, <span class="keyword">int</span> col) &#123;</span><br><span class="line">        <span class="keyword">this</span>.row = row;</span><br><span class="line">        <span class="keyword">this</span>.col = col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthSmallestInSortedMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Node&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;((n1, n2) -&gt; matrix[n1.row][n1.col] - matrix[n2.row][n2.col]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put the 1st element of each row in the min heap</span></span><br><span class="line">        <span class="comment">// we don't need to push more than 'k' elements in the heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length &amp;&amp; i &lt; k; i++)</span><br><span class="line">            minHeap.add(<span class="keyword">new</span> Node(i, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// take the smallest (top) element form the min heap, if the running count is equal to k return the number</span></span><br><span class="line">        <span class="comment">// if the row of the top element has more elements, add the next element to the heap</span></span><br><span class="line">        <span class="keyword">int</span> numberCount = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!minHeap.isEmpty()) &#123;</span><br><span class="line">            Node node = minHeap.poll();</span><br><span class="line">            result = matrix[node.row][node.col];</span><br><span class="line">            <span class="keyword">if</span> (++numberCount == k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            node.col++;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>].length &gt; node.col)</span><br><span class="line">                minHeap.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Binary search</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> start = matrix[<span class="number">0</span>][<span class="number">0</span>], end = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// first number is the smallest and the second number is the largest</span></span><br><span class="line">        <span class="keyword">int</span>[] smallLargePair = &#123; matrix[<span class="number">0</span>][<span class="number">0</span>], matrix[n - <span class="number">1</span>][n - <span class="number">1</span>] &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = countLessEqual(matrix, mid, smallLargePair);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == k)</span><br><span class="line">            <span class="keyword">return</span> smallLargePair[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &lt; k)</span><br><span class="line">            start = smallLargePair[<span class="number">1</span>]; <span class="comment">// search higher</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            end = smallLargePair[<span class="number">0</span>]; <span class="comment">// search lower</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLessEqual</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] smallLargePair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length, row = n - <span class="number">1</span>, col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (row &gt;= <span class="number">0</span> &amp;&amp; col &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// as matrix[row][col] is bigger than the mid, let's keep track of the</span></span><br><span class="line">            <span class="comment">// smallest number greater than the mid</span></span><br><span class="line">            smallLargePair[<span class="number">1</span>] = Math.min(smallLargePair[<span class="number">1</span>], matrix[row][col]);</span><br><span class="line">            row--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// as matrix[row][col] is less than or equal to the mid, let's keep track of the</span></span><br><span class="line">            <span class="comment">// biggest number less than or equal to the mid</span></span><br><span class="line">            smallLargePair[<span class="number">0</span>] = Math.max(smallLargePair[<span class="number">0</span>], matrix[row][col]);</span><br><span class="line">            count += row + <span class="number">1</span>;</span><br><span class="line">            col++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Smallest-Number-Range-Hard-✨"><a href="#🌕Unsolved-Smallest-Number-Range-Hard-✨" class="headerlink" title="🌕Unsolved Smallest Number Range (Hard)✨"></a>🌕Unsolved Smallest Number Range (Hard)✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: L1&#x3D;[1, 5, 8], L2&#x3D;[4, 12], L3&#x3D;[7, 8, 10]</span><br><span class="line">Output: [4, 7]</span><br><span class="line">Explanation: The range [4, 7] includes 5 from L1, 4 from L2 and 7 from L3.</span><br><span class="line"></span><br><span class="line">Input: L1&#x3D;[1, 9], L2&#x3D;[4, 12], L3&#x3D;[7, 10, 16]</span><br><span class="line">Output: [9, 12]</span><br><span class="line">Explanation: The range [9, 12] includes 9 from L1, 12 from L2 and 10 from L3.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> elementIndex;</span><br><span class="line">    <span class="keyword">int</span> arrayIndex;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> elementIndex, <span class="keyword">int</span> arrayIndex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementIndex = elementIndex;</span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallestRange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findSmallestRange(List&lt;Integer[]&gt; lists) &#123;</span><br><span class="line">        PriorityQueue&lt;Node&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;(</span><br><span class="line">            (n1, n2) -&gt; lists.get(n1.arrayIndex)[n1.elementIndex] - lists.get(n2.arrayIndex)[n2.elementIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rangeStart = <span class="number">0</span>, rangeEnd = Integer.MAX_VALUE, currentMaxNumber = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// put the 1st element of each array in the min heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++)</span><br><span class="line">            <span class="keyword">if</span> (lists.get(i) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                minHeap.add(<span class="keyword">new</span> Node(<span class="number">0</span>, i));</span><br><span class="line">                currentMaxNumber = Math.max(currentMaxNumber, lists.get(i)[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// take the smallest (top) element form the min heap, if it gives us smaller range, update the ranges</span></span><br><span class="line">        <span class="comment">// if the array of the top element has more elements, insert the next element in the heap</span></span><br><span class="line">        <span class="keyword">while</span> (minHeap.size() == lists.size()) &#123;</span><br><span class="line">            Node node = minHeap.poll();</span><br><span class="line">            <span class="keyword">if</span> (rangeEnd - rangeStart &gt; currentMaxNumber - lists.get(node.arrayIndex)[node.elementIndex]) &#123;</span><br><span class="line">                rangeStart = lists.get(node.arrayIndex)[node.elementIndex];</span><br><span class="line">                rangeEnd = currentMaxNumber;</span><br><span class="line">            &#125;</span><br><span class="line">            node.elementIndex++;</span><br><span class="line">            <span class="keyword">if</span> (lists.get(node.arrayIndex).length &gt; node.elementIndex) &#123;</span><br><span class="line">                minHeap.add(node); <span class="comment">// insert the next element in the heap</span></span><br><span class="line">                currentMaxNumber = Math.max(currentMaxNumber, lists.get(node.arrayIndex)[node.elementIndex]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;rangeStart, rangeEnd&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="632-Smallest-Range-Covering-Elements-from-K-Lists✨"><a href="#632-Smallest-Range-Covering-Elements-from-K-Lists✨" class="headerlink" title="632. Smallest Range Covering Elements from K Lists✨"></a><a href="https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener">632. Smallest Range Covering Elements from K Lists✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arrayIdx;</span><br><span class="line">    <span class="keyword">int</span> eleIdx;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> arrayIdx, <span class="keyword">int</span> eleIdx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayIdx = arrayIdx;</span><br><span class="line">        <span class="keyword">this</span>.eleIdx = eleIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line">        Queue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (nums.get(a.arrayIdx).get(a.eleIdx) - nums.get(b.arrayIdx).get(b.eleIdx)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> curMax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            Node cur = <span class="keyword">new</span> Node(i, <span class="number">0</span>);</span><br><span class="line">            heap.add(cur);</span><br><span class="line">            curMax = Math.max(curMax, nums.get(i).get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(heap.size() == nums.size()) &#123;</span><br><span class="line">            Node node = heap.poll();</span><br><span class="line">            <span class="keyword">if</span> ((end - start) &gt; (curMax - nums.get(node.arrayIdx).get(node.eleIdx))) &#123;</span><br><span class="line">                end = curMax;</span><br><span class="line">                start = nums.get(node.arrayIdx).get(node.eleIdx);</span><br><span class="line">            &#125;</span><br><span class="line">            node.eleIdx++;</span><br><span class="line">            <span class="keyword">if</span> (nums.get(node.arrayIdx).size() &gt; node.eleIdx) &#123;</span><br><span class="line">                heap.add(node);</span><br><span class="line">                curMax = Math.max(curMax, nums.get(node.arrayIdx).get(node.eleIdx));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Challenge-1-K-Pairs-with-Largest-Sums-Hard"><a href="#🌕Unsolved-Challenge-1-K-Pairs-with-Largest-Sums-Hard" class="headerlink" title="🌕Unsolved Challenge 1 K Pairs with Largest Sums (Hard)"></a>🌕Unsolved Challenge 1 K Pairs with Largest Sums (Hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: L1&#x3D;[9, 8, 2], L2&#x3D;[6, 3, 1], K&#x3D;3</span><br><span class="line">Output: [9, 3], [9, 6], [8, 6] </span><br><span class="line">Explanation: These 3 pairs have the largest sum. No other pair has a sum larger than any of these.</span><br></pre></td></tr></table></figure>

<h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity #"></a>Time complexity <a href="https://www.educative.io/courses/grokking-the-coding-interview/N767x7VoYmK#time-complexity" target="_blank" rel="noopener">#</a></h4><p>Since, at most, we’ll be going through all the elements of both arrays and we will add/remove one element in the heap in each step, the time complexity of the above algorithm will be O(N<em>M</em>logK)<em>O</em>(<em>N</em>∗<em>M</em>∗<em>l<strong>o</strong>g**K</em>) where ‘N’ and ‘M’ are the total number of elements in both arrays, respectively.</p>
<p>If we assume that both arrays have at least ‘K’ elements then the time complexity can be simplified to O(K^2logK)<em>O</em>(<em>K</em>2<em>l<strong>o</strong>g**K</em>), because we are not iterating more than ‘K’ elements in both arrays.</p>
<h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity #"></a>Space complexity <a href="https://www.educative.io/courses/grokking-the-coding-interview/N767x7VoYmK#space-complexity" target="_blank" rel="noopener">#</a></h4><p>The space complexity will be O(K)<em>O</em>(<em>K</em>) because, at any time, our <strong>Min Heap</strong> will be storing ‘K’ largest pairs.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">int</span>[]&gt; findKLargestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;((p1, p2) -&gt; (p1[<span class="number">0</span>] + p1[<span class="number">1</span>]) - (p2[<span class="number">0</span>] + p2[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.length &amp;&amp; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minHeap.size() &lt; k) &#123;</span><br><span class="line">                minHeap.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; nums1[i], nums2[j] &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// if the sum of the two numbers from the two arrays is smaller than the smallest (top) element of the heap, we can 'break' here. Since the arrays are sorted in the descending order, we'll not be able to find a pair with a higher sum moving forward.</span></span><br><span class="line">                <span class="keyword">if</span> (nums1[i] + nums2[j] &lt; minHeap.peek()[<span class="number">0</span>] + minHeap.peek()[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// else: we have a pair with a larger sum, remove top and insert this pair in the heap</span></span><br><span class="line">                    minHeap.poll();</span><br><span class="line">                    minHeap.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; nums1[i], nums2[j] &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(minHeap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🌕Unsolved-373-Find-K-Pairs-with-Smallest-Sums🎂"><a href="#🌕Unsolved-373-Find-K-Pairs-with-Smallest-Sums🎂" class="headerlink" title="🌕Unsolved 373. Find K Pairs with Smallest Sums🎂"></a><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/?utm_source=AlgoTogether&utm_campaign=05bc9f4051-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_4&utm_medium=email&utm_term=0_38d4e2e3e2-05bc9f4051-231340480" target="_blank" rel="noopener">🌕Unsolved 373. Find K Pairs with Smallest Sums🎂</a></h3><h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><p><img src="https://cloud.githubusercontent.com/assets/8743900/17332795/0bb46cfe-589e-11e6-90b5-5d3c9696c4f0.png" alt=""></p>
<ol>
<li><p>Use min_heap to keep track on next minimum pair sum, and we only need to maintain K possible candidates in the data structure.</p>
<p>Some observations: For every numbers in nums1, its best partner(yields min sum) always strats from nums2[0] since arrays are all sorted; And for a specific number in nums1, its next candidate sould be <strong>[this specific number]</strong> + <strong>nums2[current_associated_index + 1]</strong>, unless out of boundary;)</p>
</li>
<li><p>The run time complexity is O(kLogk) since que.size &lt;= k and we do at most k loop.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// min queue, sorted by pair sum</span></span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (a[<span class="number">0</span>] + a[<span class="number">1</span>]) - (b[<span class="number">0</span>] + b[<span class="number">1</span>]));</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">int</span> N1 = nums1.length, N2 = nums2.length;</span><br><span class="line">    <span class="keyword">if</span> (N1 == <span class="number">0</span> || N2 == <span class="number">0</span>) <span class="keyword">return</span> res; <span class="comment">// no pairs to form, just return an empty res list</span></span><br><span class="line">    <span class="comment">// offer initial pairs &#123;num1, num2, index_of_num2&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(N1, k); i++) q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums1[i], nums2[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="comment">// get 1st k elem into result, each time, offer potential better pairs into queue</span></span><br><span class="line">    <span class="comment">// if there r not enough pair, just return all pairs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(N1 * N2, k); i++) &#123;</span><br><span class="line">        <span class="comment">// get the best pair and put into res</span></span><br><span class="line">        <span class="keyword">int</span>[] cur = q.poll();</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cur[<span class="number">0</span>], cur[<span class="number">1</span>]&#125;);</span><br><span class="line">        <span class="comment">// next better pair could with be A: &#123;after(num1), num2&#125; or B: &#123;num1. after(num2)&#125;</span></span><br><span class="line">        <span class="comment">// for A, we've already added top possible k into queue, so A is either in the queue already, or not qualified</span></span><br><span class="line">        <span class="comment">// for B, it might be a better choice, so we offer it into queue</span></span><br><span class="line">        <span class="keyword">if</span> (cur[<span class="number">2</span>] &lt; N2 - <span class="number">1</span> ) &#123; <span class="comment">// still at least one elem after num2 in array nums2</span></span><br><span class="line">            <span class="keyword">int</span> idx = cur[<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">            q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cur[<span class="number">0</span>], nums2[idx], idx&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：最小的组合一定是排的较靠前的数字的组合，用最小堆保存最小值，遍历所有可能。先取一个数组的首 元素和另一数组每个元素两两结合，放入最小堆，可以证明堆中是小和值就是所有和值中最小。然后每次取出 当前对后，把第一个数组对应的值换成其下一个数，组成新对再放入堆。这个和值就是第二个数组对应数与所 有第一个数组中数和值中仅小于当前第一数组对应值的和值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Pair</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Pair that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sum - that.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    PriorityQueue&lt;Pair&gt; pQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len1 = nums1.length, len2 = nums2.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line">        pQueue.offer(<span class="keyword">new</span> Pair(<span class="number">0</span>, i, nums1[<span class="number">0</span>] + nums2[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(k, len1 * len2); i++) &#123;</span><br><span class="line">        Pair p = pQueue.poll();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(nums1[p.x]);</span><br><span class="line">        list.add(nums2[p.y]);</span><br><span class="line">        result.add(list);</span><br><span class="line">        <span class="keyword">if</span> (p.x == len1 - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        pQueue.offer(<span class="keyword">new</span> Pair(p.x + <span class="number">1</span>, p.y, nums1[p.x + <span class="number">1</span>] + nums2[p.y]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h1><h2 id="Bubble-Sort-AE"><a href="#Bubble-Sort-AE" class="headerlink" title="Bubble Sort(AE)"></a>Bubble Sort(AE)</h2><p>Bubble sort do not use other helper array</p>
<p>O(N^2) T</p>
<p>O(1) S</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;  <span class="comment">//&lt; array.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++) &#123;  <span class="comment">//i表示右侧排序后的固定的长度，逐渐增加</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Insertion-Sort-AE"><a href="#Insertion-Sort-AE" class="headerlink" title="Insertion Sort(AE)"></a>Insertion Sort(AE)</h2><p><img src="https://static.javatpoint.com/corebasic/programs/images/insertion-sort.png" alt=""></p>
<h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comaparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--)</span><br><span class="line">                exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;  <span class="comment">//edge case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j] &lt; array[j - <span class="number">1</span>]) &#123;  <span class="comment">//以j = i为起点向前进行比较交换</span></span><br><span class="line">            <span class="keyword">int</span> temp = array[j - <span class="number">1</span>];</span><br><span class="line">            array[j - <span class="number">1</span>] = array[j];</span><br><span class="line">            array[j] = temp;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Selection-Sort-AE-💜"><a href="#🌕Selection-Sort-AE-💜" class="headerlink" title="🌕Selection Sort(AE)💜"></a>🌕Selection Sort(AE)💜</h2><p>traverse整个array， 把最小的元素更新到pointer处，traverse完的左边部分就是sorted的</p>
<h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (less(a[i], a[min])) min = j;</span><br><span class="line">            exch(a, j, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;   <span class="comment">//edge case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = array[i];  <span class="comment">//mark the first element in unsorted array</span></span><br><span class="line">        <span class="keyword">int</span> minIdx = i;  <span class="comment">//mark the index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;  <span class="comment">//find the smallest in the unsorted array</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; min) &#123;</span><br><span class="line">                min = array[j];</span><br><span class="line">                minIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIdx != i) &#123;</span><br><span class="line">            array[minIdx] = array[i];</span><br><span class="line">            array[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Quick-Sort-AE-✨"><a href="#🌕Quick-Sort-AE-✨" class="headerlink" title="🌕Quick Sort(AE)✨"></a>🌕Quick Sort(AE)✨</h2><h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">array : [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">take <span class="number">8</span> as pivit</span><br><span class="line">array : [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">         p L         R</span><br><span class="line">L &lt; P and R &lt; P, leave it here</span><br><span class="line">keep moving</span><br><span class="line">array : [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">         p     L     R</span><br><span class="line">L = <span class="number">9</span> &gt; P, swap(L, R)</span><br><span class="line">array : [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">         p       L R</span><br><span class="line">array : [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">         p         R</span><br><span class="line">                   L</span><br><span class="line">array : [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">         p         R L</span><br><span class="line">when R &lt; L, swap(P, R)</span><br><span class="line">array : [<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">         p         R L</span><br><span class="line">apply same technique to two subarray recursively</span><br><span class="line">[<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], [<span class="number">9</span>]</span><br><span class="line">[<span class="number">9</span>] only one ele, is base line so fixed it</span><br><span class="line">subarray : [<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">            p L     R</span><br><span class="line">subarray : [<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">            p   L   R</span><br><span class="line">subarray : [<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">            p     L R</span><br><span class="line">subarray : [<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">            p       R</span><br><span class="line">                    L</span><br><span class="line">subarray : [<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>] <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">            p       R</span><br><span class="line">                       L</span><br><span class="line">when R &lt; L, swap(P, R)</span><br><span class="line">subarray : [<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>] <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">then apply to [<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">subarray : [<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="number">6</span> <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">            p L   R</span><br><span class="line">L &lt;= P, keep moving L</span><br><span class="line">subarray : [<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="number">6</span> <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">            p   L R</span><br><span class="line">subarray : [<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="number">6</span> <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">            p     R</span><br><span class="line">                  L</span><br><span class="line">subarray : [<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="number">6</span> <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">            p     R  L</span><br><span class="line">when R &lt; L, swap(P, R)</span><br><span class="line">subarray : [<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>] <span class="number">5</span>, <span class="number">6</span> <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">            p L R</span><br><span class="line">L &gt; P, R &lt; P,swap(L, R)</span><br><span class="line">subarray : [<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>] <span class="number">5</span>, <span class="number">6</span> <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">            p L R</span><br><span class="line">L &lt; P, moving L; R &gt; P, moving R </span><br><span class="line">subarray : [<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>] <span class="number">5</span>, <span class="number">6</span> <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">            p R L</span><br><span class="line">when R &lt; L, swap(P, R)</span><br><span class="line">subarray : [<span class="number">2</span>,<span class="number">3</span>] <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span> <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">now two subarray is [<span class="number">2</span>], [<span class="number">5</span>], base line fixed them directly</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Quick always apply to shorter subarray first, then another one</p>
</li>
<li><p>Best: O(n log n) time | O(log n) space</p>
<p>Average: O(n log n) time | O(log n) space</p>
<p>Worst: O(n ^ 2) time | O(log n) space</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> p = partition(a, lo, hi);</span><br><span class="line">        sort(a, lo, p - <span class="number">1</span>);</span><br><span class="line">        sort(a, p + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo+<span class="number">1</span>, j = hi;</span><br><span class="line">        Comparable p = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; p &amp;&amp; a[j] &lt; p)</span><br><span class="line">                exch(a, i, j);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= p) i++;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt;= p) j--;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)  <span class="comment">//base line, can not produce 2 pointers, left = start+1, right = end</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = start;</span><br><span class="line">    <span class="keyword">int</span> left = start + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = end;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[left] &gt; array[pivot] &amp;&amp; array[right] &lt; array[pivot]) &#123;</span><br><span class="line">            swap(left, right, array);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[left] &lt;= array[pivot]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[right] &gt;= array[pivot]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(pivot, right, array);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//find the smaller subarray</span></span><br><span class="line">    <span class="keyword">boolean</span> leftSubarrayIsSmaller = right - <span class="number">1</span> - start &lt; end - (right + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (leftSubarrayIsSmaller) &#123;</span><br><span class="line">        quickSort(array, start, right - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, right + <span class="number">1</span>, end);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quickSort(array, right + <span class="number">1</span>, end);</span><br><span class="line">        quickSort(array, start, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[j];</span><br><span class="line">    array[j] = array[i];</span><br><span class="line">    array[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Merge-Sort-Arrays-AE"><a href="#Merge-Sort-Arrays-AE" class="headerlink" title="Merge Sort Arrays(AE)"></a>Merge Sort Arrays(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="🌕Merge-Sort-AE-✨"><a href="#🌕Merge-Sort-AE-✨" class="headerlink" title="🌕Merge Sort(AE) ✨"></a>🌕Merge Sort(AE) ✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">divide and conquer</span><br><span class="line">array : [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">midIdx = (<span class="number">0</span> + <span class="number">6</span>) / <span class="number">2</span> = <span class="number">3</span></span><br><span class="line">subarray : [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">9</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">recursively call merge sort to subarray</span><br><span class="line">[<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">9</span>] -&gt; [<span class="number">8</span>, <span class="number">5</span>] , [<span class="number">2</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">5</span>] -&gt; [<span class="number">8</span>], [<span class="number">5</span>] base line, merge it to [<span class="number">5</span>, <span class="number">8</span>] (sorted)</span><br><span class="line">[<span class="number">2</span>, <span class="number">9</span>] -&gt; [<span class="number">2</span>], [<span class="number">9</span>] base line, merge it to [<span class="number">2</span>, <span class="number">9</span>] (sorted)</span><br><span class="line">merge to [<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>] (sorted)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">do</span> same thing to another subarray</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>] -&gt; [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">3</span>] base line</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>] -&gt; [<span class="number">5</span>], [<span class="number">6</span>] base line, merge it to [<span class="number">5</span>, <span class="number">6</span>] (sorted)</span><br><span class="line">merge to [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>] (sorted)</span><br><span class="line"></span><br><span class="line">merge to [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>] (sorted)</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comaparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comaparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);</span><br><span class="line">        sort(a, mid+<span class="number">1</span>, hi);</span><br><span class="line">        merge(a, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Cpmparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//将a[lo..mid] 和 a[mid+1..hi] 归并</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[i], aux[j])) a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">//edge case</span></span><br><span class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = array.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] left = Arrays.copyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">    <span class="keyword">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">    <span class="keyword">return</span> mergeSortedArrays(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSortedArrays(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[i] &lt;= right[j]) &#123;</span><br><span class="line">            sortedArray[k++] = left[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sortedArray[k++] = right[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; left.length) &#123;</span><br><span class="line">        sortedArray[k++] = left[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; right.length) &#123;</span><br><span class="line">        sortedArray[k++] = right[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3:"></a>Solution3:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] auxiliaryArray = array.clone();</span><br><span class="line">    mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>, auxiliaryArray)</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] mainArray, <span class="keyword">int</span> startIdx, <span class="keyword">int</span> endIdx, <span class="keyword">int</span>[] auxiliaryArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIdx == endIdx)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = startIdx + (endIdx - startIdx) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(auxiliaryArray, startIdx, mid, mainArray);</span><br><span class="line">    mergeSort(auxiliaryArray, mid + <span class="number">1</span>, endIdx, mainArray);</span><br><span class="line">    doMerge(mainArray, startIdx, mid, endIdx, auxiliaryArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doMerge</span><span class="params">(<span class="keyword">int</span>[] mainArray, <span class="keyword">int</span> startIdx, <span class="keyword">int</span> mid, <span class="keyword">int</span> endIdx, <span class="keyword">int</span>[] auxiliaryArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = startIdx;</span><br><span class="line">    <span class="keyword">int</span> i = startIdx;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt; endIdx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (auxiliaryArray[i] &lt;= auxiliaryArray[j]) &#123;</span><br><span class="line">            mainArray[k++] = auxiliaryArray[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mainArray[k++] = auxiliaryArray[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        mainArray[k++] = auxiliaryArray[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= endIdx) &#123;</span><br><span class="line">        mainArray[k++] = auxiliaryArray[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Heap-Sort-AE"><a href="#Heap-Sort-AE" class="headerlink" title="Heap Sort(AE)"></a>Heap Sort(AE)</h2><h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">array : [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">unsorted:[<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">sorted: []</span><br><span class="line">[<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">swap(<span class="number">9</span>, <span class="number">3</span>)</span><br><span class="line">[<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,| <span class="number">9</span>] the rightpaet of | is sorted</span><br><span class="line">sift down <span class="number">3</span></span><br><span class="line">[<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,| <span class="number">9</span>]</span><br><span class="line">[<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,| <span class="number">9</span>]</span><br><span class="line">swap(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">[<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,| <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">sift down <span class="number">2</span></span><br><span class="line">[<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,| <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">swap(<span class="number">6</span>,<span class="number">5</span>)</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,| <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">sift down <span class="number">5</span></span><br><span class="line">child <span class="number">5</span> and <span class="number">2</span> both &lt;= <span class="number">5</span>, so <span class="keyword">do</span> nothing</span><br><span class="line">swap(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">[<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,| <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">sift down <span class="number">3</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,| <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">swap(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,| <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">sift down <span class="number">2</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">2</span>,| <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">swap(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,| <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Best: O(n log n) time | O(1) space</p>
<p>Average: O(n log n) time | O(1) space</p>
<p>Worst: O(n log n) time | O(1) space</p>
</li>
<li><p>Built a max-heap, O(n) time, sift down n time which is log n time, so totally O(n log n) </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    buildMaxHeap(array);</span><br><span class="line">    <span class="comment">//keep swap the last node and first node, then sift down</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> endIdx = array.length - <span class="number">1</span>; endIdx &gt; <span class="number">0</span>; endIdx--) &#123;</span><br><span class="line">        swap(<span class="number">0</span>, endIdx, array);</span><br><span class="line">        siftDown(<span class="number">0</span>, endIdx - <span class="number">1</span>, array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstParentIdx = (array.length - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> currentIdx = firstParentIdx; currentIdx &gt;= <span class="number">0</span>; currentIdx--) &#123;</span><br><span class="line">        siftDown(currentIdx, array.length - <span class="number">1</span>, array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> currentIdx, <span class="keyword">int</span> endIdx, <span class="keyword">int</span>[] heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childOneIdx = currentIdx * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (childOneIdx &lt;= endIdx) &#123;</span><br><span class="line">        <span class="keyword">int</span> childTwoIdx = currentIdx * <span class="number">2</span> + <span class="number">2</span> &lt;= endIdx ? currentIdx * <span class="number">2</span> + <span class="number">2</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> idxToSwap;</span><br><span class="line">        <span class="keyword">if</span> (childTwoIdx != -<span class="number">1</span> &amp;&amp; heap[childTwoIdx] &gt; heap[childOneIdx]) &#123;</span><br><span class="line">            idxToSwap = childTwoIdx;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            idxToSwap = childOneIdx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap[idxToSwap] &gt; heap[currentIdx]) &#123;</span><br><span class="line">            swap(currentIdx, idxToSwap, heap);</span><br><span class="line">            currentIdx = idxToSwap;</span><br><span class="line">            childOneIdx = currentIdx * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[j];</span><br><span class="line">    array[j] = array[i];</span><br><span class="line">    array[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用于求解 <strong>TopK Elements</strong> 问题，也就是 K 个最小元素的问题。可以维护一个大小为 K 的最小堆，最小堆中的元素就是最小元素。最小堆需要使用大顶堆来实现，大顶堆表示堆顶元素是堆中最大元素。这是因为我们要得到 k 个最小的元素，因此当遍历到一个新的元素时，需要知道这个新元素是否比堆中最大的元素更小，更小的话就把堆中最大元素去除，并将新元素添加到堆中。所以我们需要很容易得到最大元素并移除最大元素，大顶堆就能很好满足这个要求。</p>
<p>堆也可以用于求解 Kth Element 问题，得到了大小为 k 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 k 大的元素。</p>
<p>快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。</p>
<p>可以看到，快速选择和堆排序都可以求解 Kth Element 和 Top K Elements 问题。</p>
<h2 id="912-Sort-an-Array✨"><a href="#912-Sort-an-Array✨" class="headerlink" title="912. Sort an Array✨"></a><a href="https://leetcode.com/problems/sort-an-array/" target="_blank" rel="noopener">912. Sort an Array✨</a></h2><h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Selection Sort</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">//selection</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(nums[j], nums[min])) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(nums, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Quick Sort</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = partition(nums, lo, hi);</span><br><span class="line">    quickSort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo+<span class="number">1</span>, j = hi;</span><br><span class="line">    <span class="keyword">int</span> p = nums[lo];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; p &amp;&amp; nums[j] &lt; p)&#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= p) i++;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt;= p) j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, lo, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3-1"><a href="#Solution3-1" class="headerlink" title="Solution3:"></a>Solution3:</h3><ol>
<li>Merge Sort</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] aux;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    aux = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, lo, mid);</span><br><span class="line">    mergeSort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        aux[k] = nums[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) nums[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) nums[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[i], aux[j])) nums[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> nums[k] = aux[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-969-Pancake-Sorting💜"><a href="#🌕Unsolved-969-Pancake-Sorting💜" class="headerlink" title="🌕Unsolved 969. Pancake Sorting💜"></a><a href="https://leetcode.com/problems/pancake-sorting/" target="_blank" rel="noopener">🌕Unsolved 969. Pancake Sorting💜</a></h2><h3 id="Solution1-19"><a href="#Solution1-19" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Find the largest number</li>
<li>Flip twice to the tail</li>
</ol>
<p>Time: O(N^2)<br>Flips: 2*N</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">pancakeSort</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = A.length, largest = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = find(A, largest);</span><br><span class="line">        flip(A, index);</span><br><span class="line">        flip(A, largest - <span class="number">1</span>);</span><br><span class="line">        result.add(index + <span class="number">1</span>);</span><br><span class="line">        result.add(largest--);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = index;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = A[i];</span><br><span class="line">        A[i++] = A[j];</span><br><span class="line">        A[j--] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-10"><a href="#Solution2-10" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><strong>Explanation</strong><br>Find the index <code>i</code> of the next maximum number <code>x</code>.<br>Reverse <code>i + 1</code> numbers, so that the <code>x</code> will be at <code>A[0]</code><br>Reverse <code>x</code> numbers, so that <code>x</code> will be at <code>A[x - 1]</code>.<br>Repeat this process <code>N</code> times.</li>
<li>Update:<br>Actually, I didn’t use the condition permutation of <code>[1,2,..., A.length]</code>.<br>I searched in the descending order of <code>A</code>.</li>
<li>Time Complexity: O(N^2)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">pancakeSort</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = A.length;</span><br><span class="line">    <span class="comment">//len is the total elements in the current array which are unsorted</span></span><br><span class="line">    <span class="comment">//through each iteration of while loop, we try to set the current max element to the len-1 position</span></span><br><span class="line">    <span class="comment">//and also decrease len by 1</span></span><br><span class="line">    <span class="keyword">while</span>(len&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = A[<span class="number">0</span>], index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//find the index of the max element in current unsorted part of the array; up to len</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;max) &#123;</span><br><span class="line">                max = A[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//if max is at last position, no need to do any flips</span></span><br><span class="line">        <span class="keyword">if</span>(index==len-<span class="number">1</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//reverse the string till max index so max comes to the front</span></span><br><span class="line">        result.add(index+<span class="number">1</span>);</span><br><span class="line">        reverse(A, index+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//then reverse it till size of the current unsorted array</span></span><br><span class="line">        result.add(len);</span><br><span class="line">        reverse(A, len);</span><br><span class="line">        len--;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = A[left];</span><br><span class="line">        A[left++] = A[right];</span><br><span class="line">        A[right--] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕1122-Relative-Sort-Array⭐"><a href="#🌕1122-Relative-Sort-Array⭐" class="headerlink" title="🌕1122. Relative Sort Array⭐"></a><a href="https://leetcode.com/problems/relative-sort-array/submissions/" target="_blank" rel="noopener">🌕1122. Relative Sort Array⭐</a></h2><h3 id="Solution1-20"><a href="#Solution1-20" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time: O(max(n2, N)), space: O(N), where n2 = arr2.length, N = max(arr2).</li>
<li>Sort arr1 based on arr2 secquence</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] relativeSortArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1001</span>], ans = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr1)                      <span class="comment">// Count each number in arr1.</span></span><br><span class="line">        ++cnt[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr2)                      <span class="comment">// Sort the common numbers in both arrays by the order of arr2.</span></span><br><span class="line">        <span class="keyword">while</span> (cnt[i]-- &gt; <span class="number">0</span>)</span><br><span class="line">            ans[k++] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; ++i)          <span class="comment">// Sort the numbers only in arr1.</span></span><br><span class="line">        <span class="keyword">while</span> (cnt[i]-- &gt; <span class="number">0</span>)</span><br><span class="line">            ans[k++] = i;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Follow-up: What if this constraint <code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code> doesn’t exist?</strong></p>
<p>Use TreeMap.</p>
<p>Time: O(NlogN)<br>Space: O(N)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] relativeSortArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : arr1) map.put(n, map.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : arr2) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map.get(n); j++) &#123;</span><br><span class="line">            arr1[i++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        map.remove(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : map.keySet())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map.get(n); j++) &#123;</span><br><span class="line">            arr1[i++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Quick-Select快速选择"><a href="#Quick-Select快速选择" class="headerlink" title="Quick Select快速选择"></a>Quick Select快速选择</h1><p>用于求解 <strong>Kth Element</strong> 问题，也就是第 K 个元素的问题。</p>
<p>可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N2)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSelector</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * select the kth smallest element in arr</span></span><br><span class="line"><span class="comment">     *  0 &lt;= k &lt; arr.length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickselect(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickselect</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, from, to);</span><br><span class="line">        <span class="keyword">if</span>(index-from == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index-from &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> quickselect(arr, from, index-<span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> quickselect(arr, index+<span class="number">1</span>, to, k-(index-from+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[from];</span><br><span class="line">        <span class="keyword">int</span> i = from+<span class="number">1</span>, j = to;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; arr[j] &gt;= pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= j) &#123;</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, from, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a>215. Kth Largest Element in an Array</h2><p>Personally, the most straightforward way is to use quick select. There is a simple conversion: Find kith largest element is equivalent to find (n - k)th smallest element in array. It is worth mentioning that (n - k) is the real index (start from 0) of an element.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>, index = nums.length - k;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = partion(nums, start, end);</span><br><span class="line">        <span class="keyword">if</span> (pivot &lt; index) start = pivot + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pivot &gt; index) end = pivot - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nums[pivot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partion</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = start, temp;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end &amp;&amp; nums[start] &lt;= nums[pivot]) start++;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end &amp;&amp; nums[end] &gt; nums[pivot]) end--;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">break</span>;</span><br><span class="line">        temp = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = nums[end];</span><br><span class="line">    nums[end] = nums[pivot];</span><br><span class="line">    nums[pivot] = temp;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Heap-优先队列-堆"><a href="#Heap-优先队列-堆" class="headerlink" title="Heap 优先队列/堆"></a>Heap 优先队列/堆</h1><h2 id="1710-Maximum-Units-on-a-Truck⭐"><a href="#1710-Maximum-Units-on-a-Truck⭐" class="headerlink" title="1710. Maximum Units on a Truck⭐"></a><a href="https://leetcode.com/problems/maximum-units-on-a-truck/" target="_blank" rel="noopener">1710. Maximum Units on a Truck⭐</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: boxTypes &#x3D; [[1,3],[2,2],[3,1]], truckSize &#x3D; 4</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: There are:</span><br><span class="line">- 1 box of the first type that contains 3 units.</span><br><span class="line">- 2 boxes of the second type that contain 2 units each.</span><br><span class="line">- 3 boxes of the third type that contain 1 unit each.</span><br><span class="line">You can take all the boxes of the first and second types, and one box of the third type.</span><br><span class="line">The total number of units will be &#x3D; (1 * 3) + (2 * 2) + (1 * 1) &#x3D; 8.</span><br></pre></td></tr></table></figure>

<h3 id="Solution0-1"><a href="#Solution0-1" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>brute force</li>
<li>Time Complexity : \mathcal{O}(n^{2})O(<em>n</em>2), where n<em>n</em> is the number of elements in array <code>boxTypes</code>. In the method <code>findMaxUnitBox</code>, we are iterating over all the elements in array <code>boxTypes</code> to find the maximum units. In the worst case, when all the boxes are added to the truck we would iterate <code>n</code> times over the array of size <code>n</code>. This would give total time complexity as \mathcal{O}(n^{2})O(<em>n</em>2).</li>
<li>Space Complexity: \mathcal{O}(1)O(1), as we are using constant extra space to maintain the variables <code>remainingTruckSize</code> and <code>unitCount</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumUnits</span><span class="params">(<span class="keyword">int</span>[][] boxTypes, <span class="keyword">int</span> truckSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unitCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> remainingTruckSize = truckSize;</span><br><span class="line">    <span class="keyword">while</span> (remainingTruckSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxUnitBoxIndex = findMaxUnitBox(boxTypes);</span><br><span class="line">        <span class="comment">// check if all boxes are used</span></span><br><span class="line">        <span class="keyword">if</span> (maxUnitBoxIndex == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// find the box count that can be put in truck</span></span><br><span class="line">        <span class="keyword">int</span> boxCount = Math.min(remainingTruckSize, boxTypes[maxUnitBoxIndex][<span class="number">0</span>]);</span><br><span class="line">        unitCount += boxCount * boxTypes[maxUnitBoxIndex][<span class="number">1</span>];</span><br><span class="line">        remainingTruckSize -= boxCount;</span><br><span class="line">        <span class="comment">// mark box with index maxUnitBoxIndex as used</span></span><br><span class="line">        boxTypes[maxUnitBoxIndex][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unitCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxUnitBox</span><span class="params">(<span class="keyword">int</span>[][] boxTypes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxUnitBoxIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxUnits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; boxTypes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (boxTypes[i][<span class="number">1</span>] &gt; maxUnits) &#123;</span><br><span class="line">            maxUnits = boxTypes[i][<span class="number">1</span>];</span><br><span class="line">            maxUnitBoxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxUnitBoxIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-21"><a href="#Solution1-21" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Time Complexity : \mathcal{O}(n \log n)O(<em>n</em>log<em>n</em>), where n<em>n</em> is the number of elements in array <code>boxTypes</code>.</p>
<p>We are adding all the elements of the array <code>boxTypes</code> in the priority queue, which takes \mathcal{O}(n)O(<em>n</em>) time.</p>
<p>Post that, we would continue iteration until queue is not empty or remaining truck size is greater than 00. In worst case, we might end up iterating n<em>n</em> times. Also, removing elements from queue would take (\log n)(log<em>n</em>) time. This gives us time complexity as \mathcal{O}(n \log n) + \mathcal{O}(n) = \mathcal{O}(n \log n)O(<em>n</em>log<em>n</em>)+O(<em>n</em>)=O(<em>n</em>log<em>n</em>).</p>
</li>
<li><p>Space Complexity: \mathcal{O}(n)O(<em>n</em>), as we use a queue of size n<em>n</em>.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumUnits</span><span class="params">(<span class="keyword">int</span>[][] boxTypes, <span class="keyword">int</span> truckSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;((a, b) -&gt; (b[<span class="number">1</span>] - a[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] box : boxTypes) &#123;</span><br><span class="line">        heap.add(box);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(truckSize-- &gt; <span class="number">0</span> &amp;&amp; !heap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = heap.poll();</span><br><span class="line">        max += cur[<span class="number">1</span>];</span><br><span class="line">        cur[<span class="number">0</span>]--;</span><br><span class="line">        <span class="keyword">if</span> (cur[<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            heap.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="973-K-Closest-Points-to-Origin⭐"><a href="#973-K-Closest-Points-to-Origin⭐" class="headerlink" title="973. K Closest Points to Origin⭐"></a><a href="https://leetcode.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. K Closest Points to Origin⭐</a></h2><h3 id="Solution0-2"><a href="#Solution0-2" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Sort</li>
<li>Time : O(n log n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">    Arrays.sort(points, (p1, p2) -&gt; p1[<span class="number">0</span>] * p1[<span class="number">0</span>] + p1[<span class="number">1</span>] * p1[<span class="number">1</span>] - p2[<span class="number">0</span>] * p2[<span class="number">0</span>] - p2[<span class="number">1</span>] * p2[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(points, <span class="number">0</span>, K);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">    <span class="keyword">int</span> N = points.length;</span><br><span class="line">    <span class="keyword">int</span>[] dists = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        dists[i] = dist(points[i]);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(dists);</span><br><span class="line">    <span class="keyword">int</span> distK = dists[K-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//creat ans to save pointer which dist &lt;= distK</span></span><br><span class="line">    <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">if</span> (dist(points[i]) &lt;= distK)</span><br><span class="line">            ans[idx++] = points[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span>[] point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> point[<span class="number">0</span>] * point[<span class="number">0</span>] + point[<span class="number">1</span>] * point[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-22"><a href="#Solution1-22" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Heap</li>
<li>O(n log k)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (b[<span class="number">0</span>] * b[<span class="number">0</span>] + b[<span class="number">1</span>]* b[<span class="number">1</span>]) - (a[<span class="number">0</span>]*a[<span class="number">0</span>] + a[<span class="number">1</span>]*a[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] point : points) &#123;</span><br><span class="line">        maxHeap.add(point);</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() &gt; K) &#123;</span><br><span class="line">            maxHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (K-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans[K] = maxHeap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-Solution2-1"><a href="#Unsolved-Solution2-1" class="headerlink" title="Unsolved Solution2:"></a>Unsolved Solution2:</h3><p><a href="https://leetcode.com/problems/k-closest-points-to-origin/discuss/220235/Java-Three-solutions-to-this-classical-K-th-problem" target="_blank" rel="noopener">https://leetcode.com/problems/k-closest-points-to-origin/discuss/220235/Java-Three-solutions-to-this-classical-K-th-problem</a>.</p>
<p>The last solution is based on quick sort, we can also call it <strong>quick select</strong>. In the quick sort, we will always choose a pivot to compare with other elements. After one iteration, we will get an array that all elements smaller than the pivot are on the left side of the pivot and all elements greater than the pivot are on the right side of the pviot (assuming we sort the array in ascending order). So, inspired from this, each iteration, we choose a pivot and then find the position <strong>p</strong> the pivot should be. Then we compare <strong>p</strong> with the <strong>K</strong>, if the <strong>p</strong> is smaller than the <strong>K</strong>, meaning the all element on the left of the pivot are all proper candidates but it is not adequate, we have to do the same thing on right side, and vice versa. If the <strong>p</strong> is exactly equal to the <strong>K</strong>, meaning that we’ve found the K-th position. Therefore, we just return the first K elements, since they are not greater than the pivot.</p>
<p><strong>Theoretically</strong>, the average time complexity is <strong>O(N)</strong> , but just like quick sort, in the worst case, this solution would be degenerated to <strong>O(N^2)</strong>, and <strong>pratically</strong>, the real time it takes on leetcode is <strong>15ms</strong>.</p>
<p>The <strong>advantage</strong> of this solution is it is very efficient.<br>The <strong>disadvatage</strong> of this solution are it is neither an online solution nor a stable one. And the K elements closest are <strong>not sorted</strong> in ascending order.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">    <span class="keyword">int</span> len =  points.length, l = <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = helper(points, l, r);</span><br><span class="line">        <span class="keyword">if</span> (mid == K) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; K) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(points, <span class="number">0</span>, K);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[][] A, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] pivot = A[l];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; compare(A[r], pivot) &gt;= <span class="number">0</span>) r--;</span><br><span class="line">        A[l] = A[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; compare(A[l], pivot) &lt;= <span class="number">0</span>) l++;</span><br><span class="line">        A[r] = A[l];</span><br><span class="line">    &#125;</span><br><span class="line">    A[l] = pivot;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] p1, <span class="keyword">int</span>[] p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1[<span class="number">0</span>] * p1[<span class="number">0</span>] + p1[<span class="number">1</span>] * p1[<span class="number">1</span>] - p2[<span class="number">0</span>] * p2[<span class="number">0</span>] - p2[<span class="number">1</span>] * p2[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="767-Reorganize-String⭐"><a href="#767-Reorganize-String⭐" class="headerlink" title="767. Reorganize String⭐"></a><a href="https://leetcode.com/problems/reorganize-string/" target="_blank" rel="noopener">767. Reorganize String⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: S = <span class="string">"aab"</span></span><br><span class="line">Output: <span class="string">"aba"</span></span><br><span class="line">    </span><br><span class="line">Input: S = <span class="string">"aaab"</span></span><br><span class="line">Output: <span class="string">""</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-23"><a href="#Solution1-23" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n logn) | S O(log n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reorganizeString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">        count.put(c, count.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Character&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (count.get(b) - count.get(a)));</span><br><span class="line">    maxHeap.addAll(count.keySet());  <span class="comment">//addAll method</span></span><br><span class="line"></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (maxHeap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> cur = maxHeap.poll();</span><br><span class="line">        <span class="keyword">char</span> next = maxHeap.poll();</span><br><span class="line">        result.append(cur);</span><br><span class="line">        result.append(next);</span><br><span class="line">        count.put(cur, count.get(cur) - <span class="number">1</span>);</span><br><span class="line">        count.put(next, count.get(next) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (count.get(cur) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxHeap.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count.get(next) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxHeap.add(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!maxHeap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">char</span> last = maxHeap.poll();</span><br><span class="line">        <span class="keyword">if</span> (count.get(last) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.append(last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Continuous-Median-AE"><a href="#🌕Continuous-Median-AE" class="headerlink" title="🌕Continuous Median(AE)"></a>🌕Continuous Median(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContinuousMedianHandler</span> </span>&#123;</span><br><span class="line">    Heap lowes = <span class="keyword">new</span> Heap(Heap::Max_VALUE_FUNC, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    Heap greaters = <span class="function">enw <span class="title">Heap</span><span class="params">(Heap::MIN_FUNC, new ArrayList&lt;Integer&gt;()</span>)</span>;</span><br><span class="line">    <span class="keyword">double</span> median = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1046-Last-Stone-Weight✨"><a href="#1046-Last-Stone-Weight✨" class="headerlink" title="1046. Last Stone Weight✨"></a><a href="https://leetcode.com/problems/last-stone-weight/" target="_blank" rel="noopener">1046. Last Stone Weight✨</a></h2><h3 id="Solution1-24"><a href="#Solution1-24" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n log n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt;  b - a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">        heap.add(stone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> stoneOne = heap.poll();</span><br><span class="line">        <span class="keyword">int</span> stoneTwo = heap.poll();</span><br><span class="line">        <span class="keyword">if</span> (stoneOne != stoneTwo) &#123;</span><br><span class="line">            heap.add(stoneOne - stoneTwo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap.isEmpty() ? <span class="number">0</span> : heap.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="215-Kth-Largest-Element-in-an-Array✨"><a href="#215-Kth-Largest-Element-in-an-Array✨" class="headerlink" title="215.Kth Largest Element in an Array✨"></a><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">215.Kth Largest Element in an Array✨</a></h2><p>题目描述：找到倒数第 k 个的元素。</p>
<p>Find the <strong>k</strong>th largest element in an unsorted array. </p>
<p>Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] and k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-25"><a href="#Solution1-25" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路 1：排序后取第 k 大。O(nlogn)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度 O(NlogN)，空间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-11"><a href="#Solution2-11" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Heap 思路 2：维护一个前 k 大的队列，最后弹出第一个元素。O(nlogk)</li>
<li>Time complexity : \mathcal{O}(N \log k)O(<em>N</em>log<em>k</em>).</li>
<li>Space complexity : \mathcal{O}(k)O(<em>k</em>) to store the heap elements.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度 O(NlogK)，空间复杂度 O(K)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// init heap 'the smallest element first'</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap =</span><br><span class="line">        <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; n1 - n2);  <span class="comment">// min heap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// keep k largest elements in the heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">        heap.add(n);</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &gt; k)  <span class="comment">//keep the size of heap is K, min value pop</span></span><br><span class="line">            heap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">return</span> heap.poll();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3-2"><a href="#Solution3-2" class="headerlink" title="Solution3:"></a>Solution3:</h3><ol>
<li>Quick sort 思路 3（略）：类似快速排序，先找出前 k 个数，然后取最大。O(n2 )，平均 O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度 O(N)，空间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k = nums.length - k;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">            l = j + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[++i] &lt; a[l] &amp;&amp; i &lt; h) ;</span><br><span class="line">        <span class="keyword">while</span> (a[--j] &gt; a[l] &amp;&amp; j &gt; l) ;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, l, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕703-Kth-Largest-Element-in-a-Stream✨"><a href="#🌕703-Kth-Largest-Element-in-a-Stream✨" class="headerlink" title="🌕703. Kth Largest Element in a Stream✨"></a><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">🌕703. Kth Largest Element in a Stream✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[<span class="string">"KthLargest"</span>, <span class="string">"add"</span>, <span class="string">"add"</span>, <span class="string">"add"</span>, <span class="string">"add"</span>, <span class="string">"add"</span>]</span><br><span class="line">[[<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]], [<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">10</span>], [<span class="number">9</span>], [<span class="number">4</span>]]</span><br><span class="line">Output</span><br><span class="line">[<span class="keyword">null</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">KthLargest kthLargest = <span class="keyword">new</span> KthLargest(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]);</span><br><span class="line">kthLargest.add(<span class="number">3</span>);   <span class="comment">// return 4  [2,3,4,5,8]</span></span><br><span class="line">kthLargest.add(<span class="number">5</span>);   <span class="comment">// return 5  [3,4,5,5,8]</span></span><br><span class="line">kthLargest.add(<span class="number">10</span>);  <span class="comment">// return 5  [4,5,5,8,10]</span></span><br><span class="line">kthLargest.add(<span class="number">9</span>);   <span class="comment">// return 8  [5,5,8,8,10]</span></span><br><span class="line">kthLargest.add(<span class="number">4</span>);   <span class="comment">// return 8  [5,5,8,8,10]</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-26"><a href="#Solution1-26" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PriorityQueue&lt;Integer&gt; heap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.heap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">this</span>.k = k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        add(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap.size() &lt; k) &#123;</span><br><span class="line">        heap.offer(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; heap.peek()) &#123;</span><br><span class="line">        heap.poll();</span><br><span class="line">        heap.offer(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕1648-Sell-Diminishing-Valued-Colored-Balls✨"><a href="#🌕1648-Sell-Diminishing-Valued-Colored-Balls✨" class="headerlink" title="🌕1648. Sell Diminishing-Valued Colored Balls✨"></a><a href="https://leetcode.com/problems/sell-diminishing-valued-colored-balls/" target="_blank" rel="noopener">🌕1648. Sell Diminishing-Valued Colored Balls✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] inventory, <span class="keyword">int</span> orders)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> in : inventory) &#123;</span><br><span class="line">        map.put(in, map.getOrDefault(in, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        maxProfit = Math.max(maxProfit, in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(orders &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = Math.min(map.get(maxProfit), orders);</span><br><span class="line">        value += count * maxProfit;</span><br><span class="line">        orders -= count;</span><br><span class="line">        map.put(maxProfit, map.get(maxProfit) - count);</span><br><span class="line">        map.put(maxProfit - <span class="number">1</span>, map.getOrDefault(maxProfit - <span class="number">1</span>, <span class="number">0</span>) + count);</span><br><span class="line">        <span class="keyword">if</span> (map.get(maxProfit) == <span class="number">0</span>) &#123;</span><br><span class="line">            map.remove(maxProfit);</span><br><span class="line">            maxProfit--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="🌕Unsolved-502-IPO✨"><a href="#🌕Unsolved-502-IPO✨" class="headerlink" title="🌕Unsolved 502.IPO✨"></a><a href="https://leetcode.com/problems/ipo/?utm_source=AlgoTogether&utm_campaign=05bc9f4051-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_4&utm_medium=email&utm_term=0_38d4e2e3e2-05bc9f4051-231340480" target="_blank" rel="noopener">🌕Unsolved 502.IPO✨</a></h2><h2 id="1686-Stone-Game-VI"><a href="#1686-Stone-Game-VI" class="headerlink" title="1686. Stone Game VI"></a><a href="https://leetcode.com/problems/stone-game-vi/" target="_blank" rel="noopener">1686. Stone Game VI</a></h2><h3 id="Solution1-27"><a href="#Solution1-27" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stoneGameVI</span><span class="params">(<span class="keyword">int</span>[] aliceValues, <span class="keyword">int</span>[] bobValues)</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (b[<span class="number">0</span>] + b[<span class="number">1</span>]) - (a[<span class="number">0</span>] + a[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">int</span> n = aliceValues.length;</span><br><span class="line">    <span class="keyword">int</span> turn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pair = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;aliceValues[i], bobValues[i]&#125;;</span><br><span class="line">        pq.add(pair);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = pq.poll();</span><br><span class="line">        <span class="keyword">if</span> (turn % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            p1 += cur[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p2 += cur[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        turn++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="🌕桶排序"><a href="#🌕桶排序" class="headerlink" title="🌕桶排序"></a>🌕桶排序</h1><h2 id="🌕347-Top-K-Frequent-Elements⭐🎶"><a href="#🌕347-Top-K-Frequent-Elements⭐🎶" class="headerlink" title="🌕347.Top K Frequent Elements⭐🎶"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/description/" target="_blank" rel="noopener">🌕347.Top K Frequent Elements⭐🎶</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>] and k = <span class="number">2</span>, <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>].</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-28"><a href="#Solution1-28" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。</li>
<li>思路：桶排序。因为最大词频不可能超过数组长度，所以所有的频率都会在这个范围内，利用这个数组统计每 一个频次上出现的词的个数，取最大的 k 个（注意要把没有词频信息的排除）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) linear time</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    List&lt;Integer&gt;[] freq = <span class="keyword">new</span> List[n];</span><br><span class="line">    Map&lt;Integer, Integer&gt; freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        freqMap.put(num, freqMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : freqMap.keySet()) &#123;  <span class="comment">//index i means freq</span></span><br><span class="line">        <span class="keyword">int</span> i = freqMap.get(num) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (freq[i] == <span class="keyword">null</span>)</span><br><span class="line">            freq[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        freq[i].add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*explain why linear time even two for loop here</span></span><br><span class="line"><span class="comment">        if bucket size == 0, freq[i] == null</span></span><br><span class="line"><span class="comment">        no inner loop else </span></span><br><span class="line"><span class="comment">        inner loop runs but at most k</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; k; --i)</span><br><span class="line">        <span class="keyword">if</span> (freq[i] != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : freq[i])</span><br><span class="line">                ans[j++] = num;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-12"><a href="#Solution2-12" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Heap</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> heap(堆) 即 PriorityQueue 的用法，记录一下 PriorityQueue&lt;Map.Entry&lt;&gt;&gt; 的基本用法：</span><br><span class="line"> 写法一，直接 <span class="keyword">new</span> 一个Comparator：</span><br><span class="line"> PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; e1, Map.Entry&lt;Integer, Integer&gt; e2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e1.getValue() - e2.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">写法二， 对写法一 优化：</span><br><span class="line">PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((e1, e2) -&gt; e1.getValue() - e2.getValue());</span><br><span class="line"></span><br><span class="line">写法三， 再优化</span><br><span class="line">PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(Map.Entry::getValue));</span><br><span class="line">这里的写法最终得到的 priorityQueue 都是最小堆， 如果需要使用最大对的话，在前两种写法里面要用e2.getValue()-e1.getValue().</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n log k) time</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// O(1) time</span></span><br><span class="line">    <span class="keyword">if</span> (k == nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. build hash map : character and how often it appears</span></span><br><span class="line">    <span class="comment">// O(N) time</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">        count.put(n, count.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init heap the less frequent element first</span></span><br><span class="line">    Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((n1, n2) -&gt; count.get(n1) - count.get(n2));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. keep k top frequent elements in the heap</span></span><br><span class="line">    <span class="comment">// O(N log k) &lt; O(N log N) time</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n: count.keySet()) &#123;</span><br><span class="line">        heap.add(n);</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &gt; k) heap.poll();    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. build an output array</span></span><br><span class="line">    <span class="comment">// O(k log k) time</span></span><br><span class="line">    <span class="keyword">int</span>[] top = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        top[i] = heap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n log n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">//edge case, k == nums.length</span></span><br><span class="line">    <span class="keyword">if</span> (k == nums.length)</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map -&gt; frequency</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pq max heap, can not poll the max value, so size is n not k</span></span><br><span class="line">    Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((n1, n2) -&gt; map.get(n2) - map.get(n1));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> key : map.keySet()) &#123;</span><br><span class="line">        heap.add(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pq -&gt; int[], return</span></span><br><span class="line">    <span class="keyword">int</span>[] topK = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        topK[i] = heap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> topK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="692-Top-K-Frequent-Words⭐🎶"><a href="#692-Top-K-Frequent-Words⭐🎶" class="headerlink" title="692. Top K Frequent Words⭐🎶"></a><a href="https://leetcode.com/problems/top-k-frequent-words/" target="_blank" rel="noopener">692. Top K Frequent Words⭐🎶</a></h2><h3 id="Solution0-3"><a href="#Solution0-3" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Time O(n log n)</li>
<li>Space O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">topKFrequent</span><span class="params">(String[] words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String word : words) &#123;</span><br><span class="line">        map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;(map.keySet());</span><br><span class="line">    Collections.sort(ans, (w1, w2) -&gt; map.get(w1) == map.get(w2) ? w1.compareTo(w2) : map.get(w2) - map.get(w1));</span><br><span class="line">    <span class="keyword">return</span> ans.subList(<span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-29"><a href="#Solution1-29" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>The idea is to keep a count of each word in a HashMap and then insert in a Priority Queue.</li>
<li>While inserting in pq, if the count of two words is same then insert based on string compare of the keys.</li>
<li>Time O(n log k)</li>
<li>Space O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">topKFrequent</span><span class="params">(String[] words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String word : words) &#123;</span><br><span class="line">        map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;String&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((w1, w2) -&gt; map.get(w1) == map.get(w2) ? w2.compareTo(w1) : map.get(w1) - map.get(w2));</span><br><span class="line">    <span class="keyword">for</span> (String word : map.keySet()) &#123;</span><br><span class="line">        heap.add(word);</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">            heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        ans.add(<span class="number">0</span>, heap.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-13"><a href="#Solution2-13" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>bucket sort</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">topKFrequent</span><span class="params">(String[] words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String w: words) &#123;</span><br><span class="line">        map.put(w, map.getOrDefault(w, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        max = Math.max(max, map.get(w));</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt;[] bucket = <span class="keyword">new</span> ArrayList[max + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry: map.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">int</span> fre = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (bucket[fre] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bucket[fre] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[fre].add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = max; i &gt;= <span class="number">0</span> &amp;&amp; res.size() &lt; k; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Collections.sort(bucket[i]);</span><br><span class="line">            res.addAll(bucket[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.subList(<span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="451-Sort-Characters-By-Frequency✨"><a href="#451-Sort-Characters-By-Frequency✨" class="headerlink" title="451. Sort Characters By Frequency✨"></a><a href="https://leetcode.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">451. Sort Characters By Frequency✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="string">"tree"</span></span><br><span class="line">Output:</span><br><span class="line"><span class="string">"eert"</span></span><br><span class="line">Explanation:</span><br><span class="line"><span class="string">'e'</span> appears twice <span class="keyword">while</span> <span class="string">'r'</span> and <span class="string">'t'</span> both appear once.</span><br><span class="line">So <span class="string">'e'</span> must appear before both <span class="string">'r'</span> and <span class="string">'t'</span>. Therefore <span class="string">"eetr"</span> is also a valid answer.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-30"><a href="#Solution1-30" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Bucksort</li>
<li>The logic is very similar to NO.347 and here we just use a map a count and according to the frequency to put it into the right bucket. Then we go through the bucket to get the most frequently character and append that to the final stringbuilder.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray())</span><br><span class="line">        map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Character&gt;[] frequencyBucket = <span class="keyword">new</span> ArrayList[s.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : map.keySet()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = map.get(c);</span><br><span class="line">        <span class="keyword">if</span> (frequencyBucket[f] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            frequencyBucket[f] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        frequencyBucket[f].add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = frequencyBucket.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frequencyBucket[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : frequencyBucket[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                str.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3-3"><a href="#Solution3-3" class="headerlink" title="Solution3:"></a>Solution3:</h3><ol>
<li>And we have normal way using PriorityQueue as follows:<br>according to user “orxanb”, O(nlogm), m is the distinguish character, can be O(1) since only 26 letters. So the overall time complexity should be O(n), the same as the buck sort with less memory use.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    PriorityQueue&lt;Character&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (map.get(b) - map.get(a)));</span><br><span class="line">    maxHeap.addAll(map.keySet());</span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">char</span> current = maxHeap.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.get(current); i++) &#123;</span><br><span class="line">            ans.append(current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3-4"><a href="#Solution3-4" class="headerlink" title="Solution3:"></a>Solution3:</h3><ol>
<li>Follow up</li>
<li>when same frequency we need to maintain the same sequence as the character show in the original string, the solution is add a index as a secondary sort if the frequency is same</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, <span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(c)) map.put(c, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, i&#125;);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] freqAndSeq = map.get(c);</span><br><span class="line">            freqAndSeq[<span class="number">0</span>]++;</span><br><span class="line">            map.put(c, freqAndSeq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Character, <span class="keyword">int</span>[]&gt;&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt;</span><br><span class="line">                                                                        a.getValue()[<span class="number">0</span>] == b.getValue()[<span class="number">0</span>] ? a.getValue()[<span class="number">1</span>] - b.getValue()[<span class="number">1</span>] : b.getValue()[<span class="number">0</span>] - a.getValue()[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    pq.addAll(map.entrySet());</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        Map.Entry&lt;Character, <span class="keyword">int</span>[]&gt; e = pq.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e.getValue()[<span class="number">0</span>]; i++)</span><br><span class="line">            sb.append(e.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h1><h2 id="Time-Planner💙"><a href="#Time-Planner💙" class="headerlink" title="Time Planner💙"></a>Time Planner💙</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input:  slotsA = [[<span class="number">10</span>, <span class="number">50</span>], [<span class="number">60</span>, <span class="number">120</span>], [<span class="number">140</span>, <span class="number">210</span>]]</span><br><span class="line">        slotsB = [[<span class="number">0</span>, <span class="number">15</span>], [<span class="number">60</span>, <span class="number">70</span>]]</span><br><span class="line">        dur = <span class="number">8</span></span><br><span class="line">output: [<span class="number">60</span>, <span class="number">68</span>]</span><br><span class="line"></span><br><span class="line">input:  slotsA = [[<span class="number">10</span>, <span class="number">50</span>], [<span class="number">60</span>, <span class="number">120</span>], [<span class="number">140</span>, <span class="number">210</span>]]</span><br><span class="line">        slotsB = [[<span class="number">0</span>, <span class="number">15</span>], [<span class="number">60</span>, <span class="number">70</span>]]</span><br><span class="line">        dur = <span class="number">12</span></span><br><span class="line">output: []</span><br></pre></td></tr></table></figure>

<h3 id="Solution0-4"><a href="#Solution0-4" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>brute force</li>
<li>O(m * n)</li>
</ol>
<h3 id="Solution1-31"><a href="#Solution1-31" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] meetingPlanner(<span class="keyword">int</span>[][] slotsA, <span class="keyword">int</span>[][] slotsB, <span class="keyword">int</span> dur) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">//pointer ytaver in slotsA</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// slotsB</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; slotsA.length &amp;&amp; j &lt; slotsB.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> startTime = Math.max(slotsA[i][<span class="number">0</span>], slotsB[j][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> endTime = Math.min(slotsA[i][<span class="number">1</span>], slotsB[j][<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// [0, 2], [3, 4]</span></span><br><span class="line">        <span class="comment">//-&gt;start 3, end -&gt; 2</span></span><br><span class="line">        <span class="keyword">if</span> (endTime - startTime &lt; dur) &#123;</span><br><span class="line">            <span class="comment">//can form a tiem slot</span></span><br><span class="line">            <span class="comment">//start &lt; end</span></span><br><span class="line">            <span class="keyword">int</span>[] cur = &#123;startTime, startTime + dur&#125;;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">            <span class="comment">//[60, 120]  i</span></span><br><span class="line">            <span class="comment">//[60, 70]  j++</span></span><br><span class="line">            <span class="comment">//-&gt; [60, 70]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (slotsA[i][<span class="number">1</span>] &gt; slotsB[j][<span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h2 id="1167-Minimum-Cost-to-Connect-Sticks⭐"><a href="#1167-Minimum-Cost-to-Connect-Sticks⭐" class="headerlink" title="1167. Minimum Cost to Connect Sticks⭐"></a><a href="https://leetcode.com/problems/minimum-cost-to-connect-sticks/" target="_blank" rel="noopener">1167. Minimum Cost to Connect Sticks⭐</a></h2><h3 id="Solution1-32"><a href="#Solution1-32" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Greedy</li>
<li>Time complexity : O(N\log{N})<em>O</em>(<em>N</em>log<em>N</em>), where N<em>N</em> is the length of the input array. Let’s break it down:<ul>
<li>Step 1) Adding N<em>N</em> elements to the priority queue will be O(N\log{N})<em>O</em>(<em>N</em>log<em>N</em>).</li>
<li>Step 2) We remove two of the smallest elements and then add one element to the priority queue until we are left with one element. Since each such operation will reduce one element from the priority queue, we will perform N-1<em>N</em>−1 such operations. Now, we know that both <code>add</code> and <code>remove</code> operations take O(\log{N})<em>O</em>(log<em>N</em>) in priority queue, therefore, complexity of this step will be O(N\log{N})<em>O</em>(<em>N</em>log<em>N</em>).</li>
</ul>
</li>
<li>Space complexity : O(N)<em>O</em>(<em>N</em>) since we will store N<em>N</em> elements in our priority queue.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n log n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">connectSticks</span><span class="params">(<span class="keyword">int</span>[] sticks)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stick : sticks) &#123;</span><br><span class="line">        heap.add(stick);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (heap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> stickOne = heap.poll();</span><br><span class="line">        <span class="keyword">int</span> stickTwo = heap.poll();</span><br><span class="line">        <span class="keyword">int</span> sum = stickOne + stickTwo;</span><br><span class="line">        cost += sum;</span><br><span class="line">        heap.add(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕435-Non-overlapping-Intervals✨"><a href="#🌕435-Non-overlapping-Intervals✨" class="headerlink" title="🌕435.  Non-overlapping Intervals✨"></a><a href="https://leetcode.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">🌕435.  Non-overlapping Intervals✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: [<span class="number">1</span>,<span class="number">3</span>] can be removed and the rest of intervals are non-overlapping.</span><br><span class="line"></span><br><span class="line">Input: [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: You need to remove two [<span class="number">1</span>,<span class="number">2</span>] to make the rest of intervals non-overlapping.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-33"><a href="#Solution1-33" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>the problem is the same as “Given a collection of intervals, find the maximum number of intervals that are non-overlapping.” (the classic Greedy problem</li>
<li>Sorting Interval.end in ascending order is O(nlogn), then traverse intervals array to get the maximum number of non-overlapping intervals is O(n). Total is O(nlogn).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; (a[<span class="number">1</span>] - b[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="comment">//count the non overlapping intervals</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= end) &#123;</span><br><span class="line">            end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕1288-Remove-Covered-Intervals🎂✨"><a href="#🌕1288-Remove-Covered-Intervals🎂✨" class="headerlink" title="🌕1288. Remove Covered Intervals🎂✨"></a><a href="https://leetcode.com/problems/remove-covered-intervals/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">🌕1288. Remove Covered Intervals🎂✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">8</span>]]</span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: Interval [<span class="number">3</span>,<span class="number">6</span>] is covered by [<span class="number">2</span>,<span class="number">8</span>], therefore it is removed.</span><br><span class="line"></span><br><span class="line">Input: intervals = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-34"><a href="#Solution1-34" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Intuition</p>
<p>Imagine that, after removing all covered intervals,<br>all intervals must have different bounds,<br>After sorting, their left and right bound are increasing at the same time.</p>
</li>
<li><p>Sort the array, and note the previous <code>left</code> and <code>right</code> bound.<br>For evert interval <code>v</code>,<br>if <code>v[0] &gt; left &amp;&amp; v[1] &gt; right</code>,<br>It’s a new uncovered interval,<br>so we increment <code>++res</code>.</p>
<p>Complexity: time <code>O(NlogN)</code>, space <code>O(1)</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = -<span class="number">1</span>, right = -<span class="number">1</span>;</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; left &amp;&amp; interval[<span class="number">1</span>] &gt; right) &#123;</span><br><span class="line">            left = interval[<span class="number">0</span>];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        right = Math.max(right, interval[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-14"><a href="#Solution2-14" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Greedy Algorithm</li>
<li>The idea of greedy algorithm is to pick the <em>locally</em> optimal move at each step, which would lead to the <em>globally</em> optimal solution.</li>
<li>Sort in the ascending order by the start point. If two intervals share the same start point, put the longer one to be the first.</li>
<li>Initiate the number of non-covered intervals: <code>count = 0</code>.</li>
<li>Iterate over sorted intervals and compare end points.<ul>
<li>If the current interval is not covered by the previous one <code>end &gt; prev_end</code>, increase the number of non-covered intervals. Assign the current interval to be previous for the next step.</li>
<li>Otherwise, the current interval is covered by the previous one. Do nothing.</li>
</ul>
</li>
<li>Return <code>count</code>.</li>
</ol>
<p><img src="https://leetcode.com/problems/remove-covered-intervals/Figures/1288/sort.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Sort by start point.</span></span><br><span class="line">            <span class="comment">// If two intervals share the same start point,</span></span><br><span class="line">            <span class="comment">// put the longer one to be the first.</span></span><br><span class="line">            <span class="keyword">return</span> o1[<span class="number">0</span>] == o2[<span class="number">0</span>] ? o2[<span class="number">1</span>] - o1[<span class="number">1</span>]: o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end, prev_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] curr : intervals) &#123;</span><br><span class="line">        end = curr[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// if current interval is not covered</span></span><br><span class="line">        <span class="comment">// by the previous one</span></span><br><span class="line">        <span class="keyword">if</span> (prev_end &lt; end) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            prev_end = end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1272-Remove-Interval💎"><a href="#1272-Remove-Interval💎" class="headerlink" title="1272. Remove Interval💎"></a><a href="https://leetcode.com/problems/remove-interval/" target="_blank" rel="noopener">1272. Remove Interval💎</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">7</span>]], toBeRemoved = [<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">Output: [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">7</span>]]</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2020/12/24/removeintervalex1.png" alt=""></p>
<h3 id="Solution1-35"><a href="#Solution1-35" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; removeInterval(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] toBeRemoved) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = intervals[i];</span><br><span class="line">        <span class="keyword">if</span> (cur[<span class="number">0</span>] &gt;= toBeRemoved[<span class="number">1</span>] || cur[<span class="number">1</span>] &lt;= toBeRemoved[<span class="number">0</span>]) &#123;</span><br><span class="line">            ans.add(Arrays.asList(cur[<span class="number">0</span>], cur[<span class="number">1</span>]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// i[1] &gt; toBeRemoved[0] &amp;&amp; i[0] &lt; toBeRemoved[1]</span></span><br><span class="line">            <span class="comment">// left end no overlap.</span></span><br><span class="line">            <span class="keyword">if</span> (cur[<span class="number">0</span>] &lt; toBeRemoved[<span class="number">0</span>]) &#123;</span><br><span class="line">                ans.add(Arrays.asList(cur[<span class="number">0</span>], toBeRemoved[<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// right end no overlap.</span></span><br><span class="line">            <span class="keyword">if</span> (cur[<span class="number">1</span>] &gt; toBeRemoved[<span class="number">1</span>]) &#123;</span><br><span class="line">                ans.add(Arrays.asList(toBeRemoved[<span class="number">1</span>], cur[<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#🌕452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="🌕452. Minimum Number of Arrows to Burst Balloons"></a><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">🌕452. Minimum Number of Arrows to Burst Balloons</a></h2><h3 id="Solution1-36"><a href="#Solution1-36" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>贪婪算法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">int</span> arrow = <span class="number">1</span>; <span class="comment">// if more than 0 balloons then atleast 1 arrow to start</span></span><br><span class="line">    <span class="keyword">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; end) &#123;</span><br><span class="line">            arrow++;</span><br><span class="line">            end = points[i][<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = Math.min(end, points[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕1221-Split-a-String-in-Balanced-Strings✨"><a href="#🌕1221-Split-a-String-in-Balanced-Strings✨" class="headerlink" title="🌕1221. Split a String in Balanced Strings✨"></a><a href="https://leetcode.com/problems/split-a-string-in-balanced-strings/" target="_blank" rel="noopener">🌕1221. Split a String in Balanced Strings✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = <span class="string">"RLRRLLRLRL"</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: s can be split into <span class="string">"RL"</span>, <span class="string">"RRLL"</span>, <span class="string">"RL"</span>, <span class="string">"RL"</span>, each substring contains same number of <span class="string">'L'</span> and <span class="string">'R'</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-37"><a href="#Solution1-37" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Greedy</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> balancedCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> current = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="string">'L'</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            balancedCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> balancedCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1055-Shortest-Way-to-Form-String"><a href="#1055-Shortest-Way-to-Form-String" class="headerlink" title="1055. Shortest Way to Form String"></a><a href="https://leetcode.com/problems/shortest-way-to-form-string/" target="_blank" rel="noopener">1055. Shortest Way to Form String</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: source = <span class="string">"abc"</span>, target = <span class="string">"abcbc"</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: The target <span class="string">"abcbc"</span> can be formed by <span class="string">"abc"</span> and <span class="string">"bc"</span>, which are subsequences of source <span class="string">"abc"</span>.</span><br><span class="line">Input: source = <span class="string">"abc"</span>, target = <span class="string">"acdbc"</span></span><br><span class="line">Output: -<span class="number">1</span></span><br><span class="line">Explanation: The target string cannot be constructed from the subsequences of source string due to the character <span class="string">"d"</span> in target string.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-38"><a href="#Solution1-38" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路是在source里匹配target的第一个字符，然后尽可能延长，然后在target -&gt; remian里一处这一段common substring</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n* n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">    String remain = target;</span><br><span class="line">    <span class="keyword">while</span> (remain.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; source.length() &amp;&amp; j &lt; remain.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.charAt(i++) == remain.charAt(j)) &#123;</span><br><span class="line">                sb.append(remain.charAt(j++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//remain do not contain source string</span></span><br><span class="line">        <span class="keyword">if</span> (sb.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums++;</span><br><span class="line">        remain = remain.substring(sb.length());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕45-Assign-Cookies✨"><a href="#🌕45-Assign-Cookies✨" class="headerlink" title="🌕45. Assign Cookies✨"></a><a href="https://leetcode.com/problems/assign-cookies/" target="_blank" rel="noopener">🌕45. Assign Cookies✨</a></h2><h3 id="Solution1-39"><a href="#Solution1-39" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Simple Greedy Java Solution</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n log n) | S O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(g);</span><br><span class="line">    Arrays.sort(s);</span><br><span class="line">    <span class="keyword">int</span> children = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = g.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[j] &gt;= g[i]) &#123;  <span class="comment">//cookies is big enough to give this child</span></span><br><span class="line">            children++;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//cookies is not big enough, change another cookie</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕1055-Maximize-Sum-Of-Array-After-K-Negations✨"><a href="#🌕1055-Maximize-Sum-Of-Array-After-K-Negations✨" class="headerlink" title="🌕1055. Maximize Sum Of Array After K Negations✨"></a><a href="https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/" target="_blank" rel="noopener">🌕1055. Maximize Sum Of Array After K Negations✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>], K = <span class="number">1</span></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: <span class="function">Choose <span class="title">indices</span> <span class="params">(<span class="number">1</span>,)</span> and A becomes [4,-2,3].</span></span><br><span class="line"><span class="function">Input: A </span>= [<span class="number">3</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>], K = <span class="number">3</span></span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: <span class="function">Choose <span class="title">indices</span> <span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span> and A becomes [3,1,0,2].</span></span><br><span class="line"><span class="function">Input: A </span>= [<span class="number">2</span>,-<span class="number">3</span>,-<span class="number">1</span>,<span class="number">5</span>,-<span class="number">4</span>], K = <span class="number">2</span></span><br><span class="line">Output: <span class="number">13</span></span><br><span class="line">Explanation: <span class="function">Choose <span class="title">indices</span> <span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span> and A becomes [2,3,-1,5,4].</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-40"><a href="#Solution1-40" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : A) pq.add(n);</span><br><span class="line">    <span class="keyword">while</span>(K-- &gt; <span class="number">0</span>) pq.add(-pq.poll());</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pq.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        sum+=pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-15"><a href="#Solution2-15" class="headerlink" title="Solution2:"></a>Solution2:</h3><p><a href="https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/discuss/252254/JavaC%2B%2BPython-Sort" target="_blank" rel="noopener">https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/discuss/252254/JavaC%2B%2BPython-Sort</a></p>
<h2 id="665-Non-decreasing-Array✨"><a href="#665-Non-decreasing-Array✨" class="headerlink" title="665. Non-decreasing Array✨"></a><a href="https://leetcode.com/problems/non-decreasing-array/" target="_blank" rel="noopener">665. Non-decreasing Array✨</a></h2><p>Given an array <code>nums</code> with <code>n</code> integers, your task is to check if it could become non-decreasing by modifying <strong>at most</strong> <code>1</code> element.</p>
<p>We define an array is non-decreasing if <code>nums[i] &lt;= nums``[i + 1]</code> holds for every <code>i</code> (0-based) such that <code>(0 &lt;= i &lt;= n - 2)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="keyword">true</span></span><br><span class="line">Explanation: You could modify the first <span class="number">4</span> to <span class="number">1</span> to get a non-decreasing array.</span><br><span class="line">Input: nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation: You can<span class="string">'t get a non-decreasing array by modify at most one element.</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-41"><a href="#Solution1-41" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>This problem is like a greedy problem. When you find <code>nums[i-1] &gt; nums[i]</code> for some <code>i</code>, you will prefer to change <code>nums[i-1]</code>‘s value, since a larger <code>nums[i]</code> will give you more risks that you get inversion errors after position <code>i</code>. But, if you also find <code>nums[i-2] &gt; nums[i]</code>, then you have to change <code>nums[i]</code>‘s value instead, or else you need to change both of <code>nums[i-2]</code>‘s and <code>nums[i-1]</code>‘s values.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length &amp;&amp; ans &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt; nums[i]) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="comment">//modify nums[i-1] of a priority</span></span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">2</span> &lt; <span class="number">0</span> || nums[i - <span class="number">2</span>] &lt;= nums[i]) nums[i - <span class="number">1</span>] = nums[i];</span><br><span class="line">            <span class="comment">//have to modify nums[i]</span></span><br><span class="line">            <span class="keyword">else</span> nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1090-Largest-Values-From-Labels💎"><a href="#1090-Largest-Values-From-Labels💎" class="headerlink" title="1090. Largest Values From Labels💎"></a><a href="https://leetcode.com/problems/largest-values-from-labels/" target="_blank" rel="noopener">1090. Largest Values From Labels💎</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], labels = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], num_wanted = <span class="number">3</span>, use_limit = <span class="number">1</span></span><br><span class="line">Output: <span class="number">9</span></span><br><span class="line">Explanation: The subset chosen is the first, third, and fifth item.</span><br><span class="line">    </span><br><span class="line">use_limit -&gt; each kind of label element</span><br><span class="line">num_wanted -&gt; total element number</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-42"><a href="#Solution1-42" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestValsFromLabels</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span>[] labels, <span class="keyword">int</span> num_wanted, <span class="keyword">int</span> use_limit)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> label : labels) &#123;</span><br><span class="line">        map.put(label, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = values.length;</span><br><span class="line">    <span class="keyword">int</span>[][] lists = <span class="keyword">new</span> <span class="keyword">int</span>[size][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        lists[i][<span class="number">0</span>] = values[i];</span><br><span class="line">        lists[i][<span class="number">1</span>] = labels[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(lists, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = lists[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> lab = lists[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (num_wanted &gt; <span class="number">0</span> &amp;&amp; map.get(lab) &lt; use_limit) &#123;</span><br><span class="line">            sum += val;</span><br><span class="line">            map.put(lab, map.get(lab) + <span class="number">1</span>);</span><br><span class="line">            num_wanted--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-16"><a href="#Solution2-16" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestValsFromLabels</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span>[] labels, <span class="keyword">int</span> num_wanted, <span class="keyword">int</span> use_limit)</span> </span>&#123;</span><br><span class="line">    List&lt;Item&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        items.add(<span class="keyword">new</span> Item(values[i], labels[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Item&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (b.value - a.value));</span><br><span class="line">    heap.addAll(items);</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty() &amp;&amp; num_wanted &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Item current = heap.poll();</span><br><span class="line">        count.put(current.label, count.getOrDefault(current.label, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (count.get(current.label) &lt;= use_limit) &#123;</span><br><span class="line">            sum += current.value;</span><br><span class="line">            num_wanted--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="948-Bag-of-Tokens💎"><a href="#948-Bag-of-Tokens💎" class="headerlink" title="948. Bag of Tokens💎"></a><a href="https://leetcode.com/problems/bag-of-tokens/" target="_blank" rel="noopener">948. Bag of Tokens💎</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens = [<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>], P = <span class="number">200</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: Play the tokens in <span class="keyword">this</span> order to get a score of <span class="number">2</span>:</span><br><span class="line"><span class="number">1</span>. Play the <span class="number">0</span><span class="function">th <span class="title">token</span> <span class="params">(<span class="number">100</span>)</span> face up, your power becomes 100 and score becomes 1.</span></span><br><span class="line"><span class="function">2. Play the 3rd <span class="title">token</span> <span class="params">(<span class="number">400</span>)</span> face down, your power becomes 500 and score becomes 0.</span></span><br><span class="line"><span class="function">3. Play the 1st <span class="title">token</span> <span class="params">(<span class="number">200</span>)</span> face up, your power becomes 300 and score becomes 1.</span></span><br><span class="line"><span class="function">4. Play the 2nd <span class="title">token</span> <span class="params">(<span class="number">300</span>)</span> face up, your power becomes 0 and score becomes 2.</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-43"><a href="#Solution1-43" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagOfTokensScore</span><span class="params">(<span class="keyword">int</span>[] tokens, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(tokens);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = tokens.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (P &gt;= tokens[i]) &#123;  <span class="comment">//buy the cheapest token[i] change to score</span></span><br><span class="line">            cur++;</span><br><span class="line">            P -= tokens[i++];</span><br><span class="line">            max = Math.max(max, cur);  <span class="comment">//keep update the max score</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; <span class="number">0</span>) &#123;  <span class="comment">//use score exchage most exensive token[j]</span></span><br><span class="line">            P += tokens[j--];</span><br><span class="line">            cur--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//current score cannot change and point can not buy</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1702-Maximum-Binary-String-After-Change🎃"><a href="#1702-Maximum-Binary-String-After-Change🎃" class="headerlink" title="1702. Maximum Binary String After Change🎃"></a><a href="https://leetcode.com/problems/maximum-binary-string-after-change/" target="_blank" rel="noopener">1702. Maximum Binary String After Change🎃</a></h2><h3 id="Solution1-44"><a href="#Solution1-44" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">maximumBinaryString</span><span class="params">(String binary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = binary.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'0'</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; binary.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (binary.charAt(i) == <span class="string">'0'</span>) &#123;</span><br><span class="line">            idx = i + count - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.fill(chars, <span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">if</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">        chars[idx] = <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">maximumBinaryString</span><span class="params">(String binary)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans = <span class="keyword">new</span> StringBuilder(binary);</span><br><span class="line">    <span class="keyword">while</span> (ans.indexOf(<span class="string">"01"</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ans.indexOf(<span class="string">"01"</span>);</span><br><span class="line">        String s = ans.substring(<span class="number">0</span>, idx) + <span class="string">"10"</span> + ans.substring(idx + <span class="number">2</span>);</span><br><span class="line">        ans = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans.reverse();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ans.indexOf(<span class="string">"00"</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ans.indexOf(<span class="string">"00"</span>);</span><br><span class="line">        String s = ans.substring(<span class="number">0</span>, idx) + <span class="string">"10"</span> + ans.substring(idx + <span class="number">2</span>);</span><br><span class="line">        ans = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"000110" -&gt; "000101" </span></span><br><span class="line"><span class="comment">"000101" -&gt; "100101" </span></span><br><span class="line"><span class="comment">"100101" -&gt; "110101" </span></span><br><span class="line"><span class="comment">"110101" -&gt; "110011" </span></span><br><span class="line"><span class="comment">"110011" -&gt; "111011"</span></span><br><span class="line"><span class="comment">    先10-01</span></span><br><span class="line"><span class="comment">"000110" -&gt; "000101" </span></span><br><span class="line"><span class="comment">"000101" -&gt; "000011" </span></span><br><span class="line"><span class="comment"> 100011 -&gt;  "110011" </span></span><br><span class="line"><span class="comment">"111011" </span></span><br><span class="line"><span class="comment">    先边00-10</span></span><br><span class="line"><span class="comment">"000110" -&gt; "100110" </span></span><br><span class="line"><span class="comment">"100110" -&gt; "110110" </span></span><br><span class="line"><span class="comment">"110110"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Busiest-Time-in-The-Mall"><a href="#Busiest-Time-in-The-Mall" class="headerlink" title="Busiest Time in The Mall"></a>Busiest Time in The Mall</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input:  data = [ [<span class="number">1487799425</span>, <span class="number">14</span>, <span class="number">1</span>], </span><br><span class="line">                 [<span class="number">1487799425</span>, <span class="number">4</span>,  <span class="number">0</span>],</span><br><span class="line">                 [<span class="number">1487799425</span>, <span class="number">2</span>,  <span class="number">0</span>],</span><br><span class="line">                 [<span class="number">1487800378</span>, <span class="number">10</span>, <span class="number">1</span>],</span><br><span class="line">                 [<span class="number">1487801478</span>, <span class="number">18</span>, <span class="number">0</span>],</span><br><span class="line">                 [<span class="number">1487801478</span>, <span class="number">18</span>, <span class="number">1</span>],</span><br><span class="line">                 [<span class="number">1487901013</span>, <span class="number">1</span>,  <span class="number">0</span>],</span><br><span class="line">                 [<span class="number">1487901211</span>, <span class="number">7</span>,  <span class="number">1</span>],</span><br><span class="line">                 [<span class="number">1487901211</span>, <span class="number">7</span>,  <span class="number">0</span>] ]</span><br><span class="line"></span><br><span class="line">output: 1487800378 # since the increase in the number of people</span><br><span class="line">                   # in the mall is the highest at that point</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-45"><a href="#Solution1-45" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findBusiestPeriod</span><span class="params">(<span class="keyword">int</span>[][] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = data.length;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i][<span class="number">2</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            count += data[i][<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            count -= data[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if time stamp is same, keep calculate count in next round</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; data[i][<span class="number">0</span>] == data[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; max) &#123;</span><br><span class="line">            max = count;</span><br><span class="line">            time = data[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="561-Array-Partition-I"><a href="#561-Array-Partition-I" class="headerlink" title="561. Array Partition I"></a><a href="https://leetcode.com/problems/array-partition-i/" target="_blank" rel="noopener">561. Array Partition I</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: <span class="function">All possible <span class="title">pairings</span> <span class="params">(ignoring the ordering of elements)</span> are:</span></span><br><span class="line"><span class="function">1. <span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span>, <span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span> -&gt; <span class="title">min</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span> + <span class="title">min</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span> </span>= <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line"><span class="number">2</span>. (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>) -&gt; min(<span class="number">1</span>, <span class="number">3</span>) + min(<span class="number">2</span>, <span class="number">4</span>) = <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line"><span class="number">3</span>. (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>) -&gt; min(<span class="number">1</span>, <span class="number">2</span>) + min(<span class="number">3</span>, <span class="number">4</span>) = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span></span><br><span class="line">So the maximum possible sum is <span class="number">4</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-46"><a href="#Solution1-46" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">        ans += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Find-Minimum-Time-to-Finish-All-Jobs🎃"><a href="#Find-Minimum-Time-to-Finish-All-Jobs🎃" class="headerlink" title="Find Minimum Time to Finish All Jobs🎃"></a>Find Minimum Time to Finish All Jobs🎃</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTimeRequired</span><span class="params">(<span class="keyword">int</span>[] jobs, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(jobs);</span><br><span class="line">        reverse(jobs);</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (a[<span class="number">1</span>] - b[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            heap.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> job : jobs) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = heap.poll();</span><br><span class="line">            cur[<span class="number">1</span>] += job;</span><br><span class="line">            heap.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!heap.isEmpty()) &#123;</span><br><span class="line">            max = Math.max(max, heap.poll()[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1,2,4,7,8]</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">except</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">k=1  1,4,8</span></span><br><span class="line"><span class="comment">k=2  2,7</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">k=1  4,7</span></span><br><span class="line"><span class="comment">k=2  1,2,8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">k=1  8,</span></span><br><span class="line"><span class="comment">k=2  7,4,</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="1717-Maximum-Score-From-Removing-Substrings🎃"><a href="#1717-Maximum-Score-From-Removing-Substrings🎃" class="headerlink" title="1717. Maximum Score From Removing Substrings🎃"></a><a href="https://leetcode.com/problems/maximum-score-from-removing-substrings/" target="_blank" rel="noopener">1717. Maximum Score From Removing Substrings🎃</a></h2><h3 id="Solution1-47"><a href="#Solution1-47" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGain</span><span class="params">(String s, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> xGreat = x &gt;= y;</span><br><span class="line">    <span class="keyword">if</span> (!xGreat) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'a'</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">'b'</span>) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                ans += y;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; sb.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = sb.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'a'</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">'b'</span>) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                ans += x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'b'</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">'a'</span>) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                ans += x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; sb.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = sb.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'b'</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">'a'</span>) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                ans += y;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGain</span><span class="params">(String s, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(), stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>, max=Math.max(x,y), min =Math.min(x,y);</span><br><span class="line">    <span class="keyword">char</span> first= (x&gt;y)?<span class="string">'a'</span>:<span class="string">'b'</span>, second=(x&gt;y)?<span class="string">'b'</span>:<span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c: s.toCharArray()) </span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() == first &amp;&amp; c == second) &#123;</span><br><span class="line">            stack.pop(); </span><br><span class="line">            result +=max;</span><br><span class="line">        &#125; <span class="keyword">else</span> stack.push(c);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty() &amp;&amp; stack2.peek() == first &amp;&amp; c == second) &#123;</span><br><span class="line">            stack2.pop(); </span><br><span class="line">            result +=min;</span><br><span class="line">        &#125; <span class="keyword">else</span> stack2.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Custom-Sorting"><a href="#Custom-Sorting" class="headerlink" title="Custom Sorting"></a>Custom Sorting</h1><h2 id="🌕406-Queue-Reconstruction-by-Height✨"><a href="#🌕406-Queue-Reconstruction-by-Height✨" class="headerlink" title="🌕406. Queue Reconstruction by Height✨"></a><a href="https://leetcode.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">🌕406. Queue Reconstruction by Height✨</a></h2><h3 id="Solution1-48"><a href="#Solution1-48" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">    Comparator&lt;<span class="keyword">int</span>[]&gt; myComparator = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] people1, <span class="keyword">int</span>[] people2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (people1[<span class="number">0</span>] != people2[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> people2[<span class="number">0</span>] - people1[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> people1[<span class="number">1</span>] - people2[<span class="number">1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(people, myComparator);</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : people) &#123;</span><br><span class="line">        ans.add(p[<span class="number">1</span>], p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="937-Reorder-Data-in-Log-Files⭐"><a href="#937-Reorder-Data-in-Log-Files⭐" class="headerlink" title="937. Reorder Data in Log Files⭐"></a><a href="https://leetcode.com/problems/reorder-data-in-log-files/" target="_blank" rel="noopener">937. Reorder Data in Log Files⭐</a></h2><p>The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.</p>
<p>The digit-logs should be put in their original order.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: logs = [<span class="string">"dig1 8 1 5 1"</span>,<span class="string">"let1 art can"</span>,<span class="string">"dig2 3 6"</span>,<span class="string">"let2 own kit dig"</span>,<span class="string">"let3 art zero"</span>]</span><br><span class="line">Output: [<span class="string">"let1 art can"</span>,<span class="string">"let3 art zero"</span>,<span class="string">"let2 own kit dig"</span>,<span class="string">"dig1 8 1 5 1"</span>,<span class="string">"dig2 3 6"</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-49"><a href="#Solution1-49" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Comparator</li>
<li>The above pairwise *”less than”* relationship is also known as <strong>comparator</strong> in Java, which is a function object that helps the sorting functions to determine the orders among a collection of elements.</li>
<li>The problem is a good exercise to practice the technique of <strong>custom sort</strong> in different languages.</li>
<li>The idea of custom sort is that we don’t have to rewrite a sorting algorithm every time we have a different <strong><em>sorting criteria</em></strong> among the elements.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o1 &lt; o2)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (o1 == o2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// o1 &gt; o2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] reorderLogFiles(String[] logs) &#123;</span><br><span class="line">    Comparator&lt;String&gt; myComp = <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String log1, String log2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// split each log into two parts: &lt;identifier, content&gt;</span></span><br><span class="line">            String[] split1 = log1.split(<span class="string">" "</span>, <span class="number">2</span>);</span><br><span class="line">            String[] split2 = log2.split(<span class="string">" "</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="comment">//word(index at 1) after identifier(index at 0)</span></span><br><span class="line">            <span class="keyword">boolean</span> isDigit1 = Character.isDigit(split1[<span class="number">1</span>].charAt(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">boolean</span> isDigit2 = Character.isDigit(split2[<span class="number">1</span>].charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case 1). both logs are letter-logs</span></span><br><span class="line">            <span class="keyword">if</span> (!isDigit1 &amp;&amp; !isDigit2) &#123;</span><br><span class="line">                <span class="comment">// first compare the content</span></span><br><span class="line">                <span class="keyword">int</span> cmp = split1[<span class="number">1</span>].compareTo(split2[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (cmp != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> cmp;</span><br><span class="line">                <span class="comment">// logs of same content, compare the identifiers</span></span><br><span class="line">                <span class="keyword">return</span> split1[<span class="number">0</span>].compareTo(split2[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case 2). one of logs is digit-log</span></span><br><span class="line">            <span class="keyword">if</span> (!isDigit1 &amp;&amp; isDigit2)</span><br><span class="line">                <span class="comment">// the letter-log comes before digit-logs</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isDigit1 &amp;&amp; !isDigit2)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// case 3). both logs are digit-log</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Arrays.sort(logs, myComp);</span><br><span class="line">    <span class="keyword">return</span> logs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-179-Largest-Number⭐"><a href="#🌕Unsolved-179-Largest-Number⭐" class="headerlink" title="🌕Unsolved 179. Largest Number⭐"></a><a href="https://leetcode.com/problems/largest-number/" target="_blank" rel="noopener">🌕Unsolved 179. Largest Number⭐</a></h2><p>Given a list of non-negative integers <code>nums</code>, arrange them such that they form the largest number.</p>
<p><strong>Note:</strong> The result may be very large, so you need to return a string instead of an integer.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">10</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="string">"210"</span></span><br><span class="line">Input: nums = [<span class="number">3</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">Output: <span class="string">"9534330"</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-50"><a href="#Solution1-50" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String[] str = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        str[i] = String.valueOf(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Comparator myComp = <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">            String comb1 = s1 + s2;</span><br><span class="line">            String comb2 = s2 + s1;</span><br><span class="line">            <span class="keyword">return</span> comb2.compareTo(comb1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(str, myComp);</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>].charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (String s : str) &#123;</span><br><span class="line">        sb.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Absolute-Value-Sort💜"><a href="#Absolute-Value-Sort💜" class="headerlink" title="Absolute Value Sort💜"></a>Absolute Value Sort💜</h2><p>Given an array of integers <code>arr</code>, write a function <code>absSort(arr)</code>, that sorts the array according to the absolute values of the numbers in <code>arr</code>. If two numbers have the same absolute value, sort them according to sign, where the negative numbers come before the positive numbers.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:  arr = [<span class="number">2</span>, -<span class="number">7</span>, -<span class="number">2</span>, -<span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">output: [<span class="number">0</span>, -<span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-51"><a href="#Solution1-51" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Selection sort</p>
</li>
<li><p><strong>Time Complexity:</strong> <code>O(N^2)</code> from our two for loops.</p>
<p><strong>Space Complexity:</strong> <code>O(1)</code>, the additional space used by <code>best</code>.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">absSort</span><span class="params">(arr)</span>:</span></span><br><span class="line"><span class="function">    function <span class="title">smaller</span><span class="params">(a, b)</span>:</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">abs</span><span class="params">(a)</span> &lt; <span class="title">abs</span><span class="params">(b)</span>: return <span class="keyword">true</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">abs</span><span class="params">(a)</span> &gt; <span class="title">abs</span><span class="params">(b)</span>: return <span class="keyword">false</span></span></span><br><span class="line"><span class="function">        return a &lt; b</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> i from 0 to arr.length - 2:</span></span><br><span class="line"><span class="function">        best </span>= i</span><br><span class="line">        <span class="keyword">for</span> j from i to arr.length - <span class="number">1</span>:</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">smaller</span><span class="params">(arr[j], arr[best])</span>:</span></span><br><span class="line"><span class="function">                best </span>= j</span><br><span class="line">        arr[best], arr[i] = arr[i], arr[best]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] absSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// your code goes here</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = arr[i];</span><br><span class="line">        <span class="keyword">int</span> minidx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arrar.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (smaller(arr[j], min)) &#123;</span><br><span class="line">                min = array[j];</span><br><span class="line">                minidx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minidx != i) &#123;</span><br><span class="line">            arr[minidx] = arr[i];</span><br><span class="line">            arr[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">smaller</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(a) &lt; Math.abs(b)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(a) &gt; Math.abs(b)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;  <span class="comment">//compare the x &amp;&amp; -x case, -x will be first</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, -<span class="number">7</span>, -<span class="number">2</span>, -<span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Sysytem.println(absSort(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-17"><a href="#Solution2-17" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Custom Sort</p>
</li>
<li><p>Leverage the sort function of your languages library. Usually, it will have support for either a custom comparison function. </p>
</li>
<li><p>For a custom comparison function <code>compare(a, b)</code>, typically we want to return <code>-1</code> if <code>a &lt; b</code>, <code>1</code> if <code>a &gt; b</code>, and <code>0</code> if <code>a == b</code>.</p>
</li>
<li><p><strong>Time Complexity:</strong> <code>O(N log N)</code>, the complexity of sorting.</p>
<p><strong>Space Complexity:</strong> <code>O(N)</code>, the space typically used by compilers in their implementation of sorting operations.</p>
<p><a href="https://www.codejava.net/java-core/collections/sorting-arrays-examples-with-comparable-and-comparator" target="_blank" rel="noopener">https://www.codejava.net/java-core/collections/sorting-arrays-examples-with-comparable-and-comparator</a></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">absSort</span><span class="params">(arr)</span>:</span></span><br><span class="line"><span class="function">    def <span class="title">compare</span><span class="params">(a, b)</span>:</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">abs</span><span class="params">(a)</span> &lt; <span class="title">abs</span><span class="params">(b)</span>: return -1</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">abs</span><span class="params">(a)</span> &gt; <span class="title">abs</span><span class="params">(b)</span>: return 1</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> a &lt; b: return -1</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> a &gt; b: return 1</span></span><br><span class="line"><span class="function">        return 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    arr.<span class="title">sort</span><span class="params">(cmp = compare)</span></span></span><br><span class="line"><span class="function">    return arr</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] absSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// your code goes here</span></span><br><span class="line">        Comparator&lt;Integer&gt; myComp = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(a) &lt; Math.abs(b)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(a) &gt; Math.abs(b)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(arr, myComp);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, -<span class="number">7</span>, -<span class="number">2</span>, -<span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(absSort(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Arrays.sort(</span></span><br><span class="line"><span class="comment">        intervals,</span></span><br><span class="line"><span class="comment">        new Comparator&lt;int[]&gt;() &#123;</span></span><br><span class="line"><span class="comment">            public int compare(final int[] a, final int[] b) &#123;</span></span><br><span class="line"><span class="comment">                return a[0] - b[0];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="791-Custom-Sort-String"><a href="#791-Custom-Sort-String" class="headerlink" title="791. Custom Sort String"></a><a href="https://leetcode.com/problems/custom-sort-string/" target="_blank" rel="noopener">791. Custom Sort String</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example :</span><br><span class="line">Input: </span><br><span class="line">S = <span class="string">"cba"</span></span><br><span class="line">T = <span class="string">"abcd"</span></span><br><span class="line">Output: <span class="string">"cbad"</span></span><br><span class="line">Explanation: </span><br><span class="line"><span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> appear in S, so the order of <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> should be <span class="string">"c"</span>, <span class="string">"b"</span>, and <span class="string">"a"</span>. </span><br><span class="line">Since <span class="string">"d"</span> does not appear in S, it can be at any position in T. <span class="string">"dcba"</span>, <span class="string">"cdba"</span>, <span class="string">"cbda"</span> are also valid outputs.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-52"><a href="#Solution1-52" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time Complexity: O(S.\text{length} + T.\text{length})<em>O</em>(<em>S</em>.length+<em>T</em>.length), the time it takes to iterate through <code>S</code> and <code>T</code></li>
<li>Space Complexity: O(T.\text{length})<em>O</em>(<em>T</em>.length). We count at most 26 different lowercase letters, but the final answer has the same length as <code>T</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">customSortString</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : T.toCharArray()) &#123; ++count[c - <span class="string">'a'</span>]; &#125;  <span class="comment">// count each char in T.</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : S.toCharArray()) &#123;                            </span><br><span class="line">        <span class="keyword">while</span> (count[c - <span class="string">'a'</span>]-- &gt; <span class="number">0</span>) &#123; sb.append(c); &#125;    <span class="comment">// sort chars both in T and S by the order of S.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; ++c) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count[c - <span class="string">'a'</span>]-- &gt; <span class="number">0</span>) &#123; sb.append(c); &#125;    <span class="comment">// group chars in T but not in S.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Heap-Implementation"><a href="#Heap-Implementation" class="headerlink" title="Heap Implementation"></a>Heap Implementation</h1><h2 id="Min-Heap-Construction-AE"><a href="#Min-Heap-Construction-AE" class="headerlink" title="Min Heap Construction(AE)"></a>Min Heap Construction(AE)</h2><ol>
<li><p>Building a Min Heap form an input array of integers. Implement <strong><code>insert</code></strong>, <strong><code>remove</code></strong>, <strong><code>peek</code></strong>, <strong><code>sift up</code></strong>, <strong><code>sift down</code></strong> operations. Heap is a binary and a special type of binary tree that satisfies two additional properties.  Completeness and heap property. For Min Heap, every node value is smaller of equal to children node.</p>
</li>
<li><p>Child position formula</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">currentNode -&gt;  i</span><br><span class="line">childOne    -&gt;  <span class="number">2</span>i + <span class="number">1</span></span><br><span class="line">childTwo    -&gt;  <span class="number">2</span>i + <span class="number">2</span></span><br><span class="line">parentNode  -&gt;  floor((i - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line"> <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>,  <span class="number">8</span></span><br><span class="line">[<span class="number">8</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">17</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">44</span>,<span class="number">102</span>,<span class="number">18</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>After insert new element, sift up or down to the correct position, eg. add 9 element, it less than parent 31 swap them , 9 less than parent 12 swap them. Same to sift down, if parent small than the <strong><code>minimum children</code></strong> node, swap them. Remove root, swap last root node and children node, pop() it, then sift down</p>
</li>
<li><p>sift up &amp; sift down O(log n) every time wo remove half of the tree</p>
<p>Build Heap O(n)  not O(n logn) sift down on leaf node is constant time,  math sum up of all node sift down is n</p>
</li>
</ol>
<h3 id="Solution1-53"><a href="#Solution1-53" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> maxN)</span></span></span><br><span class="line"><span class="function">    </span>&#123;pq = (Key[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>];&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> n == <span class="number">0</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">        pq[n] = k;</span><br><span class="line">        swim(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Key max = pq[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>, n);</span><br><span class="line">        pq[n] = <span class="keyword">null</span>;</span><br><span class="line">        n--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(parent(k), k))</span><br><span class="line">        &#123;</span><br><span class="line">            exch(parent(k), k);</span><br><span class="line">            k = parent(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left(k) &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> older = left(k);</span><br><span class="line">            <span class="keyword">if</span> (right(k) &lt;= n &amp;&amp; less(older, right(k)))</span><br><span class="line">                older = right(k);</span><br><span class="line">            <span class="keyword">if</span> (less(older, k)) <span class="keyword">break</span>;</span><br><span class="line">            exch(k, older);</span><br><span class="line">            k = older;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j];)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Key temp = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-18"><a href="#Solution2-18" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; heap = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  <span class="comment">//implement by array</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(List&lt;Integer&gt; array)</span> </span>&#123;</span><br><span class="line">        heap = buildHeap(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(n) time | O(1) space</span></span><br><span class="line">    <span class="comment">//5.build Heap by calling sift down method on all parent nodes</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">buildHeap</span><span class="params">(List&lt;Integer&gt; array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> firstParentIdx = (array.size() - <span class="number">2</span>) / <span class="number">2</span>;  </span><br><span class="line">        <span class="comment">//start from first parent node, (array.size() - 1 - 1) /2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> currentIdx = firstParentIdx; currentIdx &gt;= <span class="number">0</span>; currentIdx--) &#123;  <span class="comment">//go from the end to traverse, sift all to the bottom</span></span><br><span class="line">            siftDown(currentIdx, array.size() - <span class="number">1</span>, array);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.(logn) time | O(1) space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> currentIdx, <span class="keyword">int</span> endIdx, List&lt;Integer&gt; heap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childOneIdx = currentIdx * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">//calculate the first children position</span></span><br><span class="line">        <span class="keyword">while</span> (childOneIdx &lt;= endIdx) &#123; </span><br><span class="line">            <span class="keyword">int</span> childTwoIdx = currentIdx * <span class="number">2</span> + <span class="number">2</span> &lt;= endIdx ? currentIdx * <span class="number">2</span> + <span class="number">2</span> : -<span class="number">1</span>;  <span class="comment">//if exist children 2</span></span><br><span class="line">            <span class="keyword">int</span> idxToSwap;  <span class="comment">//if we have child2 and smaller than child1, target is child2</span></span><br><span class="line">            <span class="keyword">if</span> (childTwoIdx != -<span class="number">1</span> &amp;&amp; heap.get(childTwoIdx) &lt; heap.get(childOneIdx)) &#123;</span><br><span class="line">                idxToSwap = childTwoIdx;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                idxToSwap = childOneIdx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heap.get(idxToSwap) &lt; heap.get(currentIdx)) &#123;  <span class="comment">//if if not satisfy the heap property, smallest child &lt; current value, swap them</span></span><br><span class="line">                swap(currentIdx, idxToSwap, heap);</span><br><span class="line">                currentIdx = idxToSwap;  <span class="comment">//keep track the value after previously swap</span></span><br><span class="line">                childOneIdx = currentIdx * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">//update the next child</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.O(logn) time | O(1) space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> currentIdx, List&lt;Integer&gt; heap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parentIdx = (currentIdx - <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">//find the parent index value, floor that down</span></span><br><span class="line">        <span class="keyword">while</span> (currentIdx &gt; <span class="number">0</span> &amp;&amp; heap.get(currentIdx) &lt; heap.get(parentIdx)) &#123;</span><br><span class="line">            <span class="comment">//if not satisfy the heap property, parent node is great than current, swap them, base line is current&gt;0 is child</span></span><br><span class="line">            swap(currentIdx, parentIdx, heap);</span><br><span class="line">            currentIdx = parentIdx;  <span class="comment">//update the cur and parent after swap previously</span></span><br><span class="line">            parentIdx = (currentIdx - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        swap(<span class="number">0</span>, heap.size() - <span class="number">1</span>, heap);  <span class="comment">//swap the first with last value</span></span><br><span class="line">        <span class="keyword">int</span> valueToRemove = heap.get(heap.size() - <span class="number">1</span>);  <span class="comment">//pop the target value</span></span><br><span class="line">        heap.remove(heap.size() - <span class="number">1</span>);</span><br><span class="line">        siftDown(<span class="number">0</span>, heap.size() - <span class="number">1</span>, heap);  <span class="comment">//sift down the value to the correct position</span></span><br><span class="line">        <span class="keyword">return</span> valueToRemove;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.start with insert method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        heap.add(value);  <span class="comment">//add it to the tail in the array</span></span><br><span class="line">        siftUp(heap.size() - <span class="number">1</span>, heap);  <span class="comment">//sift it up to the correct position</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, List&lt;Integer&gt; heap)</span> </span>&#123;</span><br><span class="line">        Integer temp = heap.get(j);</span><br><span class="line">        heap.set(j, heap.get(i));</span><br><span class="line">        heap.set(i, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Data-Structures-for-Coding-Interviews-in-Java"><a href="#Data-Structures-for-Coding-Interviews-in-Java" class="headerlink" title="Data Structures for Coding Interviews in Java"></a>Data Structures for Coding Interviews in Java</h1><h2 id="🌕Challenge-1-Convert-a-Max-Heap-to-a-Min-Heap"><a href="#🌕Challenge-1-Convert-a-Max-Heap-to-a-Min-Heap" class="headerlink" title="🌕Challenge 1: Convert a Max-Heap to a Min-Heap"></a>🌕Challenge 1: Convert a Max-Heap to a Min-Heap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckConvert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convertMax</span><span class="params">(<span class="keyword">int</span>[] maxHeap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Consider maxHeap just an ordinary unsorted array </span></span><br><span class="line">        <span class="comment">//Build minHeap of the given array. (We already covered that in previous lesson)</span></span><br><span class="line">        <span class="comment">//Return converted array in String format</span></span><br><span class="line">        buildMinHeap(maxHeap, maxHeap.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMinHeap</span><span class="params">(<span class="keyword">int</span>[] heapArray, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// swap smallest child to parent node </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (heapSize - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            minHeapify(heapArray, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minHeapify</span><span class="params">(<span class="keyword">int</span>[] heapArray, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> smallest = index;</span><br><span class="line">        <span class="keyword">while</span> (smallest &lt; heapSize / <span class="number">2</span>) &#123; <span class="comment">// check parent nodes only</span></span><br><span class="line">            <span class="keyword">int</span> left = (<span class="number">2</span> * index) + <span class="number">1</span>; <span class="comment">//left child</span></span><br><span class="line">            <span class="keyword">int</span> right = (<span class="number">2</span> * index) + <span class="number">2</span>; <span class="comment">//right child</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; heapArray[left] &lt; heapArray[index]) &#123;</span><br><span class="line">                smallest = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; heapArray[right] &lt; heapArray[smallest]) &#123;</span><br><span class="line">                smallest = right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (smallest != index) &#123; <span class="comment">// swap parent with smallest child</span></span><br><span class="line">                <span class="keyword">int</span> temp = heapArray[index];</span><br><span class="line">                heapArray[index] = heapArray[smallest];</span><br><span class="line">                heapArray[smallest] = temp;</span><br><span class="line">                index = smallest;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// if heap property is satisfied</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//end of while</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] heapArray = &#123;<span class="number">9</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>,-<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"Max Heap: "</span> + Arrays.toString(heapArray));</span><br><span class="line">        convertMax(heapArray);</span><br><span class="line">        System.out.println(<span class="string">"Min Heap: "</span> + Arrays.toString(heapArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-2-Find-the-k-Smallest-Elements-in-an-Array"><a href="#Challenge-2-Find-the-k-Smallest-Elements-in-an-Array" class="headerlink" title="Challenge 2: Find the k Smallest Elements in an Array"></a>Challenge 2: Find the k Smallest Elements in an Array</h2><h3 id="Solution1-54"><a href="#Solution1-54" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>The time complexity of building a heap is O(n)<em>O</em>(<em>n</em>), as discussed in the implementations. Furthermore, removing the <strong>k</strong> smallest elements takes a time complexity of O(klogn)<em>O</em>(<em>k<strong>l</strong>o<strong>g</strong>n</em>).</li>
<li>Therefore, we can say that the total time complexity is O(n+k logn).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Build minHeap of the given array. </span></span><br><span class="line"><span class="comment">//Extract the minimum element/root and add it to the result</span></span><br><span class="line"><span class="comment">//Keep removing elements and repeatedly build minHeap till we reach K.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckSmall</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findKSmallest(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> arraySize = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= arraySize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                result[i] = removeMin(arr, arraySize);</span><br><span class="line">                --arraySize;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Value of k = "</span> + k+ <span class="string">"out of bounds!"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeMin</span><span class="params">(<span class="keyword">int</span>[] heapArray, <span class="keyword">int</span> heapSize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        buildMinHeap(heapArray, heapSize);</span><br><span class="line">        <span class="keyword">int</span> min = heapArray[<span class="number">0</span>];</span><br><span class="line">        heapArray[<span class="number">0</span>] =  heapArray[heapSize-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMinHeap</span><span class="params">(<span class="keyword">int</span>[] heapArray, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// swap largest child to parent node </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (heapSize - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            minHeapify(heapArray, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minHeapify</span><span class="params">(<span class="keyword">int</span>[] heapArray, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> smallest = index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (smallest &lt; heapSize / <span class="number">2</span>) &#123; <span class="comment">// check parent nodes only</span></span><br><span class="line">            <span class="keyword">int</span> left = (<span class="number">2</span> * index) + <span class="number">1</span>; <span class="comment">//left child</span></span><br><span class="line">            <span class="keyword">int</span> right = (<span class="number">2</span> * index) + <span class="number">2</span>; <span class="comment">//right child</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; heapArray[left] &lt; heapArray[index]) &#123;</span><br><span class="line">                smallest = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; heapArray[right] &lt; heapArray[smallest]) &#123;</span><br><span class="line">                smallest = right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (smallest != index) &#123; <span class="comment">// swap parent with largest child</span></span><br><span class="line">                <span class="keyword">int</span> temp = heapArray[index];</span><br><span class="line">                heapArray[index] = heapArray[smallest];</span><br><span class="line">                heapArray[smallest] = temp;</span><br><span class="line">                index = smallest;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// if heap property is satisfied</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="comment">//end of while</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] input = &#123;<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, -<span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] output = findKSmallest(input, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; output.length; i++) </span><br><span class="line">            System.out.println(output[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-3-Find-the-k-Largest-Elements-in-an-Array"><a href="#Challenge-3-Find-the-k-Largest-Elements-in-an-Array" class="headerlink" title="Challenge 3: Find the k Largest Elements in an Array"></a>Challenge 3: Find the k Largest Elements in an Array</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/17/cs61b%20week14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/cs61b%20week14/" class="post-title-link" itemprop="url">cs61b week14</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-17 11:53:58 / 修改时间：11:55:10" itemprop="dateCreated datePublished" datetime="2020-09-17T11:53:58+09:00">2020-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cs61b/" itemprop="url" rel="index"><span itemprop="name">cs61b</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="cs61b-week14"><a href="#cs61b-week14" class="headerlink" title="cs61b week14"></a>cs61b week14</h1><h1 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a>Compression</h1><p>Compression Model #1: Algorithms Operating on Bits.</p>
<ul>
<li>Bitstream -&gt; Algorithms Operating on Bits -&gt; Compressed bits C</li>
<li>Compressed bits C -&gt; Decompression Algorithm -&gt; Bitstream</li>
</ul>
<p>A lossless compression algorithm require that no information is lost.</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/17/cs61b%20week14/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/17/cs61b%20week12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/cs61b%20week12/" class="post-title-link" itemprop="url">cs61b week12</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-17 11:50:24 / 修改时间：11:54:46" itemprop="dateCreated datePublished" datetime="2020-09-17T11:50:24+09:00">2020-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cs61b/" itemprop="url" rel="index"><span itemprop="name">cs61b</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="cs61b-week12"><a href="#cs61b-week12" class="headerlink" title="cs61b week12"></a>cs61b week12</h1><h1 id="Basic-Sorting-Algorithms"><a href="#Basic-Sorting-Algorithms" class="headerlink" title="Basic Sorting Algorithms"></a>Basic Sorting Algorithms</h1><h2 id="Definition-of-Sorting"><a href="#Definition-of-Sorting" class="headerlink" title="Definition of Sorting"></a>Definition of Sorting</h2><p>An ordering relation &lt; for keys a, b, and c has the following properties:</p>
<ul>
<li>Law of Trichotomy: Exactly one of a &lt; b, a = b, b &lt; a is true.</li>
<li>Law of Transitivity: If a &lt; b, and b &lt; c, then a &lt; c.</li>
</ul>
<p>A sort is a permutation (re-arrangement) of a sequence of elements that puts the keys into non-decreasing order relative to a given ordering relation. </p>
<p>In Java, ordering relations are typically given in the form of <code>compareTo</code> or <code>compare</code> methods.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String x, String b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x.length() - b.length();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/17/cs61b%20week12/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/15/Mock%20Interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/15/Mock%20Interview/" class="post-title-link" itemprop="url">Mock Interview</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-15 16:41:38" itemprop="dateCreated datePublished" datetime="2020-09-15T16:41:38+09:00">2020-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-19 14:31:40" itemprop="dateModified" datetime="2020-09-19T14:31:40+09:00">2020-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mock/" itemprop="url" rel="index"><span itemprop="name">mock</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Mock-Interview"><a href="#Mock-Interview" class="headerlink" title="Mock Interview"></a>Mock Interview</h1><h1 id="Case1-Shifted-Array-Search"><a href="#Case1-Shifted-Array-Search" class="headerlink" title="Case1 Shifted Array Search"></a><a href="https://www.youtube.com/watch?v=v3HVwxwbbeg" target="_blank" rel="noopener">Case1 Shifted Array Search</a></h1><p>Traverse the array twice </p>
<p>Go through the array</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/15/Mock%20Interview/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/14/AE%20Tips&Tricks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/14/AE%20Tips&Tricks/" class="post-title-link" itemprop="url">AE Tips&Tricks</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-14 19:07:08" itemprop="dateCreated datePublished" datetime="2020-09-14T19:07:08+09:00">2020-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-08 14:52:09" itemprop="dateModified" datetime="2021-02-08T14:52:09+09:00">2021-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AE/" itemprop="url" rel="index"><span itemprop="name">AE</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AE-Tips-amp-Tricks"><a href="#AE-Tips-amp-Tricks" class="headerlink" title="AE Tips&amp;Tricks"></a>AE Tips&amp;Tricks</h1><h2 id="How-to-best-use-AE"><a href="#How-to-best-use-AE" class="headerlink" title="How to best use AE?"></a>How to best use AE?</h2><ol>
<li><strong><code>Group, easy-difficult</code></strong></li>
<li>Group by category</li>
<li>Try to come up the solution by you own</li>
<li>Figure out how long before the interview and assign the tasks wisely</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/14/AE%20Tips&Tricks/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/14/AT%20week1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/14/AT%20week1/" class="post-title-link" itemprop="url">AT week1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-14 11:30:18" itemprop="dateCreated datePublished" datetime="2020-09-14T11:30:18+09:00">2020-09-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AT/" itemprop="url" rel="index"><span itemprop="name">AT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AT-week1"><a href="#AT-week1" class="headerlink" title="AT week1"></a>AT week1</h1><h3 id="What-is-an-interview-about"><a href="#What-is-an-interview-about" class="headerlink" title="What is an interview about?"></a>What is an interview about?</h3><ol>
<li>Image you are a sole founder of the company and ready to hire the first employee. How would you design the interview?<ul>
<li>Find out if the candidate will be an awesome future colleague </li>
<li>If we really want to work with you and we feel excited to have you on the team, you are definitely hired. Looking for both positive and negative signals.</li>
</ul>
</li>
</ol>
<h3 id="What-signals-to-look-for-in-a-coding-interview"><a href="#What-signals-to-look-for-in-a-coding-interview" class="headerlink" title="What signals to look for in a coding interview?"></a>What signals to look for in a coding interview?</h3><ol>
<li>Image you are a hired great engineer. You really enjoy working with this person. What are the traits that make them awesome to work with</li>
<li><strong><code>Their code is easy to read and understand.</code></strong> When you need to read their code, you can understand what they try to achieve and how they achieve it with the code they wrote.</li>
<li><strong><code>They can help you turn  a problem into clear logic.</code></strong> When you have a messy problem and don’t  know where to start you consult them. They bring you clarify. You feel the logic is so obvious that you can just turn it into clean code</li>
<li><strong><code>You feel they understand you.</code></strong> Sometimes you have a problem that you can’t even clearly describe what you want. You talk to them. They ask a few questions to learn from you. And then they describe your problem in a much better way.</li>
<li><strong><code>You feel comfortable delegating work to them.</code></strong> They don’t keep you in the dark. They explain how they are going to work succinctly. They deliver what they promise. They update you when they need to change the plan</li>
<li>They respond to your feedback in a positive way, When you point out where their work can be improved, they focus on how to achieve that improvement with you. They don’t become overly defensive.</li>
</ol>
<h3 id="Summary-of-the-signals"><a href="#Summary-of-the-signals" class="headerlink" title="Summary of the signals"></a>Summary of the signals</h3><ol>
<li>Communication<ul>
<li>Succinct articulation</li>
<li>Talking feedback</li>
</ul>
</li>
<li>Problem solving</li>
<li>Coding<ul>
<li>Language proficiency</li>
<li>Code quality</li>
</ul>
</li>
<li>Debugging and testing</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/09/Lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/09/Lab/" class="post-title-link" itemprop="url">Lab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-09 13:30:41" itemprop="dateCreated datePublished" datetime="2020-09-09T13:30:41+09:00">2020-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-15 11:25:58" itemprop="dateModified" datetime="2020-09-15T11:25:58+09:00">2020-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cs61b/" itemprop="url" rel="index"><span itemprop="name">cs61b</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-1-Setup-Setting-Up-Your-Computer"><a href="#Lab-1-Setup-Setting-Up-Your-Computer" class="headerlink" title="Lab 1 Setup: Setting Up Your Computer"></a>Lab 1 Setup: Setting Up Your Computer</h1><h1 id="Lab1-Lab1B"><a href="#Lab1-Lab1B" class="headerlink" title="Lab1, Lab1B"></a>Lab1, Lab1B</h1><h2 id="Lab1-Setup"><a href="#Lab1-Setup" class="headerlink" title="Lab1 Setup"></a>Lab1 Setup</h2><h4 id="A-Configure-Your-Computer"><a href="#A-Configure-Your-Computer" class="headerlink" title="A. Configure Your Computer"></a>A. Configure Your Computer</h4><ul>
<li><h3 id="A-Install-Java"><a href="#A-Install-Java" class="headerlink" title="A. Install Java"></a>A. Install Java</h3></li>
</ul>
<h4 id="B-Learn-to-Use-the-Terminal"><a href="#B-Learn-to-Use-the-Terminal" class="headerlink" title="B. Learn to Use the Terminal"></a>B. Learn to Use the Terminal</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/09/Lab/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/04/cs61b%20week11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/04/cs61b%20week11/" class="post-title-link" itemprop="url">cs61b week11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-04 10:18:09" itemprop="dateCreated datePublished" datetime="2020-09-04T10:18:09+09:00">2020-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-16 21:31:45" itemprop="dateModified" datetime="2020-09-16T21:31:45+09:00">2020-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cs61b/" itemprop="url" rel="index"><span itemprop="name">cs61b</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="cs61b-week11"><a href="#cs61b-week11" class="headerlink" title="cs61b week11"></a>cs61b week11</h1><h1 id="Shortest-Paths"><a href="#Shortest-Paths" class="headerlink" title="Shortest Paths"></a>Shortest Paths</h1><h2 id="BFS-v-s-DFS-for-Path-Finding"><a href="#BFS-v-s-DFS-for-Path-Finding" class="headerlink" title="BFS v.s. DFS for Path Finding"></a>BFS v.s. DFS for Path Finding</h2><ul>
<li>BFS returns path with shortest number of edges.</li>
<li>Time efficiency is similar for both algorithms.</li>
<li>Space Efficiency is quite different.</li>
<li><ul>
<li>DFS is worse for spindly graphs. (Call stack gets very deep.)</li>
</ul>
</li>
<li><ul>
<li>BFS is worse for bushy graphs. (Queue gets very large.)</li>
</ul>
</li>
<li>Track the <code>distTo</code> and <code>edgeTo</code> arrays requires <code>Θ(V)</code> memory.</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/04/cs61b%20week11/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dejavu"
      src="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
  <p class="site-author-name" itemprop="name">Dejavu</p>
  <div class="site-description" itemprop="description">Stay gold</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Dejavu-19" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Dejavu-19" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/liu.kunling19@gmail.com" title="E-Mail → liu.kunling19@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dejavu</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false});</script></body>
</html>
