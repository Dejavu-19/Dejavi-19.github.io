<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dejavi-19.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Stay gold">
<meta property="og:type" content="website">
<meta property="og:title" content="Dejavu&#39;s Notebook">
<meta property="og:url" content="https://dejavi-19.github.io/page/3/index.html">
<meta property="og:site_name" content="Dejavu&#39;s Notebook">
<meta property="og:description" content="Stay gold">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Dejavu">
<meta property="article:tag" content="python">
<meta property="article:tag" content="java">
<meta property="article:tag" content="hexo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dejavi-19.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dejavu's Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/Dejavu-19" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dejavu's Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Alea iacta est</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首&emsp;&emsp;页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于博主</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标&emsp;&emsp;签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分&emsp;&emsp;类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归&emsp;&emsp;档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/10/21/Princeton%20Algorithms%20week3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/21/Princeton%20Algorithms%20week3/" class="post-title-link" itemprop="url">Princeton Algorithms week3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-21 20:01:06" itemprop="dateCreated datePublished" datetime="2020-10-21T20:01:06+09:00">2020-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-27 15:31:47" itemprop="dateModified" datetime="2020-10-27T15:31:47+09:00">2020-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Princeton-Algorithms-week3"><a href="#Princeton-Algorithms-week3" class="headerlink" title="Princeton Algorithms week3"></a>Princeton Algorithms week3</h1><p><strong>Suggested Readings.</strong> <strong><code>Section 2.2</code></strong> and <strong><code>2.3</code></strong> in <em>Algorithms, 4th edition</em>.</p>
<p><a href="https://coursera.cs.princeton.edu/algs4/assignments/collinear/specification.php" target="_blank" rel="noopener">assignment</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/10/21/Princeton%20Algorithms%20week3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/10/14/Searching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/Searching/" class="post-title-link" itemprop="url">Searching</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 19:01:23" itemprop="dateCreated datePublished" datetime="2020-10-14T19:01:23+09:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-13 23:38:07" itemprop="dateModified" datetime="2021-03-13T23:38:07+09:00">2021-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h1><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p><img src="https://camo.githubusercontent.com/17135f6479126d3322eb4c81746c7b7693f8f34b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39353930333837382d373235622d346564392d626465642d6263346161653037393261392e6a7067" alt=""></p>
<p>广度优先搜索一层一层地进行遍历，每层遍历都是以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。</p>
<p>需要注意的是，遍历过的节点不能再次被遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一层：</span><br><span class="line">- <span class="number">0</span> -&gt; &#123;<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">第二层：</span><br><span class="line">- <span class="number">6</span> -&gt; &#123;<span class="number">4</span>&#125;</span><br><span class="line">- <span class="number">2</span> -&gt; &#123;&#125;</span><br><span class="line">- <span class="number">1</span> -&gt; &#123;&#125;</span><br><span class="line">- <span class="number">5</span> -&gt; &#123;<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">第三层：</span><br><span class="line">- <span class="number">4</span> -&gt; &#123;&#125;</span><br><span class="line">- <span class="number">3</span> -&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>每一层遍历的节点都与根节点距离相同。设 di 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 di &lt;= dj。</p>
<p>利用这个结论，可以求解最短路径等 <strong>最优解</strong> 问题：第一次遍历到目的节点，其所经过的路径为最短路径。</p>
<p>应该注意的是，使用 BFS 只能求解无权图的最短路径，无权图是指从一个节点到另一个节点的代价都记为 1。</p>
<p>在程序实现 BFS 时需要考虑以下问题：</p>
<ul>
<li>队列：用来存储每一轮遍历得到的节点；</li>
<li>标记：对于遍历过的节点，应该将它标记，防止重复遍历。</li>
</ul>
<h2 id="547-Number-of-Provinces⭐"><a href="#547-Number-of-Provinces⭐" class="headerlink" title="547. Number of Provinces⭐"></a><a href="https://leetcode.com/problems/number-of-provinces/" target="_blank" rel="noopener">547. Number of Provinces⭐</a></h2><p>There are <code>n</code> cities. Some of them are connected, while some are not. If city <code>a</code> is connected directly with city <code>b</code>, and city <code>b</code> is connected directly with city <code>c</code>, then city <code>a</code> is connected indirectly with city <code>c</code>.</p>
<p>A <strong>province</strong> is a group of directly or indirectly connected cities and no other cities outside of the group.</p>
<p>You are given an <code>n x n</code> matrix <code>isConnected</code> where <code>isConnected[i][j] = 1</code> if the <code>ith</code> city and the <code>jth</code> city are directly connected, and <code>isConnected[i][j] = 0</code> otherwise.</p>
<p>Return <em>the total number of *</em>provinces***.</p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: isConnected = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = isConnected.length;</span><br><span class="line">    <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(i, visited, isConnected);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] visited, <span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//find all connection and mark it has been visited(include itselt)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; isConnected.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            visited[j] = -<span class="number">1</span>;</span><br><span class="line">            dfs(j, visited, isConnected);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[isConnected.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isConnected.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            dfs(i, visited, isConnected);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> city, <span class="keyword">int</span>[] visited, <span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    visited[city] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isConnected.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; isConnected[i][city] == <span class="number">1</span>) &#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(i, visited, isConnected);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Union Find</li>
<li>This is a typical <code>Union Find</code> problem - a similar problem is <a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="noopener">Graph Valid Tree</a><br>A bit advanced Union Find problems are <a href="https://leetcode.com/problems/number-of-islands-ii/#/description" target="_blank" rel="noopener">Number of Islands II</a> and <a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/#/description" target="_blank" rel="noopener">Number of Connected Components</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = M.length, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] root = <span class="keyword">new</span> <span class="keyword">int</span>[m]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) root[i] = i; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) unionFind(root, i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">if</span> (i == root[i]) cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionFind</span> <span class="params">(<span class="keyword">int</span>[] root, <span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root[v1] != v1) v1 = root[v1]; <span class="comment">//find v1's root</span></span><br><span class="line">    <span class="keyword">while</span> (root[v2] != v2) v2 = root[v2]; <span class="comment">//find v2's root</span></span><br><span class="line">    <span class="keyword">if</span> (root[v1] != root[v2]) root[v2] = v1; <span class="comment">//unite the 2 subtrees </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent, rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">            parent[p] = parent[parent[p]];    <span class="comment">// path compression by halving</span></span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[rootQ] &gt; rank[rootP]) &#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootP] == rank[rootQ]) &#123;</span><br><span class="line">                rank[rootP]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = M.length;</span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) uf.union(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uf.count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Old-version-547-Friend-Circles"><a href="#Old-version-547-Friend-Circles" class="headerlink" title="Old version 547. Friend Circles"></a>Old version 547. Friend Circles</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Explanation:The <span class="number">0</span>th and <span class="number">1</span>st students are direct friends, so they are in a friend circle.</span><br><span class="line">The <span class="number">2</span>nd student himself is in a friend circle. So <span class="keyword">return</span> <span class="number">2</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>题目描述：好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，那么 M[0] [1] 和 M[1] [0] 的值都为 1。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    n = M.length;</span><br><span class="line">    <span class="keyword">int</span> circleNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasVisited[i]) &#123;</span><br><span class="line">            dfs(M, i, hasVisited);</span><br><span class="line">            circleNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> circleNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> i, <span class="keyword">boolean</span>[] hasVisited)</span> </span>&#123;</span><br><span class="line">    hasVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (M[i][k] == <span class="number">1</span> &amp;&amp; !hasVisited[k]) &#123;</span><br><span class="line">            dfs(M, k, hasVisited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="994-Rotting-Oranges⭐"><a href="#994-Rotting-Oranges⭐" class="headerlink" title="994. Rotting Oranges⭐"></a><a href="https://leetcode.com/problems/rotting-oranges/" target="_blank" rel="noopener">994. Rotting Oranges⭐</a></h2><p><img src="https://assets.leetcode.com/uploads/2019/02/16/oranges.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>One of the most distinguished code patterns in BFS algorithms is that often we use a <strong><em>queue</em></strong> data structure to keep track of the candidates that we need to visit during the process.</p>
<p>The main algorithm is built around a loop iterating through the queue. At each iteration, we <em>pop</em> out an element from the head of the queue. Then we do some particular process with the popped element. More importantly, we then <em>append</em> neighbors of the popped element into the queue, to keep the BFS process running.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minutes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fresh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = grid.length;</span><br><span class="line">    <span class="keyword">int</span> c = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Put the position of all rotten oranges in queue, count the number of fresh oranges</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) fresh++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//edge case, if count of fresh oranges is zero --&gt; return 0 </span></span><br><span class="line">    <span class="keyword">if</span> (fresh == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//bfs starting from initially rotten oranges</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextR = cur[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nextC = cur[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nextR &lt; <span class="number">0</span> || nextR &gt;= r || nextC &lt; <span class="number">0</span> || nextC &gt;= c || grid[nextR][nextC] != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//mark the orange at (x , y) as rotten</span></span><br><span class="line">                grid[nextR][nextC] = <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//decrease the count of fresh oranges by 1</span></span><br><span class="line">                fresh--;</span><br><span class="line">                <span class="comment">//put the new rotten orange at (x , y) in queue</span></span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nextR, nextC&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        minutes++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//node result is minute - 1</span></span><br><span class="line">    <span class="keyword">return</span> fresh == <span class="number">0</span> ? minutes - <span class="number">1</span> : -<span class="number">1</span>;  <span class="comment">//last step do not increase minutes so -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="127-Word-Ladder⭐💜"><a href="#127-Word-Ladder⭐💜" class="headerlink" title="127. Word Ladder⭐💜"></a><a href="https://leetcode.com/problems/word-ladder/description/" target="_blank" rel="noopener">127. Word Ladder⭐💜</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = <span class="string">"hit"</span>,</span><br><span class="line">endWord = <span class="string">"cog"</span>,</span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is <span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span>,</span><br><span class="line"><span class="keyword">return</span> its length <span class="number">5</span>.</span><br><span class="line">    </span><br><span class="line">Input:</span><br><span class="line">beginWord = <span class="string">"hit"</span></span><br><span class="line">endWord = <span class="string">"cog"</span></span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Explanation: The endWord <span class="string">"cog"</span> is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>

<p><img src="https://leetcode.com/problems/word-ladder/Figures/127/Word_Ladder_1.png" alt=""></p>
<p>题目描述：找出一条从 beginWord 到 endWord 的最短路径，每次移动规定为改变一个字符，并且改变之后的字符串必须在 wordList 中。</p>
<h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>思路：BFS（广度优先搜索）因为只要找最短的可能，所以每次只找下一层的所有可能，再一层层递进，直到 找到。和广度优先遍历类似，使用一个 Set 缓存下一层可能的词，然后到下一层逐一试。</p>
</li>
<li><p>Time Complexity: O<em>(</em>M^2×N), where Mis the length of each word and N is the total number of words in the input word list.</p>
<p>pace Complexity: O<em>(</em>M^2×N).</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginWord.equals(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">1</span>;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(beginWord);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] current = queue.poll().toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; current.length; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> pre = current[j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                    current[j] = c;</span><br><span class="line">                    <span class="comment">//char[] -&gt; Stirng : use new String(chars) | String.valueOf(chars)</span></span><br><span class="line">                    String next = <span class="keyword">new</span> String(current);</span><br><span class="line">                    <span class="comment">//when the changed word contained in the wordlist</span></span><br><span class="line">                    <span class="keyword">if</span> (set.contains(next)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (next.equals(endWord)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> steps + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        set.remove(next);</span><br><span class="line">                        queue.add(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//undo the change for next position character</span></span><br><span class="line">                current[j] = pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-126-Word-Ladder-II⭐"><a href="#🌕Unsolved-126-Word-Ladder-II⭐" class="headerlink" title="🌕Unsolved 126. Word Ladder II⭐"></a><a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank" rel="noopener">🌕Unsolved 126. Word Ladder II⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">        HashSet&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        buildGraph(beginWord, endWord, graph, dict);</span><br><span class="line">        dfs(beginWord, endWord, graph, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(String beginWord, String endWord, HashMap&lt;String, List&lt;String&gt;&gt; graph, HashSet&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        HashSet&lt;String&gt; toVisit = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        toVisit.add(beginWord);</span><br><span class="line">        <span class="keyword">boolean</span> foundEnd = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            visited.addAll(toVisit);</span><br><span class="line">            toVisit.clear();</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                String word = queue.poll();</span><br><span class="line">                List&lt;String&gt; children = getNextLevel(word, dict);</span><br><span class="line">                <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (child.equals(endWord)) foundEnd = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(child)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!graph.containsKey(word)) &#123;</span><br><span class="line">                            graph.put(word, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">                        &#125;</span><br><span class="line">                        graph.get(word).add(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(child) &amp;&amp; !toVisit.contains(child)) &#123;</span><br><span class="line">                        queue.offer(child);</span><br><span class="line">                        toVisit.add(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (foundEnd) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getNextLevel</span><span class="params">(String word, HashSet&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chs[i] == c) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">char</span> t = chs[i];</span><br><span class="line">                chs[i] = c;</span><br><span class="line">                String target = String.valueOf(chs);</span><br><span class="line">                <span class="keyword">if</span> (dict.contains(target)) result.add(target);</span><br><span class="line">                chs[i] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String curWord, String endWord, HashMap&lt;String, List&lt;String&gt;&gt; graph, List&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        path.add(curWord);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curWord.equals(endWord)) result.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(path));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (graph.containsKey(curWord)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String nextWord : graph.get(curWord)) &#123;</span><br><span class="line">                dfs(nextWord, endWord, graph, path, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>The basic idea is:</p>
<p>1). Use BFS to find the shortest distance between start and end, tracing the distance of crossing nodes from start node to end node, and store node’s next level neighbors to HashMap;</p>
<p>2). Use DFS to output paths with the same distance as the shortest distance from distance HashMap: compare if the distance of the next level node equals the distance of the current node + 1.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, List&lt;String&gt; wordList) &#123;</span><br><span class="line">    HashSet&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;String&gt;(wordList);</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();         </span><br><span class="line">    HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt;();<span class="comment">// Neighbors for every node</span></span><br><span class="line">    HashMap&lt;String, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();<span class="comment">// Distance of every node from the start node</span></span><br><span class="line">    ArrayList&lt;String&gt; solution = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    dict.add(start);          </span><br><span class="line">    bfs(start, end, dict, nodeNeighbors, distance);                 </span><br><span class="line">    dfs(start, end, dict, nodeNeighbors, distance, solution, res);   </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS: Trace every node's distance from the start node (level by level).</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String start, </span></span></span><br><span class="line"><span class="function"><span class="params">                 String end, </span></span></span><br><span class="line"><span class="function"><span class="params">                 Set&lt;String&gt; dict, </span></span></span><br><span class="line"><span class="function"><span class="params">                 HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors, </span></span></span><br><span class="line"><span class="function"><span class="params">                 HashMap&lt;String, Integer&gt; distance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String str : dict)</span><br><span class="line">        nodeNeighbors.put(str, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    queue.offer(start);</span><br><span class="line">    distance.put(start, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = queue.size();</span><br><span class="line">        <span class="keyword">boolean</span> foundEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> curDistance = distance.get(cur);                </span><br><span class="line">            ArrayList&lt;String&gt; neighbors = getNeighbors(cur, dict);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">                nodeNeighbors.get(cur).add(neighbor);</span><br><span class="line">                <span class="keyword">if</span> (!distance.containsKey(neighbor)) &#123;<span class="comment">// Check if visited</span></span><br><span class="line">                    distance.put(neighbor, curDistance + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (end.equals(neighbor))<span class="comment">// Found the shortest path</span></span><br><span class="line">                        foundEnd = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (foundEnd)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all next level nodes.    </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String node, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">char</span> chs[] = node.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch =<span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chs[i] == ch) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">char</span> old_ch = chs[i];</span><br><span class="line">            chs[i] = ch;</span><br><span class="line">            <span class="keyword">if</span> (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">                res.add(String.valueOf(chs));</span><br><span class="line">            &#125;</span><br><span class="line">            chs[i] = old_ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS: output all paths with the shortest distance.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String cur, String end, Set&lt;String&gt; dict, HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors, HashMap&lt;String, Integer&gt; distance, ArrayList&lt;String&gt; solution, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">    solution.add(cur);</span><br><span class="line">    <span class="keyword">if</span> (end.equals(cur)) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(solution));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String next : nodeNeighbors.get(cur)) &#123;            </span><br><span class="line">            <span class="keyword">if</span> (distance.get(next) == distance.get(cur) + <span class="number">1</span>) &#123;</span><br><span class="line">                dfs(next, end, dict, nodeNeighbors, distance, solution, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;           </span><br><span class="line">    solution.remove(solution.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * High level design: BFS + DFS</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Step 1: use BFS to build graph (adjacency list of each word), as well as calculating distance from beginWord to </span></span><br><span class="line"><span class="comment"> * each node in the graph (should store minimum distance)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Step 2: use DFS to traverse and record path from beginWord to endWord with shortest path. We can use distance map</span></span><br><span class="line"><span class="comment"> * to control every next word. </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (wordList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result: result list to store final return list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph: adjacency list of key - store all neighbors of each word (neighbor means all words in dictionary </span></span><br><span class="line"><span class="comment">     *             that only has one character difference with key)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> distance: distance between beginWord and current key word, used for tracing path when we do DFS</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dict: word dictionary, efficient for searching purpose</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line"></span><br><span class="line">    bfs(beginWord, endWord, dict, graph, distance);</span><br><span class="line">    dfs(result, graph, distance, endWord, beginWord, <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(beginWord)));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String beginWord, String endWord, Set&lt;String&gt; dict, Map&lt;String, Set&lt;String&gt;&gt; graph, Map&lt;String, Integer&gt; distance)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(beginWord);</span><br><span class="line">    distance.put(beginWord, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> reachEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            String curWord = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* try all possible substitution (26 characters) in every position of current word, if newWord exists in dictionary, </span></span><br><span class="line"><span class="comment">               we add it to the adjacency list of curWord */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curWord.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] curWordArr = curWord.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                    curWordArr[j] = c;</span><br><span class="line">                    String newWord = <span class="keyword">new</span> String(curWordArr);</span><br><span class="line">                    <span class="keyword">if</span> (dict.contains(newWord)) &#123;</span><br><span class="line">                        graph.putIfAbsent(curWord, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                        graph.get(curWord).add(newWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// traverse all neighbors of current word, update distance map and queue for next ladder (level)</span></span><br><span class="line">            <span class="comment">// WARNING: DO NOT USE visited set, since it is hard to deal with end word if endWord is visited</span></span><br><span class="line">            <span class="keyword">for</span> (String neighbor : graph.get(curWord)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!distance.containsKey(neighbor)) &#123;</span><br><span class="line">                    distance.put(neighbor, distance.get(curWord) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (neighbor.equals(endWord)) &#123;</span><br><span class="line">                        reachEnd = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        queue.offer(neighbor);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reachEnd) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;String&gt;&gt; result, Map&lt;String, Set&lt;String&gt;&gt; graph, Map&lt;String, Integer&gt; distance,</span></span></span><br><span class="line"><span class="function"><span class="params">                String endWord, String curWord, List&lt;String&gt; tempList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curWord.equals(endWord)) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String nextWord : graph.get(curWord)) &#123;</span><br><span class="line">        <span class="comment">// only if next node is on the minimum path to the endWord, we can traverse it</span></span><br><span class="line">        <span class="keyword">if</span> (distance.get(nextWord) == distance.get(curWord) + <span class="number">1</span>) &#123;</span><br><span class="line">            tempList.add(nextWord);</span><br><span class="line">            dfs(result, graph, distance, endWord, nextWord, tempList);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-1258-Synonymous-Sentences⭐"><a href="#🌕Unsolved-1258-Synonymous-Sentences⭐" class="headerlink" title="🌕Unsolved 1258. Synonymous Sentences⭐"></a><a href="https://leetcode.com/problems/synonymous-sentences/" target="_blank" rel="noopener">🌕Unsolved 1258. Synonymous Sentences⭐</a></h2><p>Given a list of pairs of equivalent words <code>synonyms</code> and a sentence <code>text</code>, Return all possible synonymous sentences <strong>sorted lexicographically</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">synonyms = [[<span class="string">"happy"</span>,<span class="string">"joy"</span>],[<span class="string">"sad"</span>,<span class="string">"sorrow"</span>],[<span class="string">"joy"</span>,<span class="string">"cheerful"</span>]],</span><br><span class="line">text = <span class="string">"I am happy today but was sad yesterday"</span></span><br><span class="line">Output:</span><br><span class="line">[<span class="string">"I am cheerful today but was sad yesterday"</span>,</span><br><span class="line"><span class="string">"I am cheerful today but was sorrow yesterday"</span>,</span><br><span class="line"><span class="string">"I am happy today but was sad yesterday"</span>,</span><br><span class="line"><span class="string">"I am happy today but was sorrow yesterday"</span>,</span><br><span class="line"><span class="string">"I am joy today but was sad yesterday"</span>,</span><br><span class="line"><span class="string">"I am joy today but was sorrow yesterday"</span>]</span><br><span class="line"></span><br><span class="line">synonyms = [[<span class="string">"happy"</span>,<span class="string">"joy"</span>],[<span class="string">"strong"</span>,<span class="string">"healthy"</span>],[<span class="string">"joy"</span>,<span class="string">"cheerful"</span>]],</span><br><span class="line">text = <span class="string">"I am happy and strong"</span></span><br><span class="line">This solution will work like below picture</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/users/hiepit/image_1573965953.png" alt=""></p>
<h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateSentences</span><span class="params">(List&lt;List&lt;String&gt;&gt; synonyms, String text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//build graph</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; pair : synonyms) &#123;</span><br><span class="line">        String s1 = pair.get(<span class="number">0</span>);</span><br><span class="line">        String s2 = pair.get(<span class="number">1</span>);</span><br><span class="line">        connect(graph, s1, s2);</span><br><span class="line">        connect(graph, s2, s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    Set&lt;String&gt; ans = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(text);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        ans.add(cur);</span><br><span class="line">        String[] words = cur.split(<span class="string">"\\s"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph.get(words[i]) == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// Replace words[i] with its synonym</span></span><br><span class="line">            <span class="keyword">for</span> (String neighbor : graph.get(words[i])) &#123;</span><br><span class="line">                words[i] = neighbor;</span><br><span class="line">                String next = String.join(<span class="string">" "</span>, words);</span><br><span class="line">                <span class="keyword">if</span> (!ans.contains(next)) &#123;</span><br><span class="line">                    queue.add(next);  <span class="comment">//pay attention to here</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; graph, String s1, String s2)</span> </span>&#123;</span><br><span class="line">    graph.putIfAbsent(s1, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    graph.get(s1).add(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateSentences</span><span class="params">(List&lt;List&lt;String&gt;&gt; synonyms, String text)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; ans = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    buildGraph(graph, synonyms);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(text);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        ans.add(cur);</span><br><span class="line">        String[] strs = cur.split(<span class="string">"\\s+"</span>);  <span class="comment">//note</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            List&lt;String&gt; list = graph.get(strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String neighbor : list) &#123;</span><br><span class="line">                    strs[i] = neighbor;</span><br><span class="line">                    String next = String.join(<span class="string">" "</span>, strs);  <span class="comment">//note</span></span><br><span class="line">                    <span class="keyword">if</span> (!ans.contains(next)) &#123;</span><br><span class="line">                        queue.add(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; graph, List&lt;List&lt;String&gt;&gt; synonyms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; list : synonyms) &#123;</span><br><span class="line">        String s1 = list.get(<span class="number">0</span>);</span><br><span class="line">        String s2 = list.get(<span class="number">1</span>);</span><br><span class="line">        graph.putIfAbsent(s1, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        graph.get(s1).add(s2);</span><br><span class="line">        graph.putIfAbsent(s2, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        graph.get(s2).add(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="675-Cut-Off-Trees-for-Golf-Event⭐"><a href="#675-Cut-Off-Trees-for-Golf-Event⭐" class="headerlink" title="675. Cut Off Trees for Golf Event⭐"></a><a href="https://leetcode.com/problems/cut-off-trees-for-golf-event/" target="_blank" rel="noopener">675. Cut Off Trees for Golf Event⭐</a></h2><p><img src="https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: forest = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: Following the path above allows you to cut off the trees from shortest to tallest in <span class="number">6</span> steps.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: forest = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br><span class="line">Output: -<span class="number">1</span></span><br><span class="line">Explanation: The trees in the bottom row cannot be accessed as the middle row is blocked.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Since we have to cut trees in order of their height, we first put trees (int[] {row, col, height}) into a priority queue and sort by height.</li>
<li>Poll each tree from the queue and use BFS to find out steps needed.</li>
<li>The worst case time complexity could be O(m^2 * n^2) (m = number of rows, n = number of columns) since there are m * n trees and for each BFS worst case time complexity is O(m * n) too.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] dir = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (forest == <span class="keyword">null</span> || forest.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = forest.size(), n = forest.get(<span class="number">0</span>).size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heap : int[]&#123;x, y, height of tree&#125;</span></span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (forest.get(i).get(j) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j, forest.get(i).get(j)&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] tree = pq.poll();</span><br><span class="line">        <span class="comment">//BFS calculate steps from start to cur tree position</span></span><br><span class="line">        <span class="keyword">int</span> step = minStep(forest, start, tree, m, n);</span><br><span class="line">        <span class="comment">//if can't reach return -1</span></span><br><span class="line">        <span class="keyword">if</span> (step &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        sum += step;</span><br><span class="line">        <span class="comment">//update start point -&gt; tree postion for next round</span></span><br><span class="line">        start[<span class="number">0</span>] = tree[<span class="number">0</span>];</span><br><span class="line">        start[<span class="number">1</span>] = tree[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minStep</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] tree, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(start);</span><br><span class="line">    visited[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (curr[<span class="number">0</span>] == tree[<span class="number">0</span>] &amp;&amp; curr[<span class="number">1</span>] == tree[<span class="number">1</span>]) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dir) &#123;</span><br><span class="line">                <span class="keyword">int</span> nr = curr[<span class="number">0</span>] + d[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nc = curr[<span class="number">1</span>] + d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nr &gt;= m || nc &lt; <span class="number">0</span> || nc &gt;= n </span><br><span class="line">                    || forest.get(nr).get(nc) == <span class="number">0</span> || visited[nr][nc]) <span class="keyword">continue</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nr, nc&#125;);</span><br><span class="line">                visited[nr][nc] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> tr, <span class="keyword">int</span> tc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R = forest.size(), C = forest.get(<span class="number">0</span>).size();</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr, sc, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line">    seen[sr][sc] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (cur[<span class="number">0</span>] == tr &amp;&amp; cur[<span class="number">1</span>] == tc) <span class="keyword">return</span> cur[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">0</span>; di &lt; <span class="number">4</span>; ++di) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = cur[<span class="number">0</span>] + dr[di];</span><br><span class="line">            <span class="keyword">int</span> c = cur[<span class="number">1</span>] + dc[di];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= r &amp;&amp; r &lt; R &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; C &amp;&amp;</span><br><span class="line">                    !seen[r][c] &amp;&amp; forest.get(r).get(c) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                seen[r][c] = <span class="keyword">true</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c, cur[<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1091-Shortest-Path-in-Binary-Matrix🎂⭐"><a href="#1091-Shortest-Path-in-Binary-Matrix🎂⭐" class="headerlink" title="1091. Shortest Path in Binary Matrix🎂⭐"></a><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">1091. Shortest Path in Binary Matrix🎂⭐</a></h2><p><img src="https://assets.leetcode.com/uploads/2019/08/04/example2_2.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p>In an N by N square grid, each cell is either empty (0) or blocked (1).</p>
<p>A <em>clear path from top-left to bottom-right</em> has length <code>k</code> if and only if it is composed of cells <code>C_1, C_2, ..., C_k</code> such that:</p>
<ul>
<li>Adjacent cells <code>C_i</code> and <code>C_{i+1}</code> are connected 8-directionally (ie., they are different and share an edge or corner)</li>
<li><code>C_1</code> is at location <code>(0, 0)</code> (ie. has value <code>grid[0][0]</code>)</li>
<li><code>C_k</code> is at location <code>(N-1, N-1)</code> (ie. has value <code>grid[N-1][N-1]</code>)</li>
<li>If <code>C_i</code> is located at <code>(r, c)</code>, then <code>grid[r][c]</code> is empty (ie. <code>grid[r][c] == 0</code>).</li>
</ul>
<p>Return the length of the shortest such clear path from top-left to bottom-right. If such a path does not exist, return -1.</p>
<h3 id="Solition1"><a href="#Solition1" class="headerlink" title="Solition1:"></a>Solition1:</h3><ol>
<li>题目描述：0 表示可以经过某个位置，求解从左上角到右下角的最短路径长度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//corner case</span></span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span> || grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || grid[grid.length - <span class="number">1</span>][grid[<span class="number">0</span>].length - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Set&lt;int[]&gt; visited = new HashSet&lt;&gt;();</span></span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="comment">//visited.add(new int[]&#123;0, 0&#125;);</span></span><br><span class="line">    grid[<span class="number">0</span>][<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur[<span class="number">0</span>] == m - <span class="number">1</span> &amp;&amp; cur[<span class="number">1</span>] == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> steps;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = d[<span class="number">0</span>] + cur[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> c = d[<span class="number">1</span>] + cur[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || grid[r][c] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line">                grid[r][c] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination⭐"><a href="#🌕1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination⭐" class="headerlink" title="🌕1293. Shortest Path in a Grid with Obstacles Elimination⭐"></a><a href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/" target="_blank" rel="noopener">🌕1293. Shortest Path in a Grid with Obstacles Elimination⭐</a></h2><h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[][][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n][k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] original = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    visited[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    queue.add(original);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> r = cur[<span class="number">0</span>], c = cur[<span class="number">1</span>], curK = cur[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) <span class="keyword">return</span> steps;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextR = r + d[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nextC = c + d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> nextK = curK;</span><br><span class="line">                <span class="keyword">if</span> (nextR &gt;= <span class="number">0</span> &amp;&amp; nextR &lt; m &amp;&amp; nextC &gt;= <span class="number">0</span> &amp;&amp; nextC &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[nextR][nextC] == <span class="number">1</span>) &#123;</span><br><span class="line">                        nextK++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (nextK &lt;=k &amp;&amp; !visited[nextR][nextC][nextK]) &#123;</span><br><span class="line">                        visited[nextR][nextC][nextK] = <span class="keyword">true</span>;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nextR, nextC, nextK&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] DIRS = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] seen = <span class="keyword">new</span> <span class="keyword">int</span>[m][n]; <span class="comment">// min obstacles elimination from (0,0) to (x, y)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        Arrays.fill(seen[i], Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    seen[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur[<span class="number">0</span>] == m - <span class="number">1</span> &amp;&amp; cur[<span class="number">1</span>] == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : DIRS) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = dir[<span class="number">0</span>] + cur[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = dir[<span class="number">1</span>] + cur[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> o = grid[x][y] + cur[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (o &gt;= seen[x][y] || o &gt; k) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                seen[x][y] = o;</span><br><span class="line">                q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y, o&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="🌕Unsolved279-Perfect-Squares✨"><a href="#🌕Unsolved279-Perfect-Squares✨" class="headerlink" title="🌕Unsolved279.Perfect Squares✨"></a><a href="https://leetcode.com/problems/perfect-squares/description/" target="_blank" rel="noopener">🌕Unsolved279.Perfect Squares✨</a></h2><p>For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>
<p><a href="https://leetcode.com/problems/perfect-squares/discuss/71488/Summary-of-4-different-solutions-(BFS-DP-static-DP-and-mathematics)" target="_blank" rel="noopener">Summary of 4 different solutions (BFS, DP, static DP and mathematics)</a></p>
<h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。</p>
<p>要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。</p>
<p>本题也可以用动态规划求解，在之后动态规划部分中会再次出现。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    q.offer(<span class="number">0</span>);</span><br><span class="line">    visited.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i*i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = u+i*i;</span><br><span class="line">                <span class="keyword">if</span>(v == n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(v &gt; n) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(v)) &#123;</span><br><span class="line">                    q.offer(v);</span><br><span class="line">                    visited.add(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：动态规划。寻找 dp[i]最小的可能性，只要寻找 i 减去平方为 j 及以下的所有可能平方数（i-j*j）的可能性+1 中最小的值。O(n2 )</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j*j &lt;= i; ++j)</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i-j*j] + <span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-909-Snakes-and-Ladders🎂✨"><a href="#🌕Unsolved-909-Snakes-and-Ladders🎂✨" class="headerlink" title="🌕Unsolved 909. Snakes and Ladders🎂✨"></a><a href="https://leetcode.com/problems/snakes-and-ladders/" target="_blank" rel="noopener">🌕Unsolved 909. Snakes and Ladders🎂✨</a></h2><p><img src="https://assets.leetcode.com/users/lee215/image_1537671763.png" alt=""></p>
<h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.length;</span><br><span class="line">    <span class="comment">// convert 2D array to 1D to make processing more easier</span></span><br><span class="line">    <span class="keyword">int</span>[] flatten = convert2DTo1D(board);</span><br><span class="line">    <span class="keyword">int</span> targetIdx = n * n - <span class="number">1</span>; <span class="comment">// target index to try to reach</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();  <span class="comment">// queue for BFS</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n * n]; <span class="comment">// keep track of which node has been visited</span></span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>; <span class="comment">// keep track of number of steps (levels) we have gone in BFS</span></span><br><span class="line">    <span class="comment">// add starting node (number 1, index 0) to the queue and start BFS</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = flatten[<span class="number">0</span>] == -<span class="number">1</span> ? <span class="number">0</span> : flatten[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">    queue.offer(start);</span><br><span class="line">    visited[start] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// BFS:</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> currIdx = queue.poll();</span><br><span class="line">            <span class="comment">// in case the current index is the index we are looking for</span></span><br><span class="line">            <span class="comment">// return the number of moves used to get there</span></span><br><span class="line">            <span class="keyword">if</span> (currIdx == targetIdx) <span class="keyword">return</span> steps;</span><br><span class="line">            <span class="comment">// consider all numbers from +1 to +6, note that don't go out of bound</span></span><br><span class="line">            <span class="keyword">int</span> upper = Math.min(targetIdx, currIdx + <span class="number">6</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> nextIdx = currIdx + <span class="number">1</span>; nextIdx &lt;= upper; nextIdx++) &#123;</span><br><span class="line">                <span class="comment">// check if the nextIdx is a snake/ladder</span></span><br><span class="line">                <span class="keyword">int</span> dest = flatten[nextIdx] == -<span class="number">1</span> ? nextIdx : flatten[nextIdx] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// in case the next index is already explored, skip it</span></span><br><span class="line">                <span class="keyword">if</span> (visited[dest]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// add next index into the queue and mark it as visited</span></span><br><span class="line">                queue.offer(dest);</span><br><span class="line">                visited[dest] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] convert2DTo1D(<span class="keyword">int</span>[][] board) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.length;</span><br><span class="line">    <span class="comment">// 1D array whose size is n^2</span></span><br><span class="line">    <span class="keyword">int</span>[] rst = <span class="keyword">new</span> <span class="keyword">int</span>[n * n];</span><br><span class="line">    <span class="keyword">boolean</span> leftToRight = <span class="keyword">true</span>; <span class="comment">// order to traverse columns in each row</span></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start from the bottom row of 2D array, initially going from left to right</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// if we need to read columns from left to right</span></span><br><span class="line">            <span class="keyword">if</span> (leftToRight) &#123;</span><br><span class="line">                rst[idx++] = board[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// if we need to read columns from right to left</span></span><br><span class="line">                rst[idx++] = board[i][n - <span class="number">1</span> - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// after processing each row, switch the order</span></span><br><span class="line">        leftToRight = !leftToRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = board.length;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Integer&gt; dist = <span class="keyword">new</span> HashMap();</span><br><span class="line">    dist.put(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = queue.remove();</span><br><span class="line">        <span class="keyword">if</span> (s == N*N) <span class="keyword">return</span> dist.get(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s2 = s+<span class="number">1</span>; s2 &lt;= Math.min(s+<span class="number">6</span>, N*N); ++s2) &#123;</span><br><span class="line">            <span class="keyword">int</span> rc = get(s2, N);</span><br><span class="line">            <span class="keyword">int</span> r = rc / N, c = rc % N;</span><br><span class="line">            <span class="keyword">int</span> s2Final = board[r][c] == -<span class="number">1</span> ? s2 : board[r][c];</span><br><span class="line">            <span class="keyword">if</span> (!dist.containsKey(s2Final)) &#123;</span><br><span class="line">                dist.put(s2Final, dist.get(s) + <span class="number">1</span>);</span><br><span class="line">                queue.add(s2Final);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Given a square num s, return board coordinates (r, c) as r*N + c</span></span><br><span class="line">    <span class="keyword">int</span> quot = (s-<span class="number">1</span>) / N;</span><br><span class="line">    <span class="keyword">int</span> rem = (s-<span class="number">1</span>) % N;</span><br><span class="line">    <span class="keyword">int</span> row = N - <span class="number">1</span> - quot;</span><br><span class="line">    <span class="keyword">int</span> col = row % <span class="number">2</span> != N % <span class="number">2</span> ? rem : N - <span class="number">1</span> - rem;</span><br><span class="line">    <span class="keyword">return</span> row * N + col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕752-Open-the-Lock✨"><a href="#🌕752-Open-the-Lock✨" class="headerlink" title="🌕752. Open the Lock✨"></a><a href="https://leetcode.com/problems/open-the-lock/" target="_blank" rel="noopener">🌕752. Open the Lock✨</a></h2><h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Breadth-First Search</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(deadends));</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    q.offer(<span class="string">"0000"</span>);</span><br><span class="line">    visited.add(<span class="string">"0000"</span>);</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">            String s = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(deads.contains(s)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(target)) <span class="keyword">return</span> level;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = sb.charAt(i);</span><br><span class="line">                String s1 = sb.substring(<span class="number">0</span>, i) + (c == <span class="string">'9'</span> ? <span class="number">0</span> : c - <span class="string">'0'</span> + <span class="number">1</span>) + sb.substring(i + <span class="number">1</span>);</span><br><span class="line">                String s2 = sb.substring(<span class="number">0</span>, i) + (c == <span class="string">'0'</span> ? <span class="number">9</span> : c - <span class="string">'0'</span> - <span class="number">1</span>) + sb.substring(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(s1) &amp;&amp; !deads.contains(s1)) &#123;</span><br><span class="line">                    q.offer(s1);</span><br><span class="line">                    visited.add(s1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(s2) &amp;&amp; !deads.contains(s2)) &#123;</span><br><span class="line">                    q.offer(s2);</span><br><span class="line">                    visited.add(s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        level ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS</li>
<li>优化：把dead加到visited里</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">plusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (ch[j] == <span class="string">'9'</span>)</span><br><span class="line">        ch[j] = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ch[j] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (ch[j] == <span class="string">'0'</span>)</span><br><span class="line">        ch[j] = <span class="string">'9'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ch[j] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; dead = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String deadend : deadends) &#123;</span><br><span class="line">        dead.add(deadend);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    queue.offer(<span class="string">"0000"</span>);</span><br><span class="line">    visited.add(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            String cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (dead.contains(cur))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.equals(target))</span><br><span class="line">                <span class="keyword">return</span> steps;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(up)) &#123;</span><br><span class="line">                    queue.offer(up);</span><br><span class="line">                    visited.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(down)) &#123;</span><br><span class="line">                    queue.offer(down);</span><br><span class="line">                    visited.add(down);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕490-The-Maze✨"><a href="#🌕490-The-Maze✨" class="headerlink" title="🌕490. The Maze✨"></a><a href="https://leetcode.com/problems/the-maze/" target="_blank" rel="noopener">🌕490. The Maze✨</a></h2><p><img src="https://assets.leetcode.com/uploads/2020/09/01/maze1.png" alt=""></p>
<h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[maze.length][maze[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    Queue &lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList &lt; &gt; ();</span><br><span class="line">    queue.add(start);</span><br><span class="line">    visited[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">        <span class="comment">//if arrived destination, return true</span></span><br><span class="line">        <span class="keyword">if</span> (cur[<span class="number">0</span>] == destination[<span class="number">0</span>] &amp;&amp; cur[<span class="number">1</span>] == destination[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir: dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = cur[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = cur[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//keep add dir[] until over bounded, then minus by one dir[]</span></span><br><span class="line">            <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; maze.length &amp;&amp; y &lt; maze[<span class="number">0</span>].length &amp;&amp; maze[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                x += dir[<span class="number">0</span>];</span><br><span class="line">                y += dir[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!visited[x - dir[<span class="number">0</span>]][y - dir[<span class="number">1</span>]]) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;x - dir[<span class="number">0</span>], y - dir[<span class="number">1</span>]&#125;);</span><br><span class="line">                visited[x - dir[<span class="number">0</span>]][y - dir[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dir = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[maze.length][maze[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">return</span> dfs(maze, visited, start, destination);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span>[] c, <span class="keyword">int</span>[] des)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[c[<span class="number">0</span>]][c[<span class="number">1</span>]]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c[<span class="number">0</span>] == des[<span class="number">0</span>] &amp;&amp; c[<span class="number">1</span>] == des[<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    visited[c[<span class="number">0</span>]][c[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dir) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = c[<span class="number">0</span>] + d[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = c[<span class="number">1</span>] + d[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">0</span> &lt;= x &amp;&amp; x &lt; maze.length &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; maze[<span class="number">0</span>].length &amp;&amp; maze[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">            x += d[<span class="number">0</span>];</span><br><span class="line">            y += d[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        result = result || dfs(maze, visited, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; x - d[<span class="number">0</span>], y - d[<span class="number">1</span>]&#125;, des);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕773-Sliding-Puzzle🎂"><a href="#🌕773-Sliding-Puzzle🎂" class="headerlink" title="🌕773. Sliding Puzzle🎂"></a><a href="https://leetcode.com/problems/sliding-puzzle/" target="_blank" rel="noopener">🌕773. Sliding Puzzle🎂</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> --&gt; <span class="number">0</span> can go to &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> --&gt; <span class="number">0</span> can go to index of &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> --&gt; <span class="number">0</span> can go to &#123;<span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span> <span class="number">5</span> --&gt; <span class="number">0</span> can go to &#123;<span class="number">0</span>,<span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">0</span> <span class="number">5</span> --&gt; <span class="number">0</span> can go to &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">0</span> --&gt; <span class="number">0</span> can go to &#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Algorithm:</p>
<p>Consider each state in the board as a graph node, we just need to find out the min distance between start node and final target node “123450”. </p>
<p>Since it’s a single point to single point questions, Dijkstra is not needed here. We can simply use BFS, and also count the level we passed. Every time we swap 0 position in the String to find the next state. Use a hashTable to store the visited states.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//initail varaibles</span></span><br><span class="line">    <span class="keyword">int</span> rows = board.length;</span><br><span class="line">    <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line">    String goal = <span class="string">"123450"</span>;</span><br><span class="line">    String start = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            start += board[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            String s = queue.poll();</span><br><span class="line">            <span class="comment">//if arrive destination phase</span></span><br><span class="line">            <span class="keyword">if</span> (s == start) &#123;</span><br><span class="line">                <span class="keyword">return</span> steps;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pos = s.indexOf(<span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">int</span> x = pos % cols;</span><br><span class="line">            <span class="keyword">int</span> y = pos / cols;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] d : directions) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextX = x + d[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nextY = y + d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nextX &lt; <span class="number">0</span> || nextX &gt;= cols || nextY &lt; <span class="number">0</span> || nextY &gt;= rows) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> nextPos = nextY * cols + nextX;</span><br><span class="line">                String newS = swap(s, pos, nextPos);</span><br><span class="line">                <span class="keyword">if</span> (visited.contains(newS)) <span class="keyword">continue</span>;</span><br><span class="line">                visited.add(newS);</span><br><span class="line">                queue.add(newS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">swap</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">    chars[i] = chars[j];</span><br><span class="line">    chars[j] = temp;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/sliding-puzzle/discuss/113620/JavaPython-3-BFS-clean-codes-w-comment-Time-and-space%3A-O(m-*-n-*-(m-*-n)!)." target="_blank" rel="noopener">Explaination</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] d = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;; <span class="comment">//  relative displacements of neighbors in board.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = board.length, width = height == <span class="number">0</span> ? <span class="number">0</span> : board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// convert board to string - initial state.</span></span><br><span class="line">        String s = Arrays.deepToString(board).replaceAll(<span class="string">"\\[|\\]|,|\\s"</span>, <span class="string">""</span>); <span class="comment">// e.g., [[1,2,3],[4,0,5]] -&gt; "123405"</span></span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(s)); <span class="comment">// add initial state to queue.</span></span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;(q); <span class="comment">// used to avoid duplicates</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> steps = <span class="number">0</span>; !q.isEmpty(); ++steps) &#123; <span class="comment">// Not traverse all states yet?</span></span><br><span class="line">            <span class="comment">// loop used to control search breadth.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sz = q.size(); sz &gt; <span class="number">0</span>; --sz) &#123;</span><br><span class="line">                String str = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (str.equals(<span class="string">"123450"</span>)) &#123; <span class="keyword">return</span> steps; &#125; <span class="comment">// found target.</span></span><br><span class="line">                <span class="keyword">int</span> i = str.indexOf(<span class="string">"0"</span>), x = i / width, y = i % width; <span class="comment">// board[x][y] is '0'.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123; <span class="comment">// traverse all options.</span></span><br><span class="line">                    <span class="keyword">int</span> r = x + d[k], c = y + d[k + <span class="number">1</span>]; <span class="comment">// board[r][c] is the neighbor of '0'.</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; height &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; width) &#123;</span><br><span class="line">                        <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">                        ch[i] = ch[r * width + c]; <span class="comment">// r * width + c is the string index of board[r][c].</span></span><br><span class="line">                        ch[r * width + c] = <span class="string">'0'</span>; <span class="comment">// assign '0' to the neighbor of board[x][y].</span></span><br><span class="line">                        s = String.valueOf(ch);</span><br><span class="line">                        <span class="keyword">if</span> (seen.add(s)) q.offer(s); <span class="comment">// if not duplicate, add s to the queue.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Update 1:</p>
<ol>
<li><strong>distance</strong> in the follows changed to <strong>displacement</strong> to avoid confusion:</li>
<li>see after the code.</li>
</ol>
<p>Convert array to string, e.g., [[1,2,3],[4,0,5]] -&gt; “123405”, hence the corresponding potential swap displacements are: -1, 1, -3, 3. Also note, charAt(2) and charAt(3) are not adjacent in original 2 dimensional int array and therefore are not valid swaps.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] d = &#123; <span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">3</span> &#125;; <span class="comment">// potential swap displacements.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// convert board to string - initial state.</span></span><br><span class="line">      String s = Arrays.deepToString(board).replaceAll(<span class="string">"\\[|\\]|,|\\s"</span>, <span class="string">""</span>);</span><br><span class="line">      Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(s)); <span class="comment">// add initial state to queue.</span></span><br><span class="line">      Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;(q); <span class="comment">// used to avoid duplicates</span></span><br><span class="line">      <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// record the # of rounds of Breadth Search</span></span><br><span class="line">      <span class="keyword">while</span> (!q.isEmpty()) &#123; <span class="comment">// Not traverse all states yet?</span></span><br><span class="line">          <span class="comment">// loop used to control search breadth.</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> sz = q.size(); sz &gt; <span class="number">0</span>; --sz) &#123; </span><br><span class="line">              String str = q.poll();</span><br><span class="line">              <span class="keyword">if</span> (str.equals(<span class="string">"123450"</span>)) &#123; <span class="keyword">return</span> ans; &#125; <span class="comment">// found target.</span></span><br><span class="line">              <span class="keyword">int</span> i = str.indexOf(<span class="string">'0'</span>); <span class="comment">// locate '0'</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123; <span class="comment">// traverse all options.</span></span><br><span class="line">                  <span class="keyword">int</span> j = i + d[k]; <span class="comment">// potential swap index.</span></span><br><span class="line">                  <span class="comment">// conditional used to avoid invalid swaps.</span></span><br><span class="line">                  <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt; <span class="number">5</span> || i == <span class="number">2</span> &amp;&amp; j == <span class="number">3</span> || i == <span class="number">3</span> &amp;&amp; j == <span class="number">2</span>) &#123; <span class="keyword">continue</span>; &#125; </span><br><span class="line">                  <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">                  <span class="comment">// swap ch[i] and ch[j]:  ch[i] = ch[j], ch[j] = '0'. Updated per @caowang888's suggestion. </span></span><br><span class="line">                  ch[i] = ch[j];</span><br><span class="line">                  ch[j] = <span class="string">'0'</span>;</span><br><span class="line">                  s = String.valueOf(ch); <span class="comment">// a new candidate state.</span></span><br><span class="line">                  <span class="keyword">if</span> (seen.add(s)) &#123; q.offer(s); &#125; <span class="comment">//Avoid duplicate.</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ++ans; <span class="comment">// finished a round of Breadth Search, plus 1.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Analysis:</strong><br>There are at most 6! permutation of the 6 numbers: 0~5. For each permustion, cost spaceO(6); String.indexOf() and String.equals() cost time O(6). Therefore, space and time both cost 6 * 6! = 4320.<br>Replace the above <code>6</code> with <code>m * n</code>, we have:</p>
<p><strong>Time &amp; space: O(m * n * (m * n)!)</strong>.</p>
<p>Feel free to let me know if you can find a tighter bound.</p>
<h2 id="Unsolved-913-Cat-and-Mouse🎂"><a href="#Unsolved-913-Cat-and-Mouse🎂" class="headerlink" title="Unsolved 913. Cat and Mouse🎂"></a><a href="https://leetcode.com/problems/cat-and-mouse/" target="_blank" rel="noopener">Unsolved 913. Cat and Mouse🎂</a></h2><h2 id="Unsolved-1345-Jump-Game-IV🎂"><a href="#Unsolved-1345-Jump-Game-IV🎂" class="headerlink" title="Unsolved 1345. Jump Game IV🎂"></a><a href="https://leetcode.com/problems/jump-game-iv/?utm_source=AlgoTogether&utm_campaign=6415681024-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_3&utm_medium=email&utm_term=0_38d4e2e3e2-6415681024-231340480" target="_blank" rel="noopener">Unsolved 1345. Jump Game IV🎂</a></h2><h2 id="Unsolved-1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix🎂"><a href="#Unsolved-1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix🎂" class="headerlink" title="Unsolved 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix🎂"></a><a href="https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/?utm_source=AlgoTogether&utm_campaign=6415681024-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_3&utm_medium=email&utm_term=0_38d4e2e3e2-6415681024-231340480" target="_blank" rel="noopener">Unsolved 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix🎂</a></h2><h2 id="Unsolved-1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination🎂✨"><a href="#Unsolved-1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination🎂✨" class="headerlink" title="Unsolved 1293. Shortest Path in a Grid with Obstacles Elimination🎂✨"></a><a href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/?utm_source=AlgoTogether&utm_campaign=6415681024-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_3&utm_medium=email&utm_term=0_38d4e2e3e2-6415681024-231340480" target="_blank" rel="noopener">Unsolved 1293. Shortest Path in a Grid with Obstacles Elimination🎂✨</a></h2><h2 id="Unsolved-864-Shortest-Path-to-Get-All-Keys🎂🎶"><a href="#Unsolved-864-Shortest-Path-to-Get-All-Keys🎂🎶" class="headerlink" title="Unsolved 864. Shortest Path to Get All Keys🎂🎶"></a><a href="https://leetcode.com/problems/shortest-path-to-get-all-keys/" target="_blank" rel="noopener">Unsolved 864. Shortest Path to Get All Keys🎂🎶</a></h2><h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>BFS</p>
</li>
<li><p>find out all keys reachable from stanting</p>
<p>use all keys to open the locks</p>
<p>run more BFS to find out more keys<br>…</p>
<p>regular bfs</p>
<pre><code>visited[x] [y]: if (x. y) is reach before</code></pre><p>this bfs</p>
<pre><code>visited [x] [y] [a] [b] [c] [d] [e] [f] if access (x, y) with some of the keys</code></pre><p>visited [startX] [startY] [0] [0] [0] [1] [0] [0]</p>
<p>if run into key: set the index of the key to 1<br>if run into lock: check if we have the key</p>
<ul>
<li>If yes: unlock it &gt; visited[lockX]CLockT]<br>If no: lock-&gt; can not access<br>visited [x] [y]  [1] [1]  [1] [1] [1] [1]<br>status compression<br>visited [x] [y] [mask]<br>visited[startX] [startY] [0]<br>visited[x] [y] [0b111111]</li>
</ul>
</li>
<li><p>Use Bit to represent the keys.</p>
</li>
<li><p>Use <code>State</code> to represent visited states.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keys, i, j;</span><br><span class="line">    State(<span class="keyword">int</span> keys, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">this</span>.keys = keys;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">        <span class="keyword">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPathAllKeys</span><span class="params">(String[] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = -<span class="number">1</span>, y = -<span class="number">1</span>, m = grid.length, n = grid[<span class="number">0</span>].length(), max = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = grid[i].charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'@'</span>) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">                y = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>) &#123;</span><br><span class="line">                max = Math.max(c - <span class="string">'a'</span> + <span class="number">1</span>, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    State start = <span class="keyword">new</span> State(<span class="number">0</span>, x, y);</span><br><span class="line">    Queue&lt;State&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    visited.add(<span class="number">0</span> + <span class="string">" "</span> + x + <span class="string">" "</span> + y);</span><br><span class="line">    q.offer(start);</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            State cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur.keys == (<span class="number">1</span> &lt;&lt; max) - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cur.i + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> j = cur.j + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> keys = cur.keys;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">char</span> c = grid[i].charAt(j);</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="string">'#'</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>) &#123;</span><br><span class="line">                        keys |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'F'</span> &amp;&amp; ((keys &gt;&gt; (c - <span class="string">'A'</span>)) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(keys + <span class="string">" "</span> + i + <span class="string">" "</span> + j)) &#123;</span><br><span class="line">                        visited.add(keys + <span class="string">" "</span> + i + <span class="string">" "</span> + j);</span><br><span class="line">                        q.offer(<span class="keyword">new</span> State(keys, i, j));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="323-Number-of-Connected-Components-in-an-Undirected-Graph⭐⭐"><a href="#323-Number-of-Connected-Components-in-an-Undirected-Graph⭐⭐" class="headerlink" title="323. Number of Connected Components in an Undirected Graph⭐⭐"></a><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/" target="_blank" rel="noopener">323. Number of Connected Components in an Undirected Graph⭐⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    buildGraph(graph, edges);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            dfs(i, graph, visited);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[idx]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    visited[idx] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.get(idx)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            dfs(neighbor, graph, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> j = edge[<span class="number">1</span>];</span><br><span class="line">        graph.get(i).add(j);</span><br><span class="line">        graph.get(j).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕1192-Critical-Connections-in-a-Network⭐"><a href="#🌕1192-Critical-Connections-in-a-Network⭐" class="headerlink" title="🌕1192. Critical Connections in a Network⭐"></a><a href="https://leetcode.com/problems/critical-connections-in-a-network/" target="_blank" rel="noopener">🌕1192. Critical Connections in a Network⭐</a></h2><h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><a href="https://leetcode.com/problems/critical-connections-in-a-network/discuss/382638/DFS-detailed-explanation-O(orEor)-solution" target="_blank" rel="noopener">Explanation</a></li>
<li>思路：找环，环上任何一条边都不是criticalConnections</li>
<li>如何用O(n)找环：<ul>
<li>DFS前向搜索：每个节点最多走一遍，每走一步记录当前步数</li>
<li>DFS探索返回：返回当前节点（间接）接触到非父节点的最小步数的节点</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; criticalConnections(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(connections);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; c : connections) &#123;</span><br><span class="line">        connect(c.get(<span class="number">0</span>), c.get(<span class="number">1</span>), graph);</span><br><span class="line">        connect(c.get(<span class="number">1</span>), c.get(<span class="number">0</span>), graph);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] steps = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(steps, -<span class="number">2</span>);  <span class="comment">//-2 because when traverse the neighbor check the depth-1(parent depth)</span></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, steps, graph, set);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> depth, <span class="keyword">int</span>[] steps, Map&lt;Integer, List&lt;Integer&gt;&gt; graph, Set&lt;List&lt;Integer&gt;&gt; set)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (steps[node] &gt;= <span class="number">0</span>) <span class="keyword">return</span> steps[node];</span><br><span class="line"></span><br><span class="line">    steps[node] = depth;</span><br><span class="line">    <span class="comment">//record current min depth, if is a leave node no neighbor will return this depth value</span></span><br><span class="line">    <span class="keyword">int</span> minDepthFound = depth;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.get(node)) &#123;</span><br><span class="line">        <span class="comment">//skip the parent</span></span><br><span class="line">        <span class="keyword">if</span> (steps[neighbor] == depth - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//recursive dfs to the neighbor branch to get depth</span></span><br><span class="line">        <span class="keyword">int</span> minDepth = dfs(neighbor, depth + <span class="number">1</span>, steps, graph, set);</span><br><span class="line">        minDepthFound = Math.min(minDepthFound, minDepth);</span><br><span class="line">        <span class="comment">//if the neighbor branch depht &lt;= current depth, cycle exist</span></span><br><span class="line">        <span class="keyword">if</span> (minDepth &lt;= depth) &#123;</span><br><span class="line">            set.remove(Arrays.asList(node, neighbor));</span><br><span class="line">            set.remove(Arrays.asList(neighbor, node));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDepthFound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, Map&lt;Integer, List&lt;Integer&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">    graph.putIfAbsent(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    graph.get(i).add(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/critical-connections-in-a-network/discuss/401340/Clean-Java-Solution-With-Explanation!!!-Great-Question!" target="_blank" rel="noopener">Explanation</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; criticalConnections(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; connection : connections) &#123;</span><br><span class="line">        graph[connection.get(<span class="number">0</span>)].add(connection.get(<span class="number">1</span>));</span><br><span class="line">        graph[connection.get(<span class="number">1</span>)].add(connection.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet&lt;List&lt;Integer&gt;&gt; connectionsSet = <span class="keyword">new</span> HashSet&lt;&gt;(connections);</span><br><span class="line">    <span class="keyword">int</span>[] step = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(step, -<span class="number">2</span>);</span><br><span class="line">    dfs(graph, <span class="number">0</span>, <span class="number">0</span>, step, connectionsSet);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(connectionsSet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="keyword">int</span> node, <span class="keyword">int</span> depth, <span class="keyword">int</span>[] step, HashSet&lt;List&lt;Integer&gt;&gt; connectionsSet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case already visited node. return its depth</span></span><br><span class="line">    <span class="keyword">if</span> (step[node] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> step[node];</span><br><span class="line">    &#125;</span><br><span class="line">    step[node] = depth;</span><br><span class="line">    <span class="keyword">int</span> minDepthFound = depth;</span><br><span class="line">    <span class="keyword">for</span> (Integer neighbor : graph[node]) &#123;</span><br><span class="line">        <span class="comment">// skip parent</span></span><br><span class="line">        <span class="keyword">if</span> (step[neighbor] == depth - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> minDepth = dfs(graph, neighbor, depth + <span class="number">1</span>, step, connectionsSet);</span><br><span class="line">        minDepthFound = Math.min(minDepthFound, minDepth);</span><br><span class="line">        <span class="keyword">if</span> (minDepth &lt;= depth) &#123;</span><br><span class="line">            <span class="comment">// to avoid the sorting just try to remove both combinations. of (x,y) and (y,x)</span></span><br><span class="line">            connectionsSet.remove(Arrays.asList(node, neighbor));</span><br><span class="line">            connectionsSet.remove(Arrays.asList(neighbor, node));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDepthFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We record the timestamp that we visit each node. For each node, we check every neighbor except its parent and return a smallest timestamp in all its neighbors. If this timestamp is strictly less than the node's timestamp, we know that this node is somehow in a cycle. Otherwise, this edge from the parent to this node is a critical connection</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; criticalConnections(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(List&lt;Integer&gt; oneConnection :connections) &#123;</span><br><span class="line">        graph[oneConnection.get(<span class="number">0</span>)].add(oneConnection.get(<span class="number">1</span>));</span><br><span class="line">        graph[oneConnection.get(<span class="number">1</span>)].add(oneConnection.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> timer[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">int</span> []timeStampAtThatNode = <span class="keyword">new</span> <span class="keyword">int</span>[n]; </span><br><span class="line">    criticalConnectionsUtil(graph, -<span class="number">1</span>, <span class="number">0</span>, timer, visited, results, timeStampAtThatNode);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">criticalConnectionsUtil</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="keyword">int</span> parent, <span class="keyword">int</span> node, <span class="keyword">int</span> timer[], <span class="keyword">boolean</span>[] visited, List&lt;List&lt;Integer&gt;&gt; results, <span class="keyword">int</span> []timeStampAtThatNode)</span> </span>&#123;</span><br><span class="line">    visited[node] = <span class="keyword">true</span>;</span><br><span class="line">    timeStampAtThatNode[node] = timer[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">int</span> currentTimeStamp = timeStampAtThatNode[node];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> oneNeighbour : graph[node]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(oneNeighbour == parent) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!visited[oneNeighbour]) criticalConnectionsUtil(graph, node, oneNeighbour, timer, visited, results, timeStampAtThatNode);</span><br><span class="line">        timeStampAtThatNode[node] = Math.min(timeStampAtThatNode[node], timeStampAtThatNode[oneNeighbour]);</span><br><span class="line">        <span class="keyword">if</span>(currentTimeStamp &lt; timeStampAtThatNode[oneNeighbour]) results.add(Arrays.asList(node, oneNeighbour));</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-529-Minesweeper⭐"><a href="#🌕Unsolved-529-Minesweeper⭐" class="headerlink" title="🌕Unsolved 529. Minesweeper⭐"></a><a href="https://leetcode.com/problems/minesweeper/" target="_blank" rel="noopener">🌕Unsolved 529. Minesweeper⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">[[<span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>],</span><br><span class="line"> [<span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>],</span><br><span class="line"> [<span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>],</span><br><span class="line"> [<span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>]]</span><br><span class="line"></span><br><span class="line">Click : [<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line"></span><br><span class="line">[[<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'E'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'M'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'B'</span>],</span><br><span class="line"> [<span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>]]</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_1.png" alt=""></p>
<h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>dfs</li>
<li>This is a typical <code>Search</code> problem, either by using <code>DFS</code> or <code>BFS</code>. Search rules:<ol>
<li>If click on a mine (‘<code>M</code>‘), mark it as ‘<code>X</code>‘, stop further search.</li>
<li>If click on an empty cell (‘<code>E</code>‘), depends on how many surrounding mine:<br>2.1 Has surrounding mine(s), mark it with number of surrounding mine(s), stop further search.<br>2.2 No surrounding mine, mark it as ‘<code>B</code>‘, continue search its <code>8</code> neighbors.</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">    <span class="keyword">if</span> (board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span> || click.length != <span class="number">2</span>) <span class="keyword">return</span> board;</span><br><span class="line">    <span class="keyword">int</span> r = click[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> c = click[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (board[r][c] == <span class="string">'M'</span>) &#123;</span><br><span class="line">        board[r][c] = <span class="string">'X'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dfs(board, r, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> board;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= board.length || c &lt; <span class="number">0</span> || c &gt;= board[<span class="number">0</span>].length || board[r][c] != <span class="string">'E'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numOfMine = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = r + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = c + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= board.length || y &lt; <span class="number">0</span> || y &gt;= board[<span class="number">0</span>].length) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] == <span class="string">'M'</span>) numOfMine++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numOfMine &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        board[r][c] = (<span class="keyword">char</span>) (numOfMine + <span class="string">'0'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        board[r][c] = <span class="string">'B'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = r + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = c + dir[<span class="number">1</span>];</span><br><span class="line">            dfs(board, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> row = click[<span class="number">0</span>], col = click[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">'M'</span>) &#123; <span class="comment">// Mine</span></span><br><span class="line">            board[row][col] = <span class="string">'X'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// Empty</span></span><br><span class="line">            <span class="comment">// Get number of mines first.</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> r = row + i, c = col + j;</span><br><span class="line">                    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || c &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (board[r][c] == <span class="string">'M'</span> || board[r][c] == <span class="string">'X'</span>) count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">// If it is not a 'B', stop further DFS.</span></span><br><span class="line">                board[row][col] = (<span class="keyword">char</span>)(count + <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Continue DFS to adjacent cells.</span></span><br><span class="line">                board[row][col] = <span class="string">'B'</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">int</span> r = row + i, c = col + j;</span><br><span class="line">                        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || c &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (board[r][c] == <span class="string">'E'</span>) updateBoard(board, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(click);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cell = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> row = cell[<span class="number">0</span>], col = cell[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == <span class="string">'M'</span>) &#123; <span class="comment">// Mine</span></span><br><span class="line">                board[row][col] = <span class="string">'X'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Empty</span></span><br><span class="line">                <span class="comment">// Get number of mines first.</span></span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">int</span> r = row + i, c = col + j;</span><br><span class="line">                        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || c &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (board[r][c] == <span class="string">'M'</span> || board[r][c] == <span class="string">'X'</span>) count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">// If it is not a 'B', stop further BFS.</span></span><br><span class="line">                    board[row][col] = (<span class="keyword">char</span>)(count + <span class="string">'0'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// Continue BFS to adjacent cells.</span></span><br><span class="line">                    board[row][col] = <span class="string">'B'</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">int</span> r = row + i, c = col + j;</span><br><span class="line">                            <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || c &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">if</span> (board[r][c] == <span class="string">'E'</span>) &#123;</span><br><span class="line">                                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c&#125;);</span><br><span class="line">                                board[r][c] = <span class="string">'B'</span>; <span class="comment">// Avoid to be added again.</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-417-Pacific-Atlantic-Water-Flow🎂⭐💎"><a href="#🌕Unsolved-417-Pacific-Atlantic-Water-Flow🎂⭐💎" class="headerlink" title="🌕Unsolved 417. Pacific Atlantic Water Flow🎂⭐💎"></a><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">🌕Unsolved 417. Pacific Atlantic Water Flow🎂⭐💎</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given the following <span class="number">5</span>x5 matrix:</span><br><span class="line"></span><br><span class="line">  Pacific ~   ~   ~   ~   ~</span><br><span class="line">       ~  <span class="number">1</span>   <span class="number">2</span>   <span class="number">2</span>   <span class="number">3</span>  (<span class="number">5</span>) *</span><br><span class="line">       ~  <span class="number">3</span>   <span class="number">2</span>   <span class="number">3</span>  (<span class="number">4</span>) (<span class="number">4</span>) *</span><br><span class="line">       ~  <span class="number">2</span>   <span class="number">4</span>  (<span class="number">5</span>)  <span class="number">3</span>   <span class="number">1</span>  *</span><br><span class="line">       ~ (<span class="number">6</span>) (<span class="number">7</span>)  <span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>  *</span><br><span class="line">       ~ (<span class="number">5</span>)  <span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">4</span>  *</span><br><span class="line">          *   *   *   *   * Atlantic</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[[<span class="number">0</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">4</span>, <span class="number">0</span>]] (positions with parentheses in above matrix).</span><br></pre></td></tr></table></figure>

<ol>
<li>左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。</li>
<li><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/discuss/90733/Java-BFS-and-DFS-from-Ocean" target="_blank" rel="noopener">Explaination</a></li>
</ol>
<h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>DFS 每一个点需要回溯，会变成n^2。</li>
<li>优化，从边dfs二者，然后取交集，没有回溯变成线性O(n)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="comment">//edge case</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">    m = matrix.length;</span><br><span class="line">    n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] canReachP = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">boolean</span>[][] canReachA = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(i, <span class="number">0</span>, canReachP);</span><br><span class="line">        dfs(i, n - <span class="number">1</span>, canReachA);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, j, canReachP);</span><br><span class="line">        dfs(m - <span class="number">1</span>, j, canReachA);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canReachP[i][j] &amp;&amp; canReachA[i][j]) &#123;</span><br><span class="line">                ans.add(Arrays.asList(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] canReach)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (canReach[i][j]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    canReach[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextR = i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> nextC = j + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextR &lt; <span class="number">0</span> || nextR &gt;= m || nextC &lt; <span class="number">0</span> || nextC &gt;= n || matrix[nextR][nextC] &lt; matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(nextR, nextC, canReach);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="200-Number-of-Islands💜⭐"><a href="#200-Number-of-Islands💜⭐" class="headerlink" title="200. Number of Islands💜⭐"></a><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">200. Number of Islands💜⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br><span class="line"></span><br><span class="line">Output: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>可以将矩阵表示看成一张有向图。</p>
<h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>DFS</p>
</li>
<li><p>Time: O(MN). </p>
<p>Space: O(MN). M is the rows, N is the cols.worst case O(M×N) in case that the grid map is filled with lands where DFS goes by M \times N<em>M</em>×<em>N</em> deep.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(i, j, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] != <span class="string">'1'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mark as visited and go through 4 directions</span></span><br><span class="line">    grid[i][j] = <span class="string">' '</span>;</span><br><span class="line">    dfs(i + <span class="number">1</span>, j, grid);</span><br><span class="line">    dfs(i - <span class="number">1</span>, j, grid);</span><br><span class="line">    dfs(i, j + <span class="number">1</span>, grid);</span><br><span class="line">    dfs(i, j - <span class="number">1</span>, grid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check :</span></span><br><span class="line"><span class="comment">if grid == null || gird.length == 0 return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">DFS</span></span><br><span class="line"><span class="comment">need a dfs helper function</span></span><br><span class="line"><span class="comment">Step1: Travsse the whole grid</span></span><br><span class="line"><span class="comment">Step2: When we encounter a land(1), add max varaible by 1, apply dfs which will tarverse cuurent whole island, and mark it has been traversed</span></span><br><span class="line"><span class="comment">Step3: Continue step2 until finish the traverse the grid, finally return max</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Go through Example :</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  ["1","1","1","1","0"],</span></span><br><span class="line"><span class="comment">  ["1","1","0","1","0"],</span></span><br><span class="line"><span class="comment">  ["1","1","0","0","0"],</span></span><br><span class="line"><span class="comment">  ["0","0","0","0","0"]</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">-&gt;</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  ["-1","-1","-1","-1","0"],</span></span><br><span class="line"><span class="comment">  ["-1","-1","0","-1","0"],</span></span><br><span class="line"><span class="comment">  ["-1","-1","0","0","0"],</span></span><br><span class="line"><span class="comment">  ["0","0","0","0","0"]</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">retrun 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(mn)</span></span><br><span class="line"><span class="comment">Space O(mn)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IslandCountBFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumberOfIslands</span><span class="params">(<span class="keyword">int</span>[][] binaryMatrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (binaryMatrix == <span class="keyword">null</span> || binaryMatrix.length == <span class="number">0</span> || binaryMatrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = binaryMatrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = binaryMatrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binaryMatrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    markIsland(binaryMatrix, m, n, i, j);</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markIsland</span><span class="params">(<span class="keyword">int</span>[][] binaryMatrix, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// store the index in queue</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.remove();</span><br><span class="line">            <span class="keyword">int</span> r = cur[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (binaryMatrix[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                binaryMatrix[r][c] = -<span class="number">1</span>; <span class="comment">// mark as visited</span></span><br><span class="line">                addIfValid(queue, m, n, r - <span class="number">1</span>, c);</span><br><span class="line">                addIfValid(queue, m, n, r + <span class="number">1</span>, c);</span><br><span class="line">                addIfValid(queue, m, n, r, c - <span class="number">1</span>);</span><br><span class="line">                addIfValid(queue, m, n, r, c + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addIfValid</span><span class="params">(Queue&lt;<span class="keyword">int</span>[]&gt; queue, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n) queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] binaryMatrix = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        System.out.println(getNumberOfIslands(binaryMatrix));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="694-Number-of-Distinct-Islands⭐"><a href="#694-Number-of-Distinct-Islands⭐" class="headerlink" title="694. Number of Distinct Islands⭐"></a><a href="https://leetcode.com/problems/number-of-distinct-islands/" target="_blank" rel="noopener">694. Number of Distinct Islands⭐</a></h2><h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Hash By Local Coordinates</li>
<li>Time Complexity: O(R<em>C)*O</em>(<em>R</em>∗<em>C</em>), where R<em>R</em> is the number of rows in the given <code>grid</code>, and C<em>C</em> is the number of columns. We visit every square once.</li>
<li>Space complexity: O(R<em>C)*O</em>(<em>R</em>∗<em>C</em>), the space used by <code>seen</code> to keep track of visited squares, and <code>shapes</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;String&gt; shapes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                dfs(grid, i, j, <span class="number">0</span>, <span class="number">0</span>, sb);</span><br><span class="line">                String shape = sb.toString();</span><br><span class="line">                <span class="keyword">if</span> (!shapes.contains(shape)) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    shapes.add(shape);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> x, <span class="keyword">int</span> y, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    sb.append(<span class="string">""</span> + x + y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> c = j + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= grid.length || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].length || grid[r][c] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(grid, r, c, x + dir[<span class="number">0</span>], y + dir[<span class="number">1</span>], sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Use direction string instead of using number string in set</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                dfs(grid, i, j, sb, <span class="string">"o"</span>); <span class="comment">// origin</span></span><br><span class="line">                grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                set.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, StringBuilder sb, String dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i == grid.length || j &lt; <span class="number">0</span> || j == grid[i].length </span><br><span class="line">       || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    sb.append(dir);</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    dfs(grid, i-<span class="number">1</span>, j, sb, <span class="string">"u"</span>);</span><br><span class="line">    dfs(grid, i+<span class="number">1</span>, j, sb, <span class="string">"d"</span>);</span><br><span class="line">    dfs(grid, i, j-<span class="number">1</span>, sb, <span class="string">"l"</span>);</span><br><span class="line">    dfs(grid, i, j+<span class="number">1</span>, sb, <span class="string">"r"</span>);</span><br><span class="line">    sb.append(<span class="string">"b"</span>); <span class="comment">// back</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Universal-sink⭐⭐"><a href="#🌕Universal-sink⭐⭐" class="headerlink" title="🌕Universal sink⭐⭐"></a>🌕Universal sink⭐⭐</h2><p>Find a universal sink in a directed acyclic graph. </p>
<p>And the universal sink means a vertex that has no edge emanating from it, and all other vertices have an edge towards the sink.</p>
<h3 id="Solution1-19"><a href="#Solution1-19" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>This is a similar question with Find Celebrity, the goal of this question is to find a node which doesn’t have an arrow towards any other node in a graph.</p>
</li>
<li><p>You can start by checking any node as beginning, in any given “checking”, you have two possibility:</p>
<ol>
<li>For this node, there is an arrow towards other node, in this case, this is not candidate for our goal, then you can move on checking the next node (by following the arrow), and removing current node from candidate list</li>
<li>For this node, there is zero arrow towards other node, in this case, this is a candidate, you can save this candidate and move on checking other node.</li>
</ol>
<p>Once you exhaust all nodes and end up with an empty candidate list, you can draw the conclusion that there is no universal sink, vice versa.</p>
</li>
</ol>
<h3 id="277-Find-the-celebrity⭐⭐"><a href="#277-Find-the-celebrity⭐⭐" class="headerlink" title="277. Find the celebrity⭐⭐"></a><a href="https://leetcode.com/problems/find-the-celebrity/" target="_blank" rel="noopener">277. Find the celebrity⭐⭐</a></h3><h3 id="best"><a href="#best" class="headerlink" title="best:"></a>best:</h3><ol>
<li>stack</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Relation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(stack.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> first = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> second = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (knows(first, second)) &#123;</span><br><span class="line">                stack.push(second);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//double check last is a valid celebrity</span></span><br><span class="line">        <span class="keyword">int</span> last = stack.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == last) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(knows(i, last)) || knows(last, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-20"><a href="#Solution1-20" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：所有人都知道 c，而 c 不知道任何人，所以如果 0 是 c，则它不可能知道任何其他人，如果 0 不是 c，则他一定知道 c，以此类推，找到唯一的一个可能是 c 的。然后判断是否符合条件。O(n)</li>
<li>The first pass is to pick out the candidate. If candidate knows i, then switch candidate. The second pass is to check whether the candidate is real.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n) | S O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> candidate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//if candidate is real, he will not know everyone, i is fixed</span></span><br><span class="line">        <span class="keyword">if</span> (knows(candidate, i))</span><br><span class="line">            candidate = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//test it's a valid candidate</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != candidate &amp;&amp; (knows(candidate, i) || !knows(i, candidate)))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-10"><a href="#Solution2-10" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Brute Force</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Relation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nums;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        nums = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isCelebrity(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCelebrity</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (knows(i, j) || !knows(j, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3:"></a>Solution3:</h3><ol>
<li><p>Problem Statement </p>
</li>
<li><p>implement <code>findCelebrity()</code> method to find the celebrity in a party (matrix) using a stack. A celebrity is someone that everyone knows, but he/she doesn’t know anyone at the party.</p>
</li>
<li><p>Where the <em>party</em> is a reference variable storing a 2D matrix, which has stored all the information about acquaintances, <em>numPeople</em> and the number of people present in the party.</p>
<p>In the party matrix, a particular [row][col] stores acquaintance information for row and col. In other words, if [row][col] == 1, then it means row knows col, and if it’s zero, then it means <em>row</em> doesn’t know <em>col</em>. Remember that everyone knows a celebrity, but the celebrity doesn’t know the people at the party.</p>
</li>
<li><pre><code class="java">party = {
          {<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>},
          {<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>},
          {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},
          {<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>},
                }

numPeople = <span class="number">4</span> (Number of rows in party array)   

<span class="number">2</span> (because row Index = <span class="number">2</span> is a celebrity)
&lt;!--￼<span class="number">57</span>--&gt;
</code></pre>
</li>
</ol>
<h2 id="🌕Unsolved-332-Reconstruct-Itinerary🎂⭐"><a href="#🌕Unsolved-332-Reconstruct-Itinerary🎂⭐" class="headerlink" title="🌕Unsolved 332. Reconstruct Itinerary🎂⭐"></a><a href="https://leetcode.com/problems/reconstruct-itinerary/?utm_source=AlgoTogether&utm_campaign=6415681024-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_3&utm_medium=email&utm_term=0_38d4e2e3e2-6415681024-231340480" target="_blank" rel="noopener">🌕Unsolved 332. Reconstruct Itinerary🎂⭐</a></h2><p><a href="https://leetcode.com/problems/reconstruct-itinerary/discuss/78768/Short-Ruby-Python-Java-C%2B%2B" target="_blank" rel="noopener">https://leetcode.com/problems/reconstruct-itinerary/discuss/78768/Short-Ruby-Python-Java-C%2B%2B</a></p>
<p>“Given a list of airline tickets represented by pairs of departure and arrival airports <em><code>[from, to]</code></em>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from <em><code>JFK</code></em>. Thus, the itinerary must begin with <em><code>JFK</code></em>.”</p>
<h3 id="Solution1-21"><a href="#Solution1-21" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：假设没有重复，非常容易，只要建立词典，从 JFK 开始逐一机票使用。</li>
<li>现在是有可能有重复，不过题中还给出了另一个条件：如果有重复，则按到站的字典顺排序。所以这里只有到站是需要排序的。排序问题可以想到优先队列。</li>
<li>有了上述的准备工作，则使用 DFS 找结果，最后把结果存入数组。</li>
<li>Path.addFirst 是因为总是靠近队尾的元素更先到该句（因为是 DFS）。如果有答案，可以证明：重复到站先走哪个都应该可以完成。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, PriorityQueue&lt;String&gt;&gt; map;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; ticket : tickets) &#123;</span><br><span class="line">        map.putIfAbsent(ticket.get(<span class="number">0</span>), <span class="keyword">new</span> PriorityQueue&lt;String&gt;());</span><br><span class="line">        map.get(ticket.get(<span class="number">0</span>)).add(ticket.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="string">"JFK"</span>, path);</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String dep, List&lt;String&gt; path)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;String&gt; heap = map.get(dep);</span><br><span class="line">    <span class="keyword">while</span>(heap != <span class="keyword">null</span> &amp;&amp; !heap.isEmpty()) &#123;</span><br><span class="line">        dfs(heap.poll(), path);</span><br><span class="line">    &#125;</span><br><span class="line">    path.add(<span class="number">0</span>, dep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-11"><a href="#Solution2-11" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String[] ticket : tickets)</span><br><span class="line">        targets.computeIfAbsent(ticket[<span class="number">0</span>], k -&gt; <span class="keyword">new</span> PriorityQueue()).add(ticket[<span class="number">1</span>]);</span><br><span class="line">    visit(<span class="string">"JFK"</span>);</span><br><span class="line">    <span class="keyword">return</span> route;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;String, PriorityQueue&lt;String&gt;&gt; targets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;String&gt; route = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(String airport)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(targets.containsKey(airport) &amp;&amp; !targets.get(airport).isEmpty())</span><br><span class="line">        visit(targets.get(airport).poll());</span><br><span class="line">    route.add(<span class="number">0</span>, airport);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Iterative version:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, PriorityQueue&lt;String&gt;&gt; targets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String[] ticket : tickets)</span><br><span class="line">        targets.computeIfAbsent(ticket[<span class="number">0</span>], k -&gt; <span class="keyword">new</span> PriorityQueue()).add(ticket[<span class="number">1</span>]);</span><br><span class="line">    List&lt;String&gt; route = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(<span class="string">"JFK"</span>);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (targets.containsKey(stack.peek()) &amp;&amp; !targets.get(stack.peek()).isEmpty())</span><br><span class="line">            stack.push(targets.get(stack.peek()).poll());</span><br><span class="line">        route.add(<span class="number">0</span>, stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> route;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕980-Unique-Paths-III⭐"><a href="#🌕980-Unique-Paths-III⭐" class="headerlink" title="🌕980.Unique Paths III⭐"></a><a href="https://leetcode.com/problems/unique-paths-iii/" target="_blank" rel="noopener">🌕980.Unique Paths III⭐</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We have the following two paths: </span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</span><br><span class="line">2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-22"><a href="#Solution1-22" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>First find out where the start and the end is.<br>Also We need to know the number of empty cells.</p>
<p>We we try to explore a cell,<br>it will change 0 to -2 and do a dfs in 4 direction.</p>
<p>If we hit the target and pass all empty cells, increment the result.</p>
</li>
</ol>
<p>   Time complexity is as good as dp,<br>   but it take less space and easier to implement.</p>
<p>As a result, let us first clarify the initial and the final states of the problem.</p>
<ul>
<li><strong>Initial State</strong><ul>
<li>There are different types of squares/cells in a grid.</li>
<li>There are an origin and a destination cell, which are not given explicitly.</li>
<li>Initially, all the cells are not <strong><em>visited\</em></strong>.</li>
</ul>
</li>
<li><strong>Final State</strong><ul>
<li>We reach the destination cell, <em>i.e.</em> cell filled with the value <code>2</code>.</li>
<li>We have visited all the non-obstacle cells, including the empty cells (<em>i.e.</em> filled with <code>0</code>) and the initial cell (<em>i.e.</em> <code>1</code>).</li>
</ul>
</li>
<li>Time Complexity: O(3^N)<ul>
<li>Although technically we have 4 directions to explore at each step, we have <em>at most</em> 3 directions to try at any moment except the first step. The last direction is the direction where we came from, therefore we don’t need to explore it, since we have been there before.</li>
<li>In the worst case where none of the cells is an obstacle, we have to explore each cell. Hence, the time complexity of the algorithm is \mathcal{O}(4 * 3 ^{(N-1)}) = \mathcal{O}(3^N)O(4∗3(<em>N</em>−1))=O(3<em>N</em>).</li>
</ul>
</li>
<li>Space Complexity: O(N)<ul>
<li>Thanks to the in-place technique, we did not use any additional memory to keep track of the state.</li>
<li>On the other hand, we apply recursion in the algorithm, which could incur \mathcal{O}(N)O(<em>N</em>) space in the function call stack.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> empty = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    sx = i;</span><br><span class="line">                    sy = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    empty++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(sx, sy, grid);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case, if over bounded or meet a block</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= grid.length || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].length || grid[x][y] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if arraive setination and run out of empty grids, ans++</span></span><br><span class="line">        <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (empty == <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//mark it has been traverse</span></span><br><span class="line">        grid[x][y] = -<span class="number">1</span>;</span><br><span class="line">        empty--;</span><br><span class="line">        dfs(x - <span class="number">1</span>, y, grid);</span><br><span class="line">        dfs(x + <span class="number">1</span>, y, grid);</span><br><span class="line">        dfs(x, y - <span class="number">1</span>, grid);</span><br><span class="line">        dfs(x, y + <span class="number">1</span>, grid);</span><br><span class="line">        <span class="comment">//backtracking</span></span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        empty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-329-Longest-Increasing-Path-in-a-Matrix✨🎶"><a href="#🌕Unsolved-329-Longest-Increasing-Path-in-a-Matrix✨🎶" class="headerlink" title="🌕Unsolved 329. Longest Increasing Path in a Matrix✨🎶"></a><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">🌕Unsolved 329. Longest Increasing Path in a Matrix✨🎶</a></h2><h3 id="Solution1-23"><a href="#Solution1-23" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>(Naive DFS) [Time Limit Exceeded]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Naive DFS Solution</span></span><br><span class="line"><span class="comment">// Time Limit Exceeded</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                ans = Math.max(ans, dfs(matrix, i, j));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + d[<span class="number">0</span>], y = j + d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; m &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; n &amp;&amp; matrix[x][y] &gt; matrix[i][j])</span><br><span class="line">                ans = Math.max(ans, dfs(matrix, x, y));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-12"><a href="#Solution2-12" class="headerlink" title="Solution2:"></a>Solution2:</h3><p>DFS + Memoization</p>
<ul>
<li>Time complexity : O(mn)<em>O</em>(<em>m**n</em>). Each vertex/cell will be calculated once and only once, and each edge will be visited once and only once. The total time complexity is then O(V+E)<em>O</em>(<em>V</em>+<em>E</em>). V<em>V</em> is the total number of vertices and E<em>E</em> is the total number of edges. In our problem, O(V) = O(mn)<em>O</em>(<em>V</em>)=<em>O</em>(<em>m**n</em>), O(E) = O(4V) = O(mn)<em>O</em>(<em>E</em>)=<em>O</em>(4<em>V</em>)=<em>O</em>(<em>m**n</em>).</li>
<li>Space complexity : O(mn)<em>O</em>(<em>m**n</em>). The cache dominates the space complexity.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS + Memoization Solution</span></span><br><span class="line"><span class="comment">// Accepted and Recommended</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = dfs(matrix, i, j, m, n, cache);</span><br><span class="line">            max = Math.max(max, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache[i][j] != <span class="number">0</span>) <span class="keyword">return</span> cache[i][j];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir: dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || matrix[x][y] &lt;= matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span> + dfs(matrix, x, y, m, n, cache);</span><br><span class="line">        max = Math.max(max, len);</span><br><span class="line">    &#125;</span><br><span class="line">    cache[i][j] = max;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-1102-Path-With-Maximum-Minimum-Value🎂"><a href="#Unsolved-1102-Path-With-Maximum-Minimum-Value🎂" class="headerlink" title="Unsolved 1102. Path With Maximum Minimum Value🎂"></a><a href="https://leetcode.com/problems/path-with-maximum-minimum-value/" target="_blank" rel="noopener">Unsolved 1102. Path With Maximum Minimum Value🎂</a></h2><p>“Given a matrix of integers <em><code>A</code></em> with R rows and C columns, find the <strong>maximum</strong> score of a path starting at <em><code>[0,0]</code></em> and ending at <em><code>[R-1,C-1]</code></em>.”</p>
<p><a href="https://leetcode.com/problems/path-with-maximum-minimum-value/" target="_blank" rel="noopener">https://leetcode.com/problems/path-with-maximum-minimum-value/</a></p>
<p><a href="https://leetcode.com/problems/path-with-maximum-minimum-value/discuss/323927/Java-BFS-%2B-PQ" target="_blank" rel="noopener">https://leetcode.com/problems/path-with-maximum-minimum-value/discuss/323927/Java-BFS-%2B-PQ</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumMinimumPath</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> m = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// in the BFS approach, for each step, we are interested in getting the maximum min that we have seen so far, thus we reverse the ordering in the pq</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; b[<span class="number">2</span>] - a[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, A[<span class="number">0</span>][<span class="number">0</span>]&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BFS</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cell = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> row = cell[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> col = cell[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (row == n - <span class="number">1</span> &amp;&amp; col == m - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cell[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextRow = row + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nextCol = col + dir[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= n || nextCol &lt; <span class="number">0</span> || nextCol &gt;= m || visited[nextRow][nextCol]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// we are keeping track of the min element that we have seen until now</span></span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nextRow, nextCol, Math.min(cell[<span class="number">2</span>], A[nextRow][nextCol])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕695-Max-Area-of-Island✨"><a href="#🌕695-Max-Area-of-Island✨" class="headerlink" title="🌕695. Max Area of Island✨"></a><a href="https://leetcode.com/problems/max-area-of-island/description/" target="_blank" rel="noopener">🌕695. Max Area of Island✨</a></h2><h3 id="Solution1-24"><a href="#Solution1-24" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Given a non-empty 2D array <code>grid</code> of 0’s and 1’s, an <strong>island</strong> is a group of <code>1</code>‘s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</li>
<li>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">Given the above grid, <span class="keyword">return</span> <span class="number">6</span>. </span><br><span class="line">Note the answer is not <span class="number">11</span>, because the island must be connected <span class="number">4</span>-directionally.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j  =<span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                max = Math.max(max, dfs(i, j, grid));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">1</span>;</span><br><span class="line">    area += dfs(i + <span class="number">1</span>, j, grid);</span><br><span class="line">    area += dfs(i - <span class="number">1</span>, j, grid);</span><br><span class="line">    area += dfs(i, j + <span class="number">1</span>, grid);</span><br><span class="line">    area += dfs(i, j - <span class="number">1</span>, grid);</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> area = dfs(i, j, grid);</span><br><span class="line">                max = Math.max(max, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= grid.length || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].length || grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">1</span>;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = r + d[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> j = c + d[<span class="number">1</span>];</span><br><span class="line">        area += dfs(i, j, grid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="🌕130-Surrounded-Regions✨"><a href="#🌕130-Surrounded-Regions✨" class="headerlink" title="🌕130.Surrounded Regions✨"></a><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">🌕130.Surrounded Regions✨</a></h2><h3 id="Solution1-25"><a href="#Solution1-25" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：先把不被包围的 0 全部置成特殊字符（这里使用” + “），然后再逐一扫描元素，是’’ + ‘’的置回 0，是 0 的置成 X。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">'O'</span>) dfs(board, i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">'O'</span>) dfs(board, i, n  -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">'O'</span>) dfs(board, <span class="number">0</span>, j);</span><br><span class="line">        <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">'O'</span>) dfs(board, m - <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'A'</span>) &#123;</span><br><span class="line">                board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs change boundry "O" -&gt; "A"</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">'X'</span> || board[i][j] == <span class="string">'A'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    board[i][j] = <span class="string">'A'</span>;</span><br><span class="line">    dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">    dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-13"><a href="#Solution2-13" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Hi. So here is my accepted code using <strong>Union Find</strong> data structure. The idea comes from the observation that if a region is NOT captured, it is connected to the boundry. So if we connect all the ‘O’ nodes on the boundry to a dummy node, and then connect each ‘O’ node to its neighbour ‘O’ nodes, then we can tell directly whether a ‘O’ node is captured by checking whether it is connected to the dummy node.<br>For more about Union Find, the first assignment in the algo1 may help:<br><a href="https://www.coursera.org/course/algs4partI" target="_blank" rel="noopener">https://www.coursera.org/course/algs4partI</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* id;     <span class="comment">// id[i] = parent of i</span></span><br><span class="line">    <span class="keyword">int</span>* rank;  <span class="comment">// rank[i] = rank of subtree rooted at i (cannot be more than 31)</span></span><br><span class="line">    <span class="keyword">int</span> count;    <span class="comment">// number of components</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    UF(<span class="keyword">int</span> N)</span><br><span class="line">    &#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~UF()</span><br><span class="line">    &#123;</span><br><span class="line">        delete [] id;</span><br><span class="line">        delete [] rank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p != id[p]) &#123;</span><br><span class="line">            id[p] = id[id[p]];    <span class="comment">// path compression by halving</span></span><br><span class="line">            p = id[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">bool <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = find(p);</span><br><span class="line">        <span class="keyword">int</span> j = find(q);</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[i] &lt; rank[j]) id[i] = j;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[i] &gt; rank[j]) id[j] = i;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            id[j] = i;</span><br><span class="line">            rank[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)    <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board[<span class="number">0</span>].size();</span><br><span class="line">        UF uf = UF(n*m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i==<span class="number">0</span>||i==n-<span class="number">1</span>||j==<span class="number">0</span>||j==m-<span class="number">1</span>)&amp;&amp;board[i][j]==<span class="string">'O'</span>) <span class="comment">// if a 'O' node is on the boundry, connect it to the dummy node</span></span><br><span class="line">                    uf.connect(i*m+j,n*m);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) <span class="comment">// connect a 'O' node to its neighbour 'O' nodes</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[i-<span class="number">1</span>][j]==<span class="string">'O'</span>)</span><br><span class="line">                        uf.connect(i*m+j,(i-<span class="number">1</span>)*m+j);</span><br><span class="line">                    <span class="keyword">if</span>(board[i+<span class="number">1</span>][j]==<span class="string">'O'</span>)</span><br><span class="line">                        uf.connect(i*m+j,(i+<span class="number">1</span>)*m+j);</span><br><span class="line">                    <span class="keyword">if</span>(board[i][j-<span class="number">1</span>]==<span class="string">'O'</span>)</span><br><span class="line">                        uf.connect(i*m+j,i*m+j-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(board[i][j+<span class="number">1</span>]==<span class="string">'O'</span>)</span><br><span class="line">                        uf.connect(i*m+j,i*m+j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!uf.connected(i*m+j,n*m))&#123; <span class="comment">// if a 'O' node is not connected to the dummy node, it is captured</span></span><br><span class="line">                    board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="🌕403-Frog-Jump⭐🎶"><a href="#🌕403-Frog-Jump⭐🎶" class="headerlink" title="🌕403. Frog Jump⭐🎶"></a><a href="https://leetcode.com/problems/frog-jump/" target="_blank" rel="noopener">🌕403. Frog Jump⭐🎶</a></h2><h3 id="Solution1-26"><a href="#Solution1-26" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones[i] &gt; stones[i - <span class="number">1</span>] * <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> lastStone = stones[stones.length - <span class="number">1</span>];  <span class="comment">//taregt</span></span><br><span class="line">    Stack&lt;Integer&gt; positions = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; jump = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    positions.push(<span class="number">0</span>);</span><br><span class="line">    jump.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">        set.add(stone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!positions.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = positions.pop();</span><br><span class="line">        <span class="keyword">int</span> jumpDistance = jump.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = jumpDistance - <span class="number">1</span>; i &lt;= jumpDistance + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current + i == lastStone) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(current + i)) &#123;</span><br><span class="line">                    positions.push(current + i);</span><br><span class="line">                    jump.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕286-Walls-and-Gates✨🎶"><a href="#🌕286-Walls-and-Gates✨🎶" class="headerlink" title="🌕286. Walls and Gates✨🎶"></a><a href="https://leetcode.com/problems/walls-and-gates/" target="_blank" rel="noopener">🌕286. Walls and Gates✨🎶</a></h2><p>Given the 2D grid:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INF  -<span class="number">1</span>  <span class="number">0</span>  INF</span><br><span class="line">INF INF INF  -<span class="number">1</span></span><br><span class="line">INF  -<span class="number">1</span> INF  -<span class="number">1</span></span><br><span class="line">  <span class="number">0</span>  -<span class="number">1</span> INF INF</span><br></pre></td></tr></table></figure>

<p>After running your function, the 2D grid should be:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>  -<span class="number">1</span>   <span class="number">0</span>   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2</span>   <span class="number">1</span>  -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>  -<span class="number">1</span>   <span class="number">2</span>  -<span class="number">1</span></span><br><span class="line"><span class="number">0</span>  -<span class="number">1</span>   <span class="number">3</span>   <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-l"><a href="#Solution1-l" class="headerlink" title="Solution1:l"></a>Solution1:l</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rooms.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rooms[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i, j, <span class="number">0</span>, rooms);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> count, <span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rooms.length || j &lt; <span class="number">0</span> || j &gt;= rooms[i].length || rooms[i][j] &lt; count) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rooms[i][j] = count;</span><br><span class="line">    dfs(i + <span class="number">1</span>, j, count + <span class="number">1</span>, rooms);</span><br><span class="line">    dfs(i - <span class="number">1</span>, j, count + <span class="number">1</span>, rooms);</span><br><span class="line">    dfs(i, j + <span class="number">1</span>, count + <span class="number">1</span>, rooms);</span><br><span class="line">    dfs(i, j - <span class="number">1</span>, count + <span class="number">1</span>, rooms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-14"><a href="#Solution2-14" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rooms.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rooms[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = cur[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = x + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> c = y + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//if over bounded or not default value</span></span><br><span class="line">                <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= rooms.length || c &lt; <span class="number">0</span> || c &gt;= rooms[<span class="number">0</span>].length || rooms[r][c] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                rooms[r][c] = rooms[x][y] + <span class="number">1</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕01-Matrix✨"><a href="#🌕01-Matrix✨" class="headerlink" title="🌕01 Matrix✨"></a><a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="noopener">🌕01 Matrix✨</a></h2><h3 id="Solution1-27"><a href="#Solution1-27" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>General idea is <code>BFS</code>. Some small tricks:<ol>
<li>At beginning, set cell value to <code>Integer.MAX_VALUE</code> if it is not <code>0</code>.</li>
<li>If newly calculated distance <code>&gt;=</code> current distance, then we don’t need to explore that cell again.</li>
</ol>
</li>
<li>Time complexity: O(r \cdot c)<em>O</em>(<em>r</em>⋅<em>c</em>).<ul>
<li>Since, the new cells are added to the queue only if their current distance is greater than the calculated distance, cells are not likely to be added multiple times.</li>
</ul>
</li>
<li>Space complexity: O(r \cdot c)<em>O</em>(<em>r</em>⋅<em>c</em>). Additional O(r \cdot c)<em>O</em>(<em>r</em>⋅<em>c</em>) for queue than in Approach #1</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//otherwise fill in with Integer.MAX_VALUE -&gt; infinite value to update</span></span><br><span class="line">                matrix[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = cur[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> c = cur[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= matrix.length || c &lt; <span class="number">0</span> || c &gt;= matrix[<span class="number">0</span>].length || matrix[r][c] != Integer.MAX_VALUE) <span class="keyword">continue</span>;</span><br><span class="line">                matrix[r][c] = matrix[cur[<span class="number">0</span>]][cur[<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-419-Battleships-in-a-Board💎"><a href="#🌕Unsolved-419-Battleships-in-a-Board💎" class="headerlink" title="🌕Unsolved 419. Battleships in a Board💎"></a><a href="https://leetcode.com/problems/battleships-in-a-board/" target="_blank" rel="noopener">🌕Unsolved 419. Battleships in a Board💎</a></h2><h3 id="Solution1-28"><a href="#Solution1-28" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numBattleships = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'X'</span>) </span><br><span class="line">                numBattleships++;</span><br><span class="line">            dfs(board, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numBattleships;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != <span class="string">'X'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">    dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line">    dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Soltuion2"><a href="#Soltuion2" class="headerlink" title="Soltuion2:"></a>Soltuion2:</h3><ol>
<li><strong>Follow up:</strong><br>Could you do it in <strong>one-pass</strong>, using only <strong>O(1) extra memory</strong> and <strong>without modifying</strong> the value of the board?</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numBattleships = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">'X'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; board[i][j - <span class="number">1</span>] == <span class="string">'X'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            numBattleships++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numBattleships;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕-841-Keys-and-Rooms✨"><a href="#🌕-841-Keys-and-Rooms✨" class="headerlink" title="🌕 841. Keys and Rooms✨"></a><a href="https://leetcode.com/problems/keys-and-rooms/" target="_blank" rel="noopener">🌕 841. Keys and Rooms✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[]]</span><br><span class="line">Output: <span class="keyword">true</span></span><br><span class="line">Explanation:  </span><br><span class="line">We start in room <span class="number">0</span>, and pick up key <span class="number">1</span>.</span><br><span class="line">We then go to room <span class="number">1</span>, and pick up key <span class="number">2</span>.</span><br><span class="line">We then go to room <span class="number">2</span>, and pick up key <span class="number">3</span>.</span><br><span class="line">We then go to room <span class="number">3</span>.  Since we were able to go to every room, we <span class="keyword">return</span> <span class="keyword">true</span>.</span><br><span class="line"></span><br><span class="line">Input: [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">0</span>]]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation: We can<span class="string">'t enter the room with number 2.</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-29"><a href="#Solution1-29" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    stack.add(<span class="number">0</span>);</span><br><span class="line">    visited.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; keys = rooms.get(stack.pop());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : keys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(key)) &#123;</span><br><span class="line">                stack.push(key);</span><br><span class="line">                visited.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visited.size() == rooms.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h1><p>Backtracking（回溯）属于 DFS。</p>
<ul>
<li>普通 DFS 主要用在 <strong><code>可达性问题</code></strong> ，这种问题只需要执行到特点的位置然后返回即可。</li>
<li>而 Backtracking 主要用于求解 <strong><code>排列组合</code></strong> 问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li>
</ul>
<p>因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p>
<ul>
<li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</li>
<li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</li>
</ul>
<h2 id="🌕79-Word-Search⭐"><a href="#🌕79-Word-Search⭐" class="headerlink" title="🌕79. Word Search⭐"></a><a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">🌕79. Word Search⭐</a></h2><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">For example,</span><br><span class="line">Given board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line">word = <span class="string">"ABCCED"</span>, -&gt; returns <span class="keyword">true</span>,</span><br><span class="line">word = <span class="string">"SEE"</span>, -&gt; returns <span class="keyword">true</span>,</span><br><span class="line">word = <span class="string">"ABCB"</span>, -&gt; returns <span class="keyword">false</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-30"><a href="#Solution1-30" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span> || board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>) &amp;&amp; dfs(board, word, <span class="number">0</span>, i, j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> idx, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// if over board or not correct char</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || word.charAt(idx) != board[i][j]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//back tracking mark it to empty space dfs, and then recover</span></span><br><span class="line">    <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">    board[i][j] = <span class="string">' '</span>; <span class="comment">//mark as used</span></span><br><span class="line">    <span class="keyword">boolean</span> found = dfs(board, word, idx+<span class="number">1</span>, i + <span class="number">1</span>, j)</span><br><span class="line">        || dfs(board, word, idx+<span class="number">1</span>, i - <span class="number">1</span>, j)</span><br><span class="line">        || dfs(board, word, idx+<span class="number">1</span>, i, j + <span class="number">1</span>)</span><br><span class="line">        || dfs(board, word, idx+<span class="number">1</span>, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//recover to previoud char for next round, backtracking </span></span><br><span class="line">    board[i][j] = temp;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check:</span></span><br><span class="line"><span class="comment">1. If input is empty, just return false</span></span><br><span class="line"><span class="comment">    1) word == null || word.length == 0</span></span><br><span class="line"><span class="comment">    2) board == null || board.length == 0 || board[0].length == 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution:</span></span><br><span class="line"><span class="comment">    Use DFS to solve this problem</span></span><br><span class="line"><span class="comment">    Idea : traverse form top left to bottom right, in each unit we check if it equals to the first character in the taregt string, if same we apply dfs which return a boolean value</span></span><br><span class="line"><span class="comment">    dfs pass in the board, target string, cur idx, if tarversed string == target return true otherwise return false,</span></span><br><span class="line"><span class="comment">    in each dfs we check the char in unit is same to current idx char in target,</span></span><br><span class="line"><span class="comment">    if dfs retrun true we can just return true, said we do have taregt strig in the board</span></span><br><span class="line"><span class="comment">    booelan dfs(board, word, idx, i, j) &#123;</span></span><br><span class="line"><span class="comment">        //base case</span></span><br><span class="line"><span class="comment">        if (idx == word.length) return true;</span></span><br><span class="line"><span class="comment">        //error check</span></span><br><span class="line"><span class="comment">        if (i &lt; 0 || i &gt; board.length || j &lt; 0 || j &gt; board[0].length || word.charAt(idx) != board[i][j]) return false;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        boolean exist = dfs(board, word, idx+1, i + 1, j)</span></span><br><span class="line"><span class="comment">                        || dfs(board, word, idx+1, i - 1, j)</span></span><br><span class="line"><span class="comment">                        || dfs(board, word, idx+1, i, j + 1)</span></span><br><span class="line"><span class="comment">                        || dfs(board, word, idx+1, i, j - 1);</span></span><br><span class="line"><span class="comment">        retrun exist;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">3. Time O(mn)</span></span><br><span class="line"><span class="comment">Space O(mn)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-15"><a href="#Solution2-15" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((word.charAt(<span class="number">0</span>) == board[i][j]) &amp;&amp; search(board, word, i, j, <span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[][]board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == word.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[i].length || j &lt; <span class="number">0</span> || board[i][j] != word.charAt(index) || visited[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(search(board, word, i-<span class="number">1</span>, j, index+<span class="number">1</span>) || </span><br><span class="line">           search(board, word, i+<span class="number">1</span>, j, index+<span class="number">1</span>) ||</span><br><span class="line">           search(board, word, i, j-<span class="number">1</span>, index+<span class="number">1</span>) || </span><br><span class="line">           search(board, word, i, j+<span class="number">1</span>, index+<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = board.length;</span><br><span class="line">    n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (backtracking(<span class="number">0</span>, r, c, hasVisited, board, word)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> curLen, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] visited, <span class="keyword">final</span> <span class="keyword">char</span>[][] board, <span class="keyword">final</span> String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curLen == word.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n</span><br><span class="line">            || board[r][c] != word.charAt(curLen) || visited[r][c]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        <span class="keyword">if</span> (backtracking(curLen + <span class="number">1</span>, r + d[<span class="number">0</span>], c + d[<span class="number">1</span>], visited, board, word)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[r][c] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-212-Word-Search-II🎂⭐"><a href="#🌕Unsolved-212-Word-Search-II🎂⭐" class="headerlink" title="🌕Unsolved 212. Word Search II🎂⭐"></a><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="noopener">🌕Unsolved 212. Word Search II🎂⭐</a></h2><h3 id="Solution1-31"><a href="#Solution1-31" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>backtracking + trie</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    TrieNode root = buildTrie(words);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            dfs(board, i, j, root, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, TrieNode node, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case, if c is visited or not exist in the trie</span></span><br><span class="line">    <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'#'</span> || node.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node = node.children[c - <span class="string">'a'</span>];</span><br><span class="line">    <span class="keyword">if</span> (node.item != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ans.add(node.item);</span><br><span class="line">        node.item = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dfs(board, i - <span class="number">1</span>, j ,node, ans); </span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dfs(board, i, j - <span class="number">1</span>, node, ans);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; board.length - <span class="number">1</span>) dfs(board, i + <span class="number">1</span>, j, node, ans); </span><br><span class="line">    <span class="keyword">if</span> (j &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) dfs(board, i, j + <span class="number">1</span>, node, ans); </span><br><span class="line">    board[i][j] = c;  <span class="comment">//backtracking</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TrieNode <span class="title">buildTrie</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.item = word;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span> String item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    TrieNode root = buildTrie(words);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            dfs(board, i, j, root, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, TrieNode p, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'#'</span> || p.next[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    p = p.next[c - <span class="string">'a'</span>];</span><br><span class="line">    <span class="keyword">if</span> (p.word != <span class="keyword">null</span>) &#123;   <span class="comment">// found one</span></span><br><span class="line">        res.add(p.word);</span><br><span class="line">        p.word = <span class="keyword">null</span>;     <span class="comment">// de-duplicate</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dfs(board, i - <span class="number">1</span>, j ,p, res); </span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dfs(board, i, j - <span class="number">1</span>, p, res);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; board.length - <span class="number">1</span>) dfs(board, i + <span class="number">1</span>, j, p, res); </span><br><span class="line">    <span class="keyword">if</span> (j &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) dfs(board, i, j + <span class="number">1</span>, p, res); </span><br><span class="line">    board[i][j] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TrieNode <span class="title">buildTrie</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">        TrieNode p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : w.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = c - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.next[i] == <span class="keyword">null</span>) p.next[i] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            p = p.next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p.word = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    TrieNode[] next = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    String word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Boggle-Board-AE-⭐"><a href="#🌕Unsolved-Boggle-Board-AE-⭐" class="headerlink" title="🌕Unsolved Boggle Board(AE)⭐"></a>🌕Unsolved Boggle Board(AE)⭐</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[t,h,i,s,i,s,a],</span><br><span class="line"> [s,i,m,p,l,e,x],</span><br><span class="line"> [b,x,x,x,x,e,b],</span><br><span class="line"> [x,o,g,g,l,x,o],</span><br><span class="line"> [x,x,x,D,T,r,a],</span><br><span class="line"> [R,E,P,E,A,d,x],</span><br><span class="line"> [x,x,x,x,x,x,x],</span><br><span class="line"> [N,O,T,R,E,-,P],</span><br><span class="line"> [x,x,D,E,T,A,E],]</span><br><span class="line"></span><br><span class="line">output:[<span class="keyword">this</span>, is, a, simple, boggle, board, NOTRE-PEATED]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-32"><a href="#Solution1-32" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Use a trie data structure to store the strings</li>
<li>getNeightbors</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(nm * 8^s + ws(build trie)) (8 neighbor, s mean length of longest string)</span></span><br><span class="line"><span class="comment">//O(nm + ws)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">boggleBoard</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">    Trie trie = <span class="keyword">new</span> Trie();  <span class="comment">//create our trie</span></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;  <span class="comment">//pass in all string</span></span><br><span class="line">        trie.add(word);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//words may appear multiple times, so use hash table every word can only appear once</span></span><br><span class="line">    Set&lt;String&gt; finalWords = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//visited matrix keep track wheather the node has been visited</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="comment">//helper function which we will write in a second</span></span><br><span class="line">            explore(i, j, board, trie.root, visited, finalWords);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; finalWordsArray = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    finalWordsArray.addAll(finalWords);</span><br><span class="line">    <span class="keyword">return</span> finalWordsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//take a position, a trie node, board, trie, visited and final words</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">explore</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[][] board, TrieNode trieNode, <span class="keyword">boolean</span>[][] visited, Set&lt;String&gt; finalWords)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[i][j]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> letter = board[i][j];</span><br><span class="line">    <span class="comment">//if not we are done with this part branch</span></span><br><span class="line">    <span class="keyword">if</span> (!trieNode.children.containsKey(letter)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if it is the letter, we mark it visited and futher depth firsr seaech this path</span></span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    trieNode = trieNode.children.get(letter);  <span class="comment">//updat the trieNode, trie level</span></span><br><span class="line">    <span class="keyword">if</span> (trieNode.children.containsKey(<span class="string">'*'</span>)) &#123;  <span class="comment">//if meet '*', we get a actual string add it to finalwords</span></span><br><span class="line">        finalWords.add(trieNode.word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get all neighbors and explore all neighbors</span></span><br><span class="line">    List&lt;Integer[]&gt; neighbors = getNeighbors(i, j, board);</span><br><span class="line">    <span class="keyword">for</span> (Integer[] neighbor : neighbors) &#123;</span><br><span class="line">        explore(neighbor[<span class="number">0</span>], neighbor[<span class="number">1</span>], board, trieNode, visited, finalWords);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//unvisited the current node, like backtracking, for other branch traverse</span></span><br><span class="line">    visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer[]&gt; getNeighbors(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[][] board) &#123;</span><br><span class="line">    List&lt;Integer[]&gt; neighbors = <span class="keyword">new</span> ArrayList&lt;Integer[]&gt;();</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i - <span class="number">1</span>, j - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i - <span class="number">1</span>, j + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; board.length - <span class="number">1</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; board.length - <span class="number">1</span> &amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i + <span class="number">1</span>, j - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i - <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; board.length - <span class="number">1</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i + <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i, j - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        neighbors.add(<span class="keyword">new</span> Integer[] &#123;i, j + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> neighbors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,TrieNode&gt; children = <span class="keyword">new</span> HashMap&lt;Character, TrieNode&gt;();</span><br><span class="line">    String word = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    TrieNode root;</span><br><span class="line">    <span class="keyword">char</span> endSymbol;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="keyword">this</span>.endSymbol = <span class="string">'*'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        TrieNode node = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> letter = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.children.containsKey(letter)) &#123;</span><br><span class="line">                TrieNode newNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                node.children.put(letter, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children.get(letter);</span><br><span class="line">        &#125;</span><br><span class="line">        node.children.put(<span class="keyword">this</span>.endSymbol, <span class="keyword">null</span>);</span><br><span class="line">        node.word = strCourse Schedule II;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕51-N-Queens✨"><a href="#🌕51-N-Queens✨" class="headerlink" title="🌕51. N-Queens✨"></a><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="noopener">🌕51. N-Queens✨</a></h2><p><img src="https://camo.githubusercontent.com/538ca5bd92ad237cc495cafa937f2e324db4be6eecde13e47b25d80cb827c7b7/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30363762333130632d363837372d343066652d396463662d3130363534653733373438352e6a7067" alt=""></p>
<p>在 n*n 的矩阵中摆放 n 个皇后，并且每个皇后不能在同一行，同一列，同一对角线上，求所有的 n 皇后的解。</p>
<p>一行一行地摆放，在确定一行中的那个皇后应该摆在哪一列时，需要用三个标记数组来确定某一列是否合法，这三个标记数组分别为：列标记数组、45 度对角线标记数组和 135 度对角线标记数组。</p>
<p>45 度对角线标记数组的长度为 2 * n - 1，通过下图可以明确 (r, c) 的位置所在的数组下标为 r + c。</p>
<p><img src="https://camo.githubusercontent.com/b8607e2983ed40fa3f5f5cbad4d1467dc58fb63fff6835b9a59a4b3d04f639f3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39633432323932332d313434372d346133622d613465312d3937653636333733383138372e6a7067" alt=""></p>
<p>135 度对角线标记数组的长度也是 2 * n - 1，(r, c) 的位置所在的数组下标为 n - 1 - (r - c)。</p>
<p><img src="https://camo.githubusercontent.com/5b04d1d080eb7ffc776c17f8f5629dbec00b231b9dd7c2ee1d0cb49fa5bb2a98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37613835653238352d653135322d343131362d623664632d3366616232376261393433372e6a7067" alt=""></p>
<h3 id="Solution1-33"><a href="#Solution1-33" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：回溯法。逐行（逐位）尝试，每次置“Q”后，将其所对应的列（行已经处理了）、两个纵行（row-i+n, n*2-i-row-1）设置为已访问。O((n^2)^2)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; r = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] col = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">boolean</span>[] lr = <span class="keyword">new</span> <span class="keyword">boolean</span>[n * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">boolean</span>[] rl = <span class="keyword">new</span> <span class="keyword">boolean</span>[n * <span class="number">2</span>];</span><br><span class="line">    backtrack(<span class="number">0</span>, n, col, lr, rl, r, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n, <span class="keyword">boolean</span>[] col, <span class="keyword">boolean</span>[] lr, <span class="keyword">boolean</span>[] rl, List&lt;List&lt;String&gt;&gt; r, List&lt;String&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">    	r.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (row == n)</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> lrp = row - i + n;</span><br><span class="line">        <span class="keyword">int</span> rlp = n * <span class="number">2</span> - i - row - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (col[i] || lr[lrp] || rl[rlp])</span><br><span class="line">    	<span class="keyword">continue</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; n; ++i1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == i1) &#123;</span><br><span class="line">            sb.append(<span class="string">"Q"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	sb.append(<span class="string">"."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    l.add(sb.toString());</span><br><span class="line">    col[i] = <span class="keyword">true</span>;</span><br><span class="line">    lr[lrp] = <span class="keyword">true</span>;</span><br><span class="line">    rl[rlp] = <span class="keyword">true</span>;</span><br><span class="line">    backtrack(row + <span class="number">1</span>, n, col, lr, rl, r, l);</span><br><span class="line">    l.remove(l.size() - <span class="number">1</span>);</span><br><span class="line">    col[i] = <span class="keyword">false</span>;</span><br><span class="line">    lr[lrp] = <span class="keyword">false</span>;</span><br><span class="line">    rl[rlp] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        String[][] board = <span class="keyword">new</span> String[n][n];</span><br><span class="line">        <span class="keyword">for</span> (String[] b : board) &#123;</span><br><span class="line">            Arrays.fill(b, <span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String[][] board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base line</span></span><br><span class="line">        <span class="keyword">if</span> (row == board.length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String[] b : board)</span><br><span class="line">                res.add(Arrays.asList(b));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = board[row].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isValid(board, row, col))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            board[row][col] = <span class="string">"Q"</span>;</span><br><span class="line">            backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">            board[row][col] = <span class="string">"."</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line">        <span class="comment">//check the column</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col].equals(<span class="string">"Q"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j].equals(<span class="string">"Q"</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j].equals(<span class="string">"Q"</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Solution2-16"><a href="#Solution2-16" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; solutions;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[][] nQueens;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] colUsed;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] diagonals45Used;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] diagonals135Used;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    solutions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    nQueens = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Arrays.fill(nQueens[i], <span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    colUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    diagonals45Used = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">    diagonals135Used = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    backtracking(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> solutions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : nQueens) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">        &#125;</span><br><span class="line">        solutions.add(list);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">int</span> diagonals45Idx = row + col;</span><br><span class="line">        <span class="keyword">int</span> diagonals135Idx = n - <span class="number">1</span> - (row - col);</span><br><span class="line">        <span class="keyword">if</span> (colUsed[col] || diagonals45Used[diagonals45Idx] || diagonals135Used[diagonals135Idx]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nQueens[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = <span class="keyword">true</span>;</span><br><span class="line">        backtracking(row + <span class="number">1</span>);</span><br><span class="line">        colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = <span class="keyword">false</span>;</span><br><span class="line">        nQueens[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="36-Valid-Sudoku⭐"><a href="#36-Valid-Sudoku⭐" class="headerlink" title="36. Valid Sudoku⭐"></a><a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. Valid Sudoku⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Let us first discuss two questions.</span><br><span class="line"></span><br><span class="line">How to enumerate sub-boxes?</span><br><span class="line">One could use box_index = (row / <span class="number">3</span>) * <span class="number">3</span> + col / <span class="number">3</span> where / is an integer division, row is a row number, and col is a column number.</span><br></pre></td></tr></table></figure>

<p><img src="https://leetcode.com/problems/valid-sudoku/Figures/36/36_boxes_2.png" alt=""></p>
<p>One could just track all values which were already encountered in a hash map <code>value -&gt; count</code>.</p>
<h3 id="Solution1-34"><a href="#Solution1-34" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>brute force</li>
<li>Move along the board.<ul>
<li>Check for each cell value if it was seen already in the current row / column / box :<ul>
<li>Return <code>false</code> if yes.</li>
<li>Keep this value for a further tracking if no.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>true</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// init data</span></span><br><span class="line">    HashSet&lt;Integer&gt;[] rows = <span class="keyword">new</span> HashSet[<span class="number">9</span>];</span><br><span class="line">    HashSet&lt;Integer&gt;[] cols = <span class="keyword">new</span> HashSet[<span class="number">9</span>];</span><br><span class="line">    HashSet&lt;Integer&gt;[] boxes = <span class="keyword">new</span> HashSet[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        rows[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        cols[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        boxes[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// validate a board</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =  <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = (<span class="keyword">int</span>) board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (!rows[i].add(num)</span><br><span class="line">                    || !cols[j].add(num)</span><br><span class="line">                    || ! boxes[(i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>].add(num))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-17"><a href="#Solution2-17" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Collect the set of things we see, encoded as strings. For example:</p>
<ul>
<li><code>&#39;4&#39; in row 7</code> is encoded as <code>&quot;(4)7&quot;</code>.</li>
<li><code>&#39;4&#39; in column 7</code> is encoded as <code>&quot;7(4)&quot;</code>.</li>
<li><code>&#39;4&#39; in the top-right block</code> is encoded as <code>&quot;0(4)2&quot;</code>.</li>
</ul>
<p>Scream <code>false</code> if we ever fail to add something because it was already added (i.e., seen before).</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                String val = <span class="string">"("</span> + board[i][j] + <span class="string">")"</span>;</span><br><span class="line">                <span class="keyword">if</span> (!set.add(i + val) || !set.add(val + j) || !set.add(i/<span class="number">3</span> + val + j/<span class="number">3</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Eroor check</span></span><br><span class="line"><span class="comment">1. " ", null, return false;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">case1: each row has excatly 123456789 element - </span></span><br><span class="line"><span class="comment">case2: each row has excatly 123456789 element</span></span><br><span class="line"><span class="comment">case3: each sub square has excatly 123456789 element</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Traverse until encounter a empty space('.'), we fill this space with potenitial canidiated 1~9,visited array to record wich element has been used or not</span></span><br><span class="line"><span class="comment">potenitial candidate: we need check all the row, col, and sub square corresponding with this position, make sure no dplicate</span></span><br><span class="line"><span class="comment">otherwise did not meet these cases, we try another candidate</span></span><br><span class="line"><span class="comment">each pos we have 9 possible choice</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">when we encount a val in idx of [i, j]</span></span><br><span class="line"><span class="comment">case1(row) -&gt; String =  row(val)</span></span><br><span class="line"><span class="comment">case2(col) -&gt; String = (val)col</span></span><br><span class="line"><span class="comment">case3(sub square) -&gt; String = i/3(val)j/3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="37-Sudoku-Solver💜✨"><a href="#37-Sudoku-Solver💜✨" class="headerlink" title="37. Sudoku Solver💜✨"></a><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. Sudoku Solver💜✨</a></h2><h3 id="Solution0"><a href="#Solution0" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute Force</li>
<li>The first idea is to use brut-force to generate all possible ways to fill the cells with numbers from <code>1</code> to <code>9</code>, and then check them to keep the solution only. That means 9^{81}981 operations to do, where 99 is a number of available digits and 8181 is a number of cells to fill. Hence we’re forced to think further how to optimize.</li>
</ol>
<h3 id="Solution1-35"><a href="#Solution1-35" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Backtracking</p>
</li>
<li><p>There are two programming conceptions here which could help.</p>
<p>The first one is called <em>constrained programming</em>.</p>
</li>
</ol>
<p><img src="https://leetcode.com/problems/sudoku-solver/Figures/37/37_const3.png" alt=""></p>
<p>The second one called <em>backtracking</em>.</p>
<p><img src="https://leetcode.com/problems/sudoku-solver/Figures/37/37_backtrack2.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">How to enumerate sub-boxes</span><br><span class="line">One tip to enumerate sub-boxes: </span><br><span class="line">let us use box_index = (row / <span class="number">3</span>) * <span class="number">3</span> + column / <span class="number">3</span> where / is an integer division.</span><br></pre></td></tr></table></figure>

<p><img src="https://leetcode.com/problems/sudoku-solver/Figures/36/36_boxes_2.png" alt=""></p>
<h3 id="Solution2-18"><a href="#Solution2-18" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：回溯法，每一个未填位置试图填入 1-9 每个数，然后再试下一位置。失败时记得把当前值回置为”.”。</li>
<li>Try 1 through 9 for each cell. The time complexity should be 9 ^ m (m represents the number of blanks to be filled in), since each blank can have 9 choices. Details see comments inside code.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    solve(board);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="comment">//trial. Try 1 through 9</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isValid(board, i, j, c)) &#123;</span><br><span class="line">                        <span class="comment">//Put c for this cell</span></span><br><span class="line">                        board[i][j] = c;</span><br><span class="line">                        <span class="comment">//If it's the solution return true</span></span><br><span class="line">                        <span class="keyword">if</span> (solve(board))</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">else</span>  <span class="comment">//otherwise backtracking</span></span><br><span class="line">                            board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//check row</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][col] != <span class="string">'.'</span> &amp;&amp; board[i][col] == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//check column</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][i] != <span class="string">'.'</span> &amp;&amp; board[row][i] == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//check 3*3 block</span></span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">3</span> * (row / <span class="number">3</span>) + i / <span class="number">3</span>][<span class="number">3</span> * (col / <span class="number">3</span>) + i % <span class="number">3</span>] != <span class="string">'.'</span></span><br><span class="line">            &amp;&amp; board[<span class="number">3</span> * (row / <span class="number">3</span>) + i / <span class="number">3</span>][<span class="number">3</span> * (col / <span class="number">3</span>) + i % <span class="number">3</span>] == c)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">There are two places can be improved in the isValid() method. See detail below:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Don't need to check whether the a cell in the row, col or region is not dot. Just check these cells are not c is enough. Since c will not be a '.'</span></span><br><span class="line"><span class="comment">Define region start row and region start col variables make the code a bit more readable and reduce 8 times duplicate computing in each call.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> regionRow = <span class="number">3</span> * (row / <span class="number">3</span>);  <span class="comment">//region start row</span></span><br><span class="line">    <span class="keyword">int</span> regionCol = <span class="number">3</span> * (col / <span class="number">3</span>);    <span class="comment">//region start col</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == c) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check row</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][i] == c) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check column</span></span><br><span class="line">        <span class="keyword">if</span> (board[regionRow + i / <span class="number">3</span>][regionCol + i % <span class="number">3</span>] == c) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check 3*3 block</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="778-Swim-in-Rising-Water🎂💎"><a href="#778-Swim-in-Rising-Water🎂💎" class="headerlink" title="778. Swim in Rising Water🎂💎"></a><a href="https://leetcode.com/problems/swim-in-rising-water/" target="_blank" rel="noopener">778. Swim in Rising Water🎂💎</a></h2><h3 id="Solution1-36"><a href="#Solution1-36" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> N = grid.length;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!visited.contains(N*N-<span class="number">1</span>)) &#123;</span><br><span class="line">            visited.clear();</span><br><span class="line">            dfs(grid, <span class="number">0</span>, <span class="number">0</span>, time, visited);</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> time, Set&lt;Integer&gt; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; grid.length - <span class="number">1</span> || j &lt; <span class="number">0</span> || j &gt; grid[<span class="number">0</span>].length - <span class="number">1</span> || grid[i][j] &gt; time || visited.contains(i*grid.length+j)) <span class="keyword">return</span>;</span><br><span class="line">        visited.add(i*grid.length+j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            dfs(grid, i+dir[<span class="number">0</span>], j+dir[<span class="number">1</span>], time, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="733-Flood-Fill✨"><a href="#733-Flood-Fill✨" class="headerlink" title="733. Flood Fill✨"></a><a href="https://leetcode.com/problems/flood-fill/" target="_blank" rel="noopener">733. Flood Fill✨</a></h2><h3 id="Solution1-37"><a href="#Solution1-37" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (image[sr][sc] == newColor) &#123;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fill(image, sr, sc, image[sr][sc], newColor);</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> color, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= image.length || j &lt; <span class="number">0</span> || j &gt;= image[<span class="number">0</span>].length || image[i][j] != color) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    image[i][j] = newColor;</span><br><span class="line">    fill(image, i + <span class="number">1</span>, j, color, newColor);</span><br><span class="line">    fill(image, i - <span class="number">1</span>, j, color, newColor);</span><br><span class="line">    fill(image, i, j + <span class="number">1</span>, color, newColor);</span><br><span class="line">    fill(image, i, j - <span class="number">1</span>, color, newColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1723-Find-Minimum-Time-to-Finish-All-Jobs🎃✨"><a href="#1723-Find-Minimum-Time-to-Finish-All-Jobs🎃✨" class="headerlink" title="1723. Find Minimum Time to Finish All Jobs🎃✨"></a><a href="https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/" target="_blank" rel="noopener">1723. Find Minimum Time to Finish All Jobs🎃✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: jobs = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">3</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: By assigning each person one job, the maximum time is <span class="number">3</span>.</span><br><span class="line"></span><br><span class="line">Input: jobs = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>], k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">11</span></span><br><span class="line">Explanation: Assign the jobs the following way:</span><br><span class="line">Worker <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span> (working time = <span class="number">1</span> + <span class="number">2</span> + <span class="number">8</span> = <span class="number">11</span>)</span><br><span class="line">Worker <span class="number">2</span>: <span class="number">4</span>, <span class="number">7</span> (working time = <span class="number">4</span> + <span class="number">7</span> = <span class="number">11</span>)</span><br><span class="line">The maximum working time is <span class="number">11</span>.</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009817/One-branch-cutting-trick-to-solve-three-LeetCode-questions" target="_blank" rel="noopener">https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009817/One-branch-cutting-trick-to-solve-three-LeetCode-questions</a></p>
<h3 id="Solution1-38"><a href="#Solution1-38" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>prune1: when we have current woker sum of jobs more than the global max, we stop<br>prune2: when we assign a new job to several wokers who has same work load, we only need to pick one, and stop others recursive call.<br>prune3: sort and start from big task then smaller one, we can stop ealier based on prune1</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTimeRequired</span><span class="params">(<span class="keyword">int</span>[] jobs, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(jobs);</span><br><span class="line">    dfs(jobs, jobs.length - <span class="number">1</span>, <span class="keyword">new</span> <span class="keyword">int</span>[k]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] jobs, <span class="keyword">int</span> pos, <span class="keyword">int</span>[] sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        res = Math.min(res, Arrays.stream(sum).max().getAsInt());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Arrays.stream(sum).max().getAsInt() &gt;= res) <span class="keyword">return</span>;           <span class="comment">//prune1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; sum[i] == sum[i - <span class="number">1</span>]) <span class="keyword">continue</span>;                  <span class="comment">//prune2</span></span><br><span class="line">        sum[i] += jobs[pos];</span><br><span class="line">        dfs(jobs, pos - <span class="number">1</span>, sum);</span><br><span class="line">        sum[i] -= jobs[pos];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="290-Word-Pattern✨"><a href="#290-Word-Pattern✨" class="headerlink" title="290. Word Pattern✨"></a><a href="https://leetcode.com/problems/word-pattern/" target="_blank" rel="noopener">290. Word Pattern✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String s)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    String[] strs = s.split(<span class="string">" "</span>);</span><br><span class="line">    <span class="comment">//判断长度</span></span><br><span class="line">    <span class="keyword">if</span> (strs.length != pattern.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> key = pattern.charAt(i);</span><br><span class="line">        String val = strs[i];</span><br><span class="line">        <span class="comment">//判断char是否对应相同String</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.get(key).equals(val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//判断String没有存在在map里，已经和其他char形成了对应关系</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsValue(strs[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕291-Word-Pattern-II✨"><a href="#🌕291-Word-Pattern-II✨" class="headerlink" title="🌕291. Word Pattern II✨"></a><a href="https://leetcode.com/problems/word-pattern-ii/" target="_blank" rel="noopener">🌕291. Word Pattern II✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPatternMatch</span><span class="params">(String pattern, String s)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> dfs(pattern, s, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String pattern, String s, Map&lt;Character, String&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (pattern.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if map contains char</span></span><br><span class="line">    <span class="keyword">char</span> c = pattern.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.startsWith(map.get(c))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(pattern.substring(<span class="number">1</span>), s.substring(map.get(c).length()), map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map not contains char</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        String temp = s.substring(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (map.containsValue(temp)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        map.put(c, temp);</span><br><span class="line">        <span class="keyword">if</span> (dfs(pattern.substring(<span class="number">1</span>), s.substring(temp.length()), map)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="827-Making-A-Large-Island💎"><a href="#827-Making-A-Large-Island💎" class="headerlink" title="827. Making A Large Island💎"></a><a href="https://leetcode.com/problems/making-a-large-island/" target="_blank" rel="noopener">827. Making A Large Island💎</a></h2><h3 id="Solution1-39"><a href="#Solution1-39" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="526-Beautiful-Arrangement"><a href="#526-Beautiful-Arrangement" class="headerlink" title="526. Beautiful Arrangement"></a><a href="https://leetcode.com/problems/beautiful-arrangement/" target="_blank" rel="noopener">526. Beautiful Arrangement</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Suppose you have n integers labeled <span class="number">1</span> through n. <span class="function">A permutation of those n integers <span class="title">perm</span> <span class="params">(<span class="number">1</span>-indexed)</span> is considered a beautiful arrangement <span class="keyword">if</span> <span class="keyword">for</span> every <span class="title">i</span> <span class="params">(<span class="number">1</span> &lt;= i &lt;= n)</span>, either of the following is <span class="keyword">true</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1. perm[i] is divisible by i.</span></span><br><span class="line"><span class="function">2. i is divisible by perm[i].</span></span><br><span class="line"><span class="function">Given an integer n, return the number of the beautiful arrangements that you can construct.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Input: n </span>= <span class="number">2</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: </span><br><span class="line">The first beautiful arrangement is [<span class="number">1</span>,<span class="number">2</span>]:</span><br><span class="line">    - perm[<span class="number">1</span>] = <span class="number">1</span> is divisible by i = <span class="number">1</span></span><br><span class="line">    - perm[<span class="number">2</span>] = <span class="number">2</span> is divisible by i = <span class="number">2</span></span><br><span class="line">The second beautiful arrangement is [<span class="number">2</span>,<span class="number">1</span>]:</span><br><span class="line">    - perm[<span class="number">1</span>] = <span class="number">2</span> is divisible by i = <span class="number">1</span></span><br><span class="line">    - i = <span class="number">2</span> is divisible by perm[<span class="number">2</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-40"><a href="#Solution1-40" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countArrangement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] used = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    findArrangement(n, <span class="number">1</span>, used);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findArrangement</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> idx, <span class="keyword">int</span>[] used)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx &gt; n) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i] == <span class="number">0</span> &amp;&amp; (i % idx == <span class="number">0</span> || idx % i == <span class="number">0</span>)) &#123;</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            findArrangement(n, idx+<span class="number">1</span>, used);</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1718-Construct-the-Lexicographically-Largest-Valid-Sequence🎃"><a href="#1718-Construct-the-Lexicographically-Largest-Valid-Sequence🎃" class="headerlink" title="1718. Construct the Lexicographically Largest Valid Sequence🎃"></a><a href="https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/" target="_blank" rel="noopener">1718. Construct the Lexicographically Largest Valid Sequence🎃</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The integer <span class="number">1</span> occurs once in the sequence.</span><br><span class="line">Each integer between <span class="number">2</span> and n occurs twice in the sequence.</span><br><span class="line">For every integer i between <span class="number">2</span> and n, the distance between the two occurrences of i is exactly i.</span><br><span class="line">    </span><br><span class="line">Input: n = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">Explanation: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] is also a valid sequence, but [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>] is the lexicographically largest valid sequence.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-41"><a href="#Solution1-41" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Since ‘n’ ranges between 1 to 20 , we can afford a solution of exponential time complexity.</p>
<ol>
<li>We try to construct our result array by taking the largest number possible at each point.</li>
<li>Except 1 (since its count is 1) whenever we place an integer in a particular position, we also place the second occurence of that integer in our temporary array. This is because in the question it is mentioned that : <em>For every integer i between 2 and n, the distance between the two occurrences of i is exactly i.</em></li>
<li>As soon as we reach a valid solution that follows all the constraints we return ‘true’. This indicates we do not need to continue our search. (This is an important step as otherwise we will get TLE).</li>
<li>Since we start from largest possible number at each step once we reach a valid solution that is our answer.</li>
</ol>
<p><strong>Time Complexity</strong> : Ideally it should be (n!) since we are using backtracking and trying to find out all possible solutions.<br>But because of this constraint : <strong>For every integer i between 2 and n, the distance between the two occurrences of i is exactly i</strong>, the number of permutations under consideration is reducing greatly.<br>Also since we are trying to find out the <strong>lexicographically largest sequence</strong> we stop as soon as we find a valid solution (early stop).</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] constructDistancedSequence(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] ans =  <span class="keyword">new</span> <span class="keyword">int</span>[n*<span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">    getSequence(<span class="number">0</span>, ans, visited, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//return boolean mean can or can not form assign all value to ans ans idx add to ans.length</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getSequence</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] ans, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == ans.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans[idx] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// value already assigned in this position. So go ahead with the next index</span></span><br><span class="line">        <span class="keyword">return</span> getSequence(idx+<span class="number">1</span>, ans, visited, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// start from n to 1 since we need to find out the lexicographically largest sequence</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            ans[idx] = i;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getSequence(idx+<span class="number">1</span>, ans, visited, n)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx + i &lt; ans.length &amp;&amp; ans[idx + i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// assigning the second occurence of i in the desired position(current index + i )</span></span><br><span class="line">                ans[idx + i] = i;</span><br><span class="line">                <span class="comment">// largest possible sequence satisfying the given conditions found</span></span><br><span class="line">                <span class="keyword">if</span> (getSequence(idx+<span class="number">1</span>, ans, visited, n)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                ans[idx + i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            ans[idx] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/10/12/Princeton%20Algorithms%20week2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/12/Princeton%20Algorithms%20week2/" class="post-title-link" itemprop="url">Princeton Algorithms week2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-12 18:15:41" itemprop="dateCreated datePublished" datetime="2020-10-12T18:15:41+09:00">2020-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-05 17:03:18" itemprop="dateModified" datetime="2020-11-05T17:03:18+09:00">2020-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Princeton-Algorithms-week2"><a href="#Princeton-Algorithms-week2" class="headerlink" title="Princeton Algorithms week2"></a>Princeton Algorithms week2</h1><p><strong>Suggested Readings.</strong> <strong><code>Section 1.3</code></strong> and <strong><code>2.1</code></strong> in <em>Algorithms, 4th edition</em>.</p>
<p><a href="https://coursera.cs.princeton.edu/algs4/assignments/queues/specification.php" target="_blank" rel="noopener">assignment</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/10/12/Princeton%20Algorithms%20week2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/26/Algorithms,%204th%20edition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/26/Algorithms,%204th%20edition/" class="post-title-link" itemprop="url">Algorithms, 4th edition</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-26 16:43:35" itemprop="dateCreated datePublished" datetime="2020-09-26T16:43:35+09:00">2020-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-16 20:21:01" itemprop="dateModified" datetime="2020-12-16T20:21:01+09:00">2020-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Algorithms-4th-edition"><a href="#Algorithms-4th-edition" class="headerlink" title="Algorithms, 4th edition"></a>Algorithms, 4th edition</h1><h1 id="第二章排序"><a href="#第二章排序" class="headerlink" title="第二章排序"></a>第二章排序</h1><h2 id="2-1初级排序算法"><a href="#2-1初级排序算法" class="headerlink" title="2.1初级排序算法"></a>2.1初级排序算法</h2><h3 id="排序算法类模板"><a href="#排序算法类模板" class="headerlink" title="排序算法类模板"></a>排序算法类模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">less</span><span class="params">(Comparaible v, Comparaible w)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparaible[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Comparaible t = a[i]; a[i] = a[j]; a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparaible[] a)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">            StdOut.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        StdOut.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparaible[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i - <span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Strng[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] a = In.readStrings();</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将N个随机值的数组排序"><a href="#将N个随机值的数组排序" class="headerlink" title="将N个随机值的数组排序"></a>将N个随机值的数组排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Double[] a = <span class="keyword">new</span> Double[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">    a[i] = StrRandom.uniform();</span><br><span class="line">Quick.sort(a);</span><br></pre></td></tr></table></figure>

<p>创建数据类型时，实现Comparable接口就能保证用例代码可以将其排序</p>
<p>要做到这一点，只需要实现一个<strong><code>compareTo()</code></strong> method</p>
<p>ex</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Date</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> day;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">comparTo</span><span class="params">(Date that)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.year &gt; that.year) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.year &lt; that.year) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Selection-Sort-选择排序"><a href="#Selection-Sort-选择排序" class="headerlink" title="Selection Sort(选择排序)"></a>Selection Sort(选择排序)</h3><p>遍历，选出最小的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (less(a[j], min)) min = j;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Insertion-Sort-插入排序"><a href="#Insertion-Sort-插入排序" class="headerlink" title="Insertion Sort(插入排序)"></a>Insertion Sort(插入排序)</h3><p>像整理桥牌， 扑克一样，遍历时把当前元素 插入前面相应的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Cpmparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j - <span class="number">1</span>]); j--)</span><br><span class="line">            exch(a, j, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Shell-Sort-希尔排序"><a href="#Shell-Sort-希尔排序" class="headerlink" title="Shell Sort(希尔排序)"></a>Shell Sort(希尔排序)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparaible[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>) h = <span class="number">3</span>*h + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; h; &amp;&amp; less(a[j], a[j - h]); j -= h)</span><br><span class="line">                    exch(a, j, j - h);</span><br><span class="line">            &#125;</span><br><span class="line">            h = h / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2Mege-Sort-归并排序"><a href="#2-2Mege-Sort-归并排序" class="headerlink" title="2.2Mege Sort(归并排序)"></a>2.2Mege Sort(归并排序)</h2><h3 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; hi) a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自顶而下的归并排序"><a href="#自顶而下的归并排序" class="headerlink" title="自顶而下的归并排序"></a>自顶而下的归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">merge</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(COmparaible[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparaible[a.length];</span><br><span class="line">        sort(a, <span class="number">9</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);</span><br><span class="line">        sort(a, mid + <span class="number">1</span>, hi);</span><br><span class="line">        merge(a, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自底而上的归并排序"><a href="#自底而上的归并排序" class="headerlink" title="自底而上的归并排序"></a>自底而上的归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeBU</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comaparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        anx = <span class="keyword">new</span> Comparable[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt; n; size += size)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; n - size; lo += size+size)</span><br><span class="line">                merge(a, lo, lo + size - <span class="number">1</span>, Math.min(lo + size + size - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3Quick-Sort-快速排序"><a href="#2-3Quick-Sort-快速排序" class="headerlink" title="2.3Quick Sort(快速排序)"></a>2.3Quick Sort(快速排序)</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> vois <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StdRandom.shuffle(a);</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[a], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        sort(a, lo, j - <span class="number">1</span>);</span><br><span class="line">        sort(a, j + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序的切分"><a href="#快速排序的切分" class="headerlink" title="快速排序的切分"></a>快速排序的切分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    Comparable p = a[lo];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], p)) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (less(p, a[--j])) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(a, lo, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-4Heap-优先队列"><a href="#2-4Heap-优先队列" class="headerlink" title="2.4Heap(优先队列)"></a>2.4Heap(优先队列)</h2><h3 id="堆实现的比较和交换"><a href="#堆实现的比较和交换" class="headerlink" title="堆实现的比较和交换"></a>堆实现的比较和交换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;Key temp = pq[i]; pq[i] = pq[j]; pq[j] = temp;&#125;</span><br></pre></td></tr></table></figure>

<p>由下而上的堆有序化，上浮</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>, k))</span><br><span class="line">    &#123;</span><br><span class="line">        exch(k/<span class="number">2</span>, k);</span><br><span class="line">        k = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="由上而下的堆有序化，下沉"><a href="#由上而下的堆有序化，下沉" class="headerlink" title="由上而下的堆有序化，下沉"></a>由上而下的堆有序化，下沉</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j+<span class="number">1</span>)) j++;</span><br><span class="line">        <span class="keyword">if</span> (!less(k, j)) <span class="keyword">break</span>;</span><br><span class="line">        exch(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于堆的优先队列"><a href="#基于堆的优先队列" class="headerlink" title="基于堆的优先队列"></a>基于堆的优先队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MAXPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> maxN)</span></span></span><br><span class="line"><span class="function">    </span>&#123;pq = (Key[]) <span class="keyword">new</span> Comparable[maxN+<span class="number">1</span>];&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> N == <span class="number">0</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> N;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pq[++N] = v;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Key max = pq[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>, N--);</span><br><span class="line">        pq[N+<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Heap-Sort-堆排序"><a href="#Heap-Sort-堆排序" class="headerlink" title="Heap Sort(堆排序)"></a>Heap Sort(堆排序)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = N/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">        sink(a, k, N);</span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        exch(a, <span class="number">1</span>, N--);</span><br><span class="line">        sink(a, <span class="number">1</span>, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章查找"><a href="#第三章查找" class="headerlink" title="第三章查找"></a>第三章查找</h1><h2 id="3-1符号表"><a href="#3-1符号表" class="headerlink" title="3.1符号表"></a>3.1符号表</h2><h3 id="顺序查找-基于无序链表"><a href="#顺序查找-基于无序链表" class="headerlink" title="顺序查找(基于无序链表)"></a>顺序查找(基于无序链表)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, Node next)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            <span class="keyword">if</span> (key.equals(x.key))</span><br><span class="line">                <span class="keyword">return</span> x.val;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            <span class="keyword">if</span> (key.equals(x.key))</span><br><span class="line">            &#123;x.val = val; <span class="keyword">return</span>;&#125;</span><br><span class="line">        first = <span class="keyword">new</span> Node(key, val, first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分查找-基于有序数组"><a href="#二分查找-基于有序数组" class="headerlink" title="二分查找(基于有序数组)"></a>二分查找(基于有序数组)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchST</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        keys[] = (Key[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">        vals = (Value[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> N;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>) <span class="keyword">return</span> vals[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        &#123;vals[i] = val; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N; j &gt; i; j--)</span><br><span class="line">        &#123;keys[j] = keys[j - i]; vals[j] = vals[j - <span class="number">1</span>]&#125;</span><br><span class="line">        keys[i] = key; vals[i] = val;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="基于有序数组的二分查找-迭代"><a href="#基于有序数组的二分查找-迭代" class="headerlink" title="基于有序数组的二分查找(迭代)"></a>基于有序数组的二分查找(迭代)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = N-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(keys[mid]);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) hi = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) lo = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于二分查找的有序符号表的其他操作"><a href="#基于二分查找的有序符号表的其他操作" class="headerlink" title="基于二分查找的有序符号表的其他操作"></a>基于二分查找的有序符号表的其他操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> kets[<span class="number">0</span>]&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> keys[N-<span class="number">1</span>];&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> keys[k];&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">ceiling</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = rank(key);</span><br><span class="line">    <span class="keyword">return</span> keys[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo, Key hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;Key&gt; q = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = rank(lo)l i &lt; rank(hi); i++)</span><br><span class="line">    q.enqueue(keys[i]);</span><br><span class="line">    <span class="keyword">if</span> (contains(hi))</span><br><span class="line">        q.enqueue(keys[rank(hi));</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2Binary-Search-Tree-二叉查找树"><a href="#3-2Binary-Search-Tree-二叉查找树" class="headerlink" title="3.2Binary Search Tree(二叉查找树)"></a>3.2Binary Search Tree(二叉查找树)</h2><h3 id="基于二叉查找树的符号表"><a href="#基于二叉查找树的符号表" class="headerlink" title="基于二叉查找树的符号表"></a>基于二叉查找树的符号表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/25/Princeton%20Algorithms%20week1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/Princeton%20Algorithms%20week1/" class="post-title-link" itemprop="url">Princeton Algorithms week1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-25 16:57:35" itemprop="dateCreated datePublished" datetime="2020-09-25T16:57:35+09:00">2020-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-05 16:24:28" itemprop="dateModified" datetime="2020-11-05T16:24:28+09:00">2020-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Princeton-Algorithms-week1"><a href="#Princeton-Algorithms-week1" class="headerlink" title="Princeton Algorithms week1"></a>Princeton Algorithms week1</h1><h2 id="Course-Introduction"><a href="#Course-Introduction" class="headerlink" title="Course Introduction"></a>Course Introduction</h2><p>Finish <strong><code>Algorithms, 4th Edition</code></strong> section<strong><code>1.1, 1.2</code></strong></p>
<p><a href="https://coursera.cs.princeton.edu/algs4/assignments/percolation/specification.php" target="_blank" rel="noopener">assignment</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/25/Princeton%20Algorithms%20week1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/20/Stack%20&%20Queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/20/Stack%20&%20Queue/" class="post-title-link" itemprop="url">Stack & Queue</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-20 17:13:29" itemprop="dateCreated datePublished" datetime="2020-09-20T17:13:29+09:00">2020-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-05 01:44:14" itemprop="dateModified" datetime="2021-04-05T01:44:14+09:00">2021-04-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><h2 id="735-Asteroid-Collision⭐"><a href="#735-Asteroid-Collision⭐" class="headerlink" title="735. Asteroid Collision⭐"></a><a href="https://leetcode.com/problems/asteroid-collision/" target="_blank" rel="noopener">735. Asteroid Collision⭐</a></h2><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Say we have our answer as a stack with rightmost asteroid <code>top</code>, and a <code>new</code> asteroid comes in. If <code>new</code> is moving right (<code>new &gt; 0</code>), or if <code>top</code> is moving left (<code>top &lt; 0</code>), no collision occurs.</li>
<li>Otherwise, if <code>abs(new) &lt; abs(top)</code>, then the <code>new</code> asteroid will blow up; if <code>abs(new) == abs(top)</code> then both asteroids will blow up; and if <code>abs(new) &gt; abs(top)</code>, then the <code>top</code> asteroid will blow up (and possibly more asteroids will, so we should continue checking.)</li>
<li>Time Complexity: O(N), where N<em>N</em> is the number of asteroids. Our stack pushes and pops each asteroid at most once.</li>
<li>Space Complexity: O(N). We use a stack to keep track of the intermediate results. In the worst case, the states do not evolve at the end, <em>i.e.</em> we need O(N) space where N<em>N</em> is the number of input asteroids.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] asteroidCollision(<span class="keyword">int</span>[] asteroids) &#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span>(asteroids == <span class="keyword">null</span> || asteroids.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> asteroids;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> asteroid : asteroids) &#123;</span><br><span class="line">        <span class="keyword">if</span> (asteroid &gt; <span class="number">0</span>) &#123;  <span class="comment">// previous one does not matter, no collision forever</span></span><br><span class="line">            stack.push(asteroid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//detory small positive one</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &gt; <span class="number">0</span> &amp;&amp; stack.peek() &lt; -asteroid) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || stack.peek() &lt; <span class="number">0</span>) &#123;  <span class="comment">//both move to left</span></span><br><span class="line">                stack.push(asteroid);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.peek() == -asteroid) &#123;  <span class="comment">//same mass detory both</span></span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//bigger positive one, do nothing itself destoried</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = stack.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        result[i] = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="682-Baseball-Game⭐"><a href="#682-Baseball-Game⭐" class="headerlink" title="682. Baseball Game⭐"></a><a href="https://leetcode.com/problems/baseball-game/" target="_blank" rel="noopener">682. Baseball Game⭐</a></h2><h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Stack</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(String[] ops)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String op : ops) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> newTop = top + stack.peek();</span><br><span class="line">            stack.push(top);</span><br><span class="line">            stack.push(newTop);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"D"</span>)) &#123;</span><br><span class="line">            stack.push(stack.peek() * <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"C"</span>)) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(Integer.valueOf(op));  <span class="comment">//String -&gt; int</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : stack) ans += num;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="394-Decode-String🎂⭐"><a href="#394-Decode-String🎂⭐" class="headerlink" title="394. Decode String🎂⭐"></a><a href="https://leetcode.com/problems/decode-string/" target="_blank" rel="noopener">394. Decode String🎂⭐</a></h2><p><img src="https://leetcode.com/problems/decode-string/Figures/394/decode_overview.png" alt=""></p>
<h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><p><img src="https://leetcode.com/problems/decode-string/Figures/394/twoStack_diagram.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; nums = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;StringBuilder&gt; strs = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    StringBuilder cur = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">            count = count * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'['</span>) &#123;</span><br><span class="line">            <span class="comment">// push the number k to countStack</span></span><br><span class="line">            nums.push(count);</span><br><span class="line">            <span class="comment">// reset currentString and k</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// push the currentString to stringStack</span></span><br><span class="line">            strs.push(cur);</span><br><span class="line">            cur = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">']'</span>) &#123;</span><br><span class="line">            StringBuilder decode = strs.pop();</span><br><span class="line">            <span class="keyword">int</span> n = nums.pop();</span><br><span class="line">            <span class="comment">// decode currentK[currentString] by appending currentString k times</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                decode.append(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = decode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MIN-MAX-Stack-Construction-AE-⭐"><a href="#MIN-MAX-Stack-Construction-AE-⭐" class="headerlink" title="MIN MAX Stack Construction(AE)⭐"></a>MIN MAX Stack Construction(AE)⭐</h2><ol>
<li><p>Write MinMaxStack class support for pushing and poping values on and off the stack, peeking at the value at the top of the stack, getting both minimum and the maximum values in the stack at any given point in time; Implement a stack data structure with a couple of extra special properties, the min max properties.</p>
</li>
<li><p>Stack. LIFO standard. Be able to access the minimum and maximum value at constant time. We can use array or linkedlist to implement the stack.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack: <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span></span><br><span class="line">min    <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span></span><br><span class="line">max    <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span></span><br><span class="line">peek   <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack:                     <span class="number">5</span>   -&gt;   <span class="number">7</span>   -&gt;   <span class="number">2</span></span><br><span class="line">Map&lt;String, Integer&gt;[<span class="string">"min"</span>-<span class="number">5</span>, <span class="string">"min"</span>-<span class="number">5</span>, <span class="string">"min"</span>-<span class="number">2</span>]</span><br><span class="line">				  [<span class="string">"max"</span>-<span class="number">5</span>, <span class="string">"max"</span>-<span class="number">7</span>, <span class="string">"max"</span>-<span class="number">7</span>]</span><br><span class="line">peek                       <span class="number">5</span>   -&gt;   <span class="number">7</span>   -&gt;   <span class="number">2</span></span><br><span class="line">minMaxStack is a list of Map&lt;String, Integer&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MinMaxStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//initialize minMaxStack varaible, a list that holds minimum and maximum values and stack varaible holds our values</span></span><br><span class="line">    List&lt;Map&lt;String, Integer&gt;&gt; minMaxStack = <span class="keyword">new</span> ArrayList&lt;Map&lt;String, Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayList&lt;Inetger&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(1) time | O(1) space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;  <span class="comment">//just return the last enelemt</span></span><br><span class="line">        <span class="keyword">return</span> stack.get(stack.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(1) time | O(1) space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minMaxStack.remove(minMaxStack.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> stack.remove(stack.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(1) time | O(1) space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; newMinMax = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  <span class="comment">//declare a varaible</span></span><br><span class="line">        newMinMax.put(<span class="string">"min"</span>, number);</span><br><span class="line">        newMinMax.put(<span class="string">"max"</span>, number);</span><br><span class="line">        <span class="keyword">if</span> (minMaxStack.size() &gt; <span class="number">0</span>) &#123;  <span class="comment">//if there are previous values in stack</span></span><br><span class="line">            Map&lt;String, Integer&gt; lastMinMax = (minMaxStack.get(minMaxStack.size() - <span class="number">1</span>));  <span class="comment">//peeking the final value of the last minMaxStack, use it update current </span></span><br><span class="line">            newMinMax.replace(<span class="string">"min"</span>, Math.min(lastMInMax.get(<span class="string">"min"</span>), number));</span><br><span class="line">            newMinMax.replace(<span class="string">"max"</span>, Math.max(lastMInMax.get(<span class="string">"max"</span>), number));</span><br><span class="line">        &#125;</span><br><span class="line">        minMaxStack.add(newMinMax);</span><br><span class="line">        stack.add(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(1) time | O(1) space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minMaxStack.get(minMaxStack.size() - <span class="number">1</span>).get(<span class="string">"min"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(1) time | O(1) space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minMaxStack.get(minMaxStack.size() - <span class="number">1</span>).get(<span class="string">"max"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a><a href="https://leetcode.com/problems/min-stack" target="_blank" rel="noopener">155. Min Stack</a></h3><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. </p>
<ul>
<li>push(x) – Push element x onto stack. </li>
<li>pop() – Removes the element on top of the stack. </li>
<li>top() – Get the top element. </li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.getMin(); --&gt; Returns -<span class="number">3</span>.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top(); --&gt; Returns <span class="number">0</span>.</span><br><span class="line">minStack.getMin(); --&gt; Returns -<span class="number">2</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><p><img src="https://leetcode.com/problems/min-stack/Figures/155/two_stacks.png" alt=""></p>
<ol>
<li>思路1：Two Stacks</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || x &lt;= minStack.peek()) &#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.peek().equals(minStack.peek())) &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><p><img src="https://leetcode.com/problems/min-stack/Figures/155/stack_with_mins.png" alt=""></p>
<ol>
<li>思路2（略）：Stack of Value/ Minimum Pairs</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;<span class="keyword">int</span>[]&gt; stack;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* If the stack is empty, then the min value</span></span><br><span class="line"><span class="comment">         * must just be the first value we add. */</span></span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, x&#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> currentMin = stack.peek()[<span class="number">1</span>];</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, Math.min(x, currentMin)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek()[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="716-Max-Stack"><a href="#716-Max-Stack" class="headerlink" title="716. Max Stack"></a><a href="https://leetcode.com/problems/max-stack/" target="_blank" rel="noopener">716. Max Stack</a></h3><h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Stack&lt;Integer&gt; stack;</span><br><span class="line"><span class="keyword">public</span> Stack&lt;Integer&gt; maxStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MaxStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    maxStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = maxStack.isEmpty()? x : maxStack.peek();</span><br><span class="line">    max = Math.max(max, x);</span><br><span class="line">    maxStack.push(max);</span><br><span class="line">    stack.push(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    maxStack.pop();</span><br><span class="line">    <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peekMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxStack.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = peekMax();</span><br><span class="line">    Stack&lt;Integer&gt; temp = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(stack.peek() != max) &#123;</span><br><span class="line">        temp.push(pop());</span><br><span class="line">    &#125;</span><br><span class="line">    pop();</span><br><span class="line">    <span class="keyword">while</span>(!temp.isEmpty()) &#123;</span><br><span class="line">        push(temp.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Balanced-Brackets-AE"><a href="#Balanced-Brackets-AE" class="headerlink" title="Balanced Brackets(AE)"></a>Balanced Brackets(AE)</h2><ol>
<li><p>Given a string of brackets, there are 3 type brackets. And each have opening and closing brackets. Every opening and closing have to be matched. </p>
</li>
<li><p>Apply stack LIFO to keep track of every pairs.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(([]()())&#123;&#125;)</span><br><span class="line">[(, (, [,],] -&gt; wheninput is closing bracket ], first check stack is not empty and last element, the last opening bracket need to matching current closing bracket, <span class="keyword">if</span> match pop them</span><br><span class="line">[(, (]  (remove [] matched)</span><br><span class="line">[(, (, (]</span><br><span class="line">[(, (]  (remove () matched) etc</span><br><span class="line">after iterate process we need to check <span class="keyword">if</span> stack is empty</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(n) space  eg.imbalanced string (((((( case, store them in stack will be O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">balancedBrackets</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    String openingBrackets = <span class="string">"([&#123;"</span>;</span><br><span class="line">    String closingBrackets = <span class="string">")]&#125;"</span>;</span><br><span class="line">    Map&lt;Character, Character&gt; matchingBrackets = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();  <span class="comment">//use hash table to store the closing bracket matching the corresponding opening bracket</span></span><br><span class="line">    matchingBrackets.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">    matchingBrackets.put(<span class="string">']'</span>, <span class="string">'['</span>);</span><br><span class="line">    matchingBrackets.put(<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>);</span><br><span class="line">    List&lt;Character&gt; stack = <span class="keyword">new</span> ArrayList&lt;Character&gt;();  <span class="comment">//create the stack to store</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> letter = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (openingBrackets.indexOf(letter) != -<span class="number">1</span>) &#123;</span><br><span class="line">            stack.add(letter);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closingBrackets.indexOf(letter) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.size() == <span class="number">0</span>) &#123;  <span class="comment">//is stack is empty, we don't have openging bracket to pair</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.get(stack.size() - <span class="number">1</span>) == matchingBrackets.get(letter)) &#123;</span><br><span class="line">                stack.remove(stack.size() - <span class="number">1</span>);  <span class="comment">//if matched, remove the matched ele in stack</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.size() == <span class="number">0</span>;  <span class="comment">//after traverse stack shouldbe empty if all ele correctly matched</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-Valid-Parentheses✨"><a href="#20-Valid-Parentheses✨" class="headerlink" title="20. Valid Parentheses✨"></a><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. Valid Parentheses✨</a></h3><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.</p>
<h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：典型的压栈出栈操作，遇左括号则压右括号，右则出栈且对比。对比有不同或最后栈不为空，则失败。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">']'</span>, <span class="string">'['</span>);</span><br><span class="line">    map.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">    map.put(<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>);</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tarverse s, if c else if o</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(c)) &#123;  <span class="comment">//遇到右括号则pop()对比出栈括号元素是否是同类型closing bracket</span></span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || map.get(c) != stack.peek()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//遇左括号则push stack</span></span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Shorten-Path-AE"><a href="#🌕Shorten-Path-AE" class="headerlink" title="🌕Shorten Path(AE)"></a>🌕Shorten Path(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.. mean <span class="keyword">return</span> to previous path</span><br><span class="line">. mean turn to current dictionary, <span class="keyword">do</span> nothing</span><br><span class="line"><span class="string">"/foo/../test/../test/../foo//bar/./baz"</span> = <span class="string">"/foo/bar/baz"</span></span><br><span class="line">Step1: split with respect to forward slashes</span><br><span class="line">Step2: filter out all of the empty strings and single dots</span><br><span class="line">Step3: add to a <span class="keyword">final</span> stack, <span class="keyword">if</span> an absolute path, (<span class="string">"/"</span> is first character) add empty string to stack</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">shortenPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//check if an absolute path</span></span><br><span class="line">    <span class="keyword">boolean</span> startsWithPath = path.charAt(<span class="number">0</span>) == <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//split with respect to "/"</span></span><br><span class="line">    String[] tokensArr = path.split(<span class="string">"/"</span>);</span><br><span class="line">    List&lt;String&gt; tokensList = Arrays.asList(tokensArr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//filter out all of the "" and "."</span></span><br><span class="line">    List&lt;String&gt; filteredTokens = tokensList.stream().filter(token -&gt; isImportantToken(token)).collect(Collectors.toList());  </span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; stack = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span> (startsWithPath) stack.add(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (String token : filteredTokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (token.equals(<span class="string">".."</span>)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            case1 expty stack or double dots ../../foo can not remove .. otherwise lose information, add ".." to the stack</span></span><br><span class="line"><span class="comment">            case2 foo/.. , pop stack</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (stack.size() == <span class="number">0</span> || stack.get(stack.size() - <span class="number">1</span>).equals(<span class="string">".."</span>)) &#123;</span><br><span class="line">                stack.add(token);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!stack.get(stack.size() - <span class="number">1</span>).equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                stack.remove(stack.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.add(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack.size() == <span class="number">1</span> &amp;&amp; stack.get(<span class="number">0</span>).equals(<span class="string">""</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">    <span class="keyword">return</span> String.join(<span class="string">"/"</span>, stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isImportantToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> token.length() &gt; <span class="number">0</span> &amp;&amp; !token.equals(<span class="string">"."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="71-Simplify-Path✨"><a href="#71-Simplify-Path✨" class="headerlink" title="71. Simplify Path✨"></a><a href="https://leetcode.com/problems/simplify-path/" target="_blank" rel="noopener">71. Simplify Path✨</a></h3><h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Using Stacks</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Handle empty string</span></span><br><span class="line">    <span class="keyword">if</span> (path.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize a stack</span></span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">    String[] components = path.split(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split the input string on "/" as the delimiter and process each portion one by one</span></span><br><span class="line">    <span class="keyword">for</span> (String directory : components) &#123;</span><br><span class="line">        <span class="comment">// A no-op for a "." or an empty string</span></span><br><span class="line">        <span class="keyword">if</span> (directory.equals(<span class="string">"."</span>) || directory.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (directory.equals(<span class="string">".."</span>)) &#123;</span><br><span class="line">            <span class="comment">// If the current component is a "..", then</span></span><br><span class="line">            <span class="comment">// we pop an entry from the stack if it's non-empty</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Finally, a legitimate directory name, so we add it</span></span><br><span class="line">            <span class="comment">// to our stack</span></span><br><span class="line">            stack.add(directory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stich together all the directory names together    </span></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (String dir : stack) &#123;  <span class="comment">//traverse a stack from bottom to top using a for loop</span></span><br><span class="line">        result.append(<span class="string">"/"</span>);</span><br><span class="line">        result.append(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.length() &gt; <span class="number">0</span> ? result.toString() : <span class="string">"/"</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：逐一加入 List，再逐一输出到 StringBuilder 中即可，注意每一级间需要/。特殊情况：//，先去除所有 //。“.”，不预理睬。“..”向上一级目录（如果存在则在 List 中删除）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = path.length();</span><br><span class="line">    String[] p = path.split(<span class="string">"/"</span>);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    LinkedList&lt;String&gt; s = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String pa : p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa.equals(<span class="string">".."</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.isEmpty()) &#123;</span><br><span class="line">                s.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pa.equals(<span class="string">"/"</span>) || pa.equals(<span class="string">"."</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pa.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s.add(pa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">        sb.append(<span class="string">"/"</span>).append(s.pollFirst());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sb.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        sb.append(<span class="string">"/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="232-Implement-Queue-using-Stacks🎂✨"><a href="#232-Implement-Queue-using-Stacks🎂✨" class="headerlink" title="232. Implement Queue using Stacks🎂✨"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/" target="_blank" rel="noopener">232. Implement Queue using Stacks🎂✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A good question to ask the interviewer is: *what operation needs to be faster in the stack implementation?</span><br></pre></td></tr></table></figure>

<p>栈的顺序为后进先出，而队列的顺序为先进先出。</p>
<p>使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。</p>
<p><img src="https://assets.leetcode.com/static_assets/media/original_images/232_queue_using_stacksBPush.png" alt=""></p>
<h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：栈是先入后出，所以只要借助另一个栈就能达到先进先出。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.isEmpty())</span><br><span class="line">            front = x;</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty())</span><br><span class="line">            s2.push(s1.pop());</span><br><span class="line">        s2.push(x);</span><br><span class="line">        <span class="keyword">while</span> (!s2.isEmpty())</span><br><span class="line">            s1.push(s2.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = s1.pop();</span><br><span class="line">        <span class="keyword">if</span> (!s1.isEmpty())</span><br><span class="line">            front = s1.peek();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="225-Implement-Stack-using-Queues🎂"><a href="#225-Implement-Stack-using-Queues🎂" class="headerlink" title="225. Implement Stack using Queues🎂"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/description/" target="_blank" rel="noopener">225. Implement Stack using Queues🎂</a></h2><p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。</p>
<p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) – Push element x onto stack. </li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element. </li>
<li>empty() – Return whether the stack is empty.</li>
</ul>
<p>Notes:</p>
<ul>
<li>You must use only standard operations of a queue – which means only <strong><code>push to back</code></strong>, <strong><code>peek/pop from front</code></strong>, <strong><code>size</code></strong>, and <strong><code>is empty</code></strong> operations are valid. </li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. </li>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
</ul>
<h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：为了先进后出，每次添加新元素后都反转前面所有元素，即逐个重新入栈。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queue.size() - <span class="number">1</span>; i++) &#123;  <span class="comment">//rotating the order of the elements before last element in the deque</span></span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Two Queues</p>
</li>
<li><p>Two Queues, push - O(1)<em>O</em>(1), pop O(n)<em>O</em>(<em>n</em>)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Queue&lt;Integer&gt; q2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push element x onto stack.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    q1.add(x);</span><br><span class="line">    top = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes the element on top of the stack.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (q1.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        top = q1.remove();</span><br><span class="line">        q2.add(top);</span><br><span class="line">    &#125;</span><br><span class="line">    q1.remove();</span><br><span class="line">    Queue&lt;Integer&gt; temp = q1;</span><br><span class="line">    q1 = q2;</span><br><span class="line">    q2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Two Queues, push - O(n)<em>O</em>(<em>n</em>), pop O(1)<em>O</em>(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    q2.add(x);</span><br><span class="line">    top = x;</span><br><span class="line">    <span class="keyword">while</span> (!q1.isEmpty()) &#123;                </span><br><span class="line">        q2.add(q1.remove());</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Integer&gt; temp = q1;</span><br><span class="line">    q1 = q2;</span><br><span class="line">    q2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕901-Online-Stock-Span✨"><a href="#🌕901-Online-Stock-Span✨" class="headerlink" title="🌕901. Online Stock Span✨"></a><a href="https://leetcode.com/problems/online-stock-span/" target="_blank" rel="noopener">🌕901. Online Stock Span✨</a></h2><p>Explanation</p>
<p>You can refer to the same problem 739. Daily Temperatures.Push every pair of <code>&lt;price, result&gt;</code> to a stack.<br>Pop lower price from the stack and accumulate the count. One price will be pushed once and popped once.<br>So <code>2 * N</code> times stack operations and <code>N</code> times calls. I’ll say time complexity is amortized <code>O(1)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        We should have a stack of a pair of (current  price, maximum number of consecutive days)</span></span><br><span class="line"><span class="comment">        Since we don't have an access to the indicies.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Stack&lt;<span class="keyword">int</span>[]&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StockSpanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   Let's trace the algorithm together on [100, 80, 60, 70, 60, 75, 85]</span></span><br><span class="line"><span class="comment">   1. calling StockSpanner.next(100) should result in first element in our stack will be (100, 1) (s.size() == 1)</span></span><br><span class="line"><span class="comment">   2. calling StockSpanner.next(80) should result in second element in our stack will be (80, 1) (s.size() == 2)</span></span><br><span class="line"><span class="comment">   3. calling StockSpanner.next(60) should result in third element in our stack will be (60, 1) (s.size() == 3)</span></span><br><span class="line"><span class="comment">   4. Now on calling StockSpanner.next(70) we should add span of (60) + 1 &#123;the current day&#125;</span></span><br><span class="line"><span class="comment">   and remove it from stack (70, 2) (s.size() == 3)</span></span><br><span class="line"><span class="comment">   5. Now on calling StockSpanner.next(60) result in fourth element in our stack will be (60, 1) (s.size() == 4)</span></span><br><span class="line"><span class="comment">   6. Now on calling StockSpanner.next(75) we should add span of (60) and (70) + 1 &#123;the current day&#125;</span></span><br><span class="line"><span class="comment">   and remove it from stack : (75, 4) (s.size() == 3)</span></span><br><span class="line"><span class="comment">   7. Now on calling StockSpanner.next(85) we should add span of (75) and (80) + 1 &#123;the current day&#125;</span></span><br><span class="line"><span class="comment">   and remove it from stack : (85, 6) (s.size() == 2)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> span = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; price &gt;= s.peek()[<span class="number">0</span>]) &#123; <span class="comment">// If the current price is greater than stack peek.</span></span><br><span class="line">            span += s.peek()[<span class="number">1</span>];</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;price, span&#125;);</span><br><span class="line">        <span class="keyword">return</span> span;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="739-Daily-Temperatures✨🎶"><a href="#739-Daily-Temperatures✨🎶" class="headerlink" title="739. Daily Temperatures✨🎶"></a><a href="https://leetcode.com/problems/daily-temperatures/description/" target="_blank" rel="noopener">739. Daily Temperatures✨🎶</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">71</span>, <span class="number">69</span>, <span class="number">72</span>, <span class="number">76</span>, <span class="number">73</span>]</span><br><span class="line">Output: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">return</span> the next greater num index</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>在遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = T.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> curIdx = <span class="number">0</span>; curIdx &lt; n; ++curIdx) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[curIdx] &gt; T[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> preIdx = stack.pop();</span><br><span class="line">            res[preIdx] = curIdx - preIdx;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.add(curIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="503-Next-Greater-Element-II✨"><a href="#503-Next-Greater-Element-II✨" class="headerlink" title="503. Next Greater Element II✨"></a><a href="https://leetcode.com/problems/next-greater-element-ii/description/" target="_blank" rel="noopener">503. Next Greater Element II✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: [<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Explanation: The first <span class="number">1</span> next greater number is <span class="number">2</span>;</span><br><span class="line">The number <span class="number">2</span> can not find next greater number;</span><br><span class="line">The second <span class="number">1</span> next greater number needs to search circularly, which is also <span class="number">2</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Explanation</p>
<p>Loop once, we can get the Next Greater Number of a normal array.</p>
<p>Loop twice, we can get the Next Greater Number of a circular array</p>
<p>Complexity</p>
<p>Time <code>O(N)</code> for one pass<br>Spce <code>O(N)</code> in worst case</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区别于next greater element I, 有重复元素所以index入栈，而不是用哈希表记录对应元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length, res[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; A[stack.peek()] &lt; A[i % n])</span><br><span class="line">            res[stack.pop()] = A[i % n];</span><br><span class="line">        stack.push(i % n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="496-Next-Greater-Element-I✨"><a href="#496-Next-Greater-Element-I✨" class="headerlink" title="496. Next Greater Element I✨"></a><a href="https://leetcode.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. Next Greater Element I✨</a></h3><h3 id="Solution0"><a href="#Solution0" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute Force</li>
<li>Time complexity : O(mn). The complete nums<em>nums array(of size n*n</em>) needs to be scanned for all the m<em>m</em> elements of findNums<em>findNums</em> in the worst case.</li>
<li>Space complexity : O(m). res array of size m<em>m</em> is used, where m<em>m</em> is the length of findNums array.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] findNums, <span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[findNums.length];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; findNums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (found &amp;&amp; nums[j] &gt; findNums[i]) &#123;</span><br><span class="line">                res[i] = nums[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == findNums[i]) &#123;</span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == nums.length) &#123;</span><br><span class="line">            res[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Using Stack</li>
<li>Suppose we have a decreasing sequence followed by a greater number<br>For example <code>[5, 4, 3, 2, 1, 6]</code> then the greater number <code>6</code> is the next greater element for all previous numbers in the sequence</li>
<li>We use a stack to keep a <strong>decreasing</strong> sub-sequence, whenever we see a number <code>x</code> greater than <code>stack.peek()</code> we pop all elements less than <code>x</code> and for all the popped ones, their next greater element is <code>x</code><br>For example <code>[9, 8, 7, 3, 2, 1, 6]</code><br>The stack will first contain <code>[9, 8, 7, 3, 2, 1]</code> and then we see <code>6</code> which is greater than <code>1</code> so we pop <code>1 2 3</code> whose next greater element should be <code>6</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] findNums, <span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[findNums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; nums[i] &gt; stack.peek())</span><br><span class="line">            map.put(stack.pop(), nums[i]);</span><br><span class="line">        stack.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty())</span><br><span class="line">        map.put(stack.pop(), -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; findNums.length; i++) &#123;</span><br><span class="line">        res[i] = map.get(findNums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1019-Next-Greater-Node-In-Linked-List✨"><a href="#1019-Next-Greater-Node-In-Linked-List✨" class="headerlink" title="1019. Next Greater Node In Linked List✨"></a><a href="https://leetcode.com/problems/next-greater-node-in-linked-list/" target="_blank" rel="noopener">1019. Next Greater Node In Linked List✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">Output: [<span class="number">5</span>,<span class="number">5</span>,<span class="number">0</span>]</span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">Output: [<span class="number">7</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>O(N) Time, O(N) Space</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nums.add(cur.val);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()];</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums.get(stack.peek()) &lt; nums.get(i)) &#123;</span><br><span class="line">            ans[stack.pop()] = nums.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="150-Evaluate-Reverse-Polish-Notation✨"><a href="#150-Evaluate-Reverse-Polish-Notation✨" class="headerlink" title="150. Evaluate Reverse Polish Notation✨"></a><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. Evaluate Reverse Polish Notation✨</a></h2><h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>思路：无须考虑括号，典型栈操作即可完成，如果碰到数字就入栈，碰到操作符就出栈两个并进行相应操作后 再入栈，最后弹出栈中结果。</p>
</li>
<li><p>Java valueOf() 方法</p>
</li>
<li><p>valueOf() 方法用于返回给定参数的原生 Number 对象值，参数可以是原生数据类型, String等。</p>
<p>该方法是静态方法。该方法可以接收两个参数一个是字符串，一个是基数。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    Integer x = Integer.valueOf(<span class="number">9</span>);</span><br><span class="line">    Double c = Double.valueOf(<span class="number">5</span>);</span><br><span class="line">    Float a = Float.valueOf(<span class="string">"80"</span>);              </span><br><span class="line">    Integer b = Integer.valueOf(<span class="string">"444"</span>,<span class="number">16</span>);   <span class="comment">// 使用 16 进制</span></span><br><span class="line"></span><br><span class="line">    System.out.println(x);  <span class="comment">//9</span></span><br><span class="line">    System.out.println(c);  <span class="comment">//5.0</span></span><br><span class="line">    System.out.println(a);  <span class="comment">//80.0</span></span><br><span class="line">    System.out.println(b);  <span class="comment">//1092</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span> (String t : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"+"</span>.equals(t))</span><br><span class="line">            s.push(s.pop() + s.pop());</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"-"</span>.equals(t))</span><br><span class="line">            s.push(<span class="number">0</span> - (s.pop() - s.pop()));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"*"</span>.equals(t))</span><br><span class="line">            s.push(s.pop() * s.pop());</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"/"</span>.equals(t)) &#123;</span><br><span class="line">            a = s.pop();</span><br><span class="line">            b = s.pop();</span><br><span class="line">            s.push(b / a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.push(Integer.valueOf(t));  <span class="comment">//String -&gt; int</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕946-Validate-Stack-Sequences💎"><a href="#🌕946-Validate-Stack-Sequences💎" class="headerlink" title="🌕946. Validate Stack Sequences💎"></a><a href="https://leetcode.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">🌕946. Validate Stack Sequences💎</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="keyword">true</span></span><br><span class="line">Explanation: We might <span class="keyword">do</span> the following sequence:</span><br><span class="line">push(<span class="number">1</span>), push(<span class="number">2</span>), push(<span class="number">3</span>), push(<span class="number">4</span>), pop() -&gt; <span class="number">4</span>,</span><br><span class="line">push(<span class="number">5</span>), pop() -&gt; <span class="number">5</span>, pop() -&gt; <span class="number">3</span>, pop() -&gt; <span class="number">2</span>, pop() -&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Simulating</li>
<li>Initialize am empty <code>stack</code>,<br>iterate and push elements from <code>pushed</code> one by one.<br>Each time, we’ll try to pop the elements from as many as possibile <code>popped</code>.<br>In the end, we we’ll check if <code>stack</code> is empty.</li>
<li>Time <code>O(N)</code><br>Space <code>O(N)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : pushed) &#123;</span><br><span class="line">        stack.push(num);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popped[idx]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-678-Valid-Parenthesis-String✨"><a href="#🌕Unsolved-678-Valid-Parenthesis-String✨" class="headerlink" title="🌕Unsolved 678. Valid Parenthesis String✨"></a><a href="https://leetcode.com/problems/valid-parenthesis-string/" target="_blank" rel="noopener">🌕Unsolved 678. Valid Parenthesis String✨</a></h2><h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><p><strong>Problem 1: Check Valid Parenthesis of a string containing only two types of characters: ‘(‘, ‘)’</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> openCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                openCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                openCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (openCount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;    <span class="comment">// Currently, don't have enough open parentheses to match close parentheses-&gt; Invalid</span></span><br><span class="line">            <span class="comment">// For example: ())(</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> openCount == <span class="number">0</span>; <span class="comment">// Fully match open parentheses with close parentheses</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Problem 2: Check Valid Parenthesis of a string containing only three types of characters: ‘(‘, ‘)’, ‘*‘</strong><br>Example:</p>
<p><img src="https://assets.leetcode.com/users/hiepit/image_1587291349.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cmin = <span class="number">0</span>, cmax = <span class="number">0</span>; <span class="comment">// open parentheses count in range [cmin, cmax]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                cmax++;</span><br><span class="line">                cmin++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                cmax--;</span><br><span class="line">                cmin--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'*'</span>) &#123;</span><br><span class="line">                cmax++; <span class="comment">// if `*` become `(` then openCount++</span></span><br><span class="line">                cmin--; <span class="comment">// if `*` become `)` then openCount--</span></span><br><span class="line">                <span class="comment">// if `*` become `` then nothing happens</span></span><br><span class="line">                <span class="comment">// So openCount will be in new range [cmin-1, cmax+1]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cmax &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// Currently, don't have enough open parentheses to match close parentheses-&gt; Invalid</span></span><br><span class="line">            <span class="comment">// For example: ())(</span></span><br><span class="line">            cmin = Math.max(cmin, <span class="number">0</span>);   <span class="comment">// It's invalid if open parentheses count &lt; 0 that's why cmin can't be negative</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cmin == <span class="number">0</span>; <span class="comment">// Return true if can found `openCount == 0` in range [cmin, cmax]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-856-Score-of-Parentheses✨"><a href="#🌕Unsolved-856-Score-of-Parentheses✨" class="headerlink" title="🌕Unsolved 856. Score of Parentheses✨"></a><a href="https://leetcode.com/problems/score-of-parentheses/" target="_blank" rel="noopener">🌕Unsolved 856. Score of Parentheses✨</a></h2><h3 id="Solution1-19"><a href="#Solution1-19" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><code>cur</code> record the score at the current layer level.</li>
<li>If we meet <code>&#39;(&#39;</code>,<br>we push the current score to <code>stack</code>,<br>enter the next inner layer level,<br>and reset <code>cur = 0</code>.</li>
<li>If we meet <code>&#39;)&#39;</code>,<br>the <code>cur</code> score will be doubled and will be at least 1.<br>We exit the current layer level,<br>and set <code>cur = stack.pop() + cur</code></li>
<li>Complexity: <code>O(N)</code> time and <code>O(N)</code> space</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack.pop() + Math.max(<span class="number">1</span>, <span class="number">2</span> * cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="🌕Unsolved-385-Mini-Parser💎"><a href="#🌕Unsolved-385-Mini-Parser💎" class="headerlink" title="🌕Unsolved 385.Mini Parser💎"></a><a href="https://leetcode.com/problems/mini-parser/" target="_blank" rel="noopener">🌕Unsolved 385.Mini Parser💎</a></h2><h3 id="Solution1-20"><a href="#Solution1-20" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：典型压栈题，每一级元素放在同一 List 中。递归实现，只有是根级括号（open == 1）才具体计算，否则 压栈把子串进行相同的运算并作为当前数组的一个值（子序列）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NestedInteger <span class="title">deserialize</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s.startsWith(<span class="string">"["</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NestedInteger(Integer.valueOf(s));</span><br><span class="line">    NestedInteger ni = <span class="keyword">new</span> NestedInteger();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> open = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (open == <span class="number">1</span> &amp;&amp; (Character.isDigit(c) || c == <span class="string">'-'</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">'-'</span>)</span><br><span class="line">                num = c - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">                num = -num;</span><br><span class="line">            ni.add(<span class="keyword">new</span> NestedInteger(num));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'['</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (open == <span class="number">1</span>)</span><br><span class="line">                start = i - <span class="number">1</span>;</span><br><span class="line">            open++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">']'</span>) &#123;</span><br><span class="line">            open--;</span><br><span class="line">            <span class="keyword">if</span> (open == <span class="number">1</span>)</span><br><span class="line">                ni.add(deserialize(s.substring(start, i)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ni;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>This approach will just iterate through every char in the string (no recursion).<ul>
<li>If encounters ‘[‘, push current NestedInteger to stack and start a new one.</li>
<li>If encounters ‘]’, end current NestedInteger and pop a NestedInteger from stack to continue.</li>
<li>If encounters ‘,’, append a new number to curr NestedInteger, if this comma is not right after a brackets.</li>
<li>Update index l and r, where l shall point to the start of a integer substring, while r shall points to the end+1 of substring.</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NestedInteger <span class="title">deserialize</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) != <span class="string">'['</span>) <span class="comment">// ERROR: special case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NestedInteger(Integer.valueOf(s));</span><br><span class="line"></span><br><span class="line">    Stack&lt;NestedInteger&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    NestedInteger curr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>; <span class="comment">// l shall point to the start of a number substring; </span></span><br><span class="line">    <span class="comment">// r shall point to the end+1 of a number substring</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; s.length(); r++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = s.charAt(r);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'['</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">            &#125;</span><br><span class="line">            curr = <span class="keyword">new</span> NestedInteger();</span><br><span class="line">            l = r+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">']'</span>) &#123;</span><br><span class="line">            String num = s.substring(l, r);</span><br><span class="line">            <span class="keyword">if</span> (!num.isEmpty())</span><br><span class="line">                curr.add(<span class="keyword">new</span> NestedInteger(Integer.valueOf(num)));</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                NestedInteger pop = stack.pop();</span><br><span class="line">                pop.add(curr);</span><br><span class="line">                curr = pop;</span><br><span class="line">            &#125;</span><br><span class="line">            l = r+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">','</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(r-<span class="number">1</span>) != <span class="string">']'</span>) &#123;</span><br><span class="line">                String num = s.substring(l, r);</span><br><span class="line">                curr.add(<span class="keyword">new</span> NestedInteger(Integer.valueOf(num)));</span><br><span class="line">            &#125;</span><br><span class="line">            l = r+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1047-Remove-All-Adjacent-Duplicates-In-String✨"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String✨" class="headerlink" title="1047. Remove All Adjacent Duplicates In String✨"></a><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noopener">1047. Remove All Adjacent Duplicates In String✨</a></h2><h3 id="Solution1-21"><a href="#Solution1-21" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == c) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : stack) &#123;</span><br><span class="line">        sb.append(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringBuilder as stack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = sb.length();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; sb.charAt(size - <span class="number">1</span>) == c) &#123;</span><br><span class="line">            sb.deleteCharAt(size - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p><code>i</code> refers to the index to set next character in the output string.<br><code>j</code> refers to the index of current iteration in the input string.</p>
<p>Iterate characters of <code>S</code> one by one by increasing <code>j</code>.</p>
<p>If <code>S[j]</code> is same as the current last character <code>S[i - 1]</code>,<br>we remove duplicates by doing <code>i -= 2</code>.</p>
<p>If <code>S[j]</code> is different as the current last character <code>S[i - 1]</code>,<br>we set <code>S[i] = S[j]</code> and increment <code>i++</code>.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, n = s.length();</span><br><span class="line">    <span class="keyword">char</span>[] res = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j, ++i) &#123;</span><br><span class="line">        res[i] = res[j];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; res[i - <span class="number">1</span>] == res[i]) <span class="comment">// count = 2</span></span><br><span class="line">            i -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(res, <span class="number">0</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-1209-Remove-All-Adjacent-Duplicates-in-String-II✨"><a href="#🌕Unsolved-1209-Remove-All-Adjacent-Duplicates-in-String-II✨" class="headerlink" title="🌕Unsolved 1209. Remove All Adjacent Duplicates in String II✨"></a><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/" target="_blank" rel="noopener">🌕Unsolved 1209. Remove All Adjacent Duplicates in String II✨</a></h2><p><img src="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/Figures/1209/1209_approach1.png" alt=""></p>
<h3 id="Solution1-22"><a href="#Solution1-22" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Stack with Reconstruction</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">int</span> times;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            ch = c;</span><br><span class="line">            times = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; k) <span class="keyword">return</span> s;</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || c != stack.peek().ch) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> Node(c));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//same character with stack.peek(), increase node.times</span></span><br><span class="line">                <span class="keyword">int</span> times = stack.peek().times;</span><br><span class="line">                <span class="keyword">if</span> (times + <span class="number">1</span> == k) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.peek().times++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Node node : stack) &#123;</span><br><span class="line">            <span class="keyword">int</span> times = node.times;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">                sb.append(node.ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Stack</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">    Stack&lt;Integer&gt; counts = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sb.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || sb.charAt(i) != sb.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">            counts.push(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> incremented = counts.pop() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (incremented == k) &#123;</span><br><span class="line">                sb.delete(i - k + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">                i = i - k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.push(incremented);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3:"></a>Solution3:</h3><ol>
<li>Brute Force</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">    <span class="keyword">int</span> length = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (length != sb.length()) &#123;</span><br><span class="line">        length = sb.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = <span class="number">1</span>; i &lt; sb.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || sb.charAt(i) != sb.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (++count == k) &#123;</span><br><span class="line">                sb.delete(i - k + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-224-Basic-Calculator🎂✨"><a href="#🌕Unsolved-224-Basic-Calculator🎂✨" class="headerlink" title="🌕Unsolved 224. Basic Calculator🎂✨"></a><a href="https://leetcode.com/problems/basic-calculator/?utm_source=AlgoTogether&utm_campaign=44f863357f-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_1&utm_medium=email&utm_term=0_38d4e2e3e2-44f863357f-231340480" target="_blank" rel="noopener">🌕Unsolved 224. Basic Calculator🎂✨</a></h2><h3 id="Solution1："><a href="#Solution1：" class="headerlink" title="Solution1："></a>Solution1：</h3><p><a href="https://leetcode.com/problems/basic-calculator-iii/discuss/113592/Development-of-a-generic-solution-for-the-series-of-the-calculator-problems" target="_blank" rel="noopener">Explanation</a></p>
<ol>
<li>思路：只有加减法，所以括号里面部分可以当加数处理和符号相乘。碰到括号时压栈（包括符号和当前数值， 并重置 Result 和符号），反括号出栈，第一个是符号，第二个是压栈前的结果，符号乘当时 Result+压栈前结 果就是当前结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length(), sign = <span class="number">1</span>, result = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; len &amp;&amp; Character.isDigit(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                sum = sum * <span class="number">10</span> + s.charAt(i + <span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            result += sum * sign;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span>)</span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'-'</span>)</span><br><span class="line">            sign = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="comment">//we push the result first, then sign;</span></span><br><span class="line">            stack.push(result);</span><br><span class="line">            stack.push(sign);</span><br><span class="line">            <span class="comment">//reset the sign and result for the value in the parenthesis</span></span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;  <span class="comment">//stack.pop() is the sign before the parenthesis and next stack.pop() is the result calculated before the parenthesis</span></span><br><span class="line">            result = result * stack.pop() + stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-227-Basic-Calculator-II✨"><a href="#🌕Unsolved-227-Basic-Calculator-II✨" class="headerlink" title="🌕Unsolved 227. Basic Calculator II✨"></a><a href="https://leetcode.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">🌕Unsolved 227. Basic Calculator II✨</a></h2><h3 id="Solution1-23"><a href="#Solution1-23" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Scan the input string <code>s</code> from left to right and evaluate the expressions based on the following rules</p>
<ol>
<li>If the current character is a digit <code>0-9</code> ( operand ), add it to the number <code>currentNumber</code>.</li>
<li>Otherwise, the current character must be an operation <code>(+,-,*, /)</code>. Evaluate the expression based on the type of operation.</li>
</ol>
<ul>
<li>Addition <code>(+)</code> or Subtraction <code>(-)</code>: We must evaluate the expression later based on the next operation. So, we must store the <code>currentNumber</code> to be used later. Let’s push the currentNumber in the Stack.</li>
<li>Multiplication <code>(*)</code> or Division <code>(/)</code>: Pop the top values from the stack and evaluate the current expression. Push the evaluated value back to the stack.</li>
</ul>
<p>Once the string is scanned, pop from the stack and add to the <code>result</code>.</p>
</li>
<li><p>Time Complexity: \mathcal{O}(n)O(<em>n</em>), where n<em>n</em> is the length of the string s<em>s</em>. We iterate over the string s<em>s</em> at most twice.</p>
</li>
<li><p>Space Complexity: \mathcal{O}(n)O(<em>n</em>), where n<em>n</em> is the length of the string s<em>s</em>.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> operation = <span class="string">'+'</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">            cur = cur * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!Character.isDigit(c) &amp;&amp; c != <span class="string">' '</span> || i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operation == <span class="string">'+'</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="string">'-'</span>) &#123;</span><br><span class="line">                stack.push(-cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="string">'*'</span>) &#123;</span><br><span class="line">                stack.push(stack.pop() * cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="string">'/'</span>) &#123;</span><br><span class="line">                stack.push(stack.pop() / cur);</span><br><span class="line">            &#125;</span><br><span class="line">            operation = c;</span><br><span class="line">            cur = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : stack) &#123;</span><br><span class="line">        ans += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕1249-Minimum-Remove-to-Make-Valid-Parentheses✨🎶"><a href="#🌕1249-Minimum-Remove-to-Make-Valid-Parentheses✨🎶" class="headerlink" title="🌕1249. Minimum Remove to Make Valid Parentheses✨🎶"></a><a href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/" target="_blank" rel="noopener">🌕1249. Minimum Remove to Make Valid Parentheses✨🎶</a></h2><h3 id="Solution1-24"><a href="#Solution1-24" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>To make the string valid with minimum removals, we need to get rid of all parentheses that do not have a matching pair.</p>
<p>Push char index into the stack when we see <code>&#39;(&#39;</code>.</p>
<p>Pop from the stack when we see <code>&#39;)&#39;</code>.</p>
<p>​    If the stack is empty, then we have <code>&#39;)&#39;</code> without the pair, and it needs to be removed.</p>
<p>In the end, the stack will contain indexes of <code>&#39;(&#39;</code> without the pair, if any. We need to remove all of them too.</p>
</li>
<li><p>Time: O(n). We process each character once, or twice for ‘single’ <code>&#39;(&#39;</code>.</p>
</li>
<li><p>Memory: O(n) for the stack.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minRemoveToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.setCharAt(i, <span class="string">'#'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx : stack) &#123;</span><br><span class="line">        sb.setCharAt(idx, <span class="string">'#'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString().replaceAll(<span class="string">"#"</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-726-Number-of-Atoms🎂✨🎶"><a href="#🌕Unsolved-726-Number-of-Atoms🎂✨🎶" class="headerlink" title="🌕Unsolved 726. Number of Atoms🎂✨🎶"></a><a href="https://leetcode.com/problems/number-of-atoms/" target="_blank" rel="noopener">🌕Unsolved 726. Number of Atoms🎂✨🎶</a></h2><h3 id="Solution1-25"><a href="#Solution1-25" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Java Solution using Stack and Map</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countOfAtoms</span><span class="params">(String formula)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Map&lt;String,Integer&gt;&gt; stack= <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Map&lt;String,Integer&gt; map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, n = formula.length();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = formula.charAt(i);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'('</span>)&#123;</span><br><span class="line">            stack.push(map);</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; Character.isDigit(formula.charAt(i)))</span><br><span class="line">                val = val * <span class="number">10</span> + formula.charAt(i++) - <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(val == <span class="number">0</span>) val = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                Map&lt;String,Integer&gt; temp = map;</span><br><span class="line">                map = stack.pop();</span><br><span class="line">                <span class="keyword">for</span>(String key: temp.keySet())</span><br><span class="line">                    map.put(key,map.getOrDefault(key,<span class="number">0</span>) + temp.get(key)*val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> start=i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n &amp;&amp; Character.isLowerCase(formula.charAt(i)))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            String s= formula.substring(start,i);</span><br><span class="line">            <span class="keyword">int</span> val=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n &amp;&amp; Character.isDigit(formula.charAt(i))) val=val*<span class="number">10</span>+ formula.charAt(i++)-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(val==<span class="number">0</span>) val=<span class="number">1</span>;</span><br><span class="line">            map.put(s,map.getOrDefault(s,<span class="number">0</span>)+val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb= <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    List&lt;String&gt; list= <span class="keyword">new</span> ArrayList&lt;&gt;(map.keySet());</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    <span class="keyword">for</span>(String key: list)&#123; </span><br><span class="line">        sb.append(key);</span><br><span class="line">        <span class="keyword">if</span>(map.get(key)&gt;<span class="number">1</span>) sb.append(map.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-316-Remove-Duplicate-Letters🎂✨"><a href="#🌕Unsolved-316-Remove-Duplicate-Letters🎂✨" class="headerlink" title="🌕Unsolved 316. Remove Duplicate Letters🎂✨"></a><a href="https://leetcode.com/problems/remove-duplicate-letters/?utm_source=AlgoTogether&utm_campaign=05bc9f4051-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_4&utm_medium=email&utm_term=0_38d4e2e3e2-05bc9f4051-231340480" target="_blank" rel="noopener">🌕Unsolved 316. Remove Duplicate Letters🎂✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; lastIdx = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;Character&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        lastIdx.put(c, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!seen.contains(c)) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; c &lt; stack.peek() &amp;&amp; i &lt; lastIdx.get(stack.peek())) &#123;</span><br><span class="line">                <span class="keyword">char</span> temp = stack.pop();</span><br><span class="line">                seen.remove(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(c);</span><br><span class="line">            seen.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : stack) sb.append(c + <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="239-Sliding-Window-Maximum⭐"><a href="#239-Sliding-Window-Maximum⭐" class="headerlink" title="239. Sliding Window Maximum⭐"></a><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. Sliding Window Maximum⭐</a></h2><h3 id="Solution0-1"><a href="#Solution0-1" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li><p>Bruteforce(TLE)</p>
</li>
<li><p>The straightforward solution is to iterate over all sliding windows and find a maximum for each window. There are <code>N - k + 1</code> sliding windows and there are <code>k</code> elements in each window, that results in a quite bad time complexity O(Nk).</p>
<p>As you can imagine, this straightforward solution would result in <strong>TLE</strong> (Time Limit Exceed) exception.</p>
</li>
<li><p>Time complexity : O(Nk), where <code>N</code> is number of elements in the array.</p>
</li>
<li><p>Space complexity : O(N−k+1) for an output array.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> ||  k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> [] output = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; i + k; j++) </span><br><span class="line">            max = Math.max(max, nums[j]);</span><br><span class="line">        output[i] = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><p>An alternative approach to this problem is to use <a href="https://www.educative.io/edpresso/what-is-a-heap" target="_blank" rel="noopener">heaps</a> for searching the maximum in every window. In that case, the time complexity will rise to O(n \space log(w))<em>O</em>(<em>n</em> <em>l<strong>o</strong>g</em>(<em>w</em>)).</p>
<h3 id="Solution3-1"><a href="#Solution3-1" class="headerlink" title="Solution3:"></a>Solution3:</h3><p>我们来比较一下<code>Queue</code>和<code>Deque</code>出队和入队的方法：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Queue</th>
<th align="left">Deque</th>
</tr>
</thead>
<tbody><tr>
<td align="left">添加元素到队尾</td>
<td align="left">add(E e) / offer(E e)</td>
<td align="left">addLast(E e) / offerLast(E e)</td>
</tr>
<tr>
<td align="left">取队首元素并删除</td>
<td align="left">E remove() / E poll()</td>
<td align="left">E removeFirst() / E pollFirst()</td>
</tr>
<tr>
<td align="left">取队首元素但不删除</td>
<td align="left">E element() / E peek()</td>
<td align="left">E getFirst() / E peekFirst()</td>
</tr>
<tr>
<td align="left">添加元素到队首</td>
<td align="left">无</td>
<td align="left">addFirst(E e) / offerFirst(E e)</td>
</tr>
<tr>
<td align="left">取队尾元素并删除</td>
<td align="left">无</td>
<td align="left">E removeLast() / E pollLast()</td>
</tr>
<tr>
<td align="left">取队尾元素但不删除</td>
<td align="left">无</td>
<td align="left">E getLast() / E peekLast()</td>
</tr>
</tbody></table>
<ol>
<li>explaining the deque method (approach 2): <strong>You want to ensure the deque window only has decreasing elements. That way, the leftmost element is always the largest.</strong></li>
<li>takes O(n) time and O(k) space</li>
</ol>
<p>Using Monotonic Deque:</p>
<ol>
<li>Process the first <code>k</code> elements separately to initiate the deque.</li>
<li>Iterate over the array. At each step :<ul>
<li>Clean the deque :<ul>
<li>Keep only the indexes of elements from the current sliding window.</li>
<li>Remove indexes of all elements smaller than the current one, since they will not be the maximum ones.</li>
</ul>
</li>
<li>Append the current element to the deque.</li>
<li>Append <code>deque[0]</code> to the output.</li>
</ul>
</li>
<li>Return the output array.</li>
</ol>
<p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2018/01/239-ep159-2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/hot13399/leetcode-graphic-answer/master/239.%20Sliding%20Window%20Maximum.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//pay attention to the size</span></span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>; end &lt; nums.length; end++) &#123;</span><br><span class="line">        <span class="comment">// remove numbers out of range k</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[end]) &#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove smaller numbers in k range as they are useless</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekFirst()] &lt;= end - k) &#123;</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// store index</span></span><br><span class="line">        deque.add(end);</span><br><span class="line">        <span class="keyword">if</span> (end &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            ans[idx++] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="346-Moving-Average-from-Data-Stream⭐"><a href="#346-Moving-Average-from-Data-Stream⭐" class="headerlink" title="346. Moving Average from Data Stream⭐"></a><a href="https://leetcode.com/problems/moving-average-from-data-stream" target="_blank" rel="noopener">346. Moving Average from Data Stream⭐</a></h2><p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. </p>
<p>For example,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MovingAverage m = <span class="keyword">new</span> MovingAverage(<span class="number">3</span>);</span><br><span class="line">m.next(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">m.next(<span class="number">10</span>) = (<span class="number">1</span> + <span class="number">10</span>) / <span class="number">2</span></span><br><span class="line">m.next(<span class="number">3</span>) = (<span class="number">1</span> + <span class="number">10</span> + <span class="number">3</span>) / <span class="number">3</span></span><br><span class="line">m.next(<span class="number">5</span>) = (<span class="number">10</span> + <span class="number">3</span> + <span class="number">5</span>) / <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-26"><a href="#Solution1-26" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：维护一个和值，每次出入元素时减或加该元素值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> sum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovingAverage</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        maxSize = size;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.size() == maxSize) &#123;</span><br><span class="line">            sum -= queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        sum += val;</span><br><span class="line">        queue.add(val);</span><br><span class="line">        <span class="keyword">return</span> sum / queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕1673-Find-the-Most-Competitive-Subsequence💎"><a href="#🌕1673-Find-the-Most-Competitive-Subsequence💎" class="headerlink" title="🌕1673. Find the Most Competitive Subsequence💎"></a><a href="https://leetcode.com/problems/find-the-most-competitive-subsequence/" target="_blank" rel="noopener">🌕1673. Find the Most Competitive Subsequence💎</a></h2><p><a href="https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/952786/JavaC%2B%2BPython-One-Pass-Stack-Solution" target="_blank" rel="noopener">https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/952786/JavaC%2B%2BPython-One-Pass-Stack-Solution</a></p>
<p>More Good Stack Problems</p>
<p>Here are some problems that impressed me.<br>Good luck and have fun.</p>
<ul>
<li><ol>
<li><a href="https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/952786/javacpython-one-pass-stack-solution/776191" target="_blank" rel="noopener">Find the Most Competitive Subsequence</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque" target="_blank" rel="noopener">Constrained Subsequence Sum</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space" target="_blank" rel="noopener">Minimum Cost Tree From Leaf Values</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution" target="_blank" rel="noopener">Sum of Subarray Minimums</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1)" target="_blank" rel="noopener">Online Stock Span</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space" target="_blank" rel="noopener">Score of Parentheses</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice" target="_blank" rel="noopener">Next Greater Element II</a></li>
</ol>
</li>
<li><ol>
<li>Next Greater Element I</li>
</ol>
</li>
<li><ol>
<li>Largest Rectangle in Histogram</li>
</ol>
</li>
<li><ol>
<li>Trapping Rain Water</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,5,2,6], k &#x3D; 2</span><br><span class="line">Output: [2,6]</span><br><span class="line">Explanation: Among the set of every possible subsequence: &#123;[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]&#125;, [2,6] is the most competitive.</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [2,4,3,3,5,4,9,6], k &#x3D; 4</span><br><span class="line">Output: [2,3,3,4]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-27"><a href="#Solution1-27" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Monotonic Deque</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mostCompetitive(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> remain = nums.length - k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; queue.peekLast() &gt; nums[i] &amp;&amp; remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            queue.pollLast();</span><br><span class="line">            remain--;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        res[i] = queue.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Use a mono incrasing stack.Keep a mono incrasing stackas result.<br>If current element <code>a</code> is smaller then the last element in the stack, we can replace it to get a smaller sequence.</p>
<p>Before we do this, we need to check if we still have enough elements after.<br>After we pop the last element from <code>stack</code>, we have <code>stack.size() - 1</code> in the stack, there are <code>A.size() - i</code> can still be pushed.<br>if <code>stack.size() - 1 + A.size() - i &gt;= k</code>, we can pop the stack.</p>
<p>Then, is the stack not full with <code>k</code> element, we push <code>A[i]</code> into the stack.</p>
<p>Finally we return <code>stack</code> as the result directly.</p>
<p>Complexity: Time <code>O(n)</code> Space <code>O(k)</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mostCompetitive(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; nums[i] &lt; nums[stack.peek()] &amp;&amp; nums.length - i + stack.size() &gt; k) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.size() &lt; k) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        result[i] = nums[stack.pop()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Use array</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mostCompetitive(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> stack[] = <span class="keyword">new</span> <span class="keyword">int</span>[k], n = A.length, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; stack[j - <span class="number">1</span>] &gt; A[i] &amp;&amp; j - <span class="number">1</span> + n - i &gt;= k)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; k)</span><br><span class="line">            stack[j++] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕1670-Design-Front-Middle-Back-Queue✨🎃"><a href="#🌕1670-Design-Front-Middle-Back-Queue✨🎃" class="headerlink" title="🌕1670. Design Front Middle Back Queue✨🎃"></a><a href="https://leetcode.com/problems/design-front-middle-back-queue/" target="_blank" rel="noopener">🌕1670. Design Front Middle Back Queue✨🎃</a></h2><h3 id="Solution1-28"><a href="#Solution1-28" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Two Deque</p>
<p>Use two <code>deque&lt;int&gt; a, b</code> where <code>a</code> and <code>b</code> represent the first and second half of the numbers in queue, respectively.</p>
<p>Make sure <code>a.size()</code> be either <code>b.size()</code> or <code>b.size() - 1</code> so that when we <code>pushMiddle</code>, always push to <code>a</code>.</p>
<p><code>a2b</code> and <code>b2a</code> are two helper functions nudging numbers around to ensure the above criteria.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//keep balance, left size &lt;= right size</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrontMiddleBackQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrontMiddleBackQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        left = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        right = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushFront</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        left.addFirst(val);</span><br><span class="line">        <span class="keyword">if</span> (left.size() &gt; right.size()) right.addFirst(left.pollLast());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushMiddle</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left.size() == right.size()) right.addFirst(val);</span><br><span class="line">        <span class="keyword">else</span> left.addLast(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushBack</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left.size() &lt; right.size()) left.addLast(right.pollFirst());</span><br><span class="line">        right.addLast(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left.size() &lt; right.size()) left.addLast(right.pollFirst());</span><br><span class="line">        <span class="keyword">return</span> left.isEmpty()? -<span class="number">1</span> : left.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popMiddle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left.size() == right.size()) <span class="keyword">return</span> left.isEmpty() ? -<span class="number">1</span> : left.pollLast();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> right.isEmpty()? -<span class="number">1</span> : right.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left.size() == right.size() &amp;&amp; !left.isEmpty()) right.addFirst(left.pollLast());</span><br><span class="line">        <span class="keyword">return</span> right.isEmpty() ? -<span class="number">1</span> : right.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-933-Number-of-Recent-Calls🎂"><a href="#Unsolved-933-Number-of-Recent-Calls🎂" class="headerlink" title="Unsolved 933. Number of Recent Calls🎂"></a><a href="https://leetcode.com/problems/number-of-recent-calls/" target="_blank" rel="noopener">Unsolved 933. Number of Recent Calls🎂</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        queue.add(t);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; queue.peek() &lt; t - <span class="number">3000</span>)&#123;</span><br><span class="line">            queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><h2 id="🌕341-Flatten-Nested-List-Iterator🎂✨"><a href="#🌕341-Flatten-Nested-List-Iterator🎂✨" class="headerlink" title="🌕341. Flatten Nested List Iterator🎂✨"></a><a href="https://leetcode.com/problems/flatten-nested-list-iterator/" target="_blank" rel="noopener">🌕341. Flatten Nested List Iterator🎂✨</a></h2><h3 id="Solution1-29"><a href="#Solution1-29" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路 1：初始化时将结果存入一维数组。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        helper(nestedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;NestedInteger&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger in: list)&#123;</span><br><span class="line">            <span class="keyword">if</span> (in.isInteger())</span><br><span class="line">                queue.offer(in.getInteger());</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                helper(in.getList());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNext())&#123;</span><br><span class="line">            <span class="keyword">return</span> queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!queue.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路 2：next 前把当前元素（如果是数组）重新按元素顺序放到缓存数组最前。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    List&lt;NestedInteger&gt; l = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        l = nestedList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!l.isEmpty()) &#123;</span><br><span class="line">            NestedInteger cur = l.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (cur.isInteger())</span><br><span class="line">                <span class="keyword">return</span> cur.getInteger();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cur.getList().size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                NestedInteger v = cur.getList().get(i);</span><br><span class="line">                l.add(<span class="number">0</span>, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!l.isEmpty()) &#123;</span><br><span class="line">            NestedInteger cur = l.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (cur.isInteger())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            l.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cur.getList().size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                NestedInteger v = cur.getList().get(i);</span><br><span class="line">                l.add(<span class="number">0</span>, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-281-Zigzag-Iterator"><a href="#Unsolved-281-Zigzag-Iterator" class="headerlink" title="Unsolved 281.  Zigzag Iterator"></a><a href="https://leetcode.com/problems/zigzag-iterator/" target="_blank" rel="noopener">Unsolved 281.  Zigzag Iterator</a></h2><h2 id="Unsolved-565-Array-Nesting"><a href="#Unsolved-565-Array-Nesting" class="headerlink" title="Unsolved 565. Array Nesting"></a><a href="https://leetcode.com/problems/array-nesting/" target="_blank" rel="noopener">Unsolved 565. Array Nesting</a></h2><h2 id="Unsolved-385-Mini-Parser💎"><a href="#Unsolved-385-Mini-Parser💎" class="headerlink" title="Unsolved 385. Mini Parser💎"></a><a href="https://leetcode.com/problems/mini-parser/" target="_blank" rel="noopener">Unsolved 385. Mini Parser💎</a></h2><h2 id="251-Flatten-2D-Vector"><a href="#251-Flatten-2D-Vector" class="headerlink" title="251. Flatten 2D Vector"></a><a href="https://leetcode.com/problems/flatten-2d-vector/" target="_blank" rel="noopener">251. Flatten 2D Vector</a></h2><h3 id="Solution1-30"><a href="#Solution1-30" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor will put all the nums into this list.</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// Keep track of where the Iterator is up to.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We need to iterate over the 2D vector, getting all the integers</span></span><br><span class="line">    <span class="comment">// out of it and putting them into nums (a field).</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector2D</span><span class="params">(<span class="keyword">int</span>[][] v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] innerV : v) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : innerV) &#123;</span><br><span class="line">                nums.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// In Java, we throw a NoSuchElementException when next() is called</span></span><br><span class="line">        <span class="comment">// on an exhausted Iterator.</span></span><br><span class="line">        <span class="keyword">if</span> (!hasNext()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">// Store the number we need to return, as we still need to move position forward.</span></span><br><span class="line">        <span class="keyword">int</span> result = nums.get(position);</span><br><span class="line">        <span class="comment">// Move the position pointer forward by 1, so that it's ready for</span></span><br><span class="line">        <span class="comment">// the next call to next, and gives a correct hasNext result.</span></span><br><span class="line">        position++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// There's nums left as long as position is a valid index of the list.</span></span><br><span class="line">        <span class="keyword">return</span> position &lt; nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Vector2D object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Vector2D obj = new Vector2D(v);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next();</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：每次把最外面一层的 Iterator 拿出，用完后再换下一，直到全部用尽。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;List&lt;Integer&gt;&gt; i;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Integer&gt; j;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector2D</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; vec2d)</span> </span>&#123;</span><br><span class="line">        i = vec2d.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hasNext();</span><br><span class="line">        <span class="keyword">return</span> j.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ((j == <span class="keyword">null</span> || !j.hasNext()) &amp;&amp; i.hasNext())</span><br><span class="line">            j = i.next().iterator();</span><br><span class="line">        <span class="keyword">return</span> j != <span class="keyword">null</span> &amp;&amp; j.hasNext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-862-Shortest-Subarray-with-Sum-at-Least-K🎂"><a href="#Unsolved-862-Shortest-Subarray-with-Sum-at-Least-K🎂" class="headerlink" title="Unsolved 862. Shortest Subarray with Sum at Least K🎂"></a><a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/?utm_source=AlgoTogether&utm_campaign=05bc9f4051-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_4&utm_medium=email&utm_term=0_38d4e2e3e2-05bc9f4051-231340480" target="_blank" rel="noopener">Unsolved 862. Shortest Subarray with Sum at Least K🎂</a></h2><h1 id="Queue-amp-Stack-Implementation"><a href="#Queue-amp-Stack-Implementation" class="headerlink" title="Queue &amp; Stack Implementation"></a>Queue &amp; Stack Implementation</h1><h2 id="Queue-Implementation"><a href="#Queue-Implementation" class="headerlink" title="Queue - Implementation"></a>Queue - Implementation</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// store elements</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">// a pointer to indicate the start position</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> MyQueue &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Insert an element into the queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> booelan <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        queue.add(n);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.get(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Checks whether the queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start &gt;= queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Circular-Queue-Implementation"><a href="#Circular-Queue-Implementation" class="headerlink" title="Circular Queue - Implementation"></a>Circular Queue - Implementation</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        head = -<span class="number">1</span>;</span><br><span class="line">        tail = -<span class="number">1</span>;</span><br><span class="line">        size = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull() == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty() == <span class="keyword">true</span>) &#123;</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % size;</span><br><span class="line">        data[tail] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty() == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            head = -<span class="number">1</span>;</span><br><span class="line">            tail = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = (head + <span class="number">1</span>) % size;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty() == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[head];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty() == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[tail];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((tail + <span class="number">1</span>) % size) == head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕622-Design-Circular-Queue✨"><a href="#🌕622-Design-Circular-Queue✨" class="headerlink" title="🌕622. Design Circular Queue✨"></a><a href="https://leetcode.com/problems/design-circular-queue/" target="_blank" rel="noopener">🌕622. Design Circular Queue✨</a></h2><h3 id="Solution1-31"><a href="#Solution1-31" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Implementation the <code>MyCircularQueue</code> class:<ul>
<li><code>MyCircularQueue(k)</code> Initializes the object with the size of the queue to be <code>k</code>.</li>
<li><code>int Front()</code> Gets the front item from the queue. If the queue is empty, return <code>-1</code>.</li>
<li><code>int Rear()</code> Gets the last item from the queue. If the queue is empty, return <code>-1</code>.</li>
<li><code>boolean enQueue(int value)</code> Inserts an element into the circular queue. Return <code>true</code> if the operation is successful.</li>
<li><code>boolean deQueue()</code> Deletes an element from the circular queue. Return <code>true</code> if the operation is successful.</li>
<li><code>boolean isEmpty()</code> Checks whether the circular queue is empty or not.</li>
<li><code>boolean isFull()</code> Checks whether the circular queue is full or not.</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">this</span>.size = k;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        queue[(start + count) % size] = value;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        start = (start + <span class="number">1</span>) % size;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[(start + count - <span class="number">1</span>) % size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BFS-Template"><a href="#BFS-Template" class="headerlink" title="BFS - Template"></a>BFS - Template</h2><h3 id="Template-I"><a href="#Template-I" class="headerlink" title="Template I"></a>Template I</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                add next to queue;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Template-II"><a href="#Template-II" class="headerlink" title="Template II"></a>Template II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    Set&lt;Node&gt; visited;  <span class="comment">// store all the nodes that we've visited</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    add root to visited;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next is not in used) &#123;</span><br><span class="line">                    add next to queue;</span><br><span class="line">                    add next to visited;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Stack-Implementation"><a href="#🌕Stack-Implementation" class="headerlink" title="🌕Stack - Implementation"></a>🌕Stack - Implementation</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "static void main" must be defined in a public class.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; data;               <span class="comment">// store elements</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Insert an element into the stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        data.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Checks whether the queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get the top item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.get(data.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data.remove(data.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyStack s = <span class="keyword">new</span> MyStack();</span><br><span class="line">        s.push(<span class="number">1</span>);</span><br><span class="line">        s.push(<span class="number">2</span>);</span><br><span class="line">        s.push(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.isEmpty()) &#123;</span><br><span class="line">                System.out.println(s.top());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(s.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>use LinkedList(推荐)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dummy = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(v);</span><br><span class="line">        node.next = dummy.next;</span><br><span class="line">        dummy.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = dummy.next.val;</span><br><span class="line">        dummy.next = dummy.next.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dummy.next.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>use ArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; array;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        array.add(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = array.size();</span><br><span class="line">        <span class="keyword">return</span> array.remove(size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = array.size();</span><br><span class="line">        <span class="keyword">return</span> array.get(size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DFS-Template-I"><a href="#DFS-Template-I" class="headerlink" title="DFS - Template I"></a>DFS - Template I</h2><h3 id="Template-Recursion"><a href="#Template-Recursion" class="headerlink" title="Template - Recursion"></a>Template - Recursion</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(Node cur, Node target, Set&lt;Node&gt; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">    <span class="keyword">for</span> (next : each neighbor of cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">            add next to visted;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">true</span> <span class="keyword">if</span> <span class="title">DFS</span><span class="params">(next, target, visited)</span> </span>== <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS-Template-II"><a href="#DFS-Template-II" class="headerlink" title="DFS - Template II"></a>DFS - Template II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    Set&lt;Node&gt; visited;</span><br><span class="line">    Stack&lt;Node&gt; stack;</span><br><span class="line">    add root to stack;</span><br><span class="line">    <span class="keyword">while</span> (s is not empty) &#123;</span><br><span class="line">        Node cur = the top element in stack;</span><br><span class="line">        remove the cur from the stack;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">        <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">                add next to visited;</span><br><span class="line">                add next to stack;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Data-Structures-for-Coding-Interviews-in-Java"><a href="#Data-Structures-for-Coding-Interviews-in-Java" class="headerlink" title="Data Structures for Coding Interviews in Java"></a>Data Structures for Coding Interviews in Java</h1><h2 id="Challenge-1-Generate-Binary-Numbers-from-1-to-n-using-a-Queue"><a href="#Challenge-1-Generate-Binary-Numbers-from-1-to-n-using-a-Queue" class="headerlink" title="Challenge 1: Generate Binary Numbers from 1 to n using a Queue"></a>Challenge 1: Generate Binary Numbers from 1 to n using a Queue</h2><p>A positive integer <em>n</em>.</p>
<p>It returns binary numbers up to <em>n</em>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">3</span></span><br><span class="line">result = &#123;<span class="string">"1"</span>,<span class="string">"10"</span>,<span class="string">"11"</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckBinary</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] findBin(<span class="keyword">int</span> number) &#123;</span><br><span class="line">        String[] result = <span class="keyword">new</span> String[number];</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> Queue&lt;String&gt;(number + <span class="number">1</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">            result[i] = queue.dequeue();</span><br><span class="line">            String s1 = result[i] + <span class="string">"0"</span>;</span><br><span class="line">            String s2 = result[i] + <span class="string">"1"</span>;</span><br><span class="line">            queue.enqueue(s1);</span><br><span class="line">            queue.enqueue(s2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">//For number = 3 , result = &#123;"1","10","11"&#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] output = findBin(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            System.out.print(output[i] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-2-Implement-Two-Stacks-using-one-Array"><a href="#Challenge-2-Implement-Two-Stacks-using-one-Array" class="headerlink" title="Challenge 2: Implement Two Stacks using one Array"></a>Challenge 2: Implement Two Stacks using one Array</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStacks</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top1, top2; <span class="comment">//Store top value indices of Stack 1 and Stack 2</span></span><br><span class="line">    <span class="keyword">private</span> V[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoStacks</span><span class="params">(<span class="keyword">int</span> max_size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = max_size;</span><br><span class="line">        <span class="keyword">this</span>.top1 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.top2 = max_size;</span><br><span class="line">        array = (V[]) <span class="keyword">new</span> Object[max_size];<span class="comment">//type casting Object[] to V[]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert at top of first stack</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push1</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top1 &lt; top2 - <span class="number">1</span>) &#123;</span><br><span class="line">            array[++top1] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert at top of second stack</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push2</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top1 &lt; top2 - <span class="number">1</span>) &#123;</span><br><span class="line">            array[--top2] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remove and return value from top of first stack</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">pop1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top1 &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> array[top1--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remove and return value from top of second stack</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">pop2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top2 &lt; maxSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> array[top2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-3-Reversing-the-First-k-Elements-of-a-Queue"><a href="#Challenge-3-Reversing-the-First-k-Elements-of-a-Queue" class="headerlink" title="Challenge 3: Reversing the First k Elements of a Queue"></a>Challenge 3: Reversing the First k Elements of a Queue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Step1. use stack store first k element in queue</span><br><span class="line">Step2. add ele in stack to queue</span><br><span class="line">Step3. queue.add(queue.poll())  queue.size() - k 次</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-4-Implement-Queue-using-Stack"><a href="#Challenge-4-Implement-Queue-using-Stack" class="headerlink" title="Challenge 4: Implement Queue using Stack"></a>Challenge 4: Implement Queue using Stack</h2><h2 id="🌕Challenge-5-Sort-the-Values-in-a-Stack"><a href="#🌕Challenge-5-Sort-the-Values-in-a-Stack" class="headerlink" title="🌕Challenge 5: Sort the Values in a Stack"></a>🌕Challenge 5: Sort the Values in a Stack</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortStack</span><span class="params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; newStack = <span class="keyword">new</span> Stack&lt;&gt;(stack.getMaxSize());</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Integer value = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (!newStack.isEmpty() &amp;&amp; value &gt;= newStack.top()) &#123;</span><br><span class="line">                newStack.push(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!newStack.isEmpty() &amp;&amp; newStack.top() &gt; value) &#123;</span><br><span class="line">                    stack.push(newStack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                newStack.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!newStack.isEmpty())</span><br><span class="line">            stack.push(newStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;(<span class="number">7</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">97</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.push(<span class="number">42</span>);</span><br><span class="line">        stack.push(<span class="number">12</span>);</span><br><span class="line">        stack.push(<span class="number">60</span>);</span><br><span class="line">        stack.push(<span class="number">23</span>);</span><br><span class="line">        sortStack(stack);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-6-Evaluate-Postfix-Expressions-using-Stacks"><a href="#Challenge-6-Evaluate-Postfix-Expressions-using-Stacks" class="headerlink" title="Challenge 6: Evaluate Postfix Expressions using Stacks"></a>Challenge 6: Evaluate Postfix Expressions using Stacks</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expression = "921*-8-4+" # 9 - 2 * 1 - 8 + 4</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="Challenge-7-Next-Greater-Element-using-Stack"><a href="#Challenge-7-Next-Greater-Element-using-Stack" class="headerlink" title="Challenge 7: Next Greater Element using Stack"></a>Challenge 7: Next Greater Element using Stack</h2><h2 id="🌕Challenge-8-Solve-a-Celebrity-Problem-using-a-Stack⭐"><a href="#🌕Challenge-8-Solve-a-Celebrity-Problem-using-a-Stack⭐" class="headerlink" title="🌕Challenge 8: Solve a Celebrity Problem using a Stack⭐"></a>🌕Challenge 8: Solve a Celebrity Problem using a Stack⭐</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindCelebChallenge</span> </span>&#123;</span><br><span class="line">    <span class="comment">//returns true if x knows y else returns false</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">knows</span><span class="params">(<span class="keyword">int</span>[][] party, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (party[x][y] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> celebrity = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Push all people in stack</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//Take two people out of stack and check if they know each other</span></span><br><span class="line">            <span class="comment">//One who doesn't know the other, push it back in stack.</span></span><br><span class="line">            <span class="keyword">int</span> cur = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                celebrity = cur;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> next = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (knows(cur, next)) &#123;</span><br><span class="line">                <span class="comment">//x knows y , discard x and push y in stack</span></span><br><span class="line">                stack.push(next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Check it to make sure it's the right celebrity</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (celebrity != i &amp;&amp; knows(celebrity, i) || !knows(i, celebrity)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> celebrity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [][] party1 = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,   </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [][] party2 = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,   </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [][] party3 = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,   </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(findCelebrity(party1,<span class="number">4</span>));</span><br><span class="line">        System.out.println(findCelebrity(party2,<span class="number">4</span>));</span><br><span class="line">        System.out.println(findCelebrity(party3,<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-9-Check-for-Balanced-Parentheses-using-a-Stack"><a href="#Challenge-9-Check-for-Balanced-Parentheses-using-a-Stack" class="headerlink" title="Challenge 9: Check for Balanced Parentheses using a Stack"></a>Challenge 9: Check for Balanced Parentheses using a Stack</h2><h2 id="Challenge-10-Create-Stack-where-min-gives-minimum-in-O-1"><a href="#Challenge-10-Create-Stack-where-min-gives-minimum-in-O-1" class="headerlink" title="Challenge 10: Create Stack where min() gives minimum in O(1)"></a>Challenge 10: Create Stack where min() gives minimum in O(1)</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/18/Programming%20Interviews%20Exposed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/18/Programming%20Interviews%20Exposed/" class="post-title-link" itemprop="url">Programming Interviews Exposed</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-18 15:59:20" itemprop="dateCreated datePublished" datetime="2020-09-18T15:59:20+09:00">2020-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-19 14:31:34" itemprop="dateModified" datetime="2020-09-19T14:31:34+09:00">2020-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mock/" itemprop="url" rel="index"><span itemprop="name">mock</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Programming-Interviews-Exposed"><a href="#Programming-Interviews-Exposed" class="headerlink" title="Programming Interviews Exposed"></a>Programming Interviews Exposed</h1><h2 id="CHAPTER-1-Before-the-Search"><a href="#CHAPTER-1-Before-the-Search" class="headerlink" title="CHAPTER 1  Before the Search"></a>CHAPTER 1  Before the Search</h2><h3 id="SUMMARY"><a href="#SUMMARY" class="headerlink" title="SUMMARY"></a>SUMMARY</h3><p>What you do before a formal job search is critical to finding the right kind of job. </p>
<p>With that in  mind, you should consider the following things:<br> ➤ Know your likes and dislikes as a programmer and a prospective employee.<br> ➤ Understand the market to find and apply for the best jobs.<br> ➤ Develop the marketable skills that employers look for and that can enhance your career.<br> ➤ Manage your public profile to show you in the best possible light and make sure there are no  surprises to turn off potential employers.<br>Once you’ve worked through all these points, you’re ready to begin your job search.</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/18/Programming%20Interviews%20Exposed/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/17/Dynamic%20Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/Dynamic%20Programming/" class="post-title-link" itemprop="url">Dynamic Programming</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 13:16:45" itemprop="dateCreated datePublished" datetime="2020-09-17T13:16:45+09:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-21 23:03:12" itemprop="dateModified" datetime="2021-04-21T23:03:12+09:00">2021-04-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Unsolved-932-Beautiful-Array💎"><a href="#Unsolved-932-Beautiful-Array💎" class="headerlink" title="Unsolved 932. Beautiful Array💎"></a><a href="https://leetcode.com/problems/beautiful-array/" target="_blank" rel="noopener">Unsolved 932. Beautiful Array💎</a></h3><p>花花酱</p>
<p><a href="https://leetcode-cn.com/circle/article/2Xxlw3/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/2Xxlw3/</a></p>
<p><a href="https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-dp-summary/" target="_blank" rel="noopener">https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-dp-summary/</a></p>
<p><a href="https://leetcode.com/discuss/general-discussion/592146/dynamic-programming-summary/513130" target="_blank" rel="noopener">https://leetcode.com/discuss/general-discussion/592146/dynamic-programming-summary/513130</a></p>
<h2 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a><a href="https://leetcode.com/problems/triangle/" target="_blank" rel="noopener">120. Triangle</a></h2><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> col;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        row = triangle.size();</span><br><span class="line">        col = triangle.get(row - <span class="number">1</span>).size();</span><br><span class="line">        Integer[][] memo = <span class="keyword">new</span> Integer[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, memo, triangle);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, Integer[][] memo, List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (r == row - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> triangle.get(row - <span class="number">1</span>).get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (memo[r][c] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(dfs(r+<span class="number">1</span>, c, memo, triangle), dfs(r+<span class="number">1</span>, c+<span class="number">1</span>, memo, triangle));</span><br><span class="line">            memo[r][c] = triangle.get(r).get(c) + min;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> memo[r][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="474-Ones-and-Zeroes"><a href="#474-Ones-and-Zeroes" class="headerlink" title="474. Ones and Zeroes"></a><a href="https://leetcode.com/problems/ones-and-zeroes/solution/" target="_blank" rel="noopener">474. Ones and Zeroes</a></h2><h3 id="Solution1-Brute-Force-Time-Limit-Exceeded"><a href="#Solution1-Brute-Force-Time-Limit-Exceeded" class="headerlink" title="Solution1: Brute Force [Time Limit Exceeded]"></a>Solution1: Brute Force [Time Limit Exceeded]</h3><p>In the brute force approach we will consider every subset of strs<em>s<strong>t</strong>r**s</em> array and count the total number of zeroes and ones in that subset. The subset with zeroes less than equal to m<em>m</em> and ones less than equal to n<em>n</em> will be considered as the valid subsets. The maximum length subset among all valid subsets will be our required subset.</p>
<p>Obviously, there are 2^n2<em>n</em> subsets possible for the list of length n<em>n</em> and here we are using int(32 bits) for iterating every subset. So this method will not work for the list having length greater than 32.</p>
<ul>
<li>Time complexity : O(2^l<em>x)*O</em>(2<em>l</em>∗<em>x</em>). 2^l2<em>l</em> possible subsets, where l<em>l</em> is the length of the list strs<em>s<strong>t</strong>r**s</em> and x<em>x</em> is the average string length.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant Space required.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; strs.length); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> zeroes = <span class="number">0</span>, ones = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] count = countzeroesones(strs[j]);</span><br><span class="line">                    zeroes += count[<span class="number">0</span>];</span><br><span class="line">                    ones += count[<span class="number">1</span>];</span><br><span class="line">                    len++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (zeroes &lt;= m &amp;&amp; ones &lt;= n)</span><br><span class="line">                maxlen = Math.max(maxlen, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countzeroesones(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            c[s.charAt(i)-<span class="string">'0'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ul>
<li>Time complexity : O(l<em>m</em>n)<em>O</em>(<em>l</em>∗<em>m</em>∗<em>n</em>). memo<em>m<strong>e</strong>m**o</em> array of size l<em>m</em>n<em>l</em>∗<em>m</em>∗<em>n</em> is filled, where l<em>l</em> is the length of strs<em>s<strong>t</strong>r**s</em>, m<em>m</em> and n<em>n</em> are the number of zeroes and ones respectively.</li>
<li>Space complexity : O(l<em>m</em>n)<em>O</em>(<em>l</em>∗<em>m</em>∗<em>n</em>). 3D array memo<em>m<strong>e</strong>m**o</em> is used.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[strs.length][m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> calculate(strs, <span class="number">0</span>, m, n, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String[] strs, <span class="keyword">int</span> i, <span class="keyword">int</span> zeroes, <span class="keyword">int</span> ones, <span class="keyword">int</span>[][][] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == strs.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][zeroes][ones] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i][zeroes][ones];</span><br><span class="line">        <span class="keyword">int</span>[] count = countzeroesones(strs[i]);</span><br><span class="line">        <span class="keyword">int</span> taken = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (zeroes - count[<span class="number">0</span>] &gt;= <span class="number">0</span> &amp;&amp; ones - count[<span class="number">1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">            taken = calculate(strs, i + <span class="number">1</span>, zeroes - count[<span class="number">0</span>], ones - count[<span class="number">1</span>], memo) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> not_taken = calculate(strs, i + <span class="number">1</span>, zeroes, ones, memo);</span><br><span class="line">        memo[i][zeroes][ones] = Math.max(taken, not_taken);</span><br><span class="line">        <span class="keyword">return</span> memo[i][zeroes][ones];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countzeroesones(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            c[s.charAt(i)-<span class="string">'0'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="🌕Unsolved-1262-Greatest-Sum-Divisible-by-Three-Shopee"><a href="#🌕Unsolved-1262-Greatest-Sum-Divisible-by-Three-Shopee" class="headerlink" title="🌕Unsolved 1262. Greatest Sum Divisible by Three(Shopee)"></a><a href="https://leetcode.com/problems/greatest-sum-divisible-by-three/" target="_blank" rel="noopener">🌕Unsolved 1262. Greatest Sum Divisible by Three(Shopee)</a></h2><h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><p><a href="https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/431077/JavaC%2B%2BPython-One-Pass-O(1)-space" target="_blank" rel="noopener">https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/431077/JavaC%2B%2BPython-One-Pass-O(1)-space</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//init: dp[i] = max sum such that the remainder == i when sum / 3 </span></span><br><span class="line">    <span class="comment">//dp[0]=0: max sum such that the remainder == 0 when 0 / 3 is 0</span></span><br><span class="line">    <span class="comment">//dp[1]=-Inf: max sum such that the remainder == 1 when 0 / 3 does not exist</span></span><br><span class="line">    <span class="comment">//dp[2]=-Inf: max sum such that the remainder == 2 when 0 / 3 does not exist</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, Integer.MIN_VALUE, Integer.MIN_VALUE&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//dp transition</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> remainder=<span class="number">0</span>; remainder&lt;<span class="number">3</span>; remainder++)&#123;</span><br><span class="line">            <span class="comment">//updating each remainder for current "num"</span></span><br><span class="line">            temp[(num+remainder)%<span class="number">3</span>] = Math.max(dp[(num+remainder)%<span class="number">3</span>], dp[remainder]+num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//rotating array</span></span><br><span class="line">        dp = temp; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return: max sum such that the remainder == 0 when sum / 3 </span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕10-Regular-Expression-Matching⭐"><a href="#🌕10-Regular-Expression-Matching⭐" class="headerlink" title="🌕10. Regular Expression Matching⭐"></a><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">🌕10. Regular Expression Matching⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    Boolean[][] dp = <span class="keyword">new</span> Boolean[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> decode(<span class="number">0</span>, <span class="number">0</span>, s, p, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String s, String p, Boolean[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> ans;</span><br><span class="line">        <span class="comment">//如果pattern中j已遍历完， j无对应的char存在时</span></span><br><span class="line">        <span class="keyword">if</span> (j == p.length()) &#123;</span><br><span class="line">            ans = (i == s.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//j对应的char存在时</span></span><br><span class="line">            <span class="comment">//first match style 'a'-'z'&lt;-&gt;'.', 条件j对应的char存在,且c1 == c2 || c2 == '.'</span></span><br><span class="line">            <span class="keyword">boolean</span> first_match = (i &lt; s.length() &amp;&amp; (s.charAt(i) == p.charAt(j) || (p.charAt(j) == <span class="string">'.'</span>) ));</span><br><span class="line">            <span class="comment">//second match style 'ccccc' &lt;-&gt; 'c*', *可以为0， 消除前一个c</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="comment">//* == 0 || * != 0</span></span><br><span class="line">                ans = (decode(i, j + <span class="number">2</span>, s, p, dp)) || first_match &amp;&amp; decode(i + <span class="number">1</span>, j, s, p, dp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = first_match &amp;&amp; decode(i + <span class="number">1</span>, j + <span class="number">1</span>, s, p, dp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="376-Wiggle-Subsequence➰"><a href="#376-Wiggle-Subsequence➰" class="headerlink" title="376. Wiggle Subsequence➰"></a><a href="https://leetcode.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. Wiggle Subsequence➰</a></h2><h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>For every position in the array, there are only three possible statuses for it.</p>
<ul>
<li>up position, it means nums[i] &gt; nums[i-1]</li>
<li>down position, it means nums[i] &lt; nums[i-1]</li>
<li>equals to position, nums[i] == nums[i-1]</li>
</ul>
<p>So we can use two arrays up[] and down[] to record <em>the max wiggle sequence length so far</em> at index <strong><em>i</em></strong>.<br>If nums[i] &gt; nums[i-1], that means it wiggles up. the element before it must be a down position. so up[i] = down[i-1] + 1; down[i] keeps the same with before.<br>If nums[i] &lt; nums[i-1], that means it wiggles down. the element before it must be a up position. so down[i] = up[i-1] + 1; up[i] keeps the same with before.<br>If nums[i] == nums[i-1], that means it will not change anything becasue it didn’t wiggle at all. so both down[i] and up[i] keep the same.</p>
<p>In fact, we can reduce the space complexity to O(1), but current way is more easy to understanding.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( nums.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">    up[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums[i] &gt; nums[i-<span class="number">1</span>] )&#123;</span><br><span class="line">            up[i] = down[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[i] &lt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">            down[i] = up[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">            up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(down[nums.length-<span class="number">1</span>],up[nums.length-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Short version</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> down = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            up = down + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            down = up + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕1359-Count-All-Valid-Pickup-and-Delivery-Options"><a href="#🌕1359-Count-All-Valid-Pickup-and-Delivery-Options" class="headerlink" title="🌕1359. Count All Valid Pickup and Delivery Options"></a><a href="https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/" target="_blank" rel="noopener">🌕1359. Count All Valid Pickup and Delivery Options</a></h2><h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOrders</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span>[] d : dp) Arrays.fill(d, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.toIntExact(dfs(n, <span class="number">0</span>, dp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pick, <span class="keyword">int</span> delivery, <span class="keyword">long</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (pick == <span class="number">0</span> &amp;&amp; delivery == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[pick][delivery] == -<span class="number">1</span>) &#123;</span><br><span class="line">            dp[pick][delivery] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (pick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[pick][delivery] += pick * dfs(pick - <span class="number">1</span>, delivery + <span class="number">1</span>, dp); </span><br><span class="line">                dp[pick][delivery] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (delivery &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[pick][delivery] += delivery * dfs(pick, delivery - <span class="number">1</span>, dp) % mod;</span><br><span class="line">                dp[pick][delivery] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[pick][delivery];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><p><a href="https://zhuanlan.zhihu.com/p/91582909" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91582909</a></p>
<h2 id="🌕Unsolved-1335-Minimum-Difficulty-of-a-Job-Schedule⭐"><a href="#🌕Unsolved-1335-Minimum-Difficulty-of-a-Job-Schedule⭐" class="headerlink" title="🌕Unsolved 1335. Minimum Difficulty of a Job Schedule⭐"></a><a href="https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/" target="_blank" rel="noopener">🌕Unsolved 1335. Minimum Difficulty of a Job Schedule⭐</a></h2><p><img src="https://assets.leetcode.com/uploads/2020/01/16/untitled.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: jobDifficulty &#x3D; [6,5,4,3,2,1], d &#x3D; 2</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: First day you can finish the first 5 jobs, total difficulty &#x3D; 6.</span><br><span class="line">Second day you can finish the last job, total difficulty &#x3D; 1.</span><br><span class="line">The difficulty of the schedule &#x3D; 6 + 1 &#x3D; 7</span><br></pre></td></tr></table></figure>

<p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2020/01/56F9A2C8-3F83-4C84-880B-F7551A06029D-1024x580.jpeg" alt=""></p>
<h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Solution 1: Top-down DP with cache</p>
</li>
<li><p><code>dfs</code> help find the the minimum difficulty<br>if start work at <code>i</code>th job with <code>d</code> days left.</p>
<p>If <code>d = 1</code>, only one day left, we have to do all jobs,<br>return the maximum difficulty of jobs.</p>
<p>Time complexity <code>O(nnd)</code><br>Space complexity <code>O(nd)</code></p>
</li>
</ol>
<p><a href="https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/963963/Java-Top-down-and-bottom-up-DP-monotonic-stack-time-O(nd)-space-O(nd)-with-detailed-explanation" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/963963/Java-Top-down-and-bottom-up-DP-monotonic-stack-time-O(nd)-space-O(nd)-with-detailed-explanation</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer[][] memo;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] maxSoFar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="keyword">int</span>[] jobDifficulty, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (jobDifficulty == <span class="keyword">null</span> || jobDifficulty.length &lt; d || d &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = jobDifficulty.length;</span><br><span class="line">    memo = <span class="keyword">new</span> Integer[d + <span class="number">1</span>][n];</span><br><span class="line"></span><br><span class="line">    maxSoFar = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    maxSoFar[<span class="number">0</span>] = jobDifficulty[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        maxSoFar[i] = Math.max(maxSoFar[i - <span class="number">1</span>], jobDifficulty[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(jobDifficulty, d, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return min difficulty if dividing A[0..j] to i days</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; j + <span class="number">1</span>) &#123; <span class="comment">// more days than tasks</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxSoFar[j];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (memo[i][j] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memo[i][j] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxK2J = A[j]; <span class="comment">// max(A[k+1..j])</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = j - <span class="number">1</span>; k &gt;= i - <span class="number">2</span>; k--) &#123; <span class="comment">// assume second last subarray ends at A[k]</span></span><br><span class="line">        maxK2J = Math.max(maxK2J, A[k + <span class="number">1</span>]);</span><br><span class="line">        memo[i][j] = Math.min(memo[i][j], maxK2J + dfs(A, i - <span class="number">1</span>, k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/490316/JavaC%2B%2BPython3-DP-O(nd)-Solution" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/490316/JavaC%2B%2BPython3-DP-O(nd)-Solution</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="keyword">int</span>[] jobDifficulty, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = jobDifficulty.length;</span><br><span class="line">    <span class="keyword">if</span>(N &lt; D) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[N][D + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] row : memo) Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(D, <span class="number">0</span>, jobDifficulty, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> len, <span class="keyword">int</span>[] jobDifficulty, <span class="keyword">int</span>[][] memo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = jobDifficulty.length;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span> &amp;&amp; len == N) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span> || len == N) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(memo[len][d] != -<span class="number">1</span>) <span class="keyword">return</span> memo[len][d];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curMax = jobDifficulty[len];</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> schedule = len; schedule &lt; N; ++schedule)&#123;</span><br><span class="line">        curMax = Math.max(curMax, jobDifficulty[schedule]);</span><br><span class="line">        <span class="keyword">int</span> temp = dfs(d - <span class="number">1</span>, schedule + <span class="number">1</span>, jobDifficulty, memo);</span><br><span class="line">        <span class="keyword">if</span>(temp != Integer.MAX_VALUE)</span><br><span class="line">            min = Math.min(min, temp + curMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[len][d] = min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>dp<a href="#">i</a> := min difficulties to schedule jobs 1~i in k days.</p>
<p>Schedule 1 ~ j in k – 1 days and schedule j + 1 ~ i in 1 day.</p>
<p>Init: dp[0] [0] = 0 Transition: dp<a href="#">i</a> := min(dp[j] [k -1] + max(jobs[j + 1 ~ i]), k – 1 &lt;= j &lt; i Answer: dp[n] [d]</p>
<p>Time complexity: O(n^2*d) Space complexity: O(n)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="keyword">int</span>[] jobDifficulty, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">int</span> n = jobDifficulty.length;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; d) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][d+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] a : dp) &#123;</span><br><span class="line">        Arrays.fill(a, Integer.MAX_VALUE/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= d; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxDifficulty = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= k-<span class="number">1</span>; j--) &#123;</span><br><span class="line">                maxDifficulty = Math.max(maxDifficulty, jobDifficulty[j]);</span><br><span class="line">                dp[i][k] = Math.min(dp[i][k], dp[j][k-<span class="number">1</span>] + maxDifficulty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][d];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Solution1: DP</span></span><br><span class="line"><span class="comment">dp[i][k] = minimum jod difficulty to schedule first i jobs in k days</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">initial: dp[0][0] = 0;, dp[*][*] = Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Transition:</span></span><br><span class="line"><span class="comment">d[i][k] = min&#123;dp[j][k-1] + max(jobs[j+1 ~ i])&#125;;</span></span><br><span class="line"><span class="comment">k-1 &lt;= j &lt; i;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Answer: dp[n][d];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(n^2k)</span></span><br><span class="line"><span class="comment">Space O(nk)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-72-Edit-Distance✨"><a href="#🌕Unsolved-72-Edit-Distance✨" class="headerlink" title="🌕Unsolved 72. Edit Distance✨"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">🌕Unsolved 72. Edit Distance✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">main</span><span class="params">(lines)</span>:</span></span><br><span class="line"><span class="function">    # このコードは標準入力と標準出力を用いたサンプルコードです。</span></span><br><span class="line"><span class="function">    # このコードは好きなように編集・削除してもらって構いません。</span></span><br><span class="line"><span class="function">    # ---</span></span><br><span class="line"><span class="function">    # This is a sample code to use stdin and stdout.</span></span><br><span class="line"><span class="function">    # Edit and remove <span class="keyword">this</span> code as you like.</span></span><br><span class="line"><span class="function">    <span class="keyword">try</span>:</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> not lines: </span></span><br><span class="line"><span class="function">            <span class="title">print</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        elif <span class="title">len</span><span class="params">(lines)</span> !</span>=<span class="number">1</span>: </span><br><span class="line">            print(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            word_pair = lines[<span class="number">0</span>].split(<span class="string">" "</span>)</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(word_pair)</span> </span>== <span class="number">1</span>: </span><br><span class="line">                print(len(word_pair[<span class="number">0</span>]))</span><br><span class="line">            <span class="function">elif <span class="title">len</span><span class="params">(word_pair)</span> &gt; 2: </span></span><br><span class="line"><span class="function">                <span class="title">exit</span><span class="params">(<span class="number">100</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">else</span>:</span></span><br><span class="line"><span class="function">                word1, word2 </span>= word_pair</span><br><span class="line">                <span class="keyword">if</span> not word1.isalnum() or not word2.isalnum(): exit(<span class="number">100</span>)</span><br><span class="line">                ans = minDistance(word1, word2)</span><br><span class="line">                print(ans)</span><br><span class="line">    except:</span><br><span class="line">        exit(<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function">def <span class="title">minDistance</span><span class="params">(word1: str, word2: str)</span>:</span></span><br><span class="line"><span class="function">        m </span>= len(word1)</span><br><span class="line">        n = len(word2)</span><br><span class="line">        <span class="keyword">if</span> n * m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> n + m</span><br><span class="line">        res = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="function"><span class="keyword">for</span> _ in <span class="title">range</span><span class="params">(n+<span class="number">1</span>)</span>]</span></span><br><span class="line"><span class="function">        <span class="keyword">for</span> i in <span class="title">range</span><span class="params">(n+<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">            res[i][0] </span>= i</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">for</span> j in <span class="title">range</span><span class="params">(m+<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">            res[0][j] </span>= j</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">1</span>, n+<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">            <span class="keyword">for</span> j in <span class="title">range</span><span class="params">(<span class="number">1</span>, m+<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">                <span class="keyword">if</span> word1[j-1] !</span>= word2[i-<span class="number">1</span>]:</span><br><span class="line">                    res[i][j] = <span class="number">1</span> + min(res[i-<span class="number">1</span>][j], res[i][j-<span class="number">1</span>], res[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res[i][j] = <span class="number">1</span> + min(res[i-<span class="number">1</span>][j], res[i][j-<span class="number">1</span>], res[i-<span class="number">1</span>][j-<span class="number">1</span>]-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res[n][m]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lines = []</span><br><span class="line">    <span class="keyword">for</span> l in sys.stdin:</span><br><span class="line">        lines.append(l.rstrip(<span class="string">'\r\n'</span>))</span><br><span class="line">    main(lines)</span><br></pre></td></tr></table></figure>



<h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>Top down dfs + memo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.length();</span><br><span class="line">    <span class="keyword">int</span> n = word2.length();</span><br><span class="line">    Integer[][] memo = <span class="keyword">new</span> Integer[m][n];</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, word1, word2, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String word1, String word2, Integer[][] memo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == word1.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> word2.length() - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == word2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> word1.length() - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memo[i][j] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//same character no need to operation</span></span><br><span class="line">        <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(i + <span class="number">1</span>, j + <span class="number">1</span>, word1, word2, memo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> insert = <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, word1, word2, memo);</span><br><span class="line">        <span class="keyword">int</span> remove = <span class="number">1</span> + dfs(i, j + <span class="number">1</span>, word1, word2, memo);</span><br><span class="line">        <span class="keyword">int</span> replace = <span class="number">1</span> + dfs(i + <span class="number">1</span>, j + <span class="number">1</span>, word1, word2, memo);</span><br><span class="line"></span><br><span class="line">        memo[i][j] = Math.min(insert, Math.min(remove, replace));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="🌕53-Maximum-Subarray✨"><a href="#🌕53-Maximum-Subarray✨" class="headerlink" title="🌕53. Maximum Subarray✨"></a><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">🌕53. Maximum Subarray✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Find the contiguous subarray within an <span class="title">array</span> <span class="params">(containing at least one number)</span> which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum </span>= <span class="number">6</span>.</span><br><span class="line"></span><br><span class="line">Input: nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] has the largest sum = <span class="number">6</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路 1：类似股票题目，逐一求和，如果小于 0 则再从 0 开始。O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[i];</span><br><span class="line">        sum += cur;</span><br><span class="line">        max = Math.max(max, sum);</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/maximum-subarray/discuss/20193/DP-solution-and-some-thoughts" target="_blank" rel="noopener">思路</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> currSum = nums[<span class="number">0</span>], maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        currSum = Math.max(nums[i], currSum + nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum, currSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        curSum = Math.max(nums[i], curSum + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (curSum &gt; max) &#123;</span><br><span class="line">            max = curSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//dp[i] means the maximum subarray ending with A[i];</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕91-Decode-Ways✨🎶"><a href="#🌕91-Decode-Ways✨🎶" class="headerlink" title="🌕91. Decode Ways✨🎶"></a><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">🌕91. Decode Ways✨🎶</a></h2><h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Integer[] dp = <span class="keyword">new</span> Integer[s.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> recursiveWithMemo(<span class="number">0</span>, s, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursiveWithMemo</span><span class="params">(<span class="keyword">int</span> idx, String s, Integer[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case,order matter edgecase input "0"</span></span><br><span class="line">    <span class="comment">// If you reach the end of the string</span></span><br><span class="line">    <span class="comment">// Return 1 for success.</span></span><br><span class="line">    <span class="keyword">if</span> (idx == s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the string starts with a zero, it can't be decoded</span></span><br><span class="line">    <span class="keyword">if</span> (s.charAt(idx) == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> oneChar = recursiveWithMemo(idx + <span class="number">1</span>, s, dp);</span><br><span class="line">        <span class="keyword">int</span> twoChar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(s.substring(idx, idx + <span class="number">2</span>)) &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            twoChar = recursiveWithMemo(idx + <span class="number">2</span>, s, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx] = oneChar + twoChar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation" target="_blank" rel="noopener">explanation</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//""</span></span><br><span class="line">    dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> oneDigits = Integer.valueOf(s.substring(i - <span class="number">1</span>, i));</span><br><span class="line">        <span class="keyword">int</span> twoDigits = Integer.valueOf(s.substring(i - <span class="number">2</span>, i));</span><br><span class="line">        <span class="keyword">if</span> (oneDigits &gt;= <span class="number">1</span> &amp;&amp; oneDigits &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">            dp[i] += dp[i-<span class="number">1</span>];  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (twoDigits &gt;= <span class="number">10</span> &amp;&amp; twoDigits &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="221-Maximal-Square⭐"><a href="#221-Maximal-Square⭐" class="headerlink" title="221. Maximal Square⭐"></a><a href="https://leetcode.com/problems/maximal-square/" target="_blank" rel="noopener">221. Maximal Square⭐</a></h2><p><img src="https://assets.leetcode.com/users/leetcode/image_1573111823.png" alt=""></p>
<h3 id="Solution0"><a href="#Solution0" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute force</li>
<li>Time complexity : O\big((mn)^2\big)<em>O</em>((<em>m**n</em>)2). In worst case, we need to traverse the complete matrix for every 1.</li>
<li>Space complexity : O(1)<em>O</em>(1). No extra space is used.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length, cols = rows &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxsqlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> sqlen = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">while</span> (sqlen + i &lt; rows &amp;&amp; sqlen + j &lt; cols &amp;&amp; flag) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= sqlen + j; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + sqlen][k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            flag = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= sqlen + i; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[k][j + sqlen] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            flag = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (flag)</span><br><span class="line">                        sqlen++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (maxsqlen &lt; sqlen) &#123;</span><br><span class="line">                    maxsqlen = sqlen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsqlen * maxsqlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><code>dp[i][j]</code> represents the length of the square which lower right corner is located at <code>(i, j)</code>.<br>If the value of this cell is also <code>1</code>, then the length of the square is the <strong>minimum</strong> of: the one above, its left, and diagonal up-left value +1. Because if one side is short or missing, it will not form a square.</li>
<li>Time complexity : O(mn)<em>O</em>(<em>m**n</em>). Single pass.</li>
<li>Space complexity : O(mn)<em>O</em>(<em>m**n</em>). Another matrix of same size is used for dp.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length; </span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> edge = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n+<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]), dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                edge = Math.max(edge, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edge * edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1155-Number-of-Dice-Rolls-With-Target-Sum⭐"><a href="#1155-Number-of-Dice-Rolls-With-Target-Sum⭐" class="headerlink" title="1155. Number of Dice Rolls With Target Sum⭐"></a><a href="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/" target="_blank" rel="noopener">1155. Number of Dice Rolls With Target Sum⭐</a></h2><h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>dfs + memorization</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> MOD = <span class="number">1000000000</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span> || target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    String s = d + <span class="string">"|"</span> + target;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &gt;= i) &#123;</span><br><span class="line">            res = (res + numRollsToTarget(d - <span class="number">1</span>, f, target - i)) % MOD;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>dp</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[d + <span class="number">1</span>][target + <span class="number">1</span>]; </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//how many possibility can i dices sum up to j;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; i * f) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;         <span class="comment">//If j is larger than largest possible sum of i dices, there is no possible ways.        </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                      <span class="comment">//watch out below condition, or NPE</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f &amp;&amp; k &lt;= j ; k++) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j - k]) % MOD; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[d][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="139-Word-Break⭐🎶"><a href="#139-Word-Break⭐🎶" class="headerlink" title="139. Word Break⭐🎶"></a><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">139. Word Break⭐🎶</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">递归求解，划分left, right substring</span><br><span class="line">check <span class="keyword">if</span> dic contains right, recursively apply function to left</span><br><span class="line">wordbreak(<span class="string">"leetcode"</span>) = </span><br><span class="line">wordbreak(<span class="string">""</span>) &amp;&amp; inDict(<span class="string">"leetcode"</span>)</span><br><span class="line">|| wordbreak(<span class="string">"l"</span>) &amp;&amp; inDict(<span class="string">"eetcode"</span>)</span><br><span class="line">|| wordbreak(<span class="string">"le"</span>) &amp;&amp; inDict(<span class="string">"etcode"</span>)</span><br><span class="line">|| wordbreak(<span class="string">"lee"</span>) &amp;&amp; inDict(<span class="string">"tcode"</span>)</span><br><span class="line">|| wordbreak(<span class="string">"leet"</span>) &amp;&amp; inDict(<span class="string">"code"</span>) ✔</span><br><span class="line">|| wordbreak(<span class="string">"lettc"</span>) &amp;&amp; inDict(<span class="string">"leetcode"</span>)</span><br><span class="line"></span><br><span class="line">wordbreak(<span class="string">"leet"</span>) =</span><br><span class="line">||wordbreak(<span class="string">""</span>) &amp;&amp; inDict(<span class="string">"leet"</span>)✔</span><br><span class="line">||wordbreak(<span class="string">"l"</span>) &amp;&amp; inDict(<span class="string">"eet"</span>)</span><br><span class="line">||wordbreak(<span class="string">"le"</span>) &amp;&amp; inDict(<span class="string">"et"</span>)</span><br><span class="line">||wordbreak(<span class="string">"lee"</span>) &amp;&amp; inDict(<span class="string">"t"</span>)</span><br><span class="line">||wordbreak(<span class="string">"leet"</span>) &amp;&amp; inDict(<span class="string">""</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Boolean[] dp = <span class="keyword">new</span> Boolean[s.length()];</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    <span class="keyword">return</span> findPartition(<span class="number">0</span>, s, set, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findPartition</span><span class="params">(<span class="keyword">int</span> idx, String s, Set&lt;String&gt; set, Boolean[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == s.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> canSplit = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            String sub = s.substring(idx, i);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(sub) &amp;&amp; findPartition(i, s, set, dp)) &#123;</span><br><span class="line">                canSplit = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx] = canSplit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">    Map&lt;String, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> wordBreak(s, map, dict);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, Map&lt;String, Boolean&gt; map, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//in memory directly return</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//base case, if s is valid word memorie it and return</span></span><br><span class="line">    <span class="keyword">if</span> (dict.contains(s)) &#123;</span><br><span class="line">        map.put(s, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//divie the string to left right two part, in all possibilities</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        String left = s.substring(<span class="number">0</span>, i);</span><br><span class="line">        String right = s.substring(i);</span><br><span class="line">        <span class="keyword">if</span> (dict.contains(right) &amp;&amp; wordBreak(left, map, dict)) &#123;</span><br><span class="line">            map.put(s, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>思路 1：动态规划，每次都利用已处理部分可分信息看到当前位置是否可分，如果可分置 True。O(n2k)</p>
</li>
<li><p>f[i] stands for whether subarray(0, i) can be segmented into words from the dictionary. So f[0] means whether subarray(0, 0) (which is an empty string) can be segmented, and of course the answer is yes.</p>
<p>The default value for boolean array is false. Therefore we need to set f[0] to be true.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-140-Word-Break-II⭐"><a href="#Unsolved-140-Word-Break-II⭐" class="headerlink" title="Unsolved 140. Word Break II⭐"></a><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">Unsolved 140. Word Break II⭐</a></h2><h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路 1：DFS+回溯，每次试用词典中每一个词作为下一段开始的一种可能。O（n^2k）。</li>
<li>Using DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">    Set&lt;String&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    <span class="keyword">return</span> wordBreak(s, map, words);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, HashMap&lt;String,List&lt;String&gt;&gt; map, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//in memory</span></span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//base case, a whole string is a word</span></span><br><span class="line">    <span class="keyword">if</span>(wordDict.contains(s)) &#123;</span><br><span class="line">        res.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; s.length() ; i++) &#123;</span><br><span class="line">        String left = s.substring(<span class="number">0</span> , i);</span><br><span class="line">        String right = s.substring(i);</span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(right)) &#123;</span><br><span class="line">            List&lt;String&gt; temp = wordBreak(left, map, wordDict);</span><br><span class="line">            <span class="keyword">if</span>(temp.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; temp.size() ; j++) &#123;</span><br><span class="line">                    res.add(temp.get(j) + <span class="string">" "</span> + right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s , res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    <span class="keyword">return</span> dfs(s, words, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">dfs</span><span class="params">(String s, Set&lt;String&gt; words, Map&lt;String, List&lt;String&gt;&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.startsWith(word)) &#123;</span><br><span class="line">            List&lt;String&gt; sublist = dfs(s.substring(word.length()), words, map);</span><br><span class="line">            <span class="keyword">for</span> (String sub : sublist) &#123;</span><br><span class="line">                res.add(word + (sub.isEmpty() ? <span class="string">""</span> : <span class="string">" "</span>) + sub);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(s, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路 2：与思路 1 类似，不是词去匹配字符串，而是字符串先切分，再看分出来的部分是不是在词典中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE, max = <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">        set.add(word);</span><br><span class="line">        <span class="keyword">int</span> curLen = word.length();</span><br><span class="line">        min = (curLen &lt; min) ? curLen : min;</span><br><span class="line">        max = (curLen &gt; max) ? curLen : max;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] invalid = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()]; <span class="comment">// invalid[i]: [i:] is unbreakable</span></span><br><span class="line">    seperate(s, result, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, set, invalid, min, max);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">seperate</span><span class="params">(String s, List&lt;String&gt; res, StringBuilder tmp, <span class="keyword">int</span> index, HashSet&lt;String&gt; set, <span class="keyword">boolean</span>[] invalid, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">        res.add(tmp.toString().trim());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> breakable = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> prelen = tmp.length();</span><br><span class="line">    <span class="keyword">int</span> rightbound = Math.min(s.length(), index + max);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = index + min; end &lt;= rightbound; end++) &#123;</span><br><span class="line">        <span class="keyword">int</span> curLen = end - index;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; s.length() &amp;&amp; invalid[end])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        String cur = s.substring(index, end);</span><br><span class="line">        <span class="keyword">if</span> (set.contains(cur)) &#123;</span><br><span class="line">            tmp.append(<span class="string">" "</span>).append(cur);</span><br><span class="line">            breakable |= seperate(s, res, tmp, end, set, invalid, min, max);</span><br><span class="line">            tmp.setLength(prelen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    invalid[index] = !breakable;</span><br><span class="line">    <span class="keyword">return</span> breakable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-472-Concatenated-Words⭐"><a href="#Unsolved-472-Concatenated-Words⭐" class="headerlink" title="Unsolved 472. Concatenated Words⭐"></a><a href="https://leetcode.com/problems/concatenated-words/" target="_blank" rel="noopener">Unsolved 472. Concatenated Words⭐</a></h2><p><a href="https://leetcode.com/problems/concatenated-words/discuss/95652/Java-DP-Solution" target="_blank" rel="noopener">https://leetcode.com/problems/concatenated-words/discuss/95652/Java-DP-Solution</a></p>
<p><a href="https://leetcode.com/problems/concatenated-words/discuss/541520/Java-DFS-%2B-Memoization-Clean-code" target="_blank" rel="noopener">https://leetcode.com/problems/concatenated-words/discuss/541520/Java-DFS-%2B-Memoization-Clean-code</a></p>
<p><a href="https://leetcode.com/problems/concatenated-words/discuss/348972/Java-Common-template-Word-Break-I-Word-Break-II-Concatenated-Words" target="_blank" rel="noopener">https://leetcode.com/problems/concatenated-words/discuss/348972/Java-Common-template-Word-Break-I-Word-Break-II-Concatenated-Words</a></p>
<h2 id="64-Minimum-Path-Sum⭐"><a href="#64-Minimum-Path-Sum⭐" class="headerlink" title="64. Minimum Path Sum⭐"></a><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. Minimum Path Sum⭐</a></h2><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[ [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>] ]</span><br><span class="line">Output: <span class="number">7</span></span><br><span class="line">Explanation: Because the path <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> minimizes the sum.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：动态规划。边界上只能直接加上一位置数值到当前位置，非边界的则取上行或列中较小的加到当前数值中，最终位置数值即最小。</li>
<li>minimizes, 优化问题经常是动态规划</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//initial</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//tarverse</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n; ++j) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[[1,3,1],</span></span><br><span class="line"><span class="comment">[1,5,1],</span></span><br><span class="line"><span class="comment">[4,2,1]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Error check :</span></span><br><span class="line"><span class="comment">if input is empty or null. return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">1. First another matrix to store the path sum</span></span><br><span class="line"><span class="comment">   eg. matrix[i][j] = currnet smallest path sum from start point to current pos</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">2. Initial the boundary conditions</span></span><br><span class="line"><span class="comment">    eg. in first row like a prefix sum calculate the all the element value from start point to here: in first col, same with row</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. Traverse from [1,1] position, keep update the cur matrix value</span></span><br><span class="line"><span class="comment">    since we want minimizes the value, we will peek the smaller one from top, or left unit, and add this value with cur num value</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    [1,4,5]</span></span><br><span class="line"><span class="comment">    [2,2+5 = 7, 6]</span></span><br><span class="line"><span class="comment">    [6,8, 7]</span></span><br><span class="line"><span class="comment">4. return matrix[i][j], end point matrix path sum value</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(mn)</span></span><br><span class="line"><span class="comment">Space O(mn)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="121-Best-Time-to-Buy-and-Sell-Stock⭐"><a href="#121-Best-Time-to-Buy-and-Sell-Stock⭐" class="headerlink" title="121. Best Time to Buy and Sell Stock⭐"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock⭐</a></h2><h3 id="Most-consistent-ways-of-dealing-with-the-series-of-stock-problems"><a href="#Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" class="headerlink" title="Most consistent ways of dealing with the series of stock problems"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">Most consistent ways of dealing with the series of stock problems</a></h3><p><a href="https://mp.weixin.qq.com/s/61CU8PcT2z4Po7cVdwTprg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/61CU8PcT2z4Po7cVdwTprg</a></p>
<h3 id="Solution0-1"><a href="#Solution0-1" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute Force</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(N^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">            <span class="keyword">if</span> (profit &gt; maxprofit)</span><br><span class="line">                maxprofit = profit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>One Pass</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">            minprice = prices[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">            maxprofit = prices[i] - minprice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check:</span></span><br><span class="line"><span class="comment">1. If price == null || price.length == 0 return 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">Brute force:</span></span><br><span class="line"><span class="comment">Apply double for loop, eg.</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; prices.length; i++) &#123;</span></span><br><span class="line"><span class="comment">    for (int j = i + 1; j &lt; prices.length; j++) &#123;</span></span><br><span class="line"><span class="comment">        if (prices[j] - prices[i] &gt; max) &#123;</span></span><br><span class="line"><span class="comment">            max = prices[j] - prices[i];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Time O(n^2)</span></span><br><span class="line"><span class="comment">Spcae: O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution2:</span></span><br><span class="line"><span class="comment">maxProfit</span></span><br><span class="line"><span class="comment">we want buy the stock in min price and sold it at max prices in the future</span></span><br><span class="line"><span class="comment">we can tarck the current min price, travrse the prices, say </span></span><br><span class="line"><span class="comment">if (current price - Curmin &gt; maxProfit) &#123;</span></span><br><span class="line"><span class="comment">    maxProfit = current price - Curmin;</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">curmin = Math.min(curMin, price) //keep updating min price we have seen</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Go through example: [7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">day: </span></span><br><span class="line"><span class="comment">price: 1</span></span><br><span class="line"><span class="comment">min: 1</span></span><br><span class="line"><span class="comment">profit: </span></span><br><span class="line"><span class="comment">max: </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Time O(n)</span></span><br><span class="line"><span class="comment">Space O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II✨"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II✨" class="headerlink" title="122. Best Time to Buy and Sell Stock II✨"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">7</span></span><br><span class="line">Explanation: Buy on day <span class="number">2</span> (price = <span class="number">1</span>) and sell on day <span class="number">3</span> (price = <span class="number">5</span>), profit = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span>.</span><br><span class="line">             Then buy on day <span class="number">4</span> (price = <span class="number">3</span>) and sell on day <span class="number">5</span> (price = <span class="number">6</span>), profit = <span class="number">6</span>-<span class="number">3</span> = <span class="number">3</span>.</span><br><span class="line">    </span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Buy on day <span class="number">1</span> (price = <span class="number">1</span>) and sell on day <span class="number">5</span> (price = <span class="number">5</span>), profit = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span>.</span><br><span class="line">             Note that you cannot buy on day <span class="number">1</span>, buy on day <span class="number">2</span> and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//but that day higer the previous day tehn sell next day</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i + <span class="number">1</span>] &gt; prices[i]) &#123; </span><br><span class="line">            profit += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def compare(a, b):</span><br><span class="line">        if abs(a) &lt; abs(b): return -1</span><br><span class="line">        if abs(a) &gt; abs(b): return 1</span><br><span class="line">        if a &lt; b: return -1</span><br><span class="line">        if a &gt; b: return 1</span><br><span class="line">        return 0</span><br><span class="line"></span><br><span class="line">    arr.sort(cmp &#x3D; compare)</span><br><span class="line">    return arr</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-123-Best-Time-to-Buy-and-Sell-Stock-III✨"><a href="#Unsolved-123-Best-Time-to-Buy-and-Sell-Stock-III✨" class="headerlink" title="Unsolved 123. Best Time to Buy and Sell Stock III✨"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">Unsolved 123. Best Time to Buy and Sell Stock III✨</a></h2><h2 id="Unsolved-188-Best-Time-to-Buy-and-Sell-Stock-IV✨"><a href="#Unsolved-188-Best-Time-to-Buy-and-Sell-Stock-IV✨" class="headerlink" title="Unsolved 188. Best Time to Buy and Sell Stock IV✨"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">Unsolved 188. Best Time to Buy and Sell Stock IV✨</a></h2><h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：同 122 和 123 题。如果次数不小于天数一半，则可任意多次交易，只要上涨就计入即为最大收益。如 果次数不到天数一半，二维动态规。O(kn)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> maxCum(prices);</span><br><span class="line">    <span class="keyword">int</span>[] balance = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(balance, Integer.MIN_VALUE);</span><br><span class="line">    <span class="keyword">int</span>[] profit = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            balance[j] = Math.max(profit[j - <span class="number">1</span>] - price, balance[j]);</span><br><span class="line">            profit[j] = Math.max(balance[j] + price, profit[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCum</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (prices[i + <span class="number">1</span>] &gt; prices[i])</span><br><span class="line">            ans += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i, j] represents the max profit up until prices[j] using at most i transactions. </span></span><br><span class="line"><span class="comment"> * dp[i, j] = max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]) &#123; jj in range of [0, j-1] &#125;</span></span><br><span class="line"><span class="comment"> *          = max(dp[i, j-1], prices[j] + max(dp[i-1, jj] - prices[jj]))</span></span><br><span class="line"><span class="comment"> * dp[0, j] = 0; 0 transactions makes 0 profit</span></span><br><span class="line"><span class="comment"> * dp[i, 0] = 0; if there is only one price data point you can't make any transaction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = prices.length;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//if k &gt;= n/2, then you can make maximum number of transactions.</span></span><br><span class="line">	<span class="keyword">if</span> (k &gt;=  n/<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> maxPro = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (prices[i] &gt; prices[i-<span class="number">1</span>])</span><br><span class="line">				maxPro += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maxPro;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">    	<span class="keyword">int</span> localMax = dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    		dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>],  prices[j] + localMax);</span><br><span class="line">    		localMax = Math.max(localMax, dp[i-<span class="number">1</span>][j] - prices[j]);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3:"></a>Solution3:</h3><ol>
<li>The general idea is DP, while I had to add a “quickSolve” function to tackle some corner cases to avoid TLE. DP: t(i,j) is the max profit for up to i transactions by time j (0&lt;=i&lt;=K, 0&lt;=j&lt;=T).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= len / <span class="number">2</span>) <span class="keyword">return</span> quickSolve(prices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] t = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>][len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmpMax =  -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            t[i][j] = Math.max(t[i][j - <span class="number">1</span>], prices[j] + tmpMax);</span><br><span class="line">            tmpMax =  Math.max(tmpMax, t[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t[k][len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSolve</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length, profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        <span class="comment">// as long as there is a price gap, we gain a profit.</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Unsolved-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Unsolved 309. Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">Unsolved 309. Best Time to Buy and Sell Stock with Cooldown</a></h2><h2 id="Unsolved-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee🌕"><a href="#Unsolved-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee🌕" class="headerlink" title="Unsolved 714. Best Time to Buy and Sell Stock with Transaction Fee🌕"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">Unsolved 714. Best Time to Buy and Sell Stock with Transaction Fee🌕</a></h2><h3 id="Top-down-dp"><a href="#Top-down-dp" class="headerlink" title="Top down dp"></a>Top down dp</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[prices.length + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, prices, <span class="number">0</span>, dp, fee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] prices, <span class="keyword">int</span> hasStock, Integer[][] dp, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (prices.length == <span class="number">0</span> || idx &gt;= prices.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][hasStock] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (hasStock == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> buyCur = dfs(idx + <span class="number">1</span>, prices, <span class="number">1</span>, dp, fee) - prices[idx];</span><br><span class="line">            max = Math.max(max, buyCur);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> soldCur = dfs(idx + <span class="number">1</span>, prices, <span class="number">0</span>, dp, fee) + prices[idx] - fee;</span><br><span class="line">            max = Math.max(max, soldCur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> noOperation = dfs(idx + <span class="number">1</span>, prices, hasStock, dp, fee);</span><br><span class="line">        max = Math.max(max, noOperation);</span><br><span class="line">        dp[idx][hasStock] = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][hasStock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. Maximum Product Subarray</a></h2><h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="Max-Subset-Sum-No-Adjacent-AE-✨"><a href="#Max-Subset-Sum-No-Adjacent-AE-✨" class="headerlink" title="Max Subset Sum No Adjacent(AE)✨"></a>Max Subset Sum No Adjacent(AE)✨</h2><ol>
<li><p>Given a no negative integer array</p>
</li>
<li><p>Built an array same length with the input array, maxSums array to storing the greatest number with no adjacent numbers</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">14</span>]  <span class="comment">//input array</span></span><br><span class="line"></span><br><span class="line">[<span class="number">7</span>, <span class="number">10</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">28</span>, <span class="number">33</span>]   <span class="comment">//maxSums </span></span><br><span class="line"><span class="comment">//33 = 19 + 14</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>formula: <strong><code>maxSums[i]</code></strong> = max(<strong><code>maxSums[i - 1]</code></strong>, <strong><code>maxSums[i - 2] + array[i]</code></strong>)</p>
</li>
<li><p>time O(N), space O(N), because we build an array in length N</p>
</li>
</ol>
<h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(n) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubsetSumNoAdjacent</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;  <span class="comment">//edge case1 need take care of, the array is empty</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array.length = <span class="number">1</span>) &#123;  <span class="comment">//edge case2, the array only have one value</span></span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] maxSums = array.clone();  <span class="comment">//copy the main array, fix first 2 element,because maxSums[0] = array[0]</span></span><br><span class="line">    maxSums[<span class="number">1</span>] = Math.max(array[<span class="number">0</span>], array[<span class="number">1</span>]);  <span class="comment">//set the second value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//start traversal and apply the foluma</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">        maxSums[i] = Math.max(maxSums[i - <span class="number">1</span>], maxSums[i - <span class="number">2</span>] + array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSums[array.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Like nth Fib, sliding window</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">14</span>]  <span class="comment">//input array</span></span><br><span class="line"></span><br><span class="line">first &amp; second</span><br><span class="line">[<span class="number">7</span>, <span class="number">10</span>], <span class="number">19</span>, <span class="number">19</span>, <span class="number">28</span>, <span class="number">33</span></span><br><span class="line"><span class="number">7</span>, [<span class="number">10</span>, <span class="number">19</span>], <span class="number">19</span>, <span class="number">28</span>, <span class="number">33</span></span><br><span class="line"><span class="number">7</span>, <span class="number">10</span>, [<span class="number">19</span>, <span class="number">19</span>], <span class="number">28</span>, <span class="number">33</span></span><br><span class="line"><span class="number">7</span>, <span class="number">10</span>, <span class="number">19</span>, [<span class="number">19</span>, <span class="number">28</span>], <span class="number">33</span></span><br><span class="line"><span class="number">7</span>, <span class="number">10</span>, <span class="number">19</span>, <span class="number">19</span>, [<span class="number">28</span>, <span class="number">33</span>]   <span class="comment">//maxSums</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(1) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubsetSumNoAdjacent</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = array[<span class="number">0</span>];  <span class="comment">//create two varaible to store value rather than array in order to save space complexity, represent maxSums[i - 2], in the begining is array[0]</span></span><br><span class="line">    <span class="keyword">int</span> second = Math.max(array[<span class="number">0</span>], array[<span class="number">1</span>]);  <span class="comment">//represent maxSums[i - 1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = Math.max(second, first + array[i]);  <span class="comment">//create varaible to represent maxSums[i - 1]</span></span><br><span class="line">        first = second;</span><br><span class="line">        second = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="198-House-Robber✨🎶"><a href="#198-House-Robber✨🎶" class="headerlink" title="198.House Robber✨🎶"></a><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198.House Robber✨🎶</a></h3><h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Time complexity : O(n). Assume that n<em>n</em> is the number of houses, the time complexity is O(n)<em>O</em>(<em>n</em>).</li>
<li>Space complexity : O(1).</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prevMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : num) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = currMax;</span><br><span class="line">        currMax = Math.max(prevMax + x, currMax);</span><br><span class="line">        prevMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = Math.max(first + nums[i], second);</span><br><span class="line">        first = second;</span><br><span class="line">        second = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213.House Robber II"></a><a href="https://leetcode.com/problems/house-robber-ii/" target="_blank" rel="noopener">213.House Robber II</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regard ayyay[<span class="number">0</span>] and array[array.length - <span class="number">1</span>] as adjacent houses</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-19"><a href="#Solution1-19" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：与第 198 题思路一致，只不过要从 0 到 n-1，1 到 n 中取较大的。因为 n 和 0 相邻。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>), rob(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, preMax = <span class="number">0</span>, noRob, rob;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[i];</span><br><span class="line">        rob = preMax + cur;</span><br><span class="line">        noRob = max;</span><br><span class="line">        max = Math.max(rob, noRob);</span><br><span class="line">        preMax = noRob;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Number-Of-Ways-To-Make-Change-AE"><a href="#Number-Of-Ways-To-Make-Change-AE" class="headerlink" title="Number Of Ways To Make Change(AE)"></a>Number Of Ways To Make Change(AE)</h2><ol>
<li><p>Given an integer to represents a target amount of money, and an array input represent the coin denominations</p>
</li>
<li><p>Dynamic programming</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">10</span> [<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>]  <span class="number">4</span> ways (<span class="number">1</span>x10$, <span class="number">2</span>x5$, <span class="number">1</span>x5$+<span class="number">5</span>x1$, <span class="number">10</span>x1$);</span><br><span class="line">ways-&gt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">$   -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">initals:only <span class="number">1</span> way to change <span class="number">0</span>$ which is use <span class="number">0</span> coins, base <span class="keyword">case</span></span><br><span class="line">    </span><br><span class="line">amount &gt;= <span class="number">1</span>$ coin: </span><br><span class="line">ways-&gt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">$   -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">way[<span class="number">1</span>] += way[<span class="number">1</span> - <span class="number">1</span>]</span><br><span class="line">way[<span class="number">2</span>] += way[<span class="number">2</span> - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">amount &gt;= <span class="number">5</span>$ coin: </span><br><span class="line">ways-&gt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">$   -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">way[<span class="number">5</span>] += way[<span class="number">5</span> - <span class="number">5</span>] </span><br><span class="line">way[<span class="number">10</span>] += way[<span class="number">10</span> - <span class="number">5</span>]</span><br><span class="line">    </span><br><span class="line">amount &gt;= <span class="number">10</span>$ coin: </span><br><span class="line">ways-&gt;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">$   -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">way[<span class="number">10</span>] += way[<span class="number">10</span> - <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>if denom &lt;= amount: ways[amount] += ways[amount -denom];</p>
</li>
</ol>
<h3 id="Solution1-20"><a href="#Solution1-20" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(nd) d is denoms | O(n) space n is target amount</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfWayToMakeChange</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] denoms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ways = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//base line, only one way to change 0 $</span></span><br><span class="line">    ways[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> denom : denoms) &#123;  <span class="comment">//denoms : 1, 5, 10 ,25</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> amount = <span class="number">1</span>; amount &lt; n + <span class="number">1</span>; ++amount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (denom &lt;= amount) &#123;</span><br><span class="line">                ways[amount] += ways[amount - denom];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="518-Coin-Change-2"><a href="#518-Coin-Change-2" class="headerlink" title="518. Coin Change 2"></a><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">518. Coin Change 2</a></h3><h3 id="Solution1-21"><a href="#Solution1-21" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><strong>Algorithm</strong><ul>
<li>Initiate number of combinations array with the base case “no coins”: <code>dp[0] = 1</code>, and all the rest = 0.</li>
<li>Loop over all coins:<ul>
<li>For each coin, loop over all amounts from 0 to <code>amount</code>:<ul>
<li>For each amount x, compute the number of combinations: <code>dp[x] += dp[x - coin]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>dp[amount]</code>.</li>
</ul>
</li>
<li>Time complexity: \mathcal{O}(N \times \textrm{amount})O(<em>N</em>×amount), where N is a length of coins array.</li>
<li>Space complexity: \mathcal{O}(\textrm{amount})O(amount) to keep dp array.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coin &lt;= i) &#123;</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>This is a classic knapsack problem. </p>
<p><code>dp[i][j]</code> : the number of combinations to make up amount <code>j</code> by using the first <code>i</code> types of coins<br><code>State transition</code>:</p>
<ol>
<li>not using the <code>i</code>th coin, only using the first <code>i-1</code> coins to make up amount <code>j</code>, then we have <code>dp[i-1][j]</code> ways.</li>
<li>using the <code>i</code>th coin, since we can use unlimited same coin, we need to know how many ways to make up amount <code>j - coins[i-1]</code> by using first <code>i</code> coins(including <code>i</code>th), which is <code>dp[i][j-coins[i-1]]</code></li>
</ol>
</li>
<li><p><strong><code>Initialization:dp[i][0] = 1</code></strong></p>
</li>
<li><pre><code class="java">different ways
amount-&gt; <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span>
types
<span class="number">0</span>        <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>   <span class="number">1</span> 
<span class="number">1</span>(<span class="number">1</span>$)    <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>   <span class="number">1</span> 
<span class="number">2</span>(<span class="number">5</span>$)    <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>   <span class="number">3</span>
<span class="number">3</span>(<span class="number">10</span>$)   <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>   <span class="number">4</span>

dp[<span class="number">2</span>][<span class="number">5</span>] = dp[<span class="number">1</span>][<span class="number">5</span>] + dp[<span class="number">2</span>][<span class="number">5</span> - <span class="number">5</span>] = <span class="number">2</span>
formula:dp[i][j] = dp[i-<span class="number">1</span>][j] + (j &gt;= coins[i-<span class="number">1</span>] ? dp[i][j-coins[i-<span class="number">1</span>]] : <span class="number">0</span>)
&lt;!--￼<span class="number">54</span>--&gt;
</code></pre>
</li>
</ol>
<p>Now we can see that <code>dp[i][j]</code> only rely on <code>dp[i-1][j]</code> and <code>dp[i][j-coins[i]]</code>, then we can optimize the space by only using one-dimension array.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> denom : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (denom &lt;= i) &#123;</span><br><span class="line">                dp[i] += dp[i - denom];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Levenshtein-Distance-AE-⭐"><a href="#Levenshtein-Distance-AE-⭐" class="headerlink" title="Levenshtein Distance(AE)⭐"></a>Levenshtein Distance(AE)⭐</h2><ol>
<li><p>Return the minimum of edit operations to turn string1 to string2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"abc"</span></span><br><span class="line">str2 = <span class="string">"yabd"</span></span><br><span class="line">insert <span class="string">'y'</span> -&gt; yabc</span><br><span class="line">substitude <span class="string">'d'</span> -&gt; yabd</span><br><span class="line"><span class="number">2</span> operations</span><br><span class="line">   <span class="string">""</span> y a b d  -&gt; row mean <span class="string">""</span>、<span class="string">"y"</span>、<span class="string">"ya"</span>、<span class="string">"yab"</span>、<span class="string">"yabd"</span></span><br><span class="line"><span class="string">""</span> <span class="number">0</span>  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">a  <span class="number">1</span>  <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">b  <span class="number">2</span>  <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">c  <span class="number">3</span>  <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">formula: </span><br><span class="line"><span class="keyword">if</span> str1[r] == str2[c]</span><br><span class="line">    E[r] [c] = E[r - <span class="number">1</span>] [c - <span class="number">1</span>], diagonally equal</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	E[r] [c] = <span class="number">1</span> + min(E[r] [c - <span class="number">1</span>], E[r - <span class="number">1</span>] [c], E[r - <span class="number">1</span>] [c - <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>time O(nm) | space O(nm) -&gt; O(min(n, m)) space</p>
</li>
</ol>
<h3 id="Solution1-22"><a href="#Solution1-22" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">levenshteinDistance</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] edits = <span class="keyword">new</span> <span class="keyword">int</span>[str2.length() + <span class="number">1</span>][str1.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//initial the base line</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str2.length() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str1.length() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            edits[i][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        edits[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//start traversal and apply the formula</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str2.length() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; str1.length() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str2.charAt(i - <span class="number">1</span>) == str1.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                edits[i][j] = edits[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                edits[i][j] = <span class="number">1</span> + Math.min(edits[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(edits[i - <span class="number">1</span>][j], edits[i][j - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edits[str2.length()][str1.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-10"><a href="#Solution2-10" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">levenshteinDistance</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    String small = str1.length() &lt; str2.length()? str1 : str2;</span><br><span class="line">    String big = str1.length() &gt;= str2.length()? str1 : str2;</span><br><span class="line">    <span class="keyword">int</span>[] evenEdits = <span class="keyword">new</span> <span class="keyword">int</span>[small.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] oddEdits = <span class="keyword">new</span> <span class="keyword">int</span>[small.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; small.length() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        evenEdits[j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] currentEdits;</span><br><span class="line">    <span class="keyword">int</span>[] previousEdits;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; big.length() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            currentEdits = oddEdits;</span><br><span class="line">            previousEdits = evenEdits;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentEdits = evenEdits;</span><br><span class="line">            previousEdits = oddEdits;</span><br><span class="line">        &#125;</span><br><span class="line">        currentEdits[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; small.length() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (big.charAt(j - <span class="number">1</span>) == small.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                currentEdits[j] = previousEdits[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentEdits[j] = <span class="number">1</span> + Math.min(previousEdits[j - <span class="number">1</span>], Math.min(previousEdits[j], currentEdits[j - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> big.length() % <span class="number">2</span> == <span class="number">0</span> ? evenEdits[small.length()] : oddEdits[small.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-583-Delete-Operation-for-Two-Strings"><a href="#Unsolved-583-Delete-Operation-for-Two-Strings" class="headerlink" title="Unsolved 583. Delete Operation for Two Strings"></a><a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">Unsolved 583. Delete Operation for Two Strings</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"sea"</span>, <span class="string">"eat"</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: You need one step to make <span class="string">"sea"</span> to <span class="string">"ea"</span> and another step to make <span class="string">"eat"</span> to <span class="string">"ea"</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-23"><a href="#Solution1-23" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="Unsolved-Max-Sum-Increasing-Subsequence-AE"><a href="#Unsolved-Max-Sum-Increasing-Subsequence-AE" class="headerlink" title="Unsolved Max Sum Increasing Subsequence(AE)"></a>Unsolved Max Sum Increasing Subsequence(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array [<span class="number">8</span>,   <span class="number">12</span>, <span class="number">2</span>,   <span class="number">3</span>,      <span class="number">15</span>, <span class="number">5</span> , <span class="number">7</span>]</span><br><span class="line">sums  [<span class="number">8</span>, <span class="number">8</span>+<span class="number">12</span>, <span class="number">2</span>, <span class="number">2</span>+<span class="number">3</span>, <span class="number">8</span>+<span class="number">12</span>+<span class="number">15</span>,  ]</span><br><span class="line">	  [<span class="number">8</span>, <span class="number">20</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">35</span>, ]</span><br><span class="line">sequ  [none,<span class="number">0</span>,none, <span class="number">2</span>, <span class="number">1</span>] (track the index)</span><br><span class="line">    </span><br><span class="line">formula:</span><br><span class="line">currentSum = array[i] (ex. i = <span class="number">5</span>)</span><br><span class="line">otherSum = array[j] <span class="number">0</span> =&lt; j &lt; i</span><br><span class="line">    <span class="keyword">if</span> otherSum &lt; currentSum and sums[j] + currentSum &gt;=  sums[i]</span><br><span class="line">        update sums</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-24"><a href="#Solution1-24" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Space O(n) Time O(n^2)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; maxSumIncreasingSubsequence(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] sequences = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    Arrays.fill(sequences, Integer.MIN_VALUE);</span><br><span class="line">    <span class="keyword">int</span>[] sums = array.clone();</span><br><span class="line">    <span class="keyword">int</span> maxSumIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> currentNum = array[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> otherNum = array[j];</span><br><span class="line">            <span class="keyword">if</span> (otherNum &lt; currentNum &amp;&amp; sums[j] + currentNum &gt;= sums[i]) &#123;</span><br><span class="line">                sums[i] = sums[j] + currentNum;</span><br><span class="line">                sequences[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sums[i] &gt;= sums[maxSumIdx]) &#123;</span><br><span class="line">            maxSumIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildSequence(array, sequences, maxSumIdx, sums[maxSumIdx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; buildSequence(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] sequences, <span class="keyword">int</span> currentIdx, <span class="keyword">int</span> sums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; sequence = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    sequence.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    sequence.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    sequence.get(<span class="number">0</span>).add(sums);</span><br><span class="line">    <span class="keyword">while</span> (currentIdx != Integer.MIN_VALUE) &#123;</span><br><span class="line">        sequence.get(<span class="number">1</span>).add(<span class="number">0</span>, array[currentIdx]);</span><br><span class="line">        currentIdx = sequences[currentIdx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Longest-Common-Subsequence-AE-✨"><a href="#Unsolved-Longest-Common-Subsequence-AE-✨" class="headerlink" title="Unsolved Longest Common Subsequence(AE)✨"></a>Unsolved Longest Common Subsequence(AE)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Str1:ZXVVYZW</span><br><span class="line">Str2:XKYKZPW</span><br><span class="line">   <span class="string">""</span>   X   K   Y   K   Z   P   W</span><br><span class="line"><span class="string">""</span> <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span></span><br><span class="line">Z  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>  <span class="string">""</span>   Z   Z   Z</span><br><span class="line">X  <span class="string">""</span>   X   X   X   X   X   X   X</span><br><span class="line">V  <span class="string">""</span>   X   X   X   X   X   X   X</span><br><span class="line">V  <span class="string">""</span>   X   X   X   X   X   X   X</span><br><span class="line">Y  <span class="string">""</span>   X   X  XY  XY  XY  XY  XY</span><br><span class="line">Z  <span class="string">""</span>   X   X  XY  XY XYZ XYZ XYZ</span><br><span class="line">W  <span class="string">""</span>   X   X  XY  XY XYZ XYZ XYZW</span><br><span class="line">in pos[<span class="number">1</span>,<span class="number">1</span>] compare <span class="string">"Z"</span>,<span class="string">"X"</span> </span><br><span class="line">    last letter is not same so remove one become <span class="string">""</span>,<span class="string">"X"</span> or <span class="string">"Z"</span>,<span class="string">""</span> correspond to pos[<span class="number">0</span>,<span class="number">1</span>] pos[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">in pos[<span class="number">1</span>,<span class="number">2</span>] compare <span class="string">"Z"</span>,<span class="string">"XK"</span> <span class="comment">//same flow</span></span><br><span class="line">    last letter is not same so remove one become <span class="string">""</span>,<span class="string">"XK"</span> or <span class="string">"Z"</span>,<span class="string">"X"</span> correspond to pos[<span class="number">0</span>,<span class="number">2</span>] pos[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">in pos[<span class="number">1</span>,<span class="number">5</span>] compare <span class="string">"Z"</span>,<span class="string">"XKYKZ"</span></span><br><span class="line">    last letter is same, we remove last letter and add it to LCS, which is diagram pos[<span class="number">0</span>, <span class="number">4</span>] = <span class="string">""</span></span><br><span class="line">in pos[<span class="number">1</span>,<span class="number">6</span>] compare <span class="string">"Z"</span>,<span class="string">"XKYKZP"</span></span><br><span class="line">    last letter is not same, so remove one become <span class="string">""</span>,<span class="string">"XKYKZP"</span> or <span class="string">"Z"</span>,<span class="string">"XKYKZP"</span></span><br><span class="line">in pos[<span class="number">5</span>,<span class="number">3</span>] compare <span class="string">"ZXVVY"</span>,<span class="string">"XKY"</span></span><br><span class="line">    last letter is same, we remove last letter and add it to LCS, which is diagram pos[<span class="number">4</span>, <span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line">in pos[<span class="number">6</span>,<span class="number">3</span>] compare <span class="string">"ZXVVYZ"</span>,<span class="string">"XKY"</span></span><br><span class="line">    last letter is not same so remove one become <span class="string">"ZXVVY"</span>,<span class="string">"XKY"</span> or <span class="string">"ZXVVYZ"</span>,<span class="string">"XK"</span> correspond to pos[<span class="number">5</span>,<span class="number">3</span>] = <span class="string">"XY"</span> pos[<span class="number">6</span>,<span class="number">2</span>] = <span class="string">"X"</span>, take longer one</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-25"><a href="#Solution1-25" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>O(NM*min(N, M)) time, O(NM *min(N, M)) space </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Character&gt; <span class="title">longestCommonSubsequence</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;List&lt;Character&gt;&gt;&gt; lcs = <span class="keyword">new</span> ArrayList&lt;List&lt;List&lt;Character&gt;&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str2.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        lcs.add(<span class="keyword">new</span> ArrayList&lt;List&lt;Character&gt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str1.length() + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            lcs.get(i).add(<span class="keyword">new</span> ArrayList&lt;Character&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str2.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; str1.length() + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str2.charAt(i - <span class="number">1</span>) == str1.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">            	List&lt;Character&gt; copy = <span class="keyword">new</span> ArrayList&lt;Character&gt;(lcs.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>));</span><br><span class="line">	            lcs.get(i).set(j, copy);</span><br><span class="line">    	        lcs.get(i).get(j).add(str2.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lcs.get(i - <span class="number">1</span>).get(j).size() &gt; lcs.get(i).get(j - <span class="number">1</span>).size()) &#123;</span><br><span class="line">                    lcs.get(i).set(j, lcs.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lcs.get(i).set(j, lcs.get(i).get(j - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lcs.get(str2.length()).get(str1.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1143-Longest-Common-Subsequence✨"><a href="#1143-Longest-Common-Subsequence✨" class="headerlink" title="1143. Longest Common Subsequence✨"></a><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. Longest Common Subsequence✨</a></h3><h3 id="Solution1-26"><a href="#Solution1-26" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="Knapsack-Problem-AE"><a href="#Knapsack-Problem-AE" class="headerlink" title="Knapsack Problem(AE)"></a>Knapsack Problem(AE)</h2><h3 id="Solution1-27"><a href="#Solution1-27" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">first index represent the value</span><br><span class="line">second index represent the weight</span><br><span class="line">maximizing the value and the weight did not exceed the knapsack capacity</span><br><span class="line">build a <span class="number">2</span>D array</span><br><span class="line">capacity: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">[]        <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>  <span class="number">1</span></span><br><span class="line">[<span class="number">4</span>,<span class="number">3</span>]     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span>  <span class="number">5</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>]     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span>  <span class="number">9</span></span><br><span class="line">[<span class="number">6</span>,<span class="number">7</span>]     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> w &lt;= j</span><br><span class="line">	values[i][j] = Math.max(values[i - <span class="number">1</span>][j], value[i - <span class="number">1</span>][j - w] + v)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	values[i][j] = values[i - <span class="number">1</span>][j]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; knapsackProblem(<span class="keyword">int</span>[][] items, <span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] knapsackValues = <span class="keyword">new</span> <span class="keyword">int</span>[items.length + <span class="number">1</span>][capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; items.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> currentWeight = items[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> currentValue = items[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; capacity + <span class="number">1</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentWeight &gt; c) &#123;</span><br><span class="line">                knapsackValues[i][c] = knapsackValues[i - <span class="number">1</span>][c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                knapsackValues[i][c] = Math.max(knapsackValues[i - <span class="number">1</span>][c], knapsackValues[i - <span class="number">1</span>][c - currentWeight] + currentValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getKnapsackItems(knapsackValues, items, knapsackValues[items.length][capacity]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getKnapsackItems(<span class="keyword">int</span>[][] knapsackValues, <span class="keyword">int</span>[][] items, <span class="keyword">int</span> weight) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; sequence = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; totalWeight = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    totalWeight.add(weight);</span><br><span class="line">    sequence.add(totalWeight);</span><br><span class="line">    sequence.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">int</span> i = knapsackValues.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = knapsackValues[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (knapsackValues[i][c] == knapsackValues[i - <span class="number">1</span>][c]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence.get(<span class="number">1</span>).add(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">            c -= items[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Disk-Stacking-AE"><a href="#Disk-Stacking-AE" class="headerlink" title="Disk Stacking(AE)"></a>Disk Stacking(AE)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[2,2,1], [2,1,2],[3,2,3],[2,3,4],[4,4,5],[2,2,8]]</span><br><span class="line">width, depth, height</span><br><span class="line">sort by height</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-28"><a href="#Solution1-28" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer[]&gt; diskStacking(List&lt;Integer[]&gt; disks) &#123;</span><br><span class="line">    disks.sort((disk1, disk2) -&gt; disk1[<span class="number">2</span>].compareTo(disk[<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[disk.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disks.size(); i++) &#123;</span><br><span class="line">        heights[i] = disks.get(i)[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] sequences = <span class="keyword">new</span> <span class="keyword">int</span>[disks.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; disk.size(); i++) &#123;</span><br><span class="line">        Integer[] currentDisk = disks.get(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            Integer[] otehrDisk = disk.get(j);</span><br><span class="line">            <span class="keyword">if</span> (areValidDimensions(otherDisk, currentDisk)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (heights[i] &lt;= currentDisk[<span class="number">2</span>] + heights[j]) &#123;</span><br><span class="line">                    heights[i] = currentDIsk[<span class="number">2</span>] + heights[j];</span><br><span class="line">                    sequences[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heights[i] &gt;= heights[maxHeightIdx]) &#123;</span><br><span class="line">            maxHeightIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildSequence(disks, sequences, maxHeightIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="✅Number-of-Paths💜"><a href="#✅Number-of-Paths💜" class="headerlink" title="✅Number of Paths💜"></a><a href="https://github.com/JiawenQi98/PrampPractice/tree/master/Number%20of%20Paths" target="_blank" rel="noopener">✅Number of Paths💜</a></h2><p><img src="https://raw.githubusercontent.com/JiawenQi98/PrampPractice/master/Number%20of%20Paths/example.png" alt=""></p>
<ol>
<li><p>If you are already at the destination, there is obviously only one possible path to the destination, so we set the value for the destination to <code>1</code> (this would be the base case in your recursive version):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          ？</span><br><span class="line">        ? ?</span><br><span class="line">      ? ? ?</span><br><span class="line">    ? ? ? ?</span><br><span class="line">  ? ? ? ? ?</span><br><span class="line"><span class="number">1</span> ? ? ? ? ?</span><br></pre></td></tr></table></figure>

<p>Since every value in the lookup table is the sum of the value above it and the value to its right, we can first fill up the rightmost column from top to bottom (since the values in the rightmost column have no value to their right, every value in this column is identical to the value above it):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">1</span></span><br><span class="line">        ? <span class="number">1</span></span><br><span class="line">      ? ? <span class="number">1</span></span><br><span class="line">    ? ? ? <span class="number">1</span></span><br><span class="line">  ? ? ? ? <span class="number">1</span></span><br><span class="line">? ? ? ? ? <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Now we fill up the next rightmost column in the same way. The upmost element has no value above it, so it is identical to the value to its right.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">1</span></span><br><span class="line">        <span class="number">1</span> <span class="number">1</span></span><br><span class="line">      ? <span class="number">2</span> <span class="number">1</span></span><br><span class="line">    ? ? <span class="number">3</span> <span class="number">1</span></span><br><span class="line">  ? ? ? <span class="number">4</span> <span class="number">1</span></span><br><span class="line">? ? ? ? <span class="number">5</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Repeat this for all the other columns until you have the final lookup table:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">            ? ← destination</span><br><span class="line">          ? ?</span><br><span class="line">        ? ? ?</span><br><span class="line">      ? ? ? ?</span><br><span class="line">    ? ? ? ? ?</span><br><span class="line">  ? ? ? ? ? ?</span><br><span class="line">  ↑</span><br><span class="line">start</span><br><span class="line">                <span class="number">1</span></span><br><span class="line">             <span class="number">1</span>  <span class="number">1</span></span><br><span class="line">          <span class="number">2</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">       <span class="number">5</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">1</span></span><br><span class="line">   <span class="number">14</span> <span class="number">14</span>  <span class="number">9</span>  <span class="number">4</span>  <span class="number">1</span></span><br><span class="line"><span class="number">42</span> <span class="number">42</span> <span class="number">28</span> <span class="number">14</span>  <span class="number">5</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">calculate how many ways form current position to destination</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];     </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        dp[i][j] += dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOfPaths</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DP method: Time O(n^2), Space O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numOfPathsToDest</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">40</span>;</span><br><span class="line">        System.out.println(<span class="string">"Number of ways of n = "</span> + n1 + <span class="string">" is: "</span>+ numOfPathsToDest(n1));</span><br><span class="line">        System.out.println(<span class="string">"Number of ways of n = "</span> + n2 + <span class="string">" is: "</span>+ numOfPathsToDest(n2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62.Unique Paths"></a><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">62.Unique Paths</a></h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). </p>
<p>The robot can <strong>only move either down or right</strong> at any point in time. </p>
<p>The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there?</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt=""></p>
<p>Above is a 3 x 7 grid. How many possible unique paths are there? Note: m and n will be at most 100.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of <span class="number">3</span> ways to reach the bottom-right corner:</span><br><span class="line"><span class="number">1</span>. Right -&gt; Down -&gt; Down</span><br><span class="line"><span class="number">2</span>. Down -&gt; Down -&gt; Right</span><br><span class="line"><span class="number">3</span>. Down -&gt; Right -&gt; Down</span><br><span class="line">    </span><br><span class="line">Input: m = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">Output: <span class="number">28</span></span><br><span class="line">    </span><br><span class="line">formula dp[i] [j] = dp[i - <span class="number">1</span>] [j] + dp[i] [j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-29"><a href="#Solution1-29" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：动态规划，如果沿某边走则只有一种可能（初始化），然后内侧逐 1 添加可能性，当前可能性是上一 行和上一列相应位置的和。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        table[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        table[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; m; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">1</span>; column &lt; n; column++) &#123;</span><br><span class="line">            table[row][column] = table[row - <span class="number">1</span>][column] + table[row][column - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. Unique Paths II</a></h3><p>Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example, There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[ [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] ]</span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation:</span><br><span class="line">There is one obstacle in the middle of the <span class="number">3</span>x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line"><span class="number">1</span>. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line"><span class="number">2</span>. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure>

<p>The total number of unique paths is 2.</p>
<h3 id="Sulution1"><a href="#Sulution1" class="headerlink" title="Sulution1:"></a>Sulution1:</h3><ol>
<li>思路：动态规划。与上题解法类似，多一点碰障碍置零。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">//initial start point</span></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//initial upper boarder base line</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//initial left boarder base line</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//start traversal and apply the formula</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UnsolvedSolution2"><a href="#UnsolvedSolution2" class="headerlink" title="UnsolvedSolution2:"></a>UnsolvedSolution2:</h3><ol>
<li><a href="https://leetcode.com/problems/unique-paths-ii/discuss/23250/Short-JAVA-solution" target="_blank" rel="noopener">思路</a></li>
<li>More explanation:<br>This is a typical 2D DP problem, we can store value in 2D DP array, but since we only need to use value at dp[i - 1][j] and dp[i][j - 1] to update dp[i][j], we don’t need to store the whole 2D table, but instead store value in an 1D array, and update data by using dp[j] = dp[j] + dp[j - 1], (where here dp[j] corresponding to the dp[i - 1][j]) and dp[j - 1] corresponding to the dp[i][j - 1] in the 2D array)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> width = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[width];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] row : obstacleGrid) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[j] == <span class="number">1</span>)</span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[width - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="70-Climbing-Stairs✨"><a href="#70-Climbing-Stairs✨" class="headerlink" title="70. Climbing Stairs✨"></a><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing Stairs✨</a></h2><h3 id="Solution1-30"><a href="#Solution1-30" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Basically it’s a fibonacci.</p>
<p>Base cases:<br>if n &lt;= 0, then the number of ways should be zero.<br>if n == 1, then there is only way to climb the stair.<br>if n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time.</p>
</li>
<li><p>The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points <code>[n-1]</code> and <code>[n-2]</code> respectively, denoted as <code>n1</code> and <code>n2</code> , then the total ways to get to the point <code>[n]</code> is <code>n1 + n2</code>. Because from the <code>[n-1]</code> point, we can take one single step to reach <code>[n]</code>. And from the <code>[n-2]</code> point, we could take two steps to get there.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base cases</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] ways = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    ways[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    ways[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ways[i] = ways[i - <span class="number">1</span>] + ways[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-11"><a href="#Solution2-11" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>sliding windows</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] steps = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = steps[<span class="number">0</span>] + steps[<span class="number">1</span>];</span><br><span class="line">        steps[<span class="number">0</span>] = steps[<span class="number">1</span>];</span><br><span class="line">        steps[<span class="number">1</span>] = cur;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = first + second;</span><br><span class="line">        first = second;</span><br><span class="line">        second = cur;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">1</span> ? second : first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-1659-Maximize-Grid-Happiness"><a href="#Unsolved-1659-Maximize-Grid-Happiness" class="headerlink" title="Unsolved 1659. Maximize Grid Happiness"></a><a href="https://leetcode.com/problems/maximize-grid-happiness/" target="_blank" rel="noopener">Unsolved 1659. Maximize Grid Happiness</a></h2><h2 id="1621-Number-of-Sets-of-K-Non-Overlapping-Line-Segments🎃"><a href="#1621-Number-of-Sets-of-K-Non-Overlapping-Line-Segments🎃" class="headerlink" title="1621. Number of Sets of K Non-Overlapping Line Segments🎃"></a><a href="https://leetcode.com/contest/biweekly-contest-37/problems/number-of-sets-of-k-non-overlapping-line-segments/" target="_blank" rel="noopener">1621. Number of Sets of K Non-Overlapping Line Segments🎃</a></h2><h2 id="Solution1-31"><a href="#Solution1-31" class="headerlink" title="Solution1:"></a>Solution1:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Integer[][][] memo;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSets</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.memo = <span class="keyword">new</span> Integer[n+<span class="number">1</span>][k+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp(<span class="number">0</span>, k, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k, <span class="keyword">int</span> isStart)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memo[i][k][isStart] != <span class="keyword">null</span>) <span class="keyword">return</span> memo[i][k][isStart];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// Found a way to draw k valid segments</span></span><br><span class="line">    <span class="keyword">if</span> (i == n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Reach end of points</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = dp(i+<span class="number">1</span>, k, isStart); <span class="comment">// Skip ith point</span></span><br><span class="line">    <span class="keyword">if</span> (isStart == <span class="number">1</span>)</span><br><span class="line">        ans += dp(i+<span class="number">1</span>, k, <span class="number">0</span>); <span class="comment">// Take ith point as start</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans += dp(i, k-<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// Take ith point as end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[i][k][isStart] = ans % <span class="number">1_000_000_007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕343-Integer-Break🎶"><a href="#🌕343-Integer-Break🎶" class="headerlink" title="🌕343. Integer Break🎶"></a><a href="https://leetcode.com/problems/integer-break/" target="_blank" rel="noopener">🌕343. Integer Break🎶</a></h2><h3 id="Solution1-32"><a href="#Solution1-32" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Integer[] dp = <span class="keyword">new</span> Integer[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> findMaxValue(n, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxValue</span><span class="params">(<span class="keyword">int</span> n, Integer[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[n] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> curMax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            curMax = Math.max(curMax, i * findMaxValue(n - i, dp));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n] = curMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="516-Unsolved-Longest-Palindromic-Subsequence"><a href="#516-Unsolved-Longest-Palindromic-Subsequence" class="headerlink" title="516. Unsolved Longest Palindromic Subsequence"></a><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. Unsolved Longest Palindromic Subsequence</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]`: the longest palindromic subsequence<span class="string">'s length of substring(i, j), here i, j represent left, right indexes in the string</span></span><br><span class="line"><span class="string">`State transition`:</span></span><br><span class="line"><span class="string">`dp[i][j] = dp[i+1][j-1] + 2` if s.charAt(i) == s.charAt(j)</span></span><br><span class="line"><span class="string">otherwise, `dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])`</span></span><br><span class="line"><span class="string">`Initialization`: `dp[i][i] = 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-33"><a href="#Solution1-33" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()][s.length()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][s.length()-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="486-Predict-the-Winner"><a href="#486-Predict-the-Winner" class="headerlink" title="486. Predict the Winner"></a><a href="https://leetcode.com/problems/predict-the-winner/" target="_blank" rel="noopener">486. Predict the Winner</a></h2><h3 id="Solution1-34"><a href="#Solution1-34" class="headerlink" title="Solution1:"></a>Solution1:</h3><h2 id="Unsolved-787-Cheapest-Flights-Within-K-Stops🎂"><a href="#Unsolved-787-Cheapest-Flights-Within-K-Stops🎂" class="headerlink" title="Unsolved 787. Cheapest Flights Within K Stops🎂"></a><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 787. Cheapest Flights Within K Stops🎂</a></h2><h2 id="Unsolved-1373-Maximum-Sum-BST-in-Binary-Tree🎂✨"><a href="#Unsolved-1373-Maximum-Sum-BST-in-Binary-Tree🎂✨" class="headerlink" title="Unsolved 1373. Maximum Sum BST in Binary Tree🎂✨"></a><a href="https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 1373. Maximum Sum BST in Binary Tree🎂✨</a></h2><h2 id="Unsolved-44-Wildcard-Matching🎂✨🎶"><a href="#Unsolved-44-Wildcard-Matching🎂✨🎶" class="headerlink" title="Unsolved 44. Wildcard Matching🎂✨🎶"></a><a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">Unsolved 44. Wildcard Matching🎂✨🎶</a></h2><h3 id="Solution1-35"><a href="#Solution1-35" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：动态规划。推理条件：如果 p 是<em>，则与 p 或 s 上一位置结果相同；如果不是</em>，则看当前字符是否 match。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != <span class="string">'*'</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                &amp;&amp; (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>)</span><br><span class="line">                    || p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-12"><a href="#Solution2-12" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>The basic idea is to have one pointer for the string and one pointer for the pattern. This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step.</li>
<li><a href="https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution" target="_blank" rel="noopener">explanation</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">comparison</span><span class="params">(String str, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, p = <span class="number">0</span>, match = <span class="number">0</span>, starIdx = -<span class="number">1</span>;            </span><br><span class="line">    <span class="keyword">while</span> (s &lt; str.length())&#123;</span><br><span class="line">        <span class="comment">// advancing both pointers</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; pattern.length()  &amp;&amp; (pattern.charAt(p) == <span class="string">'?'</span> || str.charAt(s) == pattern.charAt(p)))&#123;</span><br><span class="line">            s++;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// * found, only advancing pattern pointer</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            starIdx = p;</span><br><span class="line">            match = s;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// last pattern pointer was *, advancing string pointer</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (starIdx != -<span class="number">1</span>)&#123;</span><br><span class="line">            p = starIdx + <span class="number">1</span>;</span><br><span class="line">            match++;</span><br><span class="line">            s = match;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//current pattern pointer is not star, last patter pointer was not *</span></span><br><span class="line">        <span class="comment">//characters do not match</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//check for remaining characters in pattern</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == <span class="string">'*'</span>)</span><br><span class="line">        p++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p == pattern.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="256-Paint-House"><a href="#256-Paint-House" class="headerlink" title="256. Paint House"></a><a href="https://leetcode.com/problems/paint-house/" target="_blank" rel="noopener">256. Paint House</a></h2><h3 id="Solution1-36"><a href="#Solution1-36" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">        costs[i][<span class="number">0</span>] += Math.min(costs[i - <span class="number">1</span>][<span class="number">1</span>], costs[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        costs[i][<span class="number">1</span>] += Math.min(costs[i - <span class="number">1</span>][<span class="number">0</span>], costs[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        costs[i][<span class="number">2</span>] += Math.min(costs[i - <span class="number">1</span>][<span class="number">0</span>], costs[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = Math.min(costs[costs.length - <span class="number">1</span>][<span class="number">0</span>], costs[costs.length - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    min = Math.min(min, costs[costs.length - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-464-Can-I-Win🎂"><a href="#Unsolved-464-Can-I-Win🎂" class="headerlink" title="Unsolved 464. Can I Win🎂"></a><a href="https://leetcode.com/problems/can-i-win/" target="_blank" rel="noopener">Unsolved 464. Can I Win🎂</a></h2><h3 id="Solution1-37"><a href="#Solution1-37" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><a href="https://leetcode.com/problems/can-i-win/discuss/95277/Java-solution-using-HashMap-with-detailed-explanation" target="_blank" rel="noopener">explanation</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (desiredTotal&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxChoosableInteger*(maxChoosableInteger+<span class="number">1</span>)/<span class="number">2</span>&lt;desiredTotal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> canIWin(desiredTotal, <span class="keyword">new</span> <span class="keyword">int</span>[maxChoosableInteger], <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">int</span>[] state, HashMap&lt;String, Boolean&gt; hashMap)</span> </span>&#123;</span><br><span class="line">    String curr=Arrays.toString(state);</span><br><span class="line">    <span class="keyword">if</span> (hashMap.containsKey(curr)) <span class="keyword">return</span> hashMap.get(curr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;state.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state[i]==<span class="number">0</span>) &#123;</span><br><span class="line">            state[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (total&lt;=i+<span class="number">1</span> || !canIWin(total-(i+<span class="number">1</span>), state, hashMap)) &#123;</span><br><span class="line">                hashMap.put(curr, <span class="keyword">true</span>);</span><br><span class="line">                state[i]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            state[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hashMap.put(curr, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1664-Ways-to-Make-a-Fair-Array"><a href="#1664-Ways-to-Make-a-Fair-Array" class="headerlink" title="1664. Ways to Make a Fair Array"></a><a href="https://leetcode.com/problems/ways-to-make-a-fair-array/" target="_blank" rel="noopener">1664. Ways to Make a Fair Array</a></h2><h3 id="Solution1-38"><a href="#Solution1-38" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Explanation</p>
<p>We will split the array into two parts, <code>left</code> and <code>right</code>.<br>Firstly we count the sum to an array <code>right</code>,<br>where <code>right[0] = A[0] + A[2] +...</code><br>and <code>right[1] = A[1] + A[3] +...</code></p>
<p>Now we iterates the whole array <code>A</code>, and try to split at each <code>A[i]</code>.<br>When move one element from <code>right</code> to <code>left</code>,<br>we reduce the sum in <code>right</code>,<br>check the if it’s fair,<br>then increse the sum in <code>left</code>.</p>
<p>Complexity</p>
<p>Time <code>O(N)</code><br>Space <code>O(1)</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToMakeFair</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sumEven = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sumOdd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) sumEven += nums[i];</span><br><span class="line">        <span class="keyword">else</span> sumOdd += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curEven = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curOdd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEven + sumOdd - curOdd == curOdd + sumEven - curEven - nums[i]) count++;</span><br><span class="line">            curEven += nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEven + sumOdd - curOdd - nums[i] == curOdd + sumEven - curEven) count++;</span><br><span class="line">            curOdd += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-410-Split-Array-Largest-Sum🎂✨🎶"><a href="#🌕Unsolved-410-Split-Array-Largest-Sum🎂✨🎶" class="headerlink" title="🌕Unsolved 410. Split Array Largest Sum🎂✨🎶"></a><a href="https://leetcode.com/problems/split-array-largest-sum/?utm_source=AlgoTogether&utm_campaign=dc64242af2-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_2&utm_medium=email&utm_term=0_38d4e2e3e2-dc64242af2-231340480" target="_blank" rel="noopener">🌕Unsolved 410. Split Array Largest Sum🎂✨🎶</a></h2><p>Given an array <code>nums</code> which consists of non-negative integers and an integer <code>m</code>, you can split the array into <code>m</code> non-empty continuous subarrays.</p>
<p>Write an algorithm to minimize the largest sum among these <code>m</code> subarrays.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">8</span>], m = <span class="number">2</span></span><br><span class="line">Output: <span class="number">18</span></span><br><span class="line">Explanation:</span><br><span class="line">There are four ways to split nums into two subarrays.</span><br><span class="line">The best way is to split it into [<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>] and [<span class="number">10</span>,<span class="number">8</span>],</span><br><span class="line">where the largest sum among the two subarrays is only <span class="number">18</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-39"><a href="#Solution1-39" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><a href="https://leetcode.com/problems/split-array-largest-sum/discuss/89817/Clear-Explanation%3A-8ms-Binary-Search-Java" target="_blank" rel="noopener">Explaination</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[nums.length + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    preSum[nums.length - <span class="number">1</span>] = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        preSum[i] = preSum[i + <span class="number">1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findMin(<span class="number">0</span>, nums, preSum, m, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] preSum, <span class="keyword">int</span> m, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case, m == 1, will be sum of remain array</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> preSum[idx];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dp[idx][m] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意 i &lt;= nums.length - m, 要留m - 1个给后面子数组进行分配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; nums.length - m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            left += nums[i];</span><br><span class="line">            <span class="keyword">int</span> right = findMin(i + <span class="number">1</span>, nums, preSum, m - <span class="number">1</span>, dp);</span><br><span class="line">            <span class="comment">//minimize the largest sum among subarrays</span></span><br><span class="line">            min = Math.min(min, Math.max(left, right));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx][m] = min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Grokking-Dynamic-Programming-Patterns-for-Coding-Interviews"><a href="#Grokking-Dynamic-Programming-Patterns-for-Coding-Interviews" class="headerlink" title="Grokking Dynamic Programming Patterns for Coding Interviews"></a>Grokking Dynamic Programming Patterns for Coding Interviews</h1><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="Nth-Fib"><a href="#Nth-Fib" class="headerlink" title="Nth Fib"></a>Nth Fib</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CalculateFibonacci(n-<span class="number">1</span>) + CalculateFibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-with-Memoization"><a href="#Top-down-with-Memoization" class="headerlink" title="Top-down with Memoization"></a>Top-down with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> memoize[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> CalculateFibonacciRecursive(memoize, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacciRecursive</span><span class="params">(<span class="keyword">int</span>[] memoize, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have already solved this subproblem, simply return the result from the cache</span></span><br><span class="line">    <span class="keyword">if</span>(memoize[n] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> memoize[n];</span><br><span class="line"></span><br><span class="line">    memoize[n] = CalculateFibonacciRecursive(memoize, n-<span class="number">1</span>) + CalculateFibonacciRecursive(memoize, n-<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memoize[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-with-Tabulation"><a href="#Bottom-up-with-Tabulation" class="headerlink" title="Bottom-up with Tabulation"></a>Bottom-up with Tabulation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base cases</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pattern-1-0-1-Knapsack"><a href="#Pattern-1-0-1-Knapsack" class="headerlink" title="Pattern 1: 0/1 Knapsack"></a>Pattern 1: 0/1 Knapsack</h1><h2 id="🌕0-1-Knapsack✨"><a href="#🌕0-1-Knapsack✨" class="headerlink" title="🌕0/1 Knapsack✨"></a>🌕0/1 Knapsack✨</h2><h3 id="brute-force-solution"><a href="#brute-force-solution" class="headerlink" title="brute-force solution"></a>brute-force solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n) recursion tree</span></span><br><span class="line"><span class="comment">//Space O(n) call stack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after choosing the element at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the weight of the element at currentIndex exceeds the capacity, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( weights[currentIndex] &lt;= capacity ) &#123;</span><br><span class="line">        profit1 = profits[currentIndex] + knapsackRecursive(profits, weights, capacity - weights[currentIndex], currentIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the element at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> profit2 = knapsackRecursive(profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(profit1, profit2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization"><a href="#Top-down-Dynamic-Programming-with-Memoization" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(N * C) N * C sub problems</span></span><br><span class="line"><span class="comment">//Space O(N * C + N) dp array + call stack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[profits.length][capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(dp, profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(Integer[][] dp, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] profits, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] weights, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> capacity, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex][capacity] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( weights[currentIndex] &lt;= capacity ) &#123;</span><br><span class="line">            profit1 = profits[currentIndex] + knapsackRecursive(dp, profits, weights, capacity - weights[currentIndex], currentIndex + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit2 = knapsackRecursive(dp, profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line">        dp[currentIndex][capacity] = Math.max(profit1, profit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have already solved a similar problem, return the result from memory directly</span></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since our memoization array <code>dp[profits.length][capacity+1]</code> stores the results for all the subproblems, we can conclude that we will not have more than N<em>C</em>N<em>∗</em>C* subproblems (where ‘N’ is the number of items and ‘C’ is the knapsack capacity). This means that our time complexity will be O(N<em>C)*O</em>(<em>N</em>∗<em>C</em>).</p>
<p>The above algorithm will be using O(N<em>C)*O</em>(<em>N</em>∗<em>C</em>) space for the memoization array. Other than that, we will use O(N)<em>O</em>(<em>N</em>) space for the recursion call-stack. So the total space complexity will be O(N<em>C + N)*O</em>(<em>N</em>∗<em>C</em>+<em>N</em>), which is asymptotically equivalent to O(N<em>C)*O</em>(<em>N</em>∗<em>C</em>).</p>
<h3 id="Bottom-up-Dynamic-Programming"><a href="#Bottom-up-Dynamic-Programming" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><p><strong>This means, <code>dp[i][c]</code> will represent the maximum knapsack profit for capacity ‘c’ calculated from the first ‘i’ items.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][c] &#x3D; max (dp[i-1][c], profits[i] + dp[i-1][c-weights[i]])</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// basic checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = profits.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the capacity=0 columns, with '0' capacity we have '0' profit</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have only one weight, we will take it if it is not more than the capacity</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(weights[<span class="number">0</span>] &lt;= c)</span><br><span class="line">            dp[<span class="number">0</span>][c] = profits[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// process all sub-arrays for all the capacities</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit1= <span class="number">0</span>, profit2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// include the item, if it is not more than the capacity</span></span><br><span class="line">            <span class="keyword">if</span>(weights[i] &lt;= c)</span><br><span class="line">                profit1 = profits[i] + dp[i-<span class="number">1</span>][c-weights[i]];</span><br><span class="line">            <span class="comment">// exclude the item</span></span><br><span class="line">            profit2 = dp[i-<span class="number">1</span>][c];</span><br><span class="line">            <span class="comment">// take maximum</span></span><br><span class="line">            dp[i][c] = Math.max(profit1, profit2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maximum profit will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Equal-Subset-Sum-Partition✨"><a href="#🌕Equal-Subset-Sum-Partition✨" class="headerlink" title="🌕Equal Subset Sum Partition✨"></a>🌕Equal Subset Sum Partition✨</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 1, 3, 4, 7&#125;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: The given set can be partitioned into two subsets with equal sum: &#123;1, 3, 4&#125; &amp; &#123;1, 7&#125;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; find a set equal to sum &#x2F; 2;</span><br></pre></td></tr></table></figure>

<h3 id="brute-force-algorithm"><a href="#brute-force-algorithm" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n) exponential</span></span><br><span class="line"><span class="comment">//Space O(n) recursion stack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 'sum' is a an odd number, we can't have two subsets with equal sum</span></span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(num, sum/<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPartitionRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after choosing the number at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">if</span>(num[currentIndex] &lt;= sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(canPartitionRecursive(num, sum - num[currentIndex], currentIndex + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">    <span class="keyword">return</span> canPartitionRecursive(num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-1"><a href="#Top-down-Dynamic-Programming-with-Memoization-1" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 'sum' is a an odd number, we can't have two subsets with equal sum</span></span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Boolean[][] dp = <span class="keyword">new</span> Boolean[num.length][sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(dp, num, sum / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPartitionRecursive</span><span class="params">(Boolean[][] dp, <span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have not already processed a similar problem</span></span><br><span class="line">    <span class="keyword">if</span> (dp[currentIndex][sum] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// recursive call after choosing the number at the currentIndex</span></span><br><span class="line">        <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">        <span class="keyword">if</span> (num[currentIndex] &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canPartitionRecursive(dp, num, sum - num[currentIndex], currentIndex + <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[currentIndex][sum] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">        dp[currentIndex][sum] = canPartitionRecursive(dp, num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-1"><a href="#Bottom-up-Dynamic-Programming-1" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="comment">// find the total sum</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 'sum' is a an odd number, we can't have two subsets with same total</span></span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we are trying to find a subset of given numbers that has a total sum of ‘sum/2’.</span></span><br><span class="line">    sum /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 column, as we can always have '0' sum without including any element</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to its value</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            <span class="comment">// if we can get the sum 's' without the number at index 'i'</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][s]) &#123;</span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123; <span class="comment">// else if we can find a subset to get the remaining sum</span></span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="416-Partition-Equal-Subset-Sum✨"><a href="#416-Partition-Equal-Subset-Sum✨" class="headerlink" title="416. Partition Equal Subset Sum✨"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. Partition Equal Subset Sum✨</a></h3><h3 id="Solution0-2"><a href="#Solution0-2" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li>Brute Force</li>
<li>Time exceed</li>
<li>Time Complexity : \mathcal{O}(2^{n})O(2<em>n</em>), where n<em>n</em> is equal to number of array elements. The recursive solution takes the form of a binary tree where there are 2 possibilities for every array element and the maximum depth of the tree could be n<em>n</em>. The time complexity is exponential, hence this approach is exhaustive and results in <em>Time Limit Exceeded (TLE)</em>.</li>
<li>Space Complexity: \mathcal{O}(N)O(<em>N</em>) This space will be used to store the recursion stack. We can’t have more than n<em>n</em> recursive calls on the call stack at any time.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(2^n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// find sum of all array elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        totalSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if totalSum is odd,it cannot be partitioned into equal sum subset</span></span><br><span class="line">    <span class="keyword">if</span> (totalSum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> subSetSum = totalSum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, n - <span class="number">1</span>, subSetSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> subSetSum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base Cases</span></span><br><span class="line">    <span class="keyword">if</span> (subSetSum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || subSetSum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, n - <span class="number">1</span>, subSetSum - nums[n - <span class="number">1</span>]) || dfs(nums, n - <span class="number">1</span>, subSetSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-40"><a href="#Solution1-40" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time Complexity : \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>).<ul>
<li>In the worst case where there is no overlapping calculation, the maximum number of entries in the <code>memo</code> would be m \cdot n<em>m</em>⋅<em>n</em>. For each entry, overall we could consider that it takes constant time, <em>i.e.</em> each invocation of <code>dfs()</code> at most emits one entry in the <code>memo</code>.</li>
<li>The overall computation is proportional to the number of entries in <code>memo</code>. Hence, the overall time complexity is \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>).</li>
</ul>
</li>
<li>Space Complexity: \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>). We are using a 2 dimensional array \text{memo}memo of size (m \cdot n)(<em>m</em>⋅<em>n</em>) and \mathcal{O}(n)O(<em>n</em>) space to store the recursive call stack. This gives us the space complexity as \mathcal{O}(n)O(<em>n</em>) + \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>) = \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// find sum of all array elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        totalSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if totalSum is odd, it cannot be partitioned into equal sum subset</span></span><br><span class="line">    <span class="keyword">if</span> (totalSum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> subSetSum = totalSum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    Boolean[][] memo = <span class="keyword">new</span> Boolean[n + <span class="number">1</span>][subSetSum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, n - <span class="number">1</span>, subSetSum, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, <span class="keyword">int</span> subSetSum, Boolean[][] memo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base Cases</span></span><br><span class="line">    <span class="keyword">if</span> (subSetSum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span> || subSetSum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// check if subSetSum for given n is already computed and stored in memo</span></span><br><span class="line">    <span class="keyword">if</span> (memo[idx][subSetSum] != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[n][subSetSum];</span><br><span class="line">    <span class="keyword">boolean</span> result = dfs(nums, idx - <span class="number">1</span>, subSetSum - nums[idx - <span class="number">1</span>], memo) ||</span><br><span class="line">        dfs(nums, idx - <span class="number">1</span>, subSetSum, memo);</span><br><span class="line">    <span class="comment">// store the result in memo</span></span><br><span class="line">    memo[idx][subSetSum] = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🌕Unsolved-698-Partition-to-K-Equal-Sum-Subsets"><a href="#🌕Unsolved-698-Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="🌕Unsolved 698. Partition to K Equal Sum Subsets"></a><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/" target="_blank" rel="noopener">🌕Unsolved 698. Partition to K Equal Sum Subsets</a></h3><h2 id="Subset-Sum"><a href="#Subset-Sum" class="headerlink" title="Subset Sum"></a>Subset Sum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 2, 3, 7&#125;, S&#x3D;6</span><br><span class="line">Output: True</span><br><span class="line">The given set has a subset whose sum is &#39;6&#39;: &#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>

<h3 id="brute-force-algorithm-1"><a href="#brute-force-algorithm-1" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each number &#39;i&#39; </span><br><span class="line">  create a new set which INCLUDES number &#39;i&#39; if it does not exceed &#39;S&#39;, and recursively </span><br><span class="line">     process the remaining numbers</span><br><span class="line">  create a new set WITHOUT number &#39;i&#39;, and recursively process the remaining numbers </span><br><span class="line">return true if any of the above two sets has a sum equal to &#39;S&#39;, otherwise return false</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-2"><a href="#Top-down-Dynamic-Programming-with-Memoization-2" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> Write - Your - Code</span></span><br><span class="line">    Boolean[][] dp = <span class="keyword">new</span> Boolean[num.length][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> partition(<span class="number">0</span>, num, sum, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, Boolean[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num.length == <span class="number">0</span> || idx &gt;= num.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][sum] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[idx] &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (partition(idx + <span class="number">1</span>, num, sum - num[idx], dp)) &#123;</span><br><span class="line">                dp[idx][sum] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx][sum] = partition(idx + <span class="number">1</span>, num, sum, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-2"><a href="#Bottom-up-Dynamic-Programming-2" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we can always form '0' sum with an empty set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is</span></span><br><span class="line">    <span class="comment">// equal to its value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            <span class="comment">// if we can get the sum 's' without the number at index 'i'</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][s]) &#123;</span><br><span class="line">                dp[i][s] = dp[i - <span class="number">1</span>][s];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                <span class="comment">// else include the number and see if we can find a subset to get the remaining</span></span><br><span class="line">                <span class="comment">// sum</span></span><br><span class="line">                dp[i][s] = dp[i - <span class="number">1</span>][s - num[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[num.length - <span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Minimum-Subset-Sum-Difference🎶"><a href="#🌕Minimum-Subset-Sum-Difference🎶" class="headerlink" title="🌕Minimum Subset Sum Difference🎶"></a>🌕Minimum Subset Sum Difference🎶</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 2, 3, 9&#125;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can partition the given set into two subsets where minimum absolute difference </span><br><span class="line">between the sum of numbers is &#39;3&#39;. Following are the two subsets: &#123;1, 2, 3&#125; &amp; &#123;9&#125;.</span><br><span class="line"></span><br><span class="line">Input: &#123;1, 2, 7, 1, 5&#125;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: We can partition the given set into two subsets where minimum absolute difference </span><br><span class="line">between the sum of number is &#39;0&#39;. Following are the two subsets: &#123;1, 2, 5&#125; &amp; &#123;7, 1&#125;.</span><br></pre></td></tr></table></figure>

<h3 id="brute-force-algorithm-2"><a href="#brute-force-algorithm-2" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for each number &#39;i&#39; </span><br><span class="line">  add number &#39;i&#39; to S1 and recursively process the remaining numbers</span><br><span class="line">  add number &#39;i&#39; to S2 and recursively process the remaining numbers</span><br><span class="line">return the minimum absolute difference of the above two sets</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n)</span></span><br><span class="line"><span class="comment">//Space O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(num, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">canPartitionRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> sum1, <span class="keyword">int</span> sum2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (currentIndex == num.length)</span><br><span class="line">        <span class="keyword">return</span> Math.abs(sum1 - sum2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after including the number at the currentIndex in the first set</span></span><br><span class="line">    <span class="keyword">int</span> diff1 = canPartitionRecursive(num, currentIndex+<span class="number">1</span>, sum1+num[currentIndex], sum2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after including the number at the currentIndex in the second set</span></span><br><span class="line">    <span class="keyword">int</span> diff2 = canPartitionRecursive(num, currentIndex+<span class="number">1</span>, sum1, sum2+num[currentIndex]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(diff1, diff2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-3"><a href="#Top-down-Dynamic-Programming-with-Memoization-3" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">      sum += num[i];</span><br><span class="line"></span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[num.length][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canPartitionRecursive(dp, num, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">canPartitionRecursive</span><span class="params">(Integer[][] dp, <span class="keyword">int</span>[] num, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> sum1, <span class="keyword">int</span> sum2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex == num.length)</span><br><span class="line">      <span class="keyword">return</span> Math.abs(sum1 - sum2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we have not already processed similar problem</span></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex][sum1] == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// recursive call after including the number at the currentIndex in the first set</span></span><br><span class="line">      <span class="keyword">int</span> diff1 = canPartitionRecursive(dp, num, currentIndex + <span class="number">1</span>, sum1 + num[currentIndex], sum2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// recursive call after including the number at the currentIndex in the second set</span></span><br><span class="line">      <span class="keyword">int</span> diff2 = canPartitionRecursive(dp, num, currentIndex + <span class="number">1</span>, sum1, sum2 + num[currentIndex]);</span><br><span class="line"></span><br><span class="line">      dp[currentIndex][sum1] = Math.min(diff1, diff2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][sum1];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-3"><a href="#Bottom-up-Dynamic-Programming-3" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)</span><br><span class="line">        sum += num[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][sum/<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we can always form '0' sum with an empty set</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to that number</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum/<span class="number">2</span> ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="keyword">true</span> : <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum/<span class="number">2</span>; s++) &#123;</span><br><span class="line">            <span class="comment">// if we can get the sum 's' without the number at index 'i'</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][s]) &#123;</span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                <span class="comment">// else include the number and see if we can find a subset to get the remaining sum</span></span><br><span class="line">                dp[i][s] = dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Find the largest index in the last row which is true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sum / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n-<span class="number">1</span>][i] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            sum1 = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum2 = sum - sum1;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(sum2-sum1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1049-Last-Stone-Weight-II"><a href="#1049-Last-Stone-Weight-II" class="headerlink" title="1049. Last Stone Weight II"></a><a href="https://leetcode.com/problems/last-stone-weight-ii/" target="_blank" rel="noopener">1049. Last Stone Weight II</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s : stones) &#123;</span><br><span class="line">        sum += s;</span><br><span class="line">    &#125;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[stones.length + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, stones, <span class="number">0</span>, <span class="number">0</span>, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] stones, <span class="keyword">int</span> sum1, <span class="keyword">int</span> sum2, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == stones.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(sum1 - sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][sum1] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> way1 = dfs(idx + <span class="number">1</span>, stones, sum1 + stones[idx], sum2, dp);</span><br><span class="line">        <span class="keyword">int</span> way2 = dfs(idx + <span class="number">1</span>, stones, sum1, sum2 + stones[idx], dp);</span><br><span class="line">        dp[idx][sum1] = Math.min(way1, way2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][sum1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="🌕Count-of-Subset-Sum"><a href="#🌕Count-of-Subset-Sum" class="headerlink" title="🌕Count of Subset Sum"></a>🌕Count of Subset Sum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 1, 2, 3&#125;, S&#x3D;4</span><br><span class="line">Output: 3</span><br><span class="line">The given set has &#39;3&#39; subsets whose sum is &#39;4&#39;: &#123;1, 1, 2&#125;, &#123;1, 3&#125;, &#123;1, 3&#125;</span><br><span class="line">Note that we have two similar sets &#123;1, 3&#125;, because we have two &#39;1&#39; in our input.</span><br><span class="line"></span><br><span class="line">Input: &#123;1, 2, 7, 1, 5&#125;, S&#x3D;9</span><br><span class="line">Output: 3</span><br><span class="line">The given set has &#39;3&#39; subsets whose sum is &#39;9&#39;: &#123;2, 7&#125;, &#123;1, 7, 1&#125;, &#123;1, 2, 1, 5&#125;</span><br></pre></td></tr></table></figure>

<h3 id="brute-force-algorithm-3"><a href="#brute-force-algorithm-3" class="headerlink" title="brute-force algorithm"></a>brute-force algorithm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each number &#39;i&#39; </span><br><span class="line">  create a new set which includes number &#39;i&#39; if it does not exceed &#39;S&#39;, and recursively   </span><br><span class="line">      process the remaining numbers and sum</span><br><span class="line">  create a new set without number &#39;i&#39;, and recursively process the remaining numbers </span><br><span class="line">return the count of subsets who has a sum equal to &#39;S&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countSubsetsRecursive(num, sum, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSubsetsRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the number at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num[currentIndex] &lt;= sum)</span><br><span class="line">        sum1 = countSubsetsRecursive(num, sum - num[currentIndex], currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> sum2 = countSubsetsRecursive(num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-4"><a href="#Top-down-Dynamic-Programming-with-Memoization-4" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countSubsetsRecursive(num, sum, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSubsetsRecursive</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num.length == <span class="number">0</span> || currentIndex &gt;= num.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the number at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the number at currentIndex exceeds the sum, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][sum] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[idx] &lt;= sum) &#123;</span><br><span class="line">            sum1 = count(idx + <span class="number">1</span>, num, sum - num[idx], dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recursive call after excluding the number at the currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = count(idx + <span class="number">1</span>, num, sum, dp);</span><br><span class="line">        dp[idx][sum] = sum1 + sum2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-4"><a href="#Bottom-up-Dynamic-Programming-4" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we will always have an empty set for zero sum</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to its value</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            <span class="comment">// exclude the number</span></span><br><span class="line">            dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            <span class="comment">// include the number, if it does not exceed the sum</span></span><br><span class="line">            <span class="keyword">if</span>(s &gt;= num[i])</span><br><span class="line">                dp[i][s] += dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[num.length-<span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Target-Sum"><a href="#🌕Target-Sum" class="headerlink" title="🌕Target Sum"></a>🌕Target Sum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;1, 1, 2, 3&#125;, S&#x3D;1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The given set has &#39;3&#39; ways to make a sum of &#39;1&#39;: &#123;+1-1-2+3&#125; &amp; &#123;-1+1-2+3&#125; &amp; &#123;+1+1+2-3&#125;</span><br><span class="line"></span><br><span class="line">Input: &#123;1, 2, 7, 1&#125;, S&#x3D;9</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The given set has &#39;2&#39; ways to make a sum of &#39;9&#39;: &#123;+1+2+7-1&#125; &amp; &#123;-1+2+7+1&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">We are asked to find two subsets of the given numbers whose difference is equal to the given target ‘S’. Take the first example above. As we saw, one solution is &#123;+1-1-2+3&#125;. So, the two subsets we are asked to find are &#123;1, 3&#125; &amp; &#123;1, 2&#125; because,</span><br><span class="line">(1 + 3) - (1 + 2) &#x3D; 1</span><br><span class="line"></span><br><span class="line">Sum(s1) - Sum(s2) &#x3D; S</span><br><span class="line">Sum(s1) + Sum(s2) &#x3D; Sum(num)</span><br><span class="line">Let’s add the above two equations:</span><br><span class="line">&#x3D;&gt; Sum(s1) - Sum(s2) + Sum(s1) + Sum(s2) &#x3D; S + Sum(num)</span><br><span class="line">&#x3D;&gt; 2 * Sum(s1) &#x3D;  S + Sum(num)</span><br><span class="line">&#x3D;&gt; Sum(s1) &#x3D; (S + Sum(num)) &#x2F; 2</span><br><span class="line"></span><br><span class="line">This essentially converts our problem to: “Find count of subsets of the given numbers whose sum is equal to”,</span><br><span class="line">&#x3D;&gt; (S + Sum(num)) &#x2F; 2</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The above solution has time O(N*S)</span></span><br><span class="line"><span class="comment">//space complexity of O(N∗S), where ‘N’ represents total numbers and ‘S’ is the desired sum.</span></span><br><span class="line"><span class="comment">//We can further improve the solution to use only O(S)O(S) space.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num)&#123;</span><br><span class="line">        totalSum += n;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//invalid input, the problem expects only positive numbers</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 's + totalSum' is odd, we can't find a subset with sum equal to '(s + totalSum) / 2'</span></span><br><span class="line">    <span class="keyword">if</span> (totalSum &lt; s || (s + totalSum) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> countSubsets(num, (s + totalSum) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this function is exactly similar to what we have in 'Count of Subset Sum' problem.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the sum=0 columns, as we will always have an empty set for zero sum</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one number, we can form a subset only when the required sum is equal to the number</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum ; s++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all subsets for all sums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            dp[i][s] = dp[i-<span class="number">1</span>][s];</span><br><span class="line">            <span class="keyword">if</span>(s &gt;= num[i])</span><br><span class="line">                dp[i][s] += dp[i-<span class="number">1</span>][s-num[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the bottom-right corner will have our answer.</span></span><br><span class="line">    <span class="keyword">return</span> dp[num.length-<span class="number">1</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🌕Unsolved-494-Target-Sum✨"><a href="#🌕Unsolved-494-Target-Sum✨" class="headerlink" title="🌕Unsolved 494. Target Sum✨"></a><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">🌕Unsolved 494. Target Sum✨</a></h3><h3 id="Solution1-41"><a href="#Solution1-41" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>DFS</p>
</li>
<li><p>题目大意：给你一串数字，你可以在每个数字前放置+或-，问有多少种方法可以使得表达式的值等于target。You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p>
<p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p>
</li>
<li><p>Time complexity: O(2^n)</p>
<p>Space complexity: O(n)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; Math.abs(S)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    dfs(nums, <span class="number">0</span>, S);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (start == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="number">0</span>) ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(nums, start + <span class="number">1</span>, S + nums[start]);</span><br><span class="line">    dfs(nums, start + <span class="number">1</span>, S - nums[start]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-Solution2"><a href="#Unsolved-Solution2" class="headerlink" title="Unsolved Solution2:"></a>Unsolved Solution2:</h3><ol>
<li><a href="https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-494-target-sum/" target="_blank" rel="noopener">DP</a></li>
</ol>
<h1 id="Pattern-2-Unbounded-Knapsack"><a href="#Pattern-2-Unbounded-Knapsack" class="headerlink" title="Pattern 2: Unbounded Knapsack"></a>Pattern 2: Unbounded Knapsack</h1><h2 id="🌕Unbounded-Knapsack"><a href="#🌕Unbounded-Knapsack" class="headerlink" title="🌕Unbounded Knapsack"></a>🌕Unbounded Knapsack</h2><p>The only difference between the <a href="https://www.educative.io/collection/page/5668639101419520/5633779737559040/5666387129270272/" target="_blank" rel="noopener">0/1 Knapsack</a> problem and this problem is that we are allowed to use an unlimited quantity of an item.</p>
<h3 id="brute-force"><a href="#brute-force" class="headerlink" title="brute-force"></a>brute-force</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each item &#39;i&#39; </span><br><span class="line">  create a new set which includes one quantity of item &#39;i&#39; if it does not exceed the capacity, and </span><br><span class="line">     recursively call to process all items </span><br><span class="line">  create a new set without item &#39;i&#39;, and recursively process the remaining items </span><br><span class="line">return the set from the above two sets with higher profit</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length || </span><br><span class="line">        currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after choosing the items at the currentIndex, note that we recursive call on all items as we did not increment currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weights[currentIndex] &lt;= capacity) &#123;</span><br><span class="line">        profit1 = profits[currentIndex] + knapsackRecursive(profits, weights, capacity - weights[currentIndex], currentIndex);  <span class="comment">//&lt;---------------currentIndex not increase, can be use again</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the element at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> profit2 = knapsackRecursive(profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(profit1, profit2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-5"><a href="#Top-down-Dynamic-Programming-with-Memoization-5" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[profits.length][capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.knapsackRecursive(dp, profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(Integer[][] dp, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] profits, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] weights, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> capacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length ||</span><br><span class="line">        currentIndex &gt;= profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we have not already processed a similar sub-problem</span></span><br><span class="line">    <span class="keyword">if</span> (dp[currentIndex][capacity] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// recursive call after choosing the items at the currentIndex, note that we recursive call on all</span></span><br><span class="line">        <span class="comment">// items as we did not increment currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (weights[currentIndex] &lt;= capacity) &#123;</span><br><span class="line">            profit1 = profits[currentIndex] + knapsackRecursive(dp, profits, weights, capacity - weights[currentIndex], currentIndex);  <span class="comment">//&lt;---------------currentIndex not increase, can be use again</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursive call after excluding the element at the currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> profit2 = knapsackRecursive(dp, profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        dp[currentIndex][capacity] = Math.max(profit1, profit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-5"><a href="#Bottom-up-Dynamic-Programming-5" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[index][c] &#x3D; max (dp[index-1][c], profit[index] + dp[index][c-weight[index]])</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.length == <span class="number">0</span> || weights.length != profits.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = profits.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the capacity=0 columns</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all sub-arrays for all capacities</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit1=<span class="number">0</span>, profit2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(weights[i] &lt;= c)</span><br><span class="line">                profit1 = profits[i] + dp[i][c-weights[i]];</span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span> )</span><br><span class="line">                profit2 = dp[i-<span class="number">1</span>][c];</span><br><span class="line">            dp[i][c] = profit1 &gt; profit2 ? profit1 : profit2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maximum profit will be in the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rod-Cutting"><a href="#Rod-Cutting" class="headerlink" title="Rod Cutting"></a>Rod Cutting</h2><h3 id="brute-force-solution-1"><a href="#brute-force-solution-1" class="headerlink" title="brute-force solution"></a>brute-force solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each rod length &#39;i&#39; </span><br><span class="line">  create a new set which includes one quantity of length &#39;i&#39;, and recursively process </span><br><span class="line">      all rod lengths for the remaining length </span><br><span class="line">  create a new set without rod length &#39;i&#39;, and recursively process for remaining rod lengths</span><br><span class="line">return the set from the above two sets with a higher sales price</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-6"><a href="#Top-down-Dynamic-Programming-with-Memoization-6" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveRodCutting</span><span class="params">(<span class="keyword">int</span>[] lengths, <span class="keyword">int</span>[] prices, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[lengths.length][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findTheMax(<span class="number">0</span>, lengths, prices, n, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheMax</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] lengths, <span class="keyword">int</span>[] prices, <span class="keyword">int</span> n, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (lengths.length == <span class="number">0</span> || lengths.length != prices.length || idx &gt;= lengths.length || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][n] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lengths[idx] &lt;= n) &#123;</span><br><span class="line">            profit1 = prices[idx] + findTheMax(idx, lengths, prices, n - lengths[idx], dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit2 = findTheMax(idx + <span class="number">1</span>, lengths, prices, n, dp);</span><br><span class="line">        dp[idx][n] = Math.max(profit1, profit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-6"><a href="#Bottom-up-Dynamic-Programming-6" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solveRodCutting</span><span class="params">(<span class="keyword">int</span>[] lengths, <span class="keyword">int</span>[] prices, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base checks</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || prices.length == <span class="number">0</span> || prices.length != lengths.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lengthCount = lengths.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lengthCount][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all rod lengths for all prices</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lengthCount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p1=<span class="number">0</span>, p2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(lengths[i] &lt;= len)</span><br><span class="line">                p1 = prices[i] + dp[i][len-lengths[i]];</span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span> )</span><br><span class="line">                p2 = dp[i-<span class="number">1</span>][len];</span><br><span class="line">            dp[i][len] = Math.max(p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maximum price will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[lengthCount-<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="518-Coin-Change✨-ways-to-change"><a href="#518-Coin-Change✨-ways-to-change" class="headerlink" title="518. Coin Change✨ ways to change"></a><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">518. Coin Change✨ ways to change</a></h2><h3 id="Basic-Solution"><a href="#Basic-Solution" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each coin &#39;c&#39; </span><br><span class="line">  create a new set which includes one quantity of coin &#39;c&#39; if it does not exceed &#39;T&#39;, and </span><br><span class="line">     recursively call to process all coins </span><br><span class="line">  create a new set without coin &#39;c&#39;, and recursively call to process the remaining coins </span><br><span class="line">return the count of sets who have a sum equal to &#39;T&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countChangeRecursive(denominations, total, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countChangeRecursive</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// basic checks</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(denominations.length == <span class="number">0</span> || currentIndex &gt;= denominations.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the coin at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the coin at currentIndex exceeds the total, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( denominations[currentIndex] &lt;= total )</span><br><span class="line">        sum1 = countChangeRecursive(denominations, total - denominations[currentIndex], currentIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the coin at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> sum2 = countChangeRecursive(denominations, total, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-7"><a href="#Top-down-Dynamic-Programming-with-Memoization-7" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[denominations.length][total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findCount(<span class="number">0</span>, denominations, total, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCount</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (denominations.length == <span class="number">0</span> || idx &gt;= denominations.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][total] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> way1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (denominations[idx] &lt;= total) &#123;</span><br><span class="line">            way1 = findCount(idx, denominations, total - denominations[idx], dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> way2 = findCount(idx + <span class="number">1</span>, denominations, total, dp);</span><br><span class="line">        dp[idx][total] = way1 + way2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-7"><a href="#Bottom-up-Dynamic-Programming-7" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = denominations.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][total + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the total=0 columns, as we will always have an empty set for zero total</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process all sub-arrays for all capacities</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; t &lt;= total; t++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                dp[i][t] = dp[i-<span class="number">1</span>][t];</span><br><span class="line">            <span class="keyword">if</span>(t &gt;= denominations[i])</span><br><span class="line">                dp[i][t] += dp[i][t-denominations[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total combinations will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Minimum-Coin-Change✨🎶"><a href="#🌕Minimum-Coin-Change✨🎶" class="headerlink" title="🌕Minimum Coin Change✨🎶"></a><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">🌕Minimum Coin Change✨🎶</a></h2><h3 id="Basic-Solution-1"><a href="#Basic-Solution-1" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each coin &#39;c&#39; </span><br><span class="line">  create a new set which includes one quantity of coin &#39;c&#39; if it does not exceed &#39;T&#39;, and </span><br><span class="line">     recursively call to process all coins </span><br><span class="line">  create a new set without coin &#39;c&#39;, and recursively call to process the remaining coins </span><br><span class="line">return the count of coins from the above two sets with a smaller number of coins</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="keyword">this</span>.countChangeRecursive(denominations, total, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (result == Integer.MAX_VALUE ? -<span class="number">1</span> : result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countChangeRecursive</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(denominations.length == <span class="number">0</span> || currentIndex &gt;= denominations.length)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the coin at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the coin at currentIndex exceeds the total, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> count1 = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>( denominations[currentIndex] &lt;= total ) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = countChangeRecursive(denominations, total - denominations[currentIndex], currentIndex);</span><br><span class="line">        <span class="comment">//use Integer.MAX_VALUE -&gt; can't slpit the money to coin</span></span><br><span class="line">        <span class="keyword">if</span>(res != Integer.MAX_VALUE)&#123;</span><br><span class="line">            count1 = res + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the coin at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> count2 = countChangeRecursive(denominations, total, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(count1, count2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-8"><a href="#Top-down-Dynamic-Programming-with-Memoization-8" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[denominations.length][total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="keyword">this</span>.countChangeRecursive(dp, denominations, total, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (result == Integer.MAX_VALUE ? -<span class="number">1</span> : result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countChangeRecursive</span><span class="params">(Integer[][] dp, <span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (denominations.length == <span class="number">0</span> || currentIndex &gt;= denominations.length)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we have not already processed a similar sub-problem</span></span><br><span class="line">    <span class="keyword">if</span> (dp[currentIndex][total] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// recursive call after selecting the coin at the currentIndex</span></span><br><span class="line">        <span class="comment">// if the coin at currentIndex exceeds the total, we shouldn't process this</span></span><br><span class="line">        <span class="keyword">int</span> count1 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (denominations[currentIndex] &lt;= total) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = countChangeRecursive(dp, denominations, total - denominations[currentIndex], currentIndex);</span><br><span class="line">            <span class="keyword">if</span> (res != Integer.MAX_VALUE) &#123;</span><br><span class="line">                count1 = res + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursive call after excluding the coin at the currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> count2 = countChangeRecursive(dp, denominations, total, currentIndex + <span class="number">1</span>);</span><br><span class="line">        dp[currentIndex][total] = Math.min(count1, count2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-8"><a href="#Bottom-up-Dynamic-Programming-8" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span>[] denominations, <span class="keyword">int</span> total)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = denominations.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][total + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt;= total; j++)</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the total=0 columns, as we don't need any coin to make zero total</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; t &lt;= total; t++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                dp[i][t] = dp[i-<span class="number">1</span>][t]; <span class="comment">//exclude the coin</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt;= denominations[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][t-denominations[i]] != Integer.MAX_VALUE)</span><br><span class="line">                    dp[i][t] = Math.min(dp[i][t], dp[i][t-denominations[i]]+<span class="number">1</span>); <span class="comment">// include the coin</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total combinations will be at the bottom-right corner.</span></span><br><span class="line">    <span class="keyword">return</span> (dp[n-<span class="number">1</span>][total] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[n-<span class="number">1</span>][total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Min-Number-Of-Coins-For-Change-AE-✨"><a href="#Min-Number-Of-Coins-For-Change-AE-✨" class="headerlink" title="Min Number Of Coins For Change(AE)✨"></a>Min Number Of Coins For Change(AE)✨</h3><ol>
<li><p>two inputs, target of amount of money and array of coin combinations</p>
</li>
<li><p>find the min number to get the amount</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">6</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]  <span class="number">2</span> coins(<span class="number">2</span>$ + <span class="number">4</span>$);</span><br><span class="line">with <span class="number">1</span>$</span><br><span class="line">coins-&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">$    -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">2</span> - <span class="number">1</span> = <span class="number">1</span>, <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">min[<span class="number">1</span>] += min[<span class="number">1</span> - <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">with <span class="number">1</span>$ &amp; <span class="number">2</span>$</span><br><span class="line">coins-&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">$    -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> - <span class="number">2</span> = <span class="number">0</span></span><br><span class="line"><span class="number">3</span> - <span class="number">2</span> = <span class="number">1</span>, <span class="number">4</span> - <span class="number">2</span> = <span class="number">2</span>, <span class="number">5</span> - <span class="number">2</span> = <span class="number">3</span>, <span class="number">6</span> - <span class="number">2</span> = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">with <span class="number">1</span>$ &amp; <span class="number">2</span>$ &amp; <span class="number">4</span>$</span><br><span class="line">coins-&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">$    -&gt;<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span> - <span class="number">4</span> = <span class="number">0</span></span><br><span class="line"><span class="number">5</span> - <span class="number">4</span> = <span class="number">1</span>, <span class="number">6</span> - <span class="number">4</span> = <span class="number">2</span>;</span><br><span class="line"><span class="number">1</span>($denom) &lt;= <span class="number">1</span>(amount)</span><br></pre></td></tr></table></figure>
</li>
<li><p>if amount &gt;= denom: <strong><code>nums[amount]</code></strong> = min(<strong><code>nums[amount]</code></strong>, <strong><code>1(eg. a 4$ coin) + nums[amount - denom]</code></strong>)</p>
</li>
</ol>
<h3 id="Solution1-42"><a href="#Solution1-42" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(nd) d is denom time | O(n) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberOfCoinsForChange</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] denoms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] numOfCoins = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];  <span class="comment">//add o amount which is base case at beginning</span></span><br><span class="line">    Arrays.fill(numOfCoins, Integer.MAX_VALUE);</span><br><span class="line">    numOfCoins[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> toCompare  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> denom : denoms) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> amount = <span class="number">0</span>; amount &lt; numOfCoins.length; ++amount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &gt;= denom) &#123;  <span class="comment">//if amount can use denom coin, apply the formula</span></span><br><span class="line">                <span class="keyword">if</span> (numOfCoins[amount - denom] = Integer.MAX_VALUE) &#123;</span><br><span class="line">                    toCompare = numOfCoins[amount - denom];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    toCompare = numOfCoins[amount - denom] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                numOfCoins[amount] = Math.min(numOfCoins[amount], toCompare);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfCoins[n] != Integer.MAX_VALUE ? numOfCoins[n] : - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="322-Coin-Change✨"><a href="#322-Coin-Change✨" class="headerlink" title="322. Coin Change✨"></a><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">min number</span><br><span class="line">amount-&gt; <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span></span><br><span class="line">types</span><br><span class="line"><span class="number">0</span>        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"><span class="number">1</span>(<span class="number">1</span>$)    <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span></span><br><span class="line"><span class="number">2</span>(<span class="number">5</span>$)    <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>(<span class="number">10</span>$)   <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dp[<span class="number">2</span>][<span class="number">5</span>] = Math.min(dp[<span class="number">1</span>][<span class="number">5</span>], <span class="number">1</span> + dp[<span class="number">2</span>][<span class="number">5</span> - <span class="number">5</span>]) = Math.min(<span class="number">5</span>, <span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">formula: dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], <span class="number">1</span> + dp[i][j - denom])</span><br><span class="line">nums[amount] = min(**`nums[amount]`**, **`<span class="number">1</span>(eg. a <span class="number">4</span>$ coin) + nums[amount - denom]`**)</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-43"><a href="#Solution1-43" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time complexity : O(S<em>n)*O</em>(<em>S</em>∗<em>n</em>). On each step the algorithm finds the next <em>F(i)*F</em>(*i<em>)</em> in n<em>n</em> iterations, where 1\leq i \leq S1≤<em>i</em>≤<em>S</em>. Therefore in total the iterations are S<em>n</em>S<em>∗</em>n*.</li>
<li>Space complexity : O(S)<em>O</em>(<em>S</em>). We use extra space for the memoization table.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tocompare = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> denom : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= denom) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i - denom] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    tocompare = dp[i - denom];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tocompare = dp[i - denom] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = Math.min(dp[i], tocompare);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] != Integer.MAX_VALUE ? dp[amount] : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-13"><a href="#Solution2-13" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路：动态规划。使用和不使用每一种 Coin 对于每一种 Amount 的情况逐渐累加，直到达到 Amount。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    Arrays.fill(dp, max);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin)</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[i - coins[j]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ?  -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Maximum-Ribbon-Cut"><a href="#🌕Maximum-Ribbon-Cut" class="headerlink" title="🌕Maximum Ribbon Cut"></a>🌕Maximum Ribbon Cut</h2><h3 id="Basic-Solution-2"><a href="#Basic-Solution-2" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each length &#39;l&#39; </span><br><span class="line">  create a new set which includes one quantity of length &#39;l&#39; if it does not exceed &#39;n&#39;, and </span><br><span class="line">     recursively call to process all lengths </span><br><span class="line">  create a new set without length &#39;l&#39;, and recursively call to process the remaining lengths</span><br><span class="line">return the number of pieces from the above two sets with a higher number of pieces</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRibbonPieces</span><span class="params">(<span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxPieces = <span class="keyword">this</span>.countRibbonPiecesRecursive(ribbonLengths, total, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> maxPieces == Integer.MIN_VALUE ? -<span class="number">1</span> : maxPieces;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countRibbonPiecesRecursive</span><span class="params">(<span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base check</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ribbonLengths.length == <span class="number">0</span> || currentIndex &gt;= ribbonLengths.length)</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after selecting the ribbon length at the currentIndex</span></span><br><span class="line">    <span class="comment">// if the ribbon length at the currentIndex exceeds the total, we shouldn't process this</span></span><br><span class="line">    <span class="keyword">int</span> c1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span>( ribbonLengths[currentIndex] &lt;= total ) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = countRibbonPiecesRecursive(ribbonLengths, total - ribbonLengths[currentIndex], currentIndex);</span><br><span class="line">        <span class="keyword">if</span>(result != Integer.MIN_VALUE)&#123;</span><br><span class="line">            c1 = result + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive call after excluding the ribbon length at the currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> c2 = countRibbonPiecesRecursive(ribbonLengths, total, currentIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-9"><a href="#Top-down-Dynamic-Programming-with-Memoization-9" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRibbonPieces</span><span class="params">(<span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//find the max pieces</span></span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[ribbonLengths.length][total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> result = findTheMax(<span class="number">0</span>, ribbonLengths, total, dp);</span><br><span class="line">    <span class="keyword">return</span> result == Integer.MIN_VALUE? -<span class="number">1</span> : result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheMax</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ribbonLengths.length == <span class="number">0</span> || idx &gt;= ribbonLengths.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx][total] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> way1 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (ribbonLengths[idx] &lt;= total) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = findTheMax(idx, ribbonLengths, total - ribbonLengths[idx], dp);</span><br><span class="line">            <span class="keyword">if</span> (remain != Integer.MIN_VALUE) &#123;</span><br><span class="line">                way1 = remain + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> way2 = findTheMax(idx + <span class="number">1</span>, ribbonLengths, total, dp);</span><br><span class="line">        dp[idx][total] = Math.max(way1, way2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx][total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-9"><a href="#Bottom-up-Dynamic-Programming-9" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRibbonPieces</span><span class="params">(<span class="keyword">int</span>[] ribbonLengths, <span class="keyword">int</span> total)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = ribbonLengths.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][total + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt;= total; j++)</span><br><span class="line">            dp[i][j] = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate the total=0 columns, as we don't need any ribbon to make zero total</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; t &lt;= total; t++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) <span class="comment">//exclude the ribbon</span></span><br><span class="line">                dp[i][t] = dp[i-<span class="number">1</span>][t];</span><br><span class="line">            <span class="comment">// include the ribbon and check if the remaining length can be cut into available lengths</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt;= ribbonLengths[i] &amp;&amp; dp[i][t-ribbonLengths[i]] != Integer.MIN_VALUE)</span><br><span class="line">                dp[i][t] = Math.max(dp[i][t], dp[i][t-ribbonLengths[i]]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total combinations will be at the bottom-right corner, return '-1' if cutting is not possible</span></span><br><span class="line">    <span class="keyword">return</span> (dp[n-<span class="number">1</span>][total] == Integer.MIN_VALUE ? -<span class="number">1</span> : dp[n-<span class="number">1</span>][total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a><a href="https://leetcode.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. Combination Sum IV</a></h2><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p><a href="https://leetcode.com/problems/combination-sum-iv/discuss/736395/JavaScript-Solution-Top-Down-with-Memoization" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum-iv/discuss/736395/JavaScript-Solution-Top-Down-with-Memoization</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Integer[] memo = <span class="keyword">new</span> Integer[target + <span class="number">1</span>];</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, target, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, Integer[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (memo[target] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[target];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[i]) &#123;</span><br><span class="line">                ans += dfs(nums, target - nums[i], memo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[target] = ans;</span><br><span class="line">        <span class="keyword">return</span> memo[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Pattern-3-Fibonacci-Numbers"><a href="#Pattern-3-Fibonacci-Numbers" class="headerlink" title="Pattern 3: Fibonacci Numbers"></a>Pattern 3: Fibonacci Numbers</h1><h2 id="Fibonacci-Numbers"><a href="#Fibonacci-Numbers" class="headerlink" title="Fibonacci Numbers"></a>Fibonacci Numbers</h2><h3 id="Memory-optimization"><a href="#Memory-optimization" class="headerlink" title="Memory optimization"></a>Memory optimization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CalculateFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">1</span>, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        temp = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//The above solution has a time complexity of O(n) but a constant space complexity O(1).</span></span><br></pre></td></tr></table></figure>

<h2 id="Staircase"><a href="#Staircase" class="headerlink" title="Staircase"></a>Staircase</h2><h3 id="Basic-Solution-3"><a href="#Basic-Solution-3" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// base case, we don't need to take any step, so there is only one way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can take one step to reach the end, and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// we can take one step twice or jump two steps to reach at the top</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we take 1 step, we are left with 'n-1' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take1Step = CountWays(n-<span class="number">1</span>); </span><br><span class="line">    <span class="comment">// similarly, if we took 2 steps, we are left with 'n-2' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take2Step = CountWays(n-<span class="number">2</span>); </span><br><span class="line">    <span class="comment">// if we took 3 steps, we are left with 'n-3' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take3Step = CountWays(n-<span class="number">3</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> take1Step + take2Step + take3Step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Top-down-Dynamic-Programming-with-Memoization-10"><a href="#Top-down-Dynamic-Programming-with-Memoization-10" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> CountWaysRecursive(dp, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWaysRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// base case, we don't need to take any step, so there is only one way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can take one step to reach the end, and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// we can take one step twice or jump two steps to reach at the top</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[n] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if we take 1 step, we are left with 'n-1' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take1Step = CountWaysRecursive(dp, n-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// similarly, if we took 2 steps, we are left with 'n-2' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take2Step = CountWaysRecursive(dp, n-<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// if we took 3 steps, we are left with 'n-3' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take3Step = CountWaysRecursive(dp, n-<span class="number">3</span>);</span><br><span class="line">        dp[n] = take1Step + take2Step + take3Step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-10"><a href="#Bottom-up-Dynamic-Programming-10" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>] + dp[i-<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memory-optimization-1"><a href="#Memory-optimization-1" class="headerlink" title="Memory optimization"></a>Memory optimization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">1</span>, n2=<span class="number">1</span>, n3=<span class="number">2</span>, temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        temp = n1 + n2 + n3;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">        n3 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//The above solution has a time complexity of O(n) and a constant space complexity O(1).</span></span><br></pre></td></tr></table></figure>

<h2 id="Number-factors"><a href="#Number-factors" class="headerlink" title="Number factors"></a>Number factors</h2><p>Given a number ‘n’, implement a method to count how many possible ways there are to express ‘n’ as the sum of 1, 3, or 4.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n : 4</span><br><span class="line">Number of ways &#x3D; 4</span><br><span class="line">Explanation: Following are the four ways we can express &#39;n&#39; : &#123;1,1,1,1&#125;, &#123;1,3&#125;, &#123;3,1&#125;, &#123;4&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-4"><a href="#Basic-Solution-4" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// base case, we don't need to subtract any thing, so there is only one way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can subtract 1 to be left with zero, and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can subtract 1 twice to get zero and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// '3' can be expressed as &#123;1,1,1&#125;, &#123;3&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we subtract 1, we are left with 'n-1'</span></span><br><span class="line">    <span class="keyword">int</span> subtract1 = CountWays(n-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// if we subtract 3, we are left with 'n-3'</span></span><br><span class="line">    <span class="keyword">int</span> subtract3 = CountWays(n-<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// if we subtract 4, we are left with 'n-4'</span></span><br><span class="line">    <span class="keyword">int</span> subtract4 = CountWays(n-<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subtract1 + subtract3 + subtract4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-11"><a href="#Top-down-Dynamic-Programming-with-Memoization-11" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> CountWaysRecursive(dp, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWaysRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// base case, we don't need to subtract any thing, so there is only one way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can take subtract 1 to be left with zero, and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we can subtract 1 twice to get zero and that is the only way</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// '3' can be expressed as &#123;1,1,1&#125;, &#123;3&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[n] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if we subtract 1, we are left with 'n-1'</span></span><br><span class="line">        <span class="keyword">int</span> subtract1 = CountWaysRecursive(dp, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// if we subtract 3, we are left with 'n-3'</span></span><br><span class="line">        <span class="keyword">int</span> subtract3 = CountWaysRecursive(dp, n - <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// if we subtract 4, we are left with 'n-4'</span></span><br><span class="line">        <span class="keyword">int</span> subtract4 = CountWaysRecursive(dp, n - <span class="number">4</span>);</span><br><span class="line">        dp[n] = subtract1 + subtract3 + subtract4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-11"><a href="#Bottom-up-Dynamic-Programming-11" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n &lt;= <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">3</span> ) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=n; i++)</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">3</span>] + dp[i-<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fibonacci-number-pattern"><a href="#Fibonacci-number-pattern" class="headerlink" title="Fibonacci number pattern"></a>Fibonacci number pattern</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountWays(n) &#x3D; CountWays(n-1) + CountWays(n-3) + CountWays(n-4), for n &gt;&#x3D; 4</span><br></pre></td></tr></table></figure>

<h2 id="🌕Minimum-jumps-to-reach-the-end-Jump-game⭐"><a href="#🌕Minimum-jumps-to-reach-the-end-Jump-game⭐" class="headerlink" title="🌕Minimum jumps to reach the end || Jump game⭐"></a>🌕Minimum jumps to reach the end || Jump game⭐</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input &#x3D; &#123;2,1,1,1,4&#125;</span><br><span class="line">Output &#x3D; 3</span><br><span class="line">Explanation: Starting from index &#39;0&#39;, we can reach the last index through: 0-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-5"><a href="#Basic-Solution-5" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(2^n)</span></span><br><span class="line"><span class="comment">//Space O(n) call stack</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMinJumps</span><span class="params">(<span class="keyword">int</span>[] jumps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countMinJumpsRecursive(jumps, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countMinJumpsRecursive</span><span class="params">(<span class="keyword">int</span>[] jumps, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if we have reached the last index, we don't need any more jumps</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex == jumps.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jumps[currentIndex] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalJumps = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> start = currentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = currentIndex + jumps[currentIndex];</span><br><span class="line">    <span class="keyword">while</span>(start &lt; jumps.length &amp;&amp; start &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// jump one step and recurse for the remaining array</span></span><br><span class="line">        <span class="keyword">int</span> minJumps = countMinJumpsRecursive(jumps, start++);</span><br><span class="line">        <span class="keyword">if</span>(minJumps != Integer.MAX_VALUE)</span><br><span class="line">            totalJumps = Math.min(totalJumps, minJumps + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalJumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-12"><a href="#Top-down-Dynamic-Programming-with-Memoization-12" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMinJumps</span><span class="params">(<span class="keyword">int</span>[] jumps)</span> </span>&#123;</span><br><span class="line">    Integer[] dp = <span class="keyword">new</span> Integer[jumps.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findMinJumps(<span class="number">0</span>, jumps, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinJumps</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>[] jumps, Integer[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == jumps.length  - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jumps[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[idx] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> steps = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + idx &lt; jumps.length &amp;&amp; i &lt;= jumps[idx]; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minJumps = findMinJumps(i + idx, jumps, dp);</span><br><span class="line">            <span class="keyword">if</span> (minJumps != Integer.MAX_VALUE) &#123;</span><br><span class="line">                steps = Math.min(steps, minJumps + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[idx] = steps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMinJumps</span><span class="params">(<span class="keyword">int</span>[] jumps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[jumps.length];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.countMinJumpsRecursive(dp, jumps, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countMinJumpsRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span>[] jumps, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if we have reached the last index, we don't need any more jumps</span></span><br><span class="line">    <span class="keyword">if</span>( currentIndex == jumps.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If an element is 0, then we cannot move through that element</span></span><br><span class="line">    <span class="keyword">if</span> (jumps[currentIndex] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have already solved this problem, return the result</span></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[currentIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> totalJumps = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> start = currentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = currentIndex + jumps[currentIndex];</span><br><span class="line">    <span class="keyword">while</span>(start &lt; jumps.length &amp;&amp; start &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// jump one step and recurse for the remaining array</span></span><br><span class="line">        <span class="keyword">int</span> minJumps = countMinJumpsRecursive(dp, jumps, start++);</span><br><span class="line">        <span class="keyword">if</span>(minJumps != Integer.MAX_VALUE)</span><br><span class="line">            totalJumps = Math.min(totalJumps, minJumps + <span class="number">1</span>); <span class="comment">//&lt;---------------don't forget +1</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp[currentIndex] = totalJumps;</span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-12"><a href="#Bottom-up-Dynamic-Programming-12" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMinJumps</span><span class="params">(<span class="keyword">int</span>[] jumps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[jumps.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initialize with infinity, except the first index which should be zero as we start from there</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;jumps.length; i++)</span><br><span class="line">        dp[i] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>; start &lt; jumps.length-<span class="number">1</span>; start++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end=start+<span class="number">1</span>; end &lt;= start+jumps[start] &amp;&amp; end &lt; jumps.length; end++)</span><br><span class="line">            dp[end] = Math.min(dp[end], dp[start]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[jumps.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fibonacci-number-pattern-1"><a href="#Fibonacci-number-pattern-1" class="headerlink" title="Fibonacci number pattern"></a>Fibonacci number pattern</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[end] &#x3D; Math.min(dp[end], dp[start]+1);</span><br></pre></td></tr></table></figure>

<h3 id="Min-Number-Of-Jumps-AE-⭐"><a href="#Min-Number-Of-Jumps-AE-⭐" class="headerlink" title="Min Number Of Jumps(AE)⭐"></a>Min Number Of Jumps(AE)⭐</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">nums [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">value of array mean the large pos you can jump to</span><br><span class="line">ex. nums[<span class="number">0</span>] = <span class="number">3</span>, means you can go to, nums[<span class="number">1</span>] || nums[<span class="number">2</span>] || nums[<span class="number">3</span>]</span><br><span class="line">answer <span class="number">4</span> jump : <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span> -&gt; <span class="number">7</span> -&gt; <span class="number">3</span> </span><br><span class="line">find out the min jump from start to end</span><br><span class="line"></span><br><span class="line">creat a jumps array represent the min jumps we need to current position, inital it infinate <span class="keyword">default</span> value Integer.MAX_VALUE</span><br><span class="line">jumps [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, , , , <span class="number">4</span>] </span><br><span class="line">Position jumps[<span class="number">1</span>]:</span><br><span class="line">j = <span class="number">0</span>, nums[j] = <span class="number">3</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="number">3</span> + <span class="number">0</span> &gt;= <span class="number">1</span>, and junps[<span class="number">0</span>] + <span class="number">1</span> = <span class="number">1</span> &lt; Integer.MAX_VALUE, update it</span><br><span class="line">Position jumps[<span class="number">1</span>]:</span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">j = <span class="number">0</span>, nums[j] = <span class="number">3</span></span><br><span class="line"><span class="number">3</span> + <span class="number">0</span> &gt;= <span class="number">2</span>, and junps[<span class="number">0</span>] + <span class="number">1</span> = <span class="number">1</span> &lt; Integer.MAX_VALUE, update it</span><br><span class="line">j = <span class="number">1</span>, nums[j] = <span class="number">4</span></span><br><span class="line"><span class="number">4</span> + <span class="number">1</span> &gt;= <span class="number">2</span>, and junps[<span class="number">1</span>] + <span class="number">1</span> = <span class="number">2</span> &gt; <span class="number">1</span>, <span class="keyword">do</span> nothing, keep it <span class="number">1</span></span><br><span class="line"></span><br><span class="line">formula:</span><br><span class="line"><span class="keyword">if</span> nums[j] + j &gt;= i</span><br><span class="line">    jumps[i] = Math.min(jumps[i], jumps[j] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-44"><a href="#Solution1-44" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>O(n^2) time, O(n) space</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberOfJumps</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] jumps = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    Arrays.fill(jumps, Integer.MAX_VALUE);</span><br><span class="line">    jumps[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//in first index don't need jump, initial it to 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] + j &gt;= i) &#123;  <span class="comment">//if this position i is reachable from position j</span></span><br><span class="line">                jumps[i] = Math.min(jumps[j] + <span class="number">1</span>, jumps[i]);  <span class="comment">//update it to min nums of jumps</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps[jumps.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-14"><a href="#Solution2-14" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>O(n) time, O(1) space</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nums [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">pos <span class="number">0</span> : maxReach = <span class="number">3</span> step = <span class="number">3</span>(mean we can take <span class="number">3</span> step until need a jump, <span class="keyword">if</span> arrive <span class="number">1</span>, step = <span class="number">0</span>)</span><br><span class="line">steps = <span class="number">3</span>, maxReach = <span class="number">3</span>, jumps = <span class="number">0</span></span><br><span class="line">pos <span class="number">1</span> : maxReach = <span class="number">4</span> + <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span> <span class="params">(<span class="number">1</span>, len(array)</span>)</span></span><br><span class="line"><span class="function">    maxReach </span>= max(maxReach, array[i] + i)</span><br><span class="line">    step -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> stemp == <span class="number">0</span>  <span class="comment">//is run out of steps we need a jump</span></span><br><span class="line">	    jumps += <span class="number">1</span></span><br><span class="line">        steps = maxReach - i</span><br><span class="line"><span class="keyword">return</span> jumps + <span class="number">1</span></span><br><span class="line">ex. in nums[<span class="number">3</span>] run out of steps, maxReach = nums[<span class="number">5</span>] = <span class="number">3</span>,</span><br><span class="line">update stpes = <span class="number">5</span> - <span class="number">3</span> = <span class="number">2</span>, keep going</span><br><span class="line"><span class="keyword">return</span> jumps + <span class="number">1</span> because in the end once we at the <span class="keyword">final</span> index we are done</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberOfJumps</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">1</span>)  <span class="comment">//edge case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> jumps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxReach = array[<span class="number">0</span>];  <span class="comment">//initail the array[0] as maxReach and steps</span></span><br><span class="line">    <span class="keyword">int</span> steps = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;  <span class="comment">//start traverse</span></span><br><span class="line">        maxReach = Math.max(maxReach, i + array[i]);  <span class="comment">//update the maxReach</span></span><br><span class="line">        steps--;  <span class="comment">//each iteration we consume a step, we reduce steps by one</span></span><br><span class="line">        <span class="keyword">if</span> (steps == <span class="number">0</span>) &#123;  <span class="comment">//if we run out of steps, we need to jump</span></span><br><span class="line">            jumps++;</span><br><span class="line">            steps = maxReach - i;  <span class="comment">//how many steps we need form index i to maxReach</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps + <span class="number">1</span>;  <span class="comment">//iterate to &lt; array.length - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="55-Jump-Game✨"><a href="#55-Jump-Game✨" class="headerlink" title="55.Jump Game✨"></a><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">55.Jump Game✨</a></h3><p>Given an array of <strong><code>non-negative</code></strong> integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="keyword">true</span></span><br><span class="line">Explanation: Jump <span class="number">1</span> step from index <span class="number">0</span> to <span class="number">1</span>, then <span class="number">3</span> steps to the last index.</span><br><span class="line">    </span><br><span class="line">Input: nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation: You will always arrive at index <span class="number">3</span> no matter what. Its maximum jump length is <span class="number">0</span>, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-45"><a href="#Solution1-45" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>思路：步步为营。每次看所有当前元素所能达到的最远位置，并缓存入 max，如果 i 超过 max 则表明无法达到。</p>
</li>
<li><p>The basic idea is this: at each step, we keep <strong><code>track of the furthest reachable index</code></strong>. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable.</p>
<p>Hence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reachable = <span class="number">0</span>;  <span class="comment">//track the farthest index can reach</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; reachable) <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//base line</span></span><br><span class="line">        reachable = Math.max(reachable, i + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max position one could reach </span></span><br><span class="line">    <span class="comment">// starting from index &lt;= i</span></span><br><span class="line">    <span class="keyword">int</span> maxPos = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// if one could't reach this point</span></span><br><span class="line">        <span class="keyword">if</span> (maxPos &lt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxPos = Math.max(maxPos, nums[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Approach-1-Backtracking"><a href="#Approach-1-Backtracking" class="headerlink" title="Approach 1: Backtracking"></a>Approach 1: Backtracking</h3><p><a href="https://leetcode.com/problems/jump-game/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game/solution/</a></p>
<ol>
<li>Time : O(2^n)</li>
<li>Space : O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (position == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> furthestJump = Math.min(position + nums[position], nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nextPosition = position + <span class="number">1</span>; nextPosition &lt;= furthestJump; nextPosition++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (canJumpFromPosition(nextPosition, nums)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-45-Jump-Game-II✨"><a href="#Unsolved-45-Jump-Game-II✨" class="headerlink" title="Unsolved 45. Jump Game II✨"></a><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">Unsolved 45. Jump Game II✨</a></h3><p><strong>Optimal solution</strong></p>
<p>There are several ways to solve this problem:</p>
<ul>
<li>Backtracking, \mathcal{O}(2^N)O(2<em>N</em>) time.</li>
<li>Dynamic programming, \mathcal{O}(N)O(<em>N</em>) time, \mathcal{O}(N)O(<em>N</em>) space.</li>
<li>Greedy, \mathcal{O}(N)O(<em>N</em>) time and \mathcal{O}(1)O(1) space.</li>
</ul>
<p>In this article we will consider in details the optimal greedy approach.</p>
<h3 id="Solution1-46"><a href="#Solution1-46" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Greedy</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max position one could reach </span></span><br><span class="line">    <span class="comment">// starting from index &lt;= i </span></span><br><span class="line">    <span class="keyword">int</span> maxPos = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// max number of steps one could do</span></span><br><span class="line">    <span class="comment">// inside this jump</span></span><br><span class="line">    <span class="keyword">int</span> maxSteps = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> jumps = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// if to reach this point </span></span><br><span class="line">        <span class="comment">// one needs one more jump</span></span><br><span class="line">        <span class="keyword">if</span> (maxSteps &lt; i) &#123;</span><br><span class="line">            ++jumps;</span><br><span class="line">            maxSteps = maxPos;</span><br><span class="line">        &#125;</span><br><span class="line">        maxPos = Math.max(maxPos, nums[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-15"><a href="#Solution2-15" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curMax = <span class="number">0</span>; <span class="comment">// to mark the last element in a level</span></span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= curMax) &#123; </span><br><span class="line">        <span class="keyword">int</span> furthest = curMax; <span class="comment">// to mark the last element in the next level</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= curMax; i++) &#123;</span><br><span class="line">            furthest = Math.max(furthest, nums[i] + i);</span><br><span class="line">            <span class="keyword">if</span> (furthest &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">        curMax = furthest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// if i &lt; curMax, i can't move forward anymore (the last element in the array can't be reached)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a><a href="https://leetcode.com/problems/jump-game-iii/" target="_blank" rel="noopener">1306. Jump Game III</a></h3><h3 id="Solution1-47"><a href="#Solution1-47" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="number">0</span> &amp;&amp; start &lt; arr.length &amp;&amp; arr[start] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> jump = arr[start];</span><br><span class="line">        arr[start] = -arr[start];</span><br><span class="line">        <span class="keyword">return</span> jump == <span class="number">0</span> || canReach(arr, start + jump) || canReach(arr, start - jump);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-16"><a href="#Solution2-16" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    stack.push(start);</span><br><span class="line">    set.add(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = cur + arr[cur];</span><br><span class="line">        <span class="keyword">int</span> right = cur - arr[cur];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; left &lt; arr.length &amp;&amp; !set.contains(left)) &#123;</span><br><span class="line">            stack.push(left);</span><br><span class="line">            set.add(left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; right &lt; arr.length &amp;&amp; !set.contains(right)) &#123;</span><br><span class="line">            stack.push(right);</span><br><span class="line">            set.add(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minimum-jumps-with-fee"><a href="#Minimum-jumps-with-fee" class="headerlink" title="Minimum jumps with fee"></a>Minimum jumps with fee</h2><p>Given a staircase with ‘n’ steps and an array of ‘n’ numbers representing the fee that you have to pay if you take the step. Implement a method to calculate the minimum fee required to reach the top of the staircase (beyond the top-most step). </p>
<p>At every step, you have an option to take either 1 step, 2 steps, or 3 steps. You should assume that you are standing at the first step.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Number of stairs (n) : 6</span><br><span class="line">Fee: &#123;1,2,5,2,1,2&#125;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Starting from index &#39;0&#39;, we can reach the top through: 0-&gt;3-&gt;top</span><br><span class="line">The total fee we have to pay will be (1+2).</span><br><span class="line"></span><br><span class="line">Number of stairs (n): 4</span><br><span class="line">Fee: &#123;2,3,4,5&#125;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Starting from index &#39;0&#39;, we can reach the top through: 0-&gt;1-&gt;top</span><br><span class="line">The total fee we have to pay will be (2+3).</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-6"><a href="#Basic-Solution-6" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinFee</span><span class="params">(<span class="keyword">int</span>[] fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findMinFeeRecursive(fee, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMinFeeRecursive</span><span class="params">(<span class="keyword">int</span>[] fee, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentIndex &gt; fee.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we take 1 step, we are left with 'n-1' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take1Step = findMinFeeRecursive(fee, currentIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// similarly, if we took 2 steps, we are left with 'n-2' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take2Step = findMinFeeRecursive(fee, currentIndex + <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// if we took 3 steps, we are left with 'n-3' steps;</span></span><br><span class="line">    <span class="keyword">int</span> take3Step = findMinFeeRecursive(fee, currentIndex + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = Math.min(Math.min(take1Step, take2Step), take3Step);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min + fee[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-13"><a href="#Top-down-Dynamic-Programming-with-Memoization-13" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinFee</span><span class="params">(<span class="keyword">int</span>[] fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[fee.length];</span><br><span class="line">    <span class="keyword">return</span> findMinFeeRecursive(dp, fee, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMinFeeRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span>[] fee, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( currentIndex &gt; fee.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if we take 1 step, we are left with 'n-1' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take1Step = findMinFeeRecursive(dp, fee, currentIndex + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// similarly, if we took 2 steps, we are left with 'n-2' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take2Step = findMinFeeRecursive(dp, fee, currentIndex + <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// if we took 3 steps, we are left with 'n-3' steps;</span></span><br><span class="line">        <span class="keyword">int</span> take3Step = findMinFeeRecursive(dp, fee, currentIndex + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        dp[currentIndex] = fee[currentIndex] + Math.min(Math.min(take1Step, take2Step), take3Step);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-13"><a href="#Bottom-up-Dynamic-Programming-13" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinFee</span><span class="params">(<span class="keyword">int</span>[] fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[fee.length + <span class="number">1</span>]; <span class="comment">// +1 to handle the 0th step</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// if there are no steps, we dont have to pay any fee</span></span><br><span class="line">    dp[<span class="number">1</span>] = fee[<span class="number">0</span>]; <span class="comment">// only one step, so we have to pay its fee</span></span><br><span class="line">    <span class="comment">// for 2 or 3 steps staircase, since we start from the first step so we have to pay its fee</span></span><br><span class="line">    <span class="comment">// and from the first step we can reach the top by taking two or three steps, so we don't</span></span><br><span class="line">    <span class="comment">// have to pay any other fee.</span></span><br><span class="line">    dp[<span class="number">2</span>] = dp[<span class="number">3</span>] = fee[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; fee.length; i++)</span><br><span class="line">        dp[i + <span class="number">1</span>] = Math.min(fee[i] + dp[i], Math.min(fee[i - <span class="number">1</span>] + dp[i - <span class="number">1</span>], fee[i - <span class="number">2</span>] + dp[i - <span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[fee.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="House-thief"><a href="#House-thief" class="headerlink" title="House thief"></a>House thief</h2><h3 id="Basic-Solution-7"><a href="#Basic-Solution-7" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxSteal</span><span class="params">(<span class="keyword">int</span>[] wealth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findMaxStealRecursive(wealth, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxStealRecursive</span><span class="params">(<span class="keyword">int</span>[] wealth, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(currentIndex &gt;= wealth.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// steal from current house and skip one to steal from the next house</span></span><br><span class="line">    <span class="keyword">int</span> stealCurrent = wealth[currentIndex] + findMaxStealRecursive(wealth, currentIndex + <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// skip current house to steel from the adjacent house</span></span><br><span class="line">    <span class="keyword">int</span> skipCurrent = findMaxStealRecursive(wealth, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(stealCurrent, skipCurrent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-14"><a href="#Top-down-Dynamic-Programming-with-Memoization-14" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxSteal</span><span class="params">(<span class="keyword">int</span>[] wealth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[wealth.length];</span><br><span class="line">    <span class="keyword">return</span> findMaxStealRecursive(dp, wealth, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxStealRecursive</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span>[] wealth, <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( currentIndex &gt;= wealth.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[currentIndex] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// steal from current house and skip one to steal next</span></span><br><span class="line">        <span class="keyword">int</span> stealCurrent = wealth[currentIndex] + findMaxStealRecursive(dp, wealth, currentIndex + <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// skip current house to steel from the adjacent house</span></span><br><span class="line">        <span class="keyword">int</span> skipCurrent = findMaxStealRecursive(dp, wealth, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        dp[currentIndex] = Math.max(stealCurrent, skipCurrent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-up-Dynamic-Programming-14"><a href="#Bottom-up-Dynamic-Programming-14" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxSteal</span><span class="params">(<span class="keyword">int</span>[] wealth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wealth.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[wealth.length+<span class="number">1</span>]; <span class="comment">// '+1' to handle the zero house</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// if there are no houses, the thief can't steal anything</span></span><br><span class="line">    dp[<span class="number">1</span>] = wealth[<span class="number">0</span>]; <span class="comment">// only one house, so the thief have to steal from it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// please note that dp[] has one extra element to handle zero house</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; wealth.length; i++)</span><br><span class="line">        dp[i+<span class="number">1</span>] = Math.max(wealth[i] + dp[i-<span class="number">1</span>], dp[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[wealth.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memory-optimization-2"><a href="#Memory-optimization-2" class="headerlink" title="Memory optimization"></a>Memory optimization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxSteal</span><span class="params">(<span class="keyword">int</span>[] wealth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wealth.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">0</span>, n2=wealth[<span class="number">0</span>], temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; wealth.length; i++) &#123;</span><br><span class="line">        temp = Math.max(n1 + wealth[i], n2);</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pattern-4-Palindromic-Subsequence"><a href="#Pattern-4-Palindromic-Subsequence" class="headerlink" title="Pattern 4: Palindromic Subsequence"></a>Pattern 4: Palindromic Subsequence</h1><h2 id="✨516-Longest-Palindromic-Subsequence"><a href="#✨516-Longest-Palindromic-Subsequence" class="headerlink" title="✨516. Longest Palindromic Subsequence"></a><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">✨516. Longest Palindromic Subsequence</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &#x3D; &quot;cddpd&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: LPS is &quot;ddd&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-8"><a href="#Basic-Solution-8" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>try all the subsequences of the given sequence</p>
<p>We can start processing from the beginning and the end of the sequence. So at any step, we have two options:</p>
<ol>
<li>If the element at the beginning and the end are the same, we increment our count by two and make a recursive call for the remaining sequence.</li>
<li>We will skip the element either from the beginning or the end to make two recursive calls for the remaining subsequence.</li>
</ol>
<p>If option one applies then it will give us the length of LPS; otherwise, the length of LPS will be the maximum number returned by the two recurse calls from the second option.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLPSLength</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findLPSLengthRecursive(st, <span class="number">0</span>, st.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLPSLengthRecursive</span><span class="params">(String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt; endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every sequence with one element is a palindrome of length 1</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex == endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 1: elements at the beginning and the end are the same</span></span><br><span class="line">    <span class="keyword">if</span>(st.charAt(startIndex) == st.charAt(endIndex))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> + findLPSLengthRecursive(st, startIndex+<span class="number">1</span>, endIndex-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2: skip one element either from the beginning or the end</span></span><br><span class="line">    <span class="keyword">int</span> c1 =  findLPSLengthRecursive(st, startIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">    <span class="keyword">int</span> c2 =  findLPSLengthRecursive(st, startIndex, endIndex-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-15"><a href="#Top-down-Dynamic-Programming-with-Memoization-15" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><p>The two changing values to our recursive function are the two indexes, startIndex and endIndex. Therefore, we can store the results of all the subproblems in a two-dimensional array. (Another alternative could be to use a hash-table whose key would be a string (startIndex + “|” + endIndex))</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLPSLength</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[st.length()][st.length()];</span><br><span class="line">    <span class="keyword">return</span> findLPSLengthRecursive(dp, st, <span class="number">0</span>, st.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLPSLengthRecursive</span><span class="params">(Integer[][] dp, String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt; endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every sequence with one element is a palindrome of length 1</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex == endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[startIndex][endIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// case 1: elements at the beginning and the end are the same</span></span><br><span class="line">        <span class="keyword">if</span>(st.charAt(startIndex) == st.charAt(endIndex)) &#123;</span><br><span class="line">            dp[startIndex][endIndex] = <span class="number">2</span> + findLPSLengthRecursive(dp, st, startIndex+<span class="number">1</span>, endIndex-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// case 2: skip one element either from the beginning or the end</span></span><br><span class="line">            <span class="keyword">int</span> c1 =  findLPSLengthRecursive(dp, st, startIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">            <span class="keyword">int</span> c2 =  findLPSLengthRecursive(dp, st, startIndex, endIndex-<span class="number">1</span>);</span><br><span class="line">            dp[startIndex][endIndex] = Math.max(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[startIndex][endIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a>Longest Palindromic Substring</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &#x3D; &quot;cddpd&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: LPS is &quot;dpd&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-9"><a href="#Basic-Solution-9" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLPSLength</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findLPSLengthRecursive(st, <span class="number">0</span>, st.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLPSLengthRecursive</span><span class="params">(String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt; endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every string with one character is a palindrome</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex == endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 1: elements at the beginning and the end are the same</span></span><br><span class="line">    <span class="keyword">if</span> (st.charAt(startIndex) == st.charAt(endIndex)) &#123;</span><br><span class="line">        <span class="keyword">int</span> remainingLength = endIndex - startIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// check if the remaining string is also a palindrome</span></span><br><span class="line">        <span class="keyword">if</span> (remainingLength == findLPSLengthRecursive(st, startIndex + <span class="number">1</span>, endIndex - <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> remainingLength + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2: skip one character either from the beginning or the end</span></span><br><span class="line">    <span class="keyword">int</span> c1 = findLPSLengthRecursive(st, startIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">    <span class="keyword">int</span> c2 = findLPSLengthRecursive(st, startIndex, endIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-16"><a href="#Top-down-Dynamic-Programming-with-Memoization-16" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLPSLength</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[st.length()][st.length()];</span><br><span class="line">    <span class="keyword">return</span> findLPSLengthRecursive(dp, st, <span class="number">0</span>, st.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLPSLengthRecursive</span><span class="params">(Integer[][] dp, String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt; endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every string with one character is a palindrome</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex == endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[startIndex][endIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// case 1: elements at the beginning and the end are the same</span></span><br><span class="line">        <span class="keyword">if</span> (st.charAt(startIndex) == st.charAt(endIndex)) &#123;</span><br><span class="line">            <span class="keyword">int</span> remainingLength = endIndex - startIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// check if the remaining string is also a palindrome</span></span><br><span class="line">            <span class="keyword">if</span> (remainingLength == findLPSLengthRecursive(dp, st, startIndex + <span class="number">1</span>, endIndex - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[startIndex][endIndex] = remainingLength + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// case 2: skip one character either from the beginning or the end</span></span><br><span class="line">            <span class="keyword">int</span> c1 = findLPSLengthRecursive(dp, st, startIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">            <span class="keyword">int</span> c2 = findLPSLengthRecursive(dp, st, startIndex, endIndex - <span class="number">1</span>);</span><br><span class="line">            dp[startIndex][endIndex] = Math.max(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[startIndex][endIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Count-of-Palindromic-Substrings"><a href="#🌕Unsolved-Count-of-Palindromic-Substrings" class="headerlink" title="🌕Unsolved Count of Palindromic Substrings"></a>🌕Unsolved Count of Palindromic Substrings</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abdbca&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Here are the palindromic substrings, &quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;bdb&quot;.</span><br></pre></td></tr></table></figure>

<p>can be easily converted to <a href="https://www.educative.io/collection/page/5668639101419520/5633779737559040/5661601461960704/" target="_blank" rel="noopener">Longest Palindromic Substring</a>. The only difference is that instead of calculating the longest palindromic substring, we will instead count all the palindromic substrings.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCPS</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[st.length()][st.length()];</span><br><span class="line">    <span class="keyword">return</span> findLPSLengthRecursive(dp, st, <span class="number">0</span>, st.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLPSLengthRecursive</span><span class="params">(Integer[][] dp, String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt; endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every string with one character is a palindrome</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex == endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[startIndex][endIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// case 1: elements at the beginning and the end are the same</span></span><br><span class="line">        <span class="keyword">int</span> way1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (st.charAt(startIndex) == st.charAt(endIndex)) &#123;</span><br><span class="line">            <span class="keyword">int</span> remainingLength = endIndex - startIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// check if the remaining string is also a palindrome</span></span><br><span class="line">            <span class="keyword">if</span> (remainingLength == findLPSLengthRecursive(dp, st, startIndex + <span class="number">1</span>, endIndex - <span class="number">1</span>)) &#123;</span><br><span class="line">                way1 = remainingLength + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// case 2: skip one character either from the beginning or the end</span></span><br><span class="line">        <span class="keyword">int</span> way2 = findLPSLengthRecursive(dp, st, startIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">        <span class="keyword">int</span> way3 = findLPSLengthRecursive(dp, st, startIndex, endIndex - <span class="number">1</span>);</span><br><span class="line">        dp[startIndex][endIndex] = way1 + way2 + way3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[startIndex][endIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="⭐Minimum-Deletions-in-a-String-to-make-it-a-Palindrome"><a href="#⭐Minimum-Deletions-in-a-String-to-make-it-a-Palindrome" class="headerlink" title="⭐Minimum Deletions in a String to make it a Palindrome"></a>⭐Minimum Deletions in a String to make it a Palindrome</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abdbca&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: By removing &quot;c&quot;, we get a palindrome &quot;abdba&quot;.</span><br><span class="line"></span><br><span class="line">Input: &#x3D; &quot;cddpd&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Deleting &quot;cp&quot;, we get a palindrome &quot;ddd&quot;.</span><br></pre></td></tr></table></figure>

<p>This problem can be easily converted to the <a href="https://www.educative.io/collection/page/5668639101419520/5633779737559040/5748119283171328/" target="_blank" rel="noopener">Longest Palindromic Subsequence</a> (LPS) problem. We can use the fact that LPS is the best subsequence we can have, so any character that is not part of LPS must be removed. Please note that it is ‘Longest Palindromic SubSequence’ and not ‘Longest Palindrome Substring’.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Minimum_deletions_to_make_palindrome &#x3D; Length(st) - LPS(st)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinimumDeletions</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// subtracting the length of Longest Palindromic Subsequence from the length of</span></span><br><span class="line">    <span class="comment">// the input string to get minimum number of deletions</span></span><br><span class="line">    <span class="keyword">return</span> st.length() - findLPSLength(st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLPSLength</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[st.length()][st.length()];</span><br><span class="line">    <span class="keyword">return</span> findLPSLengthRecursive(dp, st, <span class="number">0</span>, st.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLPSLengthRecursive</span><span class="params">(Integer[][] dp, String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt; endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every sequence with one element is a palindrome of length 1</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex == endIndex)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[startIndex][endIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// case 1: elements at the beginning and the end are the same</span></span><br><span class="line">        <span class="keyword">if</span>(st.charAt(startIndex) == st.charAt(endIndex)) &#123;</span><br><span class="line">            dp[startIndex][endIndex] = <span class="number">2</span> + findLPSLengthRecursive(dp, st, startIndex+<span class="number">1</span>, endIndex-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// case 2: skip one element either from the beginning or the end</span></span><br><span class="line">            <span class="keyword">int</span> c1 =  findLPSLengthRecursive(dp, st, startIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">            <span class="keyword">int</span> c2 =  findLPSLengthRecursive(dp, st, startIndex, endIndex-<span class="number">1</span>);</span><br><span class="line">            dp[startIndex][endIndex] = Math.max(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[startIndex][endIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Similar-problems"><a href="#Similar-problems" class="headerlink" title="Similar problems"></a>Similar problems</h3><h3 id="1-1312-Minimum-insertions-in-a-string-to-make-it-a-palindrome✨"><a href="#1-1312-Minimum-insertions-in-a-string-to-make-it-a-palindrome✨" class="headerlink" title="1. 1312 Minimum insertions in a string to make it a palindrome✨"></a><a href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/" target="_blank" rel="noopener">1. 1312 Minimum insertions in a string to make it a palindrome✨</a></h3><p>the length of the Longest Palindromic Subsequence is the best palindromic subsequence we can have.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abdbca&quot;   </span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>Explanation: By inserting “c”, we get a palindrome “a<strong>c</strong>bdbca”.</p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &#x3D; &quot;cddpd&quot;  </span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>Explanation: Inserting “cp”, we get a palindrome “cd<strong>p</strong>dpd<strong>c</strong>”. We can also get a palindrome by inserting “dc”: “cddpd<strong>dc</strong>”</p>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &#x3D; &quot;pqr&quot;  </span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>Explanation: We have to insert any two characters to get a palindrome (e.g. if we insert “pq”, we get a palindrome “pqr<strong>qp</strong>”).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[s.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> maxSub = findMax(<span class="number">0</span>, s.length() - <span class="number">1</span>, s, dp);</span><br><span class="line">    <span class="keyword">return</span> s.length() - maxSub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String s, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[left][right] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            dp[left][right] = <span class="number">2</span> + findMax(left + <span class="number">1</span>, right - <span class="number">1</span>, s, dp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> way1 = findMax(left + <span class="number">1</span>, right, s, dp);</span><br><span class="line">            <span class="keyword">int</span> way2 = findMax(left, right - <span class="number">1</span>, s, dp);</span><br><span class="line">            dp[left][right] = Math.max(way1, way2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[left][right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Find-if-a-string-is-K-Palindromic"><a href="#2-Find-if-a-string-is-K-Palindromic" class="headerlink" title="2. Find if a string is K-Palindromic"></a>2. Find if a string is K-Palindromic</h3><p>Any string will be called K-palindromic if it can be transformed into a palindrome by removing at most ‘K’ characters from it.</p>
<p>This problem can easily be converted to our base problem of finding the minimum deletions in a string to make it a palindrome. I</p>
<p>f the “minimum deletion count” is not more than ‘K’, the string will be K-Palindromic.</p>
<h2 id="🌕✨Unsolved-132-Palindromic-Partitioning"><a href="#🌕✨Unsolved-132-Palindromic-Partitioning" class="headerlink" title="🌕✨Unsolved 132. Palindromic Partitioning"></a><a href="https://leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">🌕✨Unsolved 132. Palindromic Partitioning</a></h2><p>Given a string, we want to cut it into pieces such that each piece is a palindrome. Write a function to return the minimum number of cuts needed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abdbca&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Palindrome pieces are &quot;a&quot;, &quot;bdb&quot;, &quot;c&quot;, &quot;a&quot;.</span><br><span class="line"></span><br><span class="line">Input: &#x3D; &quot;cddpd&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Palindrome pieces are &quot;c&quot;, &quot;d&quot;, &quot;dpd&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-10"><a href="#Basic-Solution-10" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>The brute-force solution will be to try all the substring combinations of the given string. We can start processing from the beginning of the string and keep adding one character at a time. At any step, if we get a palindrome, we take it as one piece and recursively process the remaining length of the string to find the minimum cuts needed.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMPPCuts</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.findMPPCutsRecursive(st, <span class="number">0</span>, st.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMPPCutsRecursive</span><span class="params">(String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// we don't need to cut the string if it is a palindrome</span></span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt;= endIndex || isPalindrome(st, startIndex, endIndex))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// at max, we need to cut the string into its 'length-1' pieces</span></span><br><span class="line">    <span class="keyword">int</span> minimumCuts = endIndex-startIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=startIndex; i &lt;= endIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPalindrome(st, startIndex, i))&#123;</span><br><span class="line">            <span class="comment">// we can cut here as we have a palindrome from 'startIndex' to 'i'</span></span><br><span class="line">            minimumCuts = Math.min(minimumCuts, <span class="number">1</span> + findMPPCutsRecursive(st, i+<span class="number">1</span>, endIndex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimumCuts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String st, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(st.charAt(x++) != st.charAt(y--))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-17"><a href="#Top-down-Dynamic-Programming-with-Memoization-17" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><p>We can memoize both functions <code>findMPPCutsRecursive()</code> and <code>isPalindrome()</code>. The two changing values in both these functions are the two indexes; therefore, we can store the results of all the subproblems in a two-dimensional array. (alternatively, we can use a hash-table).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMPPCuts</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">    Integer dp[][] = <span class="keyword">new</span> Integer[st.length()][st.length()];</span><br><span class="line">    Boolean dpIsPalindrome[][] = <span class="keyword">new</span> Boolean[st.length()][st.length()];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.findMPPCutsRecursive(dp, dpIsPalindrome, st, <span class="number">0</span>, st.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMPPCutsRecursive</span><span class="params">(Integer dp[][], Boolean dpIsPalindrome[][],</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String st, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex || isPalindrome(dpIsPalindrome, st, startIndex, endIndex))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[startIndex][endIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// at max, we need to cut the string into its 'length-1' pieces</span></span><br><span class="line">        <span class="keyword">int</span> minimumCuts = endIndex - startIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=startIndex; i &lt;= endIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(dpIsPalindrome, st, startIndex, i)) &#123;</span><br><span class="line">                <span class="comment">// we can cut here as we have a palindrome from 'startIndex' to 'i'</span></span><br><span class="line">                minimumCuts = Math.min(minimumCuts, <span class="number">1</span> + findMPPCutsRecursive(dp, dpIsPalindrome, st, i+<span class="number">1</span>, endIndex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[startIndex][endIndex] = minimumCuts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[startIndex][endIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(Boolean dpIsPalindrome[][], String st, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dpIsPalindrome[x][y] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        dpIsPalindrome[x][y]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i=x, j=y;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.charAt(i++) != st.charAt(j--)) &#123;</span><br><span class="line">                dpIsPalindrome[x][y]=<span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// use memoization to find if the remaining string is a palindrome</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; j &amp;&amp; dpIsPalindrome[i][j] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dpIsPalindrome[x][y] = dpIsPalindrome[i][j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpIsPalindrome[x][y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[s.length()][s.length()];</span><br><span class="line">    Boolean[][] dpIsPalindrome = <span class="keyword">new</span> Boolean[s.length()][s.length()];</span><br><span class="line">    <span class="keyword">return</span> findMaxCut(<span class="number">0</span>, s.length() - <span class="number">1</span>, s, dpIsPalindrome, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxCut</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String s, Boolean[][] dpIsPalindrome, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right || isPalindrome(left, right, s, dpIsPalindrome)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[left][right] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> minCut = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(left, i, s, dpIsPalindrome)) &#123;</span><br><span class="line">                minCut = Math.min(minCut, <span class="number">1</span> + findMaxCut(i + <span class="number">1</span>, right, s, dpIsPalindrome, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[left][right] = minCut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[left][right];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String s, Boolean[][] dpIsPalindrome)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dpIsPalindrome[left][right] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        dpIsPalindrome[left][right] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i++) != s.charAt(j--)) &#123;</span><br><span class="line">                dpIsPalindrome[left][right] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j &amp;&amp; dpIsPalindrome[i][j] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dpIsPalindrome[left][right] = dpIsPalindrome[i][j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpIsPalindrome[left][right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕131-Palindrome-Partitioning✨"><a href="#🌕131-Palindrome-Partitioning✨" class="headerlink" title="🌕131. Palindrome Partitioning✨"></a><a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">🌕131. Palindrome Partitioning✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s = <span class="string">"aab"</span></span><br><span class="line">Output: [[<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"aa"</span>,<span class="string">"b"</span>]]</span><br><span class="line"></span><br><span class="line">Input: s = <span class="string">"a"</span></span><br><span class="line">Output: [[<span class="string">"a"</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-48"><a href="#Solution1-48" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; partitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; tempPartition = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    doPartition(s, partitions, tempPartition);</span><br><span class="line">    <span class="keyword">return</span> partitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPartition</span><span class="params">(String s, List&lt;List&lt;String&gt;&gt; partitions, List&lt;String&gt; tempPartition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        partitions.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempPartition));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPalindrome(s, <span class="number">0</span>, i)) &#123;</span><br><span class="line">            tempPartition.add(s.substring(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">            doPartition(s.substring(i + <span class="number">1</span>), partitions, tempPartition);</span><br><span class="line">            tempPartition.remove(tempPartition.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(begin++) != s.charAt(end--)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-17"><a href="#Solution2-17" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getPartition(s, <span class="number">0</span>, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPartition</span><span class="params">(String s, <span class="keyword">int</span> start, List&lt;String&gt; cur, List&lt;List&lt;String&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, start, i)) &#123;</span><br><span class="line">                cur.add(s.substring(start, i+<span class="number">1</span>));</span><br><span class="line">                getPartition(s, i+<span class="number">1</span>, cur, ans);</span><br><span class="line">                cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i++) != s.charAt(j--)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="267-Palindrome-Permutation-II"><a href="#267-Palindrome-Permutation-II" class="headerlink" title="267. Palindrome Permutation II"></a><a href="https://leetcode.com/problems/palindrome-permutation-ii/" target="_blank" rel="noopener">267. Palindrome Permutation II</a></h3><h3 id="Solution1-49"><a href="#Solution1-49" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generatePalindromes</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> odds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) count[c]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            odds++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (odds &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        Character center = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                center = (<span class="keyword">char</span>) i;</span><br><span class="line">                count[i]--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        generate(ans, count, (center != <span class="keyword">null</span>? String.valueOf(center) : <span class="keyword">new</span> String()), s.length());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(List&lt;String&gt; ans, <span class="keyword">int</span>[] count, String cur, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count[i] -= <span class="number">2</span>;</span><br><span class="line">            generate(ans, count, ((<span class="keyword">char</span>) i) + cur + ((<span class="keyword">char</span>) i), size);</span><br><span class="line">            count[i] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur.length() == size) ans.add(<span class="keyword">new</span> String(cur));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pattern-5-Longest-Common-Substring"><a href="#Pattern-5-Longest-Common-Substring" class="headerlink" title="Pattern 5: Longest Common Substring"></a>Pattern 5: Longest Common Substring</h1><h2 id="🌕Longest-Common-Substring"><a href="#🌕Longest-Common-Substring" class="headerlink" title="🌕Longest Common Substring"></a>🌕Longest Common Substring</h2><p>Given two strings ‘s1’ and ‘s2’, find the length of the longest substring which is common in both the strings.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;abdca&quot;</span><br><span class="line">       s2 &#x3D; &quot;cbda&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest common substring is &quot;bd&quot;.</span><br><span class="line"></span><br><span class="line">Input: s1 &#x3D; &quot;passport&quot;</span><br><span class="line">       s2 &#x3D; &quot;ppsspt&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common substring is &quot;ssp&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-11"><a href="#Basic-Solution-11" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>A basic brute-force solution could be to try all substrings of ‘s1’ and ‘s2’ to find the longest common one. We can start matching both the strings one character at a time, so we have two options at any step:</p>
<ol>
<li>If the strings have a matching character, we can recursively match for the remaining lengths and keep a track of the current matching length.</li>
<li>If the strings don’t match, we start two new recursive calls by skipping one character separately from each string and reset the matching length.</li>
</ol>
<p>The length of the Longest Common Substring (LCS) will be the maximum number returned by the three recurse calls in the above two options.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLCSLength</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findLCSLengthRecursive(s1, s2, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLCSLengthRecursive</span><span class="params">(String s1, String s2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i1 == s1.length() || i2 == s2.length())</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s1.charAt(i1) == s2.charAt(i2))</span><br><span class="line">        count = findLCSLengthRecursive(s1, s2, i1+<span class="number">1</span>, i2+<span class="number">1</span>, count+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1 = findLCSLengthRecursive(s1, s2, i1, i2+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> c2 = findLCSLengthRecursive(s1, s2, i1+<span class="number">1</span>, i2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(count, Math.max(c1, c2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-18"><a href="#Top-down-Dynamic-Programming-with-Memoization-18" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><p>The three changing values to our recursive function are the two indexes (i1 and i2) and the ‘count’. Therefore, we can store the results of all subproblems in a three-dimensional array. (Another alternative could be to use a hash-table whose key would be a string (i1 + “|” i2 + “|” + count)).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLCSLength</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = Math.min(s1.length(), s2.length());</span><br><span class="line">    Integer[][][] dp = <span class="keyword">new</span> Integer[s1.length()][s2.length()][maxLength];</span><br><span class="line">    <span class="keyword">return</span> findLCSLengthRecursive(dp, s1, s2, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLCSLengthRecursive</span><span class="params">(Integer[][][] dp, String s1, String s2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i1 == s1.length() || i2 == s2.length())</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[i1][i2][count] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> c1 = count;</span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(i1) == s2.charAt(i2))</span><br><span class="line">            c1 = findLCSLengthRecursive(dp, s1, s2, i1+<span class="number">1</span>, i2+<span class="number">1</span>, count+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> c2 = findLCSLengthRecursive(dp, s1, s2, i1, i2+<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">//count -&gt; 归零</span></span><br><span class="line">        <span class="keyword">int</span> c3 = findLCSLengthRecursive(dp, s1, s2, i1+<span class="number">1</span>, i2, <span class="number">0</span>);</span><br><span class="line">        dp[i1][i2][count] = Math.max(c1, Math.max(c2, c3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i1][i2][count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="✨1143-Longest-Common-Subsequence"><a href="#✨1143-Longest-Common-Subsequence" class="headerlink" title="✨1143. Longest Common Subsequence"></a><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">✨1143. Longest Common Subsequence</a></h2><p>A <a href="https://en.wikipedia.org/wiki/Subsequence" target="_blank" rel="noopener">subsequence</a> is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;abdca&quot;</span><br><span class="line">       s2 &#x3D; &quot;cbda&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;bda&quot;.</span><br><span class="line"></span><br><span class="line">Input: s1 &#x3D; &quot;passport&quot;</span><br><span class="line">       s2 &#x3D; &quot;ppsspt&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest common subsequence is &quot;psspt&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-12"><a href="#Basic-Solution-12" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLCSLength</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findLCSLengthRecursive(s1, s2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLCSLengthRecursive</span><span class="params">(String s1, String s2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i1 == s1.length() || i2 == s2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s1.charAt(i1) == s2.charAt(i2))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + findLCSLengthRecursive(s1, s2, i1+<span class="number">1</span>, i2+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1 = findLCSLengthRecursive(s1, s2, i1, i2+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> c2 = findLCSLengthRecursive(s1, s2, i1+<span class="number">1</span>, i2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-19"><a href="#Top-down-Dynamic-Programming-with-Memoization-19" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLCSLength</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[s1.length()][s2.length()];</span><br><span class="line">    <span class="keyword">return</span> findLCSLengthRecursive(dp, s1, s2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLCSLengthRecursive</span><span class="params">(Integer[][] dp, String s1, String s2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i1 == s1.length() || i2 == s2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[i1][i2] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i1) == s2.charAt(i2))</span><br><span class="line">            dp[i1][i2] = <span class="number">1</span> + findLCSLengthRecursive(dp, s1, s2, i1 + <span class="number">1</span>, i2 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> c1 = findLCSLengthRecursive(dp, s1, s2, i1, i2 + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> c2 = findLCSLengthRecursive(dp, s1, s2, i1 + <span class="number">1</span>, i2);</span><br><span class="line">            dp[i1][i2] = Math.max(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i1][i2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minimum-Deletions-amp-Insertions-to-Transform-a-String-into-another"><a href="#Minimum-Deletions-amp-Insertions-to-Transform-a-String-into-another" class="headerlink" title="Minimum Deletions &amp; Insertions to Transform a String into another"></a>Minimum Deletions &amp; Insertions to Transform a String into another</h2><p>Given strings s1 and s2, we need to transform s1 into s2 by deleting and inserting characters. Write a function to calculate the count of the minimum number of deletion and insertion operations.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;abc&quot;</span><br><span class="line">       s2 &#x3D; &quot;fbc&quot;</span><br><span class="line">Output: 1 deletion and 1 insertion.</span><br><span class="line">Explanation: We need to delete &#123;&#39;a&#39;&#125; and insert &#123;&#39;f&#39;&#125; to s1 to transform it into s2.</span><br></pre></td></tr></table></figure>

<p>This problem can easily be converted to the <a href="https://www.educative.io/collection/page/5668639101419520/5633779737559040/5657535201673216/" target="_blank" rel="noopener">Longest Common Subsequence</a> (LCS). If we can find the LCS of the two input strings, we can easily find how many characters we need to insert and delete from s1. Here is how we can do this:</p>
<ol>
<li>Let’s assume <code>len1</code> is the length of s1 and <code>len2</code> is the length of s2.</li>
<li>Now let’s assume <code>c1</code> is the length of LCS of the two strings s1 and s2.</li>
<li>To transform s1 into s2, we need to delete everything from s1 which is not part of LCS, so minimum deletions we need to perform from s1 =&gt; <code>len1 - c1</code></li>
<li>Similarly, we need to insert everything in s1 which is present in s2 but not part of LCS, so minimum insertions we need to perform in s1 =&gt; <code>len2 - c1</code></li>
</ol>
<h3 id="💎583-Delete-Operation-for-Two-Strings"><a href="#💎583-Delete-Operation-for-Two-Strings" class="headerlink" title="💎583. Delete Operation for Two Strings"></a><a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">💎583. Delete Operation for Two Strings</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[word1.length()][word2.length()];</span><br><span class="line">    <span class="keyword">int</span> c = findMax(<span class="number">0</span>, <span class="number">0</span>, word1, word2, dp);</span><br><span class="line">    <span class="keyword">return</span> (word1.length() + word2.length() - <span class="number">2</span> * c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2, String s1, String s2, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i1 &gt;= s1.length() || i2 &gt;= s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[i1][i2] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i1) == s2.charAt(i2)) &#123;</span><br><span class="line">            dp[i1][i2] = <span class="number">1</span> + findMax(i1 + <span class="number">1</span>, i2 + <span class="number">1</span>, s1, s2, dp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> c1 = findMax(i1 + <span class="number">1</span>, i2, s1, s2, dp);</span><br><span class="line">            <span class="keyword">int</span> c2 = findMax(i1, i2 + <span class="number">1</span>, s1, s2, dp);</span><br><span class="line">            dp[i1][i2] = Math.max(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i1][i2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕300-Longest-Increasing-Subsequence⭐"><a href="#🌕300-Longest-Increasing-Subsequence⭐" class="headerlink" title="🌕300. Longest Increasing Subsequence⭐"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">🌕300. Longest Increasing Subsequence⭐</a></h2><p>Given a number sequence, find the length of its Longest Increasing Subsequence (LIS). In an increasing subsequence, all the elements are in increasing order (from lowest to highest).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;4,2,3,6,10,1,12&#125;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LIS is &#123;2,3,6,10,12&#125;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-13"><a href="#Basic-Solution-13" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>We can process one number at a time, so we have two options at any step:</p>
<ol>
<li>If the current number is greater than the previous number that we included, we can increment our count and make a recursive call for the remaining array.</li>
<li>We can skip the current number to make a recursive call for the remaining array.</li>
</ol>
<p>The length of the longest increasing subsequence will be the maximum number returned by the two recurse calls from the above two options.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLISLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findLISLengthRecursive(nums, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLISLengthRecursive</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> previousIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(currentIndex == nums.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// include nums[currentIndex] if it is larger than the last included number</span></span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(previousIndex == -<span class="number">1</span> || nums[currentIndex] &gt; nums[previousIndex])</span><br><span class="line">        c1 = <span class="number">1</span> + findLISLengthRecursive(nums, currentIndex+<span class="number">1</span>, currentIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// excluding the number at currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> c2 = findLISLengthRecursive(nums, currentIndex+<span class="number">1</span>, previousIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-20"><a href="#Top-down-Dynamic-Programming-with-Memoization-20" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLISLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[nums.length][nums.length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> findLISLengthRecursive(dp, nums, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLISLengthRecursive</span><span class="params">(Integer[][] dp, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> previousIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentIndex == nums.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[currentIndex][previousIndex + <span class="number">1</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// include nums[currentIndex] if it is larger than the last included number</span></span><br><span class="line">        <span class="keyword">int</span> c1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (previousIndex == -<span class="number">1</span> || nums[currentIndex] &gt; nums[previousIndex])</span><br><span class="line">            c1 = <span class="number">1</span> + findLISLengthRecursive(dp, nums, currentIndex+<span class="number">1</span>, currentIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c2 = findLISLengthRecursive(dp, nums, currentIndex+<span class="number">1</span>, previousIndex);</span><br><span class="line">        dp[currentIndex][previousIndex + <span class="number">1</span>] = Math.max(c1, c2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[currentIndex][previousIndex + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Maximum-Sum-Increasing-Subsequence"><a href="#🌕Maximum-Sum-Increasing-Subsequence" class="headerlink" title="🌕Maximum Sum Increasing Subsequence"></a>🌕Maximum Sum Increasing Subsequence</h2><p>Given a number sequence, find the increasing subsequence with the highest sum. Write a method that returns the highest sum.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;4,1,2,6,10,1,12&#125;</span><br><span class="line">Output: 32</span><br><span class="line">Explanation: The increaseing sequence is &#123;4,6,10,12&#125;. </span><br><span class="line">Please note the difference, as the LIS is &#123;1,2,6,10,12&#125; which has a sum of &#39;31&#39;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-14"><a href="#Basic-Solution-14" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>We can process one number at a time, so we have two options at any step:</p>
<ol>
<li>If the current number is greater than the previous number that we included, we include that number in a running sum and make a recursive call for the remaining array.</li>
<li>We can skip the current number to make a recursive call for the remaining array.</li>
</ol>
<p>The highest sum of any increasing subsequence would be the max value returned by the two recurse calls from the above two options.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMSIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findMSISRecursive(nums, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMSISRecursive</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> previousIndex, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(currentIndex == nums.length)</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// include nums[currentIndex] if it is larger than the last included number</span></span><br><span class="line">    <span class="keyword">int</span> s1 = sum;</span><br><span class="line">    <span class="keyword">if</span>(previousIndex == -<span class="number">1</span> || nums[currentIndex] &gt; nums[previousIndex])</span><br><span class="line">        s1 = findMSISRecursive(nums, currentIndex+<span class="number">1</span>, currentIndex, sum + nums[currentIndex]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// excluding the number at currentIndex</span></span><br><span class="line">    <span class="keyword">int</span> s2 = findMSISRecursive(nums, currentIndex+<span class="number">1</span>, previousIndex, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-21"><a href="#Top-down-Dynamic-Programming-with-Memoization-21" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMSIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; dp = <span class="keyword">new</span> HashMap&lt;&gt;();  </span><br><span class="line">    <span class="keyword">return</span> findMSISRecursive(dp, nums, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMSISRecursive</span><span class="params">(Map&lt;String, Integer&gt; dp, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span>[] nums, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> previousIndex, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentIndex == nums.length)</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    String subProblemKey = currentIndex + <span class="string">"-"</span> + previousIndex + <span class="string">"-"</span> + sum;</span><br><span class="line">    <span class="keyword">if</span> (!dp.containsKey(subProblemKey)) &#123;</span><br><span class="line">        <span class="comment">// include nums[currentIndex] if it is larger than the last included number</span></span><br><span class="line">        <span class="keyword">int</span> s1 = sum;</span><br><span class="line">        <span class="keyword">if</span>(previousIndex == -<span class="number">1</span> || nums[currentIndex] &gt; nums[previousIndex])</span><br><span class="line">            s1 = findMSISRecursive(dp, nums, currentIndex+<span class="number">1</span>, currentIndex, sum + nums[currentIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// excluding the number at currentIndex</span></span><br><span class="line">        <span class="keyword">int</span> s2 = findMSISRecursive(dp, nums, currentIndex+<span class="number">1</span>, previousIndex, sum);</span><br><span class="line">        dp.put(subProblemKey, Math.max(s1, s2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp.get(subProblemKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕✨1092-Shortest-Common-Super-sequence"><a href="#🌕✨1092-Shortest-Common-Super-sequence" class="headerlink" title="🌕✨1092. Shortest Common Super-sequence"></a><a href="https://leetcode.com/problems/shortest-common-supersequence/" target="_blank" rel="noopener">🌕✨1092. Shortest Common Super-sequence</a></h2><p>Given two sequences ‘s1’ and ‘s2’, write a method to find the length of the shortest sequence which has ‘s1’ and ‘s2’ as subsequences.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: s1: &quot;abcf&quot; s2:&quot;bdcf&quot; </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The shortest common super-sequence (SCS) is &quot;abdcf&quot;. </span><br><span class="line"></span><br><span class="line">Input: s1: &quot;dynamic&quot; s2:&quot;programming&quot; </span><br><span class="line">Output: 15</span><br><span class="line">Explanation: The SCS is &quot;dynprogrammicng&quot;.</span><br></pre></td></tr></table></figure>

<h3 id="Basic-Solution-15"><a href="#Basic-Solution-15" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>We can process both of the sequences one character at a time, so at any step we must choose between:</p>
<ol>
<li>If the sequences have a matching character, we can skip one character from both the sequences and make a recursive call for the remaining lengths to get SCS.</li>
<li>If the strings don’t match, we start two new recursive calls by skipping one character separately from each string. The minimum of these two recursive calls will have our answer.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSCSLength</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findSCSLengthRecursive(s1, s2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSCSLengthRecursive</span><span class="params">(String s1, String s2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if we have reached the end of a string, return the remaining length of the other string, </span></span><br><span class="line">    <span class="comment">// as in this case we have to take all of the remaining other string</span></span><br><span class="line">    <span class="keyword">if</span>(i1 == s1.length())</span><br><span class="line">        <span class="keyword">return</span> s2.length()-i2;</span><br><span class="line">    <span class="keyword">if</span>(i2 == s2.length())</span><br><span class="line">        <span class="keyword">return</span> s1.length()-i1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s1.charAt(i1) == s2.charAt(i2))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + findSCSLengthRecursive(s1, s2, i1+<span class="number">1</span>, i2+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length1 = <span class="number">1</span> + findSCSLengthRecursive(s1, s2, i1, i2+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> length2 = <span class="number">1</span> + findSCSLengthRecursive(s1, s2, i1+<span class="number">1</span>, i2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(length1, length2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Top-down-Dynamic-Programming-with-Memoization-22"><a href="#Top-down-Dynamic-Programming-with-Memoization-22" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSCSLength</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    Integer[][] dp = <span class="keyword">new</span> Integer[s1.length()][s2.length()];</span><br><span class="line">    <span class="keyword">return</span> findSCSLengthRecursive(dp, s1, s2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSCSLengthRecursive</span><span class="params">(Integer[][] dp, String s1, String s2, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if we have reached the end of a string, return the remaining length of the other string, </span></span><br><span class="line">    <span class="comment">// as in this case we have to take all of the remaining other string</span></span><br><span class="line">    <span class="keyword">if</span>(i1 == s1.length())</span><br><span class="line">        <span class="keyword">return</span> s2.length()-i2;</span><br><span class="line">    <span class="keyword">if</span>(i2 == s2.length())</span><br><span class="line">        <span class="keyword">return</span> s1.length()-i1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[i1][i2] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(i1) == s2.charAt(i2))</span><br><span class="line">            dp[i1][i2] = <span class="number">1</span> + findSCSLengthRecursive(dp, s1, s2, i1+<span class="number">1</span>, i2+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> length1 = <span class="number">1</span> + findSCSLengthRecursive(dp, s1, s2, i1, i2+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> length2 = <span class="number">1</span> + findSCSLengthRecursive(dp, s1, s2, i1+<span class="number">1</span>, i2);</span><br><span class="line">            dp[i1][i2] = Math.min(length1, length2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i1][i2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/17/Recursion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/Recursion/" class="post-title-link" itemprop="url">Recursion</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 13:05:50" itemprop="dateCreated datePublished" datetime="2020-09-17T13:05:50+09:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 13:20:41" itemprop="dateModified" datetime="2021-03-08T13:20:41+09:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pattern-Subsets"><a href="#Pattern-Subsets" class="headerlink" title="Pattern: Subsets"></a>Pattern: Subsets</h1><p>\301. Remove Invalid Parentheses</p>
<p>\787. Cheapest Flights Within K Stops</p>
<h2 id="Subsets-easy-✨"><a href="#Subsets-easy-✨" class="headerlink" title="Subsets (easy)✨"></a>Subsets (easy)✨</h2><p>To generate all subsets of the given set, we can use the <strong>Breadth First Search (BFS)</strong> approach. We can start with an empty set, iterate through all numbers one-by-one, and add them to existing sets to create new subsets.</p>
<p>Let’s take the example-2 mentioned above to go through each step of our algorithm:</p>
<p>Given set: [1, 5, 3]</p>
<ol>
<li>Start with an empty set: [[]]</li>
<li>Add the first number (1) to all the existing subsets to create new subsets: [[], <strong>[1]]</strong>;</li>
<li>Add the second number (5) to all the existing subsets: [[], [1], <strong>[5], [1,5]</strong>];</li>
<li>Add the third number (3) to all the existing subsets: [[], [1], [5], [1,5], <strong>[3], [1,3], [5,3], [1,5,3]</strong>].</li>
</ol>
<p>Time complexity</p>
<p>Since, in each step, the number of subsets doubles as we add each element to all the existing subsets, therefore, we will have a total of O(2^N) subsets, where ‘N’ is the total number of elements in the input set. And since we construct a new subset from an existing set, therefore, the time complexity of the above algorithm will be O(N*2^N).</p>
<p>Space complexity</p>
<p>All the additional space used by our algorithm is for the output list. Since we will have a total of O(2^N)<em>O</em>(2<em>N</em>) subsets, and each subset can take up to O(N) space, therefore, the space complexity of our algorithm will be O(N*2^N).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; findSubsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// start by adding the empty subset</span></span><br><span class="line">    subsets.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> currentNumber : nums) &#123;</span><br><span class="line">        <span class="comment">// we will take all existing subsets and insert the current number in them to create new subsets</span></span><br><span class="line">        <span class="keyword">int</span> n = subsets.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// create a new subset from the existing subset and insert the current element to it</span></span><br><span class="line">            List&lt;Integer&gt; set = <span class="keyword">new</span> ArrayList&lt;&gt;(subsets.get(i));</span><br><span class="line">            set.add(currentNumber);</span><br><span class="line">            subsets.add(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Power-Set-AE-✨"><a href="#Power-Set-AE-✨" class="headerlink" title="Power Set(AE)✨"></a>Power Set(AE)✨</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">traverse:</span><br><span class="line">[[]] <span class="comment">//1</span></span><br><span class="line">[[],[<span class="number">1</span>]] <span class="comment">//2</span></span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]]  <span class="comment">//3</span></span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n*2^n^) time | O(n*2^n^) space</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; powerset(List&lt;Integer&gt; array) &#123;</span><br><span class="line">    <span class="keyword">return</span> powerset(array, array.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; powerset(List&lt;Integer&gt; array, <span class="keyword">int</span> idx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;  <span class="comment">//edge case</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; emptySet = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        emptySet.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> emptySet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ele = array.get(idx);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = powerset(array, idx - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//powerset of [1,2,3] -&gt; add 4 ele to all prev subsets -&gt; powerset of [1,2,3,4]</span></span><br><span class="line">    <span class="keyword">int</span> length = subsets.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        List&lt;Integer&gt; currentSubset = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(subsets.get(i));</span><br><span class="line">        currentSubset.add(ele);</span><br><span class="line">        subsets.add(currentSubset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>generate the subset based on the subsets we currently have</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n*2^n^) time | O(n*2^n^) space</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; powerset(List&lt;Integer&gt; array) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();  <span class="comment">//declare out subsets varaible</span></span><br><span class="line">    subsets.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());  <span class="comment">//add the empty array</span></span><br><span class="line">    <span class="keyword">for</span> (Integer ele : array) &#123;  <span class="comment">//tarverse the element in the array</span></span><br><span class="line">        <span class="keyword">int</span> length = subsets.size();  <span class="comment">//necessary</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;  <span class="comment">//each subset add the new ele create a new subset</span></span><br><span class="line">            List&lt;Integer&gt; currentSubset = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(subsets.get(i));</span><br><span class="line">            currentSubset.add(ele);</span><br><span class="line">            subsets.add(currentSubset);  <span class="comment">//add the new subset to the subsets</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="78-Subsets✨"><a href="#78-Subsets✨" class="headerlink" title="78. Subsets✨"></a><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">78. Subsets✨</a></h3><h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Backtracking 找出集合的所有子集，子集不能重复，[1, 2] 和 [2, 1] 这种子集算重复</li>
<li><a href="https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)" target="_blank" rel="noopener">https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pick a starting point.</span><br><span class="line"><span class="keyword">while</span>(Problem is not solved)</span><br><span class="line">    For each path from the starting point.</span><br><span class="line">        check <span class="keyword">if</span> selected path is safe, <span class="keyword">if</span> yes select it</span><br><span class="line">        and make recursive call to rest of the problem</span><br><span class="line">        before which undo the current move.</span><br><span class="line">    End For</span><br><span class="line">If none of the move works out, <span class="keyword">return</span> <span class="keyword">false</span>, NO SOLUTON.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(2n) | S O(n)</span></span><br><span class="line"><span class="comment">//shell function</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;Integer&gt; subset =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(results, subset, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//magic recursive function do the work</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, </span></span></span><br><span class="line"><span class="function"><span class="params">                       List&lt;Integer&gt; subset, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> [] nums, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    results.add(<span class="keyword">new</span> ArrayList&lt;&gt;(subset));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        subset.add(nums[i]);</span><br><span class="line">        backtrack(results, subset, nums, i + <span class="number">1</span>);</span><br><span class="line">        subset.remove(subset.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">return</span> powerset(nums, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; powerset(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;  <span class="comment">//base line</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; emptySet = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        emptySet.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> emptySet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ele = nums[idx];</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = powerset(nums, idx - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//powerset of [1,2,3] -&gt; add 4 ele to all prev subsets -&gt; powerset of [1,2,3,4]</span></span><br><span class="line">    <span class="keyword">int</span> length = subsets.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        List&lt;Integer&gt; currentSubset = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(subsets.get(i));</span><br><span class="line">        currentSubset.add(ele);</span><br><span class="line">        subsets.add(currentSubset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Subsets-With-Duplicates-easy-✨"><a href="#Subsets-With-Duplicates-easy-✨" class="headerlink" title="Subsets With Duplicates (easy)✨"></a>Subsets With Duplicates (easy)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; findSubsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// sort the numbers to handle duplicates</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    subsets.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>, endIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        startIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// if current and the previous elements are same, create new subsets only from the subsets </span></span><br><span class="line">        <span class="comment">// added in the previous step</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            startIndex = endIndex + <span class="number">1</span>;</span><br><span class="line">        endIndex = subsets.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = startIndex; j &lt;= endIndex; j++) &#123;</span><br><span class="line">            <span class="comment">// create a new subset from the existing subset and add the current element to it</span></span><br><span class="line">            List&lt;Integer&gt; set = <span class="keyword">new</span> ArrayList&lt;&gt;(subsets.get(j));</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            subsets.add(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="90-Subsets-II✨"><a href="#90-Subsets-II✨" class="headerlink" title="90. Subsets II✨"></a><a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">90. Subsets II✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">For example,</span><br><span class="line">If nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], a solution is:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">traverse:</span><br><span class="line">[[]] <span class="comment">//1</span></span><br><span class="line">[[],[<span class="number">1</span>]] <span class="comment">//2</span></span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]]  <span class="comment">//3</span></span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">handle the duplicate situation</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] -&gt; [<span class="number">1</span>,<span class="number">2</span><span class="string">'] [1,2'</span><span class="string">']</span></span><br><span class="line"><span class="string">[1,2'</span><span class="string">',2'</span>] is in correct,要紧挨着挑，不能跳着挑，先<span class="number">2</span><span class="string">''</span>再<span class="number">2</span><span class="string">'继续下去会出现重复</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; subset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    getSubsets(nums, <span class="number">0</span>, subset, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> start, </span></span></span><br><span class="line"><span class="function"><span class="params">                        List&lt;Integer&gt; subset, </span></span></span><br><span class="line"><span class="function"><span class="params">                        List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    ans.add(<span class="keyword">new</span> ArrayList(subset));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//skip the duplicate，怎么判断i-1没有放进来过？i != startIdx, i - 1 &gt;= startIdx + 1</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        subset.add(nums[i]);</span><br><span class="line">        getSubsets(nums, i + <span class="number">1</span>, subset, ans);</span><br><span class="line">        subset.remove(subset.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Permutations-medium-⭐"><a href="#Permutations-medium-⭐" class="headerlink" title="Permutations (medium)⭐"></a>Permutations (medium)⭐</h2><h3 id="Permutations-AE-⭐"><a href="#Permutations-AE-⭐" class="headerlink" title="Permutations(AE)⭐"></a>Permutations(AE)⭐</h3><h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time O(n! n^2^) | Space O(n n!)  n！n factorial</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getPermutations(List&lt;Integer&gt; array) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; permutations = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    getPermutations(array, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), permutations);</span><br><span class="line">    <span class="keyword">return</span> permutations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getPermutations</span><span class="params">(List&lt;Integer&gt; array, List&lt;Integer&gt; currentPermutations, List&lt;List&lt;Integer&gt;&gt; permutations)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line, run out the element in the array</span></span><br><span class="line">    <span class="keyword">if</span> (array.size() == <span class="number">0</span> &amp;&amp; currentPermutations.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        permutations.add(currentPermutations);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size(); ++i) &#123;  <span class="comment">//move one element in array to cur</span></span><br><span class="line">            List&lt;Integer&gt; newArray = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(array);</span><br><span class="line">            newArray.remove(i);</span><br><span class="line">            List&lt;Integer&gt; newPermutations = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(currentPermutations);</span><br><span class="line">            newPermutations.add(array.get(i));</span><br><span class="line">            getPermutations(newArray, newPermutations, permutations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getPermuations(List&lt;Integer&gt; array) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; permutations = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    getPermutations(<span class="number">0</span>, array, permutations);</span><br><span class="line">    <span class="keyword">return</span> permutations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getPermutations</span><span class="params">(<span class="keyword">int</span> i, List&lt;Integer&gt; array, List&lt;List&lt;Integer&gt;&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == array.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        permutations.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(array));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.size(); ++j) &#123;</span><br><span class="line">            swap(array, i, j);</span><br><span class="line">            getPermutations(i + <span class="number">1</span>, array, permutations);</span><br><span class="line">            swap(array, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;Integer&gt; array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Integer temp = array.get(i);</span><br><span class="line">    array.set(i, array.get(j));</span><br><span class="line">    array.set(j, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="46-Permutations⭐"><a href="#46-Permutations⭐" class="headerlink" title="46. Permutations⭐"></a><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">46. Permutations⭐</a></h3><p>Given a collection of distinct numbers, return all possible permutations. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：回溯法。O(n^n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans =  <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    getPermute(nums, visited, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPermute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (cur.size() == nums.length) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        cur.add(nums[i]);</span><br><span class="line">        visited[i] = <span class="keyword">true</span>;</span><br><span class="line">        getPermute(nums, visited, cur, ans);</span><br><span class="line">        cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        visited[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><a href="https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning)" target="_blank" rel="noopener">A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partioning)</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// Arrays.sort(nums); // not necessary</span></span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tempList.size() == nums.length)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(tempList.contains(nums[i])) <span class="keyword">continue</span>; <span class="comment">// element already exists, skip</span></span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(list, tempList, nums);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title=" 47. Permutations II"></a><a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener"> 47. Permutations II</a></h3><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>思路：回溯法。去重方法：使用数组记录某元素是否已经使用，已使用则重复；如果当前元素与前元素相等， 如果前面元素未被使用，则此元素也不应使用，即相同元素序列只使用第一个元素作为开始，这样可以避免相同元素造成的重复。O(n^n)</p>
</li>
<li><p>数组元素可能含有相同的元素，进行排列时就有可能出现重复的排列，要求重复的排列只返回一个。</p>
<p>在实现上，和 Permutations 不同的是要先排序，然后在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans =  <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    getPermute(nums, visited, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPermute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (cur.size() == nums.length) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !visited[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        cur.add(nums[i]);</span><br><span class="line">        visited[i] = <span class="keyword">true</span>;</span><br><span class="line">        getPermute(nums, visited, cur, ans);</span><br><span class="line">        cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        visited[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">boolean</span> [] used)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="keyword">true</span>; </span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(list, tempList, nums, used);</span><br><span class="line">            used[i] = <span class="keyword">false</span>; </span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🌕31-Next-Permutation✨💎🎶"><a href="#🌕31-Next-Permutation✨💎🎶" class="headerlink" title="🌕31.Next Permutation✨💎🎶"></a><a href="https://leetcode.com/problems/next-permutation/" target="_blank" rel="noopener">🌕31.Next Permutation✨💎🎶</a></h3><h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：找下一个排列中略大于现在subset数的数。如果这个数存在，则数组中一定有一个低位数大于某一高位数。从个位开始向高位逐一查找，看相邻两数是否高位的较小（注意相邻两数的关系已经决定了数列的单调性），如果是，那么需要找一个大于它的数和它置换。可以证明高位之后的数字是递减排列，所以从最低位找到第一个大于该高位的数与之置换，则新数一定大于当前数，且该高位后为递减排列，这时需要把这部分倒置为递增排列。如果这个数不存在，可以证明，整个数组是递减排列，整体倒置即可。</li>
<li>Time complexity : O(n). In worst case, only two scans of the whole array are needed.</li>
<li>Space complexity : O(1). No extra space is used. In place replacements are done.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//find first descending cur</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//find min greater num than cur in the behind part, exch(cur, num)</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, i-<span class="number">1</span>, j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reverse the order behind cur</span></span><br><span class="line">    reverse(nums, i, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        swap(nums, i++, j--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="556-Next-Greater-Element-III✨"><a href="#556-Next-Greater-Element-III✨" class="headerlink" title="556. Next Greater Element III✨"></a><a href="https://leetcode.com/problems/next-greater-element-iii/" target="_blank" rel="noopener">556. Next Greater Element III✨</a></h3><h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Brute Force</p>
</li>
<li><p>Time complexity : O(n!)<em>O</em>(<em>n</em>!). A total of n!<em>n</em>! permutations are possible for a number consisting of n<em>n</em> digits.</p>
</li>
<li><p>Space complexity : O(n!)<em>O</em>(<em>n</em>!). A total of n!<em>n</em>! permutations are possible for a number consisting of n<em>n</em> digits, with each permutation consisting of n<em>n</em> digits.</p>
</li>
<li><p>I) Traverse the given number from rightmost digit, keep traversing till you find a digit which is smaller than the previously traversed digit. For example, if the input number is “534976”, we stop at 4 because 4 is smaller than next digit 9. If we do not find such a digit, then output is “Not Possible”.</p>
</li>
</ol>
<p>   II) Now search the right side of above found digit ‘d’ for the smallest digit greater than ‘d’. For “53<strong>4</strong>976″, the right side of 4 contains “976”. The smallest digit greater than 4 is <strong>6</strong>.</p>
<p>   III) Swap the above found two digits, we get 53<strong>6</strong>97<strong>4</strong> in above example.</p>
<p>   IV) Now sort all digits from position next to ‘d’ to the end of number. The number that we get after sorting is the output. For above example, we sort digits in bold 536<strong>974</strong>. We get “536<strong>479</strong>” which is the next greater number for input 534976.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] numbers = (n+<span class="string">""</span>).toCharArray();</span><br><span class="line">    <span class="comment">// I) Start from the right most digit and find the first digit that is smaller than the digit next to it.</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = numbers.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &gt; numbers[i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If no such digit is found, its the edge case 1.</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// II) Find the smallest digit on right side of (i-1)'th digit that is greater than number[i-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = numbers.length - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[j] &gt; numbers[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            swap(numbers, i-<span class="number">1</span>, j);  <span class="comment">//Swap the above found smallest digit with number[i-1]</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IV) Sort the digits after (i-1) in ascending order</span></span><br><span class="line">    reverse(numbers, i, numbers.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> ans = Long.parseLong(<span class="keyword">new</span> String(numbers));</span><br><span class="line">    <span class="keyword">return</span> ans &lt;= Integer.MAX_VALUE? (<span class="keyword">int</span>) ans : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] numbers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp = numbers[i];</span><br><span class="line">    numbers[i] = numbers[j];</span><br><span class="line">    numbers[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] numbers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">        swap(numbers, i++, j--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String-Permutations-by-changing-case-medium-✨"><a href="#String-Permutations-by-changing-case-medium-✨" class="headerlink" title="String Permutations by changing case (medium)✨"></a>String Permutations by changing case (medium)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findLetterCaseStringPermutations</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; permutations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> permutations;</span><br><span class="line"></span><br><span class="line">    permutations.add(str);</span><br><span class="line">    <span class="comment">// process every character of the string one by one</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isLetter(str.charAt(i))) &#123; <span class="comment">// only process characters, skip digits</span></span><br><span class="line">            <span class="comment">// we will take all existing permutations and change the letter case appropriately</span></span><br><span class="line">            <span class="keyword">int</span> n = permutations.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] chs = permutations.get(j).toCharArray();</span><br><span class="line">                <span class="comment">// if the current character is in upper case change it to lower case or vice versa</span></span><br><span class="line">                <span class="keyword">if</span> (Character.isUpperCase(chs[i]))</span><br><span class="line">                    chs[i] = Character.toLowerCase(chs[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    chs[i] = Character.toUpperCase(chs[i]);</span><br><span class="line">                permutations.add(String.valueOf(chs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> permutations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="784-Letter-Case-Permutation✨"><a href="#784-Letter-Case-Permutation✨" class="headerlink" title="784. Letter Case Permutation✨"></a><a href="https://leetcode.com/problems/letter-case-permutation/" target="_blank" rel="noopener">784. Letter Case Permutation✨</a></h3><h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//call magic recursive function</span></span><br><span class="line">    findPermutations(<span class="number">0</span>, S.toCharArray(), ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPermutations</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">char</span>[] chars, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == chars.length) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Character.isLetter(chars[idx])) &#123;</span><br><span class="line">        chars[idx] = Character.toUpperCase(chars[idx]);</span><br><span class="line">        findPermutations(idx + <span class="number">1</span>, chars, ans);</span><br><span class="line">        chars[idx] = Character.toLowerCase(chars[idx]);</span><br><span class="line">        findPermutations(idx + <span class="number">1</span>, chars, ans);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        findPermutations(idx + <span class="number">1</span>, chars, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">            a1b2   i=0, when it's at a, since it's a letter, we have two branches: a, A</span></span><br><span class="line"><span class="comment">         /        \</span></span><br><span class="line"><span class="comment">       a1b2       A1b2 i=1 when it's at 1, we only have 1 branch which is itself</span></span><br><span class="line"><span class="comment">        |          |   </span></span><br><span class="line"><span class="comment">       a1b2       A1b2 i=2 when it's at b, we have two branches: b, B</span></span><br><span class="line"><span class="comment">       /  \        / \</span></span><br><span class="line"><span class="comment">      a1b2 a1B2  A1b2 A1B2 i=3  when it's at 2, we only have one branch.</span></span><br><span class="line"><span class="comment">       |    |     |     |</span></span><br><span class="line"><span class="comment">      a1b2 a1B2  A1b2  A1B2 i=4 = S.length(). End recursion, add permutation to ans. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      During this process, we are changing the S char array itself</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-22-Generate-Parentheses⭐"><a href="#🌕Unsolved-22-Generate-Parentheses⭐" class="headerlink" title="🌕Unsolved 22.Generate Parentheses⭐"></a><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">🌕Unsolved 22.Generate Parentheses⭐</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N&#x3D;2</span><br><span class="line">Output: (()), ()()</span><br><span class="line">Input: N&#x3D;3</span><br><span class="line">Output: ((())), (()()), (())(), ()(()), ()()()</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//backtracking</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    generate(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(String cur, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> n, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (open == n &amp;&amp; close == n) &#123;</span><br><span class="line">        res.add(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (open &lt; n) &#123;</span><br><span class="line">        generate(cur + <span class="string">"("</span>, open + <span class="number">1</span>, close, n, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">        generate(cur + <span class="string">")"</span>, open, close + <span class="number">1</span>, n, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParenthesesString</span> </span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">    <span class="keyword">int</span> openCount; <span class="comment">// open parentheses count</span></span><br><span class="line">    <span class="keyword">int</span> closeCount; <span class="comment">// close parentheses count</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParenthesesString</span><span class="params">(String s, <span class="keyword">int</span> openCount, <span class="keyword">int</span> closeCount)</span> </span>&#123;</span><br><span class="line">        str = s;</span><br><span class="line">        <span class="keyword">this</span>.openCount = openCount;</span><br><span class="line">        <span class="keyword">this</span>.closeCount = closeCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateParentheses</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateValidParentheses</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        Queue&lt;ParenthesesString&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> ParenthesesString(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            ParenthesesString ps = queue.poll();</span><br><span class="line">            <span class="comment">// if we've reached the maximum number of open and close parentheses, add to the result</span></span><br><span class="line">            <span class="keyword">if</span> (ps.openCount == num &amp;&amp; ps.closeCount == num) &#123;</span><br><span class="line">                result.add(ps.str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ps.openCount &lt; num) <span class="comment">// if we can add an open parentheses, add it</span></span><br><span class="line">                    queue.add(<span class="keyword">new</span> ParenthesesString(ps.str + <span class="string">"("</span>, ps.openCount + <span class="number">1</span>, ps.closeCount));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ps.openCount &gt; ps.closeCount) <span class="comment">// if we can add a close parentheses, add it</span></span><br><span class="line">                    queue.add(<span class="keyword">new</span> ParenthesesString(ps.str + <span class="string">")"</span>, ps.openCount, ps.closeCount + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Unique-Generalized-Abbreviations-hard"><a href="#Unsolved-Unique-Generalized-Abbreviations-hard" class="headerlink" title="Unsolved Unique Generalized Abbreviations (hard)"></a>Unsolved Unique Generalized Abbreviations (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;BAT&quot;</span><br><span class="line">Output: &quot;BAT&quot;, &quot;BA1&quot;, &quot;B1T&quot;, &quot;B2&quot;, &quot;1AT&quot;, &quot;1A1&quot;, &quot;2T&quot;, &quot;3&quot;</span><br><span class="line"></span><br><span class="line">Input: &quot;code&quot;</span><br><span class="line">Output: &quot;code&quot;, &quot;cod1&quot;, &quot;co1e&quot;, &quot;co2&quot;, &quot;c1de&quot;, &quot;c1d1&quot;, &quot;c2e&quot;, &quot;c3&quot;, &quot;1ode&quot;, &quot;1od1&quot;, &quot;1o1e&quot;, &quot;1o2&quot;, </span><br><span class="line">&quot;2de&quot;, &quot;2d1&quot;, &quot;3e&quot;, &quot;4&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateGeneralizedAbbreviation</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wordLen = word.length();</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Queue&lt;AbbreviatedWord&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> AbbreviatedWord(<span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        AbbreviatedWord abWord = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (abWord.start == wordLen) &#123;</span><br><span class="line">            <span class="keyword">if</span> (abWord.count != <span class="number">0</span>)</span><br><span class="line">                abWord.str.append(abWord.count);</span><br><span class="line">            result.add(abWord.str.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// continue abbreviating by incrementing the current abbreviation count</span></span><br><span class="line">            queue.add(<span class="keyword">new</span> AbbreviatedWord(<span class="keyword">new</span> StringBuilder(abWord.str), abWord.start + <span class="number">1</span>, abWord.count + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// restart abbreviating, append the count and the current character to the string</span></span><br><span class="line">            <span class="keyword">if</span> (abWord.count != <span class="number">0</span>)</span><br><span class="line">                abWord.str.append(abWord.count);</span><br><span class="line">            queue.add(</span><br><span class="line">                <span class="keyword">new</span> AbbreviatedWord(<span class="keyword">new</span> StringBuilder(abWord.str).append(word.charAt(abWord.start)), abWord.start + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Challenge-1-Evaluate-Expression-hard"><a href="#Unsolved-Challenge-1-Evaluate-Expression-hard" class="headerlink" title="Unsolved Challenge 1 Evaluate Expression (hard)"></a>Unsolved Challenge 1 Evaluate Expression (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1+2*3&quot;</span><br><span class="line">Output: 7, 9</span><br><span class="line">Explanation: 1+(2*3) &#x3D;&gt; 7 and (1+2)*3 &#x3D;&gt; 9</span><br><span class="line"></span><br><span class="line">Input: &quot;2*3-4-5&quot;</span><br><span class="line">Output: 8, -12, 7, -7, -3 </span><br><span class="line">Explanation: 2*(3-(4-5)) &#x3D;&gt; 8, 2*(3-4-5) &#x3D;&gt; -12, 2*3-(4-5) &#x3D;&gt; 7, 2*(3-4)-5 &#x3D;&gt; -7, (2*3)-4-5 &#x3D;&gt; -3</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">diffWaysToEvaluateExpression</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// base case: if the input string is a number, parse and add it to output.</span></span><br><span class="line">    <span class="keyword">if</span> (!input.contains(<span class="string">"+"</span>) &amp;&amp; !input.contains(<span class="string">"-"</span>) &amp;&amp; !input.contains(<span class="string">"*"</span>)) &#123;</span><br><span class="line">        result.add(Integer.parseInt(input));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> chr = input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(chr)) &#123;</span><br><span class="line">                <span class="comment">// break the equation here into two parts and make recursively calls</span></span><br><span class="line">                List&lt;Integer&gt; leftParts = diffWaysToEvaluateExpression(input.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; rightParts = diffWaysToEvaluateExpression(input.substring(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> part1 : leftParts) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> part2 : rightParts) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (chr == <span class="string">'+'</span>)</span><br><span class="line">                            result.add(part1 + part2);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (chr == <span class="string">'-'</span>)</span><br><span class="line">                            result.add(part1 - part2);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (chr == <span class="string">'*'</span>)</span><br><span class="line">                            result.add(part1 * part2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memoized-version"><a href="#Memoized-version" class="headerlink" title="Memoized version"></a>Memoized version</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memoization map</span></span><br><span class="line">Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToEvaluateExpression</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(input))</span><br><span class="line">        <span class="keyword">return</span> map.get(input);</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// base case: if the input string is a number, parse and return it.</span></span><br><span class="line">    <span class="keyword">if</span> (!input.contains(<span class="string">"+"</span>) &amp;&amp; !input.contains(<span class="string">"-"</span>) &amp;&amp; !input.contains(<span class="string">"*"</span>)) &#123;</span><br><span class="line">        result.add(Integer.parseInt(input));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> chr = input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(chr)) &#123;</span><br><span class="line">                List&lt;Integer&gt; leftParts = diffWaysToEvaluateExpression(input.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; rightParts = diffWaysToEvaluateExpression(input.substring(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> part1 : leftParts) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> part2 : rightParts) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (chr == <span class="string">'+'</span>)</span><br><span class="line">                            result.add(part1 + part2);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (chr == <span class="string">'-'</span>)</span><br><span class="line">                            result.add(part1 - part2);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (chr == <span class="string">'*'</span>)</span><br><span class="line">                            result.add(part1 * part2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(input, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Challenge-2-Structurally-Unique-Binary-Search-Trees-hard-✨"><a href="#Unsolved-Challenge-2-Structurally-Unique-Binary-Search-Trees-hard-✨" class="headerlink" title="Unsolved Challenge 2 Structurally Unique Binary Search Trees (hard)✨"></a>Unsolved Challenge 2 Structurally Unique Binary Search Trees (hard)✨</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">findUniqueTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">return</span> findUniqueTreesRecursive(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">findUniqueTreesRecursive</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// base condition, return 'null' for an empty sub-tree</span></span><br><span class="line">    <span class="comment">// consider n=1, in this case we will have start=end=1, this means we should have only one tree</span></span><br><span class="line">    <span class="comment">// we will have two recursive calls, findUniqueTreesRecursive(1, 0) &amp; (2, 1)</span></span><br><span class="line">    <span class="comment">// both of these should return 'null' for the left and the right child</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        result.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="comment">// making 'i' root of the tree</span></span><br><span class="line">        List&lt;TreeNode&gt; leftSubtrees = findUniqueTreesRecursive(start, i - <span class="number">1</span>);</span><br><span class="line">        List&lt;TreeNode&gt; rightSubtrees = findUniqueTreesRecursive(i + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">for</span> (TreeNode leftTree : leftSubtrees) &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode rightTree : rightSubtrees) &#123;</span><br><span class="line">                TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                root.left = leftTree;</span><br><span class="line">                root.right = rightTree;</span><br><span class="line">                result.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="95-Unique-Binary-Search-Trees-II✨"><a href="#95-Unique-Binary-Search-Trees-II✨" class="headerlink" title="95. Unique Binary Search Trees II✨"></a><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. Unique Binary Search Trees II✨</a></h2><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n. For example, Given n = 3, your program should return all 5 unique BST’s shown below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&#39;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：回溯法。因结点是顺序排列的，所以头结点两侧分别为左右子树，所以左右子树和当前结点组成的树为答案。递归结束条件：start 与 end 指向同一点，则说明该点为叶子结点；start&gt;end，说明该子树不存在。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">return</span> genTreeList(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">genTreeList</span> <span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pick up a root</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx = start; idx &lt;= end; idx++) &#123;</span><br><span class="line">        <span class="comment">// all possible left subtrees if i is choosen to be a root</span></span><br><span class="line">        List&lt;TreeNode&gt; leftList = genTreeList(start, idx - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// all possible right subtrees if i is choosen to be a root</span></span><br><span class="line">        List&lt;TreeNode&gt; rightList = genTreeList(idx + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// connect left and right trees to the root i</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode left : leftList) &#123;</span><br><span class="line">            <span class="keyword">for</span>(TreeNode right: rightList) &#123;</span><br><span class="line">                TreeNode root = <span class="keyword">new</span> TreeNode(idx);</span><br><span class="line">                root.left = left;</span><br><span class="line">                root.right = right;</span><br><span class="line">                list.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Challenge-3-Count-of-Structurally-Unique-Binary-Search-Trees-hard"><a href="#Unsolved-Challenge-3-Count-of-Structurally-Unique-Binary-Search-Trees-hard" class="headerlink" title="Unsolved Challenge 3 Count of Structurally Unique Binary Search Trees (hard)"></a>Unsolved Challenge 3 Count of Structurally Unique Binary Search Trees (hard)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// making 'i' root of the tree</span></span><br><span class="line">        <span class="keyword">int</span> countOfLeftSubtrees = countTrees(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> countOfRightSubtrees = countTrees(n - i);</span><br><span class="line">        count += (countOfLeftSubtrees * countOfRightSubtrees);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memoized-version-1"><a href="#Memoized-version-1" class="headerlink" title="Memoized version"></a>Memoized version</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(n))</span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// making 'i' root of the tree</span></span><br><span class="line">        <span class="keyword">int</span> countOfLeftSubtrees = countTrees(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> countOfRightSubtrees = countTrees(n - i);</span><br><span class="line">        count += (countOfLeftSubtrees * countOfRightSubtrees);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(n, count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="96-Unique-Binary-Search-Trees✨"><a href="#96-Unique-Binary-Search-Trees✨" class="headerlink" title="96. Unique Binary Search Trees✨"></a><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. Unique Binary Search Trees✨</a></h2><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example, Given n = 3, there are a total of 5 unique BST’s.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n &#x3D; 3, there are a total of 5 unique BST&#39;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：动态规划。推导方程：每一结点（j）作为根的可能性=左面每一结点作为根的数量之和+右面每一结点 作为根的数量之和，即 c[n]=c[j-1]<em>c[n-j]，可以从 n=2 开始推导直到 n=n。<a href="https://leetcode.com/problems/unique-binary-search-trees/discuss/31666/DP-Solution-in-6-lines-with-explanation.-F(i-n)-G(i-1)--G(n-i" target="_blank" rel="noopener">详解</a></em></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] G = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Recursive with memorization</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> numTrees(n, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n, Map&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(n)) <span class="keyword">return</span> map.get(n);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//n - 1 - i, one node for root</span></span><br><span class="line">        sum += numTrees(i, map) * numTrees(n - <span class="number">1</span> - i, map);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(n, sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h1><blockquote>
<p>Recursion is an approach to solving problems using a function that calls itself as a subroutine.</p>
</blockquote>
<p>A recursive function should have the following properties so that it does not result in an infinite loop:</p>
<ol>
<li>A simple <code>base case</code> (or cases) — a terminating scenario that does not use recursion to produce an answer.</li>
<li>A set of rules, also known as <code>recurrence relation</code> that reduces all other cases towards the base case.</li>
</ol>
<h2 id="39-Combination-Sum⭐"><a href="#39-Combination-Sum⭐" class="headerlink" title="39. Combination Sum⭐"></a><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">39. Combination Sum⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span></span><br><span class="line">Output: [[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">7</span>]]</span><br><span class="line">Explanation:</span><br><span class="line"><span class="number">2</span> and <span class="number">3</span> are candidates, and <span class="number">2</span> + <span class="number">2</span> + <span class="number">3</span> = <span class="number">7</span>. Note that <span class="number">2</span> can be used multiple times.</span><br><span class="line"><span class="number">7</span> is a candidate, and <span class="number">7</span> = <span class="number">7</span>.</span><br><span class="line">These are the only two combinations.</span><br><span class="line">    </span><br><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">8</span></span><br><span class="line">Output: [[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">Input: candidates = [<span class="number">2</span>], target = <span class="number">1</span></span><br><span class="line">Output: []</span><br><span class="line"></span><br><span class="line">Input: candidates = [<span class="number">1</span>], target = <span class="number">2</span></span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>image worst case the solution is return n copies of the input (target = n), then space complexity should be O(N^target) as well</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    getCombinationSum(candidates, target, <span class="number">0</span>, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCombinationSum</span><span class="params">(<span class="keyword">int</span>[] candidates, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> remain, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> start, </span></span></span><br><span class="line"><span class="function"><span class="params">                               List&lt;Integer&gt; cur, </span></span></span><br><span class="line"><span class="function"><span class="params">                               List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//don't forget new ArrayList(cur), List is abstract class, need constructor</span></span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            cur.add(candidates[i]);</span><br><span class="line">            <span class="comment">// not i + 1 so that we can reuse same elements</span></span><br><span class="line">            getCombinationSum(candidates, remain - candidates[i], i, cur, ans);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="40-Combination-Sum-II✨"><a href="#40-Combination-Sum-II✨" class="headerlink" title="40. Combination Sum II✨"></a><a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. Combination Sum II✨</a></h3><p>can’t reuse same element</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>], target = <span class="number">8</span></span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>],</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],</span><br><span class="line">[<span class="number">1</span>,<span class="number">7</span>],</span><br><span class="line">[<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">5</span></span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">[<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    getCombinationSum2(candidates, target, <span class="number">0</span>, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCombinationSum2</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="comment">// skip duplicates</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            cur.add(candidates[i]);</span><br><span class="line">            getCombinationSum2(candidates, target - candidates[i], i + <span class="number">1</span>, cur, ans);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a><a href="https://leetcode.com/problems/combinations/description/" target="_blank" rel="noopener">77. Combinations</a></h3><h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">If n = <span class="number">4</span> and k = <span class="number">2</span>, a solution is:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; current = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getCombine(n, k, <span class="number">1</span>, current, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCombine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(current));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        current.add(i);</span><br><span class="line">        getCombine(n, k - <span class="number">1</span>, i + <span class="number">1</span>, current, ans);</span><br><span class="line">        current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="216-Combination-Sum-III✨"><a href="#216-Combination-Sum-III✨" class="headerlink" title="216. Combination Sum III✨"></a><a href="https://leetcode.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. Combination Sum III✨</a></h3><ul>
<li>Only numbers <code>1</code> through <code>9</code> are used.</li>
<li>Each number is used <strong>at most once</strong>.</li>
<li>从 1-9 数字中选出 k 个数不重复的数，使得它们的和为 n。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: k = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]]</span><br><span class="line">Explanation:</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> = <span class="number">7</span></span><br><span class="line">There are no other valid combinations.</span><br><span class="line">    </span><br><span class="line">Input: k = <span class="number">3</span>, n = <span class="number">9</span></span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">Explanation:</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">6</span> = <span class="number">9</span></span><br><span class="line"><span class="number">1</span> + <span class="number">3</span> + <span class="number">5</span> = <span class="number">9</span></span><br><span class="line"><span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">9</span></span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getCombinationSum3(k, n, <span class="number">1</span>, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCombinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> start, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (cur.size() &gt; k || n &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (cur.size() == k &amp;&amp; n == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        cur.add(i);</span><br><span class="line">        getCombinationSum3(k, n-i, i+<span class="number">1</span>, cur, ans);</span><br><span class="line">        cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-Letter-Combinations-of-a-Phone-Number⭐"><a href="#17-Letter-Combinations-of-a-Phone-Number⭐" class="headerlink" title="17. Letter Combinations of a Phone Number⭐"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener">17. Letter Combinations of a Phone Number⭐</a></h2><p>Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="https://camo.githubusercontent.com/a8fc38780ec458d1094ad58aea36666a8e818d37/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39383233373638632d323132622d346231612d623639612d6233663539653037623937372e6a7067" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:Digit string <span class="string">"23"</span></span><br><span class="line">Output: [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路：回溯法，每键创建一个新的List，使用之前的组合添加每一个可能的字符，每一种新结果添加到新List 中。O(n^k)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    String[] mapping = <span class="keyword">new</span> String[] &#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    letterCombinationsRecursive(digits, <span class="string">""</span>, <span class="number">0</span>, mapping, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letterCombinationsRecursive</span><span class="params">(String digits, String current, <span class="keyword">int</span> idx, String[] mapping, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (idx == digits.length()) &#123;</span><br><span class="line">        ans.add(current);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String letters = mapping[digits.charAt(idx) - <span class="string">'0'</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length(); i++) &#123;</span><br><span class="line">        letterCombinationsRecursive(digits, current + letters.charAt(i), idx + <span class="number">1</span>, mapping, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>single queue BFS solutions</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">if</span>(digits.isEmpty()) <span class="keyword">return</span> ans;</span><br><span class="line">		String[] mapping = <span class="keyword">new</span> String[] &#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">		ans.add(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;digits.length();i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x = Character.getNumericValue(digits.charAt(i));</span><br><span class="line">			<span class="keyword">while</span>(ans.peek().length()==i)&#123;</span><br><span class="line">				String t = ans.remove();</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">char</span> s : mapping[x].toCharArray())</span><br><span class="line">					ans.add(t+s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Restore-IP-Addresses✨"><a href="#Unsolved-Restore-IP-Addresses✨" class="headerlink" title="Unsolved Restore IP Addresses✨"></a><a href="https://leetcode.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">Unsolved Restore IP Addresses✨</a></h2><h2 id="Nth-Fibonacci-AE"><a href="#Nth-Fibonacci-AE" class="headerlink" title="Nth Fibonacci(AE)"></a>Nth Fibonacci(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>) </span><br><span class="line"><span class="comment">//bad O(2^n)T, cause do many unncessary compute</span></span><br><span class="line"><span class="comment">//eg. fib(6)-&gt; fib(5)+fib(4)-&gt;fib(4)+fib(3)+fib(3)+fib(2)   </span></span><br><span class="line"><span class="comment">//O(N) S call the stack</span></span><br><span class="line"><span class="comment">//eg.in the stack maximum </span></span><br><span class="line"><span class="comment">//fib(6)</span></span><br><span class="line"><span class="comment">//fib(5) </span></span><br><span class="line"><span class="comment">//fib(4)</span></span><br><span class="line"><span class="comment">//fib(3)</span></span><br><span class="line"><span class="comment">//fib(2)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. Fibonacci Number</a></p>
<h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>first fib = 0, second fib = 1…</li>
<li>However this solution may cause stack overflow</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(2^n) T O(n) S</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNthFib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNthFib(n - <span class="number">1</span>) + getNthFib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Using HashMap, do not have to recalculate many times, and get the calculated value in constant time</p>
</li>
<li><p><strong><code>Map&lt;Integer,Integer&gt; map = new HasMap&lt;Integer,Integer&gt;();</code></strong></p>
</li>
<li><p><strong><code>map.put(key,value)</code></strong></p>
<p><strong><code>map.get(key)</code></strong></p>
<p><strong><code>map.containsKey(key)</code></strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) T O(n) S</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNthFib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">//put the 1st Fib to map</span></span><br><span class="line">    map.put(<span class="number">2</span>, <span class="number">1</span>);  <span class="comment">//put the 2nd Fib to map</span></span><br><span class="line">    <span class="keyword">return</span> getNthFib(n, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//use a helper method pass in the index and map</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNthFib</span><span class="params">(<span class="keyword">int</span> n, Map&lt;Integer,Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(n)) &#123;  <span class="comment">//base line</span></span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> value = getNthFib(n - <span class="number">1</span>, map) + getNthFib(n - <span class="number">2</span>, map);</span><br><span class="line">        map.put(n, value);  <span class="comment">//nth Fib = (n-1)+(n-2),call it recursively</span></span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3:"></a>Solution3:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">0</span>, <span class="number">1</span>],<span class="number">1</span> ,<span class="number">2</span> -&gt; <span class="number">0</span>, [<span class="number">1</span>, <span class="number">1</span>], <span class="number">2</span> -&gt; <span class="number">0</span>,  <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>    </span><br><span class="line">  n = <span class="number">4</span></span><br><span class="line">  <span class="keyword">return</span> twoFib[<span class="number">1</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//slidint widow, lastTwo [0, 1]</span></span><br><span class="line"><span class="comment">//O(n) T O(1) S</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNthFib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] twoFib = &#123;<span class="number">0</span> , <span class="number">1</span>&#125;;  <span class="comment">//creat an array only track last two Fib</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">3</span>;  <span class="comment">//if n &gt;= 3, sliding the window, [0, 1],1 , 2 -&gt; 0, [1, 1], 2</span></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextFib = twoFib[<span class="number">0</span>] + twoFib[<span class="number">1</span>];</span><br><span class="line">        twoFib[<span class="number">0</span>] = twoFib[<span class="number">1</span>];</span><br><span class="line">        twoFib[<span class="number">1</span>] = nextFib;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">1</span> ? twoFib[<span class="number">1</span>] : twoFib[<span class="number">0</span>];  <span class="comment">//if n = 1, return the 1th element, else 2th element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Product-Sum-AE"><a href="#Product-Sum-AE" class="headerlink" title="Product Sum(AE)"></a>Product Sum(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">5</span>, <span class="number">2</span>, [<span class="number">7</span>, -<span class="number">1</span>], <span class="number">3</span>, [<span class="number">6</span>, [-<span class="number">13</span>, <span class="number">8</span>], <span class="number">4</span>]]</span><br><span class="line">output = <span class="number">12</span> = <span class="number">5</span> + <span class="number">2</span> + <span class="number">2</span> * (<span class="number">7</span> - <span class="number">1</span>) + <span class="number">3</span> + <span class="number">2</span> * (<span class="number">6</span> + <span class="number">3</span> * (-<span class="number">13</span> + <span class="number">8</span>) + <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>Use <strong><code>recursion</code></strong> method product sum to deal with array in this question, return the sum multiplied by the current depth</p>
</li>
<li><p>O(N) T every elements in the array</p>
<p>O(D) S recursive call stack, maximum case of depth(D) 3</p>
<p>explain N, D meaning</p>
</li>
<li><p>If u forget the built in method, you can just say to your interviewer: there is a way to do this built in to my language, I forget it but I think is is <code>array.isarray</code>, point is make a voice </p>
<p>Stack Overflow or the documentation online</p>
<p><strong><code>instanceof</code></strong> 判断类型</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tip: You can use `element instanceof ArrayList` to check whether an item</span></span><br><span class="line"><span class="comment">// is an array or an integer.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">productSum</span><span class="params">(List&lt;Object&gt; array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">    <span class="keyword">return</span> productSumHelper(array, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">productSumHelper</span><span class="params">(List&lt;Object&gt; array, <span class="keyword">int</span> multiplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object el : array) &#123;  <span class="comment">//object represent List or Integer</span></span><br><span class="line">        <span class="keyword">if</span> (el <span class="keyword">instanceof</span> ArrayList) &#123;  <span class="comment">//if ele is ArrayList</span></span><br><span class="line">            ArrayList ls = (ArrayList)el;  <span class="comment">//Casting Object to ArrayList</span></span><br><span class="line">            sum += productSumHelper(ls, multiplier + <span class="number">1</span>);  <span class="comment">//recursively call method</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += (<span class="keyword">int</span>) el;  <span class="comment">//if is int casting plus to sum</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum * multiplier;  <span class="comment">//time the multiplier</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="339-Nested-List-Weight-Sum✨"><a href="#339-Nested-List-Weight-Sum✨" class="headerlink" title="339. Nested List Weight Sum✨"></a><a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener">339. Nested List Weight Sum✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nestedList = [<span class="number">1</span>,[<span class="number">4</span>,[<span class="number">6</span>]]]</span><br><span class="line">Output: <span class="number">27</span></span><br><span class="line">Explanation: One <span class="number">1</span> at depth <span class="number">1</span>, one <span class="number">4</span> at depth <span class="number">2</span>, and one <span class="number">6</span> at depth <span class="number">3</span>. <span class="number">1</span>*<span class="number">1</span> + <span class="number">4</span>*<span class="number">2</span> + <span class="number">6</span>*<span class="number">3</span> = <span class="number">27</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-19"><a href="#Solution1-19" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>DFS</li>
<li>Time O(n) Space O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculate(nestedList, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;NestedInteger&gt; nestedList, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (NestedInteger ele : nestedList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ele.isInteger()) &#123;</span><br><span class="line">            sum += ele.getInteger() * depth;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;NestedInteger&gt; list = ele.getList();</span><br><span class="line">            sum += calculate(list, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input: nestedList = [1,[4,[6]]]</span></span><br><span class="line"><span class="comment">Output: 27</span></span><br><span class="line"><span class="comment">Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 1*1 + 4*2 + 6*3 = 27.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int calculate(list, 1)</span></span><br><span class="line"><span class="comment">for ele in nestedList</span></span><br><span class="line"><span class="comment">    if (ele is int) &#123;</span></span><br><span class="line"><span class="comment">        sum += int * depth;</span></span><br><span class="line"><span class="comment">    &#125; else if (ele is list) &#123;</span></span><br><span class="line"><span class="comment">        sum += calculate(ele, depth + 1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    retrun depth;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">    Queue&lt;NestedInteger&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(NestedInteger n : nestedList)&#123;</span><br><span class="line">        q.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> deep = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            NestedInteger temp = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(temp.isInteger())&#123;</span><br><span class="line">                ans += deep * temp.getInteger();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(NestedInteger n : temp.getList())&#123;</span><br><span class="line">                    q.add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        deep++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Flatten-a-Dictionary💜💙"><a href="#Flatten-a-Dictionary💜💙" class="headerlink" title="Flatten a Dictionary💜💙"></a>Flatten a Dictionary💜💙</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">input:  dict = &#123;</span><br><span class="line">            <span class="string">"Key1"</span> : <span class="string">"1"</span>,</span><br><span class="line">            <span class="string">"Key2"</span> : &#123;</span><br><span class="line">                <span class="string">"a"</span> : <span class="string">"2"</span>,</span><br><span class="line">                <span class="string">"b"</span> : <span class="string">"3"</span>,</span><br><span class="line">                <span class="string">"c"</span> : &#123;</span><br><span class="line">                    <span class="string">"d"</span> : <span class="string">"3"</span>,</span><br><span class="line">                    <span class="string">"e"</span> : &#123;</span><br><span class="line">                        <span class="string">""</span> : <span class="string">"1"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">output: &#123;</span><br><span class="line">            <span class="string">"Key1"</span> : <span class="string">"1"</span>,</span><br><span class="line">            <span class="string">"Key2.a"</span> : <span class="string">"2"</span>,</span><br><span class="line">            <span class="string">"Key2.b"</span> : <span class="string">"3"</span>,</span><br><span class="line">            <span class="string">"Key2.c.d"</span> : <span class="string">"3"</span>,</span><br><span class="line">            <span class="string">"Key2.c.e"</span> : <span class="string">"1"</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>Beat language, Java work on writing code faster. </li>
<li>Go through test before coding. </li>
<li>Time Space analyze wrong </li>
<li>Read stuff like map, list and set in java. </li>
</ol>
<h3 id="Solution1-20"><a href="#Solution1-20" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Time O(n) | Space O(n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n) | S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> HashMap&lt;String, String&gt; <span class="title">flattenDictionary</span><span class="params">(HashMap&lt;String, Object&gt; dict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// your code goes here</span></span><br><span class="line">    HashMap&lt;String, String&gt; ans = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    flattenTheHashMap(<span class="string">""</span>, dict, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flattenTheHashMap</span><span class="params">(String key, HashMap&lt;String,Object&gt; dict, HashMap&lt;String, String&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String cur : dict.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dict.get(cur) <span class="keyword">instanceof</span> String) &#123;  <span class="comment">//first round</span></span><br><span class="line">            <span class="keyword">if</span> (key.equals(<span class="string">""</span>)) &#123;  <span class="comment">//use s.equals() compare string</span></span><br><span class="line">                ans.put(cur, (String) dict.get(cur));  <span class="comment">//&lt;cur, value(String)&gt; -&gt; ans</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                ans.put(key, (String) dict.get(cur));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                ans.put(key + <span class="string">"."</span> + cur, (String) dict.get(cur));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//Object -&gt; hashmap</span></span><br><span class="line">            <span class="comment">//Map&lt;xx, xx&gt;</span></span><br><span class="line">            <span class="comment">//String &lt;- key1.key2.key3 -&gt; value</span></span><br><span class="line">            HashMap&lt;String, Object&gt; newDict = (HashMap&lt;String, Object&gt;) dict.get(cur);</span><br><span class="line">            <span class="keyword">if</span> (key.equals(<span class="string">""</span>)) &#123;   <span class="comment">//first round</span></span><br><span class="line">                flattenTheHashMap(cur, newDict, ans);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                flattenTheHashMap(key, newDict, ans);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                key += <span class="string">"."</span> + cur;</span><br><span class="line">                flattenTheHashMap(key, newDict, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters"><a href="#1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters" class="headerlink" title="1239. Maximum Length of a Concatenated String with Unique Characters"></a><a href="https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/" target="_blank" rel="noopener">1239. Maximum Length of a Concatenated String with Unique Characters</a></h2><h3 id="Solution1-21"><a href="#Solution1-21" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(List&lt;String&gt; arr)</span> </span>&#123;</span><br><span class="line">    dfs(arr, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; arr, <span class="keyword">int</span> index, String concatenatStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isUnique(concatenatStr)) max = Math.max(max, concatenatStr.length());</span><br><span class="line">    <span class="keyword">if</span> (index == arr.size() || !isUnique(concatenatStr))  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; arr.size(); i++) &#123;</span><br><span class="line">        dfs(arr, i + <span class="number">1</span>, concatenatStr + arr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] alpha = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) alpha[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; alpha.length; i++) <span class="keyword">if</span> (alpha[i] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(List&lt;String&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dfs(arr, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; arr, String current, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isUnique = isUniqueChar(current);</span><br><span class="line">    <span class="keyword">if</span> (isUnique) &#123;</span><br><span class="line">        result = Math.max(result, current.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start == arr.size() || !isUnique) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; arr.size(); i++) &#123;</span><br><span class="line">        dfs(arr, current + arr.get(i), i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUniqueChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(c)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1641-Count-Sorted-Vowel-Strings"><a href="#1641-Count-Sorted-Vowel-Strings" class="headerlink" title="1641. Count Sorted Vowel Strings"></a><a href="https://leetcode.com/problems/count-sorted-vowel-strings/" target="_blank" rel="noopener">1641. Count Sorted Vowel Strings</a></h2><h3 id="Solution1-22"><a href="#Solution1-22" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Brute Force Using Backtracking</li>
<li>Time Complexity : \mathcal{O}(n^{5})O(<em>n</em>5). We have to calculate the size of the recursion tree. Let’s analyze the number of nodes generated at each level. The following figure illustrates the number of enumerations at level 22.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] vowels = &#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>&#125;;</span><br><span class="line">    countVowels(n, vowels,<span class="string">""</span>, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countVowels</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span>[] vowels, String cur, <span class="keyword">int</span> start, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.add(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; vowels.length; i++) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(cur);</span><br><span class="line">        <span class="keyword">char</span> c = vowels[i];</span><br><span class="line">        sb.append(c);</span><br><span class="line">        countVowels(n - <span class="number">1</span>,vowels, sb.toString(), i, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> countVowelStringUtil(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countVowelStringUtil</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> vowels)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vowels; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        result += countVowelStringUtil(n - <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-10"><a href="#Solution2-10" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>dp</p>
</li>
<li><p><code>dp[n][k]</code> means the number of strings constructed by at most <code>k</code> different characters.</p>
<p>If <code>k = 1</code>, use only <code>u</code><br>If <code>k = 2</code>, use only <code>o,u</code><br>If <code>k = 3</code>, use only <code>i,o,u</code><br>If <code>k = 4</code>, use only <code>e,i,o,u</code><br>If <code>k = 5</code>, use only <code>a,e,i,o,u</code></p>
<p> Bottom Up</p>
<p>Time <code>O(nk)</code><br>Space <code>O(nk)</code><br>where k = 5</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">5</span>; ++k)</span><br><span class="line">            dp[i][k] = dp[i][k - <span class="number">1</span>] + (i &gt; <span class="number">1</span> ? dp[i - <span class="number">1</span>][k] : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//                a  e  i  o  u</span></span><br><span class="line">    <span class="comment">//     initialy: &#123;1, 1, 1, 1, 1&#125;   </span></span><br><span class="line">    <span class="comment">//      n == 1 : &#123;5, 4, 3, 2, 1&#125;   </span></span><br><span class="line">    <span class="comment">//      n == 2 : &#123;15,10,6, 3, 1&#125;   </span></span><br><span class="line">    <span class="comment">//      n == 3 : &#123;35,20,10,4, 1&#125;   </span></span><br><span class="line">    <span class="comment">//        </span></span><br><span class="line">    <span class="keyword">int</span> []permutation = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = permutation.length-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">            permutation[j] = permutation[j] + sum;</span><br><span class="line">            sum = permutation[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> permutation[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lowest-Common-Manager-AE"><a href="#Lowest-Common-Manager-AE" class="headerlink" title="Lowest Common Manager(AE)"></a>Lowest Common Manager(AE)</h2><h3 id="Solution1-23"><a href="#Solution1-23" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OrgChart <span class="title">getLowestCommonManager</span><span class="params">(OrgChart topManager, OrgChart reportOne, OrgChart reportTwo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getOrgInfo(topManager, reportOne, reportTwo).lowestCommonManager; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OrgInfo <span class="title">getOrgInfo</span><span class="params">(OrgChart manager, OrgChart reportOne, OrgChart reportTwo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numImportantReports = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (OrgChart directReport : manager.directReports) &#123;</span><br><span class="line">        OrgInfo orgInfo = getOrgInfo(directReport, reportOne, reportTwo);</span><br><span class="line">        <span class="keyword">if</span> (orgInfo.lowestCommonManager != <span class="keyword">null</span>) <span class="keyword">return</span> orgInfo;</span><br><span class="line">        numImportantReports += orgInfo.numImportantReports;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (manager == reportOne || manager == reportTwo) numImportantReports++;</span><br><span class="line">    OrgChart lowestCommonManager = numImportantReports == <span class="number">2</span> ? manager : <span class="keyword">null</span>;</span><br><span class="line">    OrgInfo newOrgInfo = <span class="keyword">new</span> OrgInfo(lowestCommonManager, numImportantReports);</span><br><span class="line">    <span class="keyword">return</span> newOrgInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrgInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> OrgChart lowestCommonManager;</span><br><span class="line">    <span class="keyword">int</span> numImportantReports;</span><br><span class="line"></span><br><span class="line">    OrgInfo(OrgChart lowestCommonManager, <span class="keyword">int</span> numImportantReports) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lowestCommonManager = lowestCommonManager;</span><br><span class="line">        <span class="keyword">this</span>.numImportantReports = numImportantReports;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrgChart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> name;</span><br><span class="line">    <span class="keyword">public</span> List&lt;OrgChart&gt; directReports;</span><br><span class="line"></span><br><span class="line">    OrgChart(<span class="keyword">char</span> name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.directReports = <span class="keyword">new</span> ArrayList&lt;OrgChart&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This method is for testing only.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDirectReports</span><span class="params">(OrgChart[] directReports)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (OrgChart directReport : directReports) &#123;</span><br><span class="line">            <span class="keyword">this</span>.directReports.add(directReport);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Interweaving-Strings-AE"><a href="#Unsolved-Interweaving-Strings-AE" class="headerlink" title="Unsolved Interweaving Strings(AE)"></a>Unsolved Interweaving Strings(AE)</h2><h3 id="Solution1-24"><a href="#Solution1-24" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>O(2^(m + n)) time | O(m + n)  space</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interweavingStrings</span><span class="params">(String one, String two, String three)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (three.length() != one.length() + two.length()) &#123;  <span class="comment">//edge case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> areInterwoven(one, two, three, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areInterwoven</span><span class="params">(String one, String two, String three, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = i + j;</span><br><span class="line">    <span class="keyword">if</span> (k == three.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//which letter we choose to be the letter in three String</span></span><br><span class="line">    <span class="comment">//choose it come from String one and recursive call</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; one.length() &amp;&amp; one.charAt(i) == three.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (areInterwoven(one, two, three, i+<span class="number">1</span>, j)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//choose it come from String two and recursive call</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; two.length() &amp;&amp; two.charAt(j) == three.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (areInterwoven(one, two, three, i, j+<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-11"><a href="#Solution2-11" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interweavingStrings</span><span class="params">(String one, String two, String three)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (three.length() != one.length() + two.length()) &#123;  <span class="comment">//edge case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean[][] cache = <span class="keyword">new</span> Boolean[one.length() + <span class="number">1</span>][two.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> areInterwoven(one, two, three, <span class="number">0</span>, <span class="number">0</span>, cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areInterwoven</span><span class="params">(String one, String two, String three, <span class="keyword">int</span> i, <span class="keyword">int</span> j, Boolean[][] cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[i][j] != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> cache[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = i + j;</span><br><span class="line">    <span class="keyword">if</span> (k == three.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; one.length() &amp;&amp; one.charAt(i) == three.charAt(k)) &#123;</span><br><span class="line">        cache[i][j] = areInterwoven(one, two, three, i + <span class="number">1</span>, j, cache);</span><br><span class="line">        <span class="keyword">if</span> (cache[i][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j &lt; two.length() &amp;&amp; two.charAt(j) == three.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">var</span> result = areInterwoven(one, two, three, i, j + <span class="number">1</span>, cache);</span><br><span class="line">        cache[i][j] = result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache[i][j] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-97-Interleaving-String"><a href="#Unsolved-97-Interleaving-String" class="headerlink" title="Unsolved 97. Interleaving String"></a><a href="https://leetcode.com/problems/interleaving-string/" target="_blank" rel="noopener">Unsolved 97. Interleaving String</a></h3><h3 id="Solution1-25"><a href="#Solution1-25" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Recursion with memoization</li>
<li>Time complexity: \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>), where m<em>m</em> is the length of s1<em>s</em>1 and n<em>n</em> is the length of s2<em>s</em>2. That’s a consequence of the fact that each <code>(i, j)</code> combination is computed only once.</li>
<li>Space complexity: \mathcal{O}(m \cdot n)O(<em>m</em>⋅<em>n</em>) to keep double array <code>memo</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">is_Interleave</span><span class="params">(String s1, <span class="keyword">int</span> i, String s2, <span class="keyword">int</span> j, String s3, <span class="keyword">int</span> k, <span class="keyword">int</span>[][] memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == s1.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.substring(j).equals(s3.substring(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.substring(i).equals(s3.substring(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (memo[i][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j] == <span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s3.charAt(k) == s1.charAt(i) &amp;&amp; is_Interleave(s1, i + <span class="number">1</span>, s2, j, s3, k + <span class="number">1</span>, memo)</span><br><span class="line">        || s3.charAt(k) == s2.charAt(j) &amp;&amp; is_Interleave(s1, i, s2, j + <span class="number">1</span>, s3, k + <span class="number">1</span>, memo)) &#123;</span><br><span class="line">        ans = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[i][j] = ans ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> memo[][] = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length()][s2.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">            memo[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_Interleave(s1, <span class="number">0</span>, s2, <span class="number">0</span>, s3, <span class="number">0</span>, memo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-12"><a href="#Solution2-12" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Brute Force</li>
<li>The most basic idea is to find every string possible by all interleavings of the two given strings s1<em>s</em>1 and s2<em>s</em>2. In order to implement this method, we are using recursion. </li>
<li>Time complexity : O(2^{m+n}). m<em>m</em> is the length of s1<em>s</em>1 and n<em>n</em> is the length of s2<em>s</em>2.</li>
<li>Space complexity : O(m+n). The size of stack for recursive calls can go upto m+n<em>m</em>+<em>n</em>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">is_Interleave</span><span class="params">(String s1,<span class="keyword">int</span> i,String s2,<span class="keyword">int</span> j,String res,String s3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.equals(s3) &amp;&amp; i==s1.length() &amp;&amp; j==s2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> ans=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;s1.length())</span><br><span class="line">        ans|=is_Interleave(s1,i+<span class="number">1</span>,s2,j,res+s1.charAt(i),s3);</span><br><span class="line">    <span class="keyword">if</span>(j&lt;s2.length())</span><br><span class="line">        ans|=is_Interleave(s1,i,s2,j+<span class="number">1</span>,res+s2.charAt(j),s3);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> is_Interleave(s1,<span class="number">0</span>,s2,<span class="number">0</span>,<span class="string">""</span>,s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Number-Of-Binary-Tree-Topologies-AE"><a href="#Number-Of-Binary-Tree-Topologies-AE" class="headerlink" title="Number Of Binary Tree Topologies(AE)"></a>Number Of Binary Tree Topologies(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume n node</span><br><span class="line">left: <span class="number">0</span> node right: n - <span class="number">1</span> <span class="function">node <span class="title">f</span><span class="params">(n - <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">left: 1 node right: n - 2 node <span class="title">f</span><span class="params">(n - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">left: x node <span class="title">f</span><span class="params">(x)</span> right: n - x - 1 node <span class="title">f</span><span class="params">(n - x - <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">eg:</span></span><br><span class="line"><span class="function">n </span>= <span class="number">6</span> nodes</span><br><span class="line">   o</span><br><span class="line"><span class="number">3</span>     <span class="number">2</span></span><br><span class="line"><span class="number">5</span>*<span class="number">2</span> f(<span class="number">3</span>) = <span class="number">5</span> f(<span class="number">2</span>) = <span class="number">2</span></span><br><span class="line">   o</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span></span><br><span class="line">   o</span><br><span class="line"><span class="number">1</span>     <span class="number">4</span></span><br><span class="line">   o</span><br><span class="line"><span class="number">0</span>     <span class="number">5</span>   etc.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pseudocode code</span><br><span class="line"><span class="function"><span class="keyword">for</span> L in <span class="title">range</span> <span class="params">(<span class="number">0</span>, n)</span> : <span class="comment">//left subtree size</span></span></span><br><span class="line"><span class="function">	R </span>= n - <span class="number">1</span> - L <span class="comment">// right subtree size</span></span><br><span class="line">	nL = f(L)  <span class="comment">//left tree topologies</span></span><br><span class="line">	nR = f(R)</span><br><span class="line">	T += nL * nR  <span class="comment">//total</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution1-26"><a href="#Solution1-26" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>O((n*(2n)!)/(n!(n + 1)!)) time, O(n) space</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfBinaryTreeTopologies</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> numberOfTrees = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> leftTrees = <span class="number">0</span>; leftTrees &lt; n; leftTrees++) &#123;</span><br><span class="line">        <span class="keyword">int</span> rightTrees = n - <span class="number">1</span> - leftTrees;</span><br><span class="line">        <span class="comment">//recursively call method to calculate the BT left and right side topologies</span></span><br><span class="line">        <span class="keyword">int</span> numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTrees);</span><br><span class="line">        <span class="keyword">int</span> numberOfRightTrees = numberOfBinaryTreeTopologies(rightTrees);</span><br><span class="line">        <span class="comment">//total topologies = how many types in left * how many types in right</span></span><br><span class="line">        numberOfTrees += numberOfLeftTrees * numberOfRightTrees;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numberOfTrees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-13"><a href="#Solution2-13" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>O(n^2) time, O(n) space</li>
<li>recursively</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfBinaryTreeTopologies</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    cache.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> numberOfBinaryTreeTopologies(n, cache);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfBinaryTreeTopologies</span><span class="params">(<span class="keyword">int</span> n, Map&lt;Integer, Integer&gt; cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(n))  <span class="comment">//base line</span></span><br><span class="line">        <span class="keyword">return</span> cache.get(n);</span><br><span class="line">    <span class="keyword">int</span> numberOfTrees = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> leftTrees = <span class="number">0</span>; leftTrees &lt; n; leftTrees++) &#123;</span><br><span class="line">        <span class="keyword">int</span> rightTrees = n - <span class="number">1</span> - leftTrees;</span><br><span class="line">        <span class="keyword">int</span> numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTrees, cache);</span><br><span class="line">        <span class="keyword">int</span> numberOfRightTrees = numberOfBinaryTreeTopologies(rightTrees, cahce);</span><br><span class="line">        numberOfTrees += numberOfLeftTrees * numberOfRightTrees;</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(n, numberOfTrees);</span><br><span class="line">    <span class="keyword">return</span> numberOfTrees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution3-1"><a href="#Solution3-1" class="headerlink" title="Solution3:"></a>Solution3:</h3><ol>
<li>O(n^2) time, O(n) space</li>
<li>iteratively</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfBinaryTreeTopologies</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    cache.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n + <span class="number">1</span>; m++) &#123;</span><br><span class="line">        <span class="keyword">int</span> numberOfTrees = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> leftTrees = <span class="number">0</span>; leftTrees &lt; m; leftTrees++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rightTrees = m - <span class="number">1</span> - leftTrees;</span><br><span class="line">            <span class="keyword">int</span> numberOfLeftTrees = cache.get(leftTrees);</span><br><span class="line">            <span class="keyword">int</span> numberOfRightTrees = cache.get(rightTrees);</span><br><span class="line">            numberOfTrees += numberOfLeftTrees * numberOfRightTrees;</span><br><span class="line">        &#125;</span><br><span class="line">        cache.add(numberOfTrees)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache.get(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-779-K-th-Symbol-in-Grammar✨"><a href="#Unsolved-779-K-th-Symbol-in-Grammar✨" class="headerlink" title="Unsolved 779. K-th Symbol in Grammar✨"></a><a href="https://leetcode.com/problems/k-th-symbol-in-grammar/" target="_blank" rel="noopener">Unsolved 779. K-th Symbol in Grammar✨</a></h2><h3 id="Solution1-27"><a href="#Solution1-27" class="headerlink" title="Solution1:"></a>Solution1:</h3><p><a href="https://leetcode.com/problems/k-th-symbol-in-grammar/discuss/113736/PythonJavaC%2B%2B-Easy-1-line-Solution-with-detailed-explanation" target="_blank" rel="noopener">Explaination</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.bitCount(K - <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">kthGrammar</span><span class="params">(self, N, K)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># Think of the base <span class="keyword">case</span>, already given here though</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> N </span>== <span class="number">1</span> and K == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    # We need to do some observation here:</span><br><span class="line"># 1 - Calculate the length of every row which is as below</span><br><span class="line">    mid = (<span class="number">2</span> ** (N-<span class="number">1</span>))<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    # If the K lies in the first half, it is actually same as prev row</span><br><span class="line">    <span class="keyword">if</span> K &lt;= mid:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(self.kthGrammar(N-<span class="number">1</span>, K))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"># Else it subtract the first half and then it is same as </span><br><span class="line">    # complement of the prev row</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">int</span>(not self.kthGrammar(N-<span class="number">1</span>, K-mid))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dejavi-19.github.io/2020/09/17/Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
      <meta itemprop="name" content="Dejavu">
      <meta itemprop="description" content="Stay gold">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dejavu's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/Graph/" class="post-title-link" itemprop="url">Graph</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 13:03:03" itemprop="dateCreated datePublished" datetime="2020-09-17T13:03:03+09:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-13 15:52:40" itemprop="dateModified" datetime="2021-03-13T15:52:40+09:00">2021-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pattern-Topological-Sort-Graph"><a href="#Pattern-Topological-Sort-Graph" class="headerlink" title="Pattern: Topological Sort (Graph)"></a>Pattern: Topological Sort (Graph)</h1><h2 id="Topological-Sort-medium"><a href="#Topological-Sort-medium" class="headerlink" title="Topological Sort (medium)"></a>Topological Sort (medium)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: Vertices&#x3D;4, Edges&#x3D;[3, 2], [3, 0], [2, 0], [2, 1]</span><br><span class="line">Output: Following are the two valid topological sorts for the given graph:</span><br><span class="line">1) 3, 2, 0, 1</span><br><span class="line">2) 3, 2, 1, 0</span><br><span class="line"></span><br><span class="line">Input: Vertices&#x3D;5, Edges&#x3D;[4, 2], [4, 3], [2, 0], [2, 1], [3, 1]</span><br><span class="line">Output: Following are all valid topological sorts for the given graph:</span><br><span class="line">1) 4, 2, 3, 0, 1</span><br><span class="line">2) 4, 3, 2, 0, 1</span><br><span class="line">3) 4, 3, 2, 1, 0</span><br><span class="line">4) 4, 2, 3, 1, 0</span><br><span class="line">5) 4, 2, 0, 3, 1</span><br><span class="line"></span><br><span class="line">A topological ordering is possible only when the graph has no directed cycles, i.e. if the graph is a Directed Acyclic Graph (DAG). </span><br><span class="line">If the graph has a cycle, some vertices will have cyclic dependencies which makes it impossible to find a linear ordering among vertices.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">sort</span><span class="params">(<span class="keyword">int</span> vertices, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (vertices &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sortedOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = edges[i][<span class="number">0</span>], child = edges[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">    <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">    <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> vertex = sources.poll();</span><br><span class="line">        sortedOrder.add(vertex);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                sources.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sortedOrder.size() != vertices) <span class="comment">// topological sort is not possible as the graph has a cycle</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tasks-Scheduling-medium"><a href="#Tasks-Scheduling-medium" class="headerlink" title="Tasks Scheduling (medium)"></a>Tasks Scheduling (medium)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSchedulingPossible</span><span class="params">(<span class="keyword">int</span> tasks, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (tasks &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = prerequisites[i][<span class="number">0</span>], child = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">        <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">        <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> vertex = sources.poll();</span><br><span class="line">            sortedOrder.add(vertex);</span><br><span class="line">            List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">                inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                    sources.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder doesn't contain all tasks, there is a cyclic dependency between tasks, therefore, we</span></span><br><span class="line">    <span class="comment">// will not be able to schedule all tasks</span></span><br><span class="line">    <span class="keyword">return</span> sortedOrder.size() == tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="207-Course-Schedule⭐🎶"><a href="#207-Course-Schedule⭐🎶" class="headerlink" title="207. Course Schedule⭐🎶"></a><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">207. Course Schedule⭐🎶</a></h2><p>There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2, [[1,0]]</span><br><span class="line">return true</span><br><span class="line">2, [[1,0],[0,1]]</span><br><span class="line">return false</span><br></pre></td></tr></table></figure>

<p>题目描述：一个课程可能会先修课程，判断给定的先修课程规定是否合法。</p>
<p>本题不需要使用拓扑排序，只需要检测有向图是否存在环即可。</p>
<p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2017/10/207-ep93.png" alt=""></p>
<p><img src="http://zxi.mytechroad.com/blog/wp-content/uploads/2017/10/207-ep93-1.png" alt=""></p>
<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//initial graph</span></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> child = p[<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child);</span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initial queue for source vertice</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> node : inDegree.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree.get(node) == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">        sortedList.add(cur);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedList.size() == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>Topological Sort</li>
<li>思路：用一个 Map 记录课程的后续课程，用一个数组记录每门课前提课程的门数。把前提门数为零的放入一个队列，然后 逐个元素看能达到的所有课程，如果达到某课，则该课的前提减 1，如果该课前提为零，则加入队列。重复直到队列为空， 如果队列中累计弹出的课程数=总课程数，则表示可以完成。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> course = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pre = p[<span class="number">1</span>];</span><br><span class="line">        graph.get(course).add(pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">boolean</span>[] visiting = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, i, visited, visiting)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs for detect cycle</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> cur, <span class="keyword">boolean</span>[] visited, <span class="keyword">boolean</span>[] visiting)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (visiting[cur]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[cur]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    visiting[cur] = <span class="keyword">true</span>;</span><br><span class="line">    visited[cur] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(cur)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, next, visited, visiting)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visiting[cur] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Author: Huahua</span></span><br><span class="line"><span class="comment">// Runtime: 6 ms</span></span><br><span class="line"><span class="comment">// HashMap is slower than ArrayList in this problem.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;        </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> course = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> prerequisite = prerequisites[i][<span class="number">1</span>];            </span><br><span class="line">            graph.get(course).add(prerequisite);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span> (dfs(i, graph, visited)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        visited[curr] = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(curr))</span><br><span class="line">            <span class="keyword">if</span> (dfs(next, graph, visited)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        visited[curr] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tasks-Scheduling-Order-medium"><a href="#Tasks-Scheduling-Order-medium" class="headerlink" title="Tasks Scheduling Order (medium)"></a>Tasks Scheduling Order (medium)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> tasks, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (tasks &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sortedOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = prerequisites[i][<span class="number">0</span>], child = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">    <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">    <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> vertex = sources.poll();</span><br><span class="line">        sortedOrder.add(vertex);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                sources.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder doesn't contain all tasks, there is a cyclic dependency between tasks, therefore, we</span></span><br><span class="line">    <span class="comment">// will not be able to schedule all tasks</span></span><br><span class="line">    <span class="keyword">if</span> (sortedOrder.size() != tasks)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-210-Course-Schedule-II🎂💜⭐"><a href="#🌕Unsolved-210-Course-Schedule-II🎂💜⭐" class="headerlink" title="🌕Unsolved 210. Course Schedule II🎂💜⭐"></a><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">🌕Unsolved 210. Course Schedule II🎂💜⭐</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>]]</span><br><span class="line">There are a total of <span class="number">4</span> courses to take. To take course <span class="number">3</span> you should have finished both courses <span class="number">1</span> and <span class="number">2</span>. Both courses <span class="number">1</span> and <span class="number">2</span> should be taken after you finished course <span class="number">0</span>. So one correct course order is [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]. Another correct ordering is[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>].</span><br></pre></td></tr></table></figure>

<p>There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. For example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>

<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>

<p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p>
<p>Note: </p>
<ol>
<li>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. </li>
<li>You may assume that there are no duplicate edges in the input prerequisites. Hints:</li>
<li>This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses. </li>
<li>Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort. </li>
<li>Topological sort could also be done via BFS</li>
</ol>
<p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2017/12/210-ep133.png" alt=""></p>
<p><a href="http://zxi.mytechroad.com/blog/graph/leetcode-210-course-schedule-ii/" target="_blank" rel="noopener">http://zxi.mytechroad.com/blog/graph/leetcode-210-course-schedule-ii/</a></p>
<h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">    List&lt;Integer&gt; sortedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initial graph inDegree -&gt; count in coming edges for vertice</span></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = p[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> child = p[<span class="number">0</span>];</span><br><span class="line">        graph.get(parent).add(child);</span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//prepare queue, add current source into it</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> node : inDegree.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree.get(node) == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//treverse left part add the node to sotedlist followe the releationship</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">        sortedList.add(cur);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//check cycle</span></span><br><span class="line">    <span class="keyword">if</span> (sortedList.size() != numCourses) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//list -&gt; array</span></span><br><span class="line">    <span class="keyword">return</span> sortedList.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li><p>Topological Sorting</p>
<p>Time complexity: O(V+E)</p>
<p>Space complexity: O(V+E)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> course = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pre = p[<span class="number">1</span>];</span><br><span class="line">        graph.get(course).add(pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">boolean</span>[] visiting = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, i, visited, visiting, ans)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> cur, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span>[] visited, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span>[] visiting,</span></span></span><br><span class="line"><span class="function"><span class="params">                   List&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (visiting[cur]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[cur]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    visiting[cur] = <span class="keyword">true</span>;</span><br><span class="line">    visited[cur] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(cur)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, next, visited, visiting, ans)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans.add(cur);</span><br><span class="line">    visiting[cur] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Author: Huahua</span></span><br><span class="line"><span class="comment">// Runtime: 83 ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> course = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> prerequisite = prerequisites[i][<span class="number">1</span>];            </span><br><span class="line">            graph.get(course).add(prerequisite);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Integer index = numCourses;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span> (dfs(i, graph, visited, ans)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[] visited, List&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        visited[curr] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(curr))</span><br><span class="line">            <span class="keyword">if</span> (dfs(next, graph, visited, ans)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        visited[curr] = <span class="number">2</span>;</span><br><span class="line">        ans.add(curr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-All-Tasks-Scheduling-Orders-hard"><a href="#🌕Unsolved-All-Tasks-Scheduling-Orders-hard" class="headerlink" title="🌕Unsolved All Tasks Scheduling Orders (hard)"></a>🌕Unsolved All Tasks Scheduling Orders (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Input: Tasks&#x3D;4, Prerequisites&#x3D;[3, 2], [3, 0], [2, 0], [2, 1]</span><br><span class="line">Output: </span><br><span class="line">1) [3, 2, 0, 1]</span><br><span class="line">2) [3, 2, 1, 0]</span><br><span class="line">Explanation: There are two possible orderings of the tasks meeting all prerequisites.</span><br><span class="line"></span><br><span class="line">Input: Tasks&#x3D;6, Prerequisites&#x3D;[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]</span><br><span class="line">Output: </span><br><span class="line">1) [0, 1, 4, 3, 2, 5]</span><br><span class="line">2) [0, 1, 3, 4, 2, 5]</span><br><span class="line">3) [0, 1, 3, 2, 4, 5]</span><br><span class="line">4) [0, 1, 3, 2, 5, 4]</span><br><span class="line">5) [1, 0, 3, 4, 2, 5]</span><br><span class="line">6) [1, 0, 3, 2, 4, 5]</span><br><span class="line">7) [1, 0, 3, 2, 5, 4]</span><br><span class="line">8) [1, 0, 4, 3, 2, 5]</span><br><span class="line">9) [1, 3, 0, 2, 4, 5]</span><br><span class="line">10) [1, 3, 0, 2, 5, 4]</span><br><span class="line">11) [1, 3, 0, 4, 2, 5]</span><br><span class="line">12) [1, 3, 2, 0, 5, 4]</span><br><span class="line">13) [1, 3, 2, 0, 4, 5]</span><br><span class="line"></span><br><span class="line">This problem is similar to Tasks Scheduling Order, the only difference is that we need to find all the topological orderings of the tasks.</span><br><span class="line"></span><br><span class="line">At any stage, if we have more than one source available and since we can choose any source, therefore, in this case, we will have multiple orderings of the tasks. We can use a recursive approach with Backtracking to consider all sources at any step.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOrders</span><span class="params">(<span class="keyword">int</span> tasks, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (tasks &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = prerequisites[i][<span class="number">0</span>], child = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">        inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printAllTopologicalSorts(graph, inDegree, sources, sortedOrder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllTopologicalSorts</span><span class="params">(HashMap&lt;Integer, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             List&lt;Integer&gt;&gt; graph,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             HashMap&lt;Integer, Integer&gt; inDegree, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             Queue&lt;Integer&gt; sources, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             List&lt;Integer&gt; sortedOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer vertex : sources) &#123;</span><br><span class="line">            sortedOrder.add(vertex);</span><br><span class="line">            Queue&lt;Integer&gt; sourcesForNextCall = cloneQueue(sources);</span><br><span class="line">            <span class="comment">// only remove the current source, all other sources should remain in the queue for the next call</span></span><br><span class="line">            sourcesForNextCall.remove(vertex);</span><br><span class="line">            List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">                inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                    sourcesForNextCall.add(child); <span class="comment">// save the new source for the next call</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// dfs, recursive call to print other orderings from the remaining (and new) sources</span></span><br><span class="line">            printAllTopologicalSorts(graph, inDegree, sourcesForNextCall, sortedOrder);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// backtrack, remove the vertex from the sorted order and put all of its children back to consider the next source instead of the current vertex</span></span><br><span class="line">            sortedOrder.remove(vertex);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children)</span><br><span class="line">                inDegree.put(child, inDegree.get(child) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="comment">// if sortedOrder doesn't contain all tasks, either we've a cyclic dependency between tasks, or </span></span><br><span class="line">    <span class="comment">// we have not processed all the tasks in this recursive call</span></span><br><span class="line">    <span class="keyword">if</span> (sortedOrder.size() == inDegree.size())</span><br><span class="line">        System.out.println(sortedOrder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makes a deep copy of the queue</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;Integer&gt; <span class="title">cloneQueue</span><span class="params">(Queue&lt;Integer&gt; queue)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; clone = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer num : queue)</span><br><span class="line">        clone.add(num);</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Alien-Dictionary-hard"><a href="#Alien-Dictionary-hard" class="headerlink" title="Alien Dictionary (hard)"></a>Alien Dictionary (hard)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: Words: [&quot;ba&quot;, &quot;bc&quot;, &quot;ac&quot;, &quot;cab&quot;]</span><br><span class="line">Output: bac</span><br><span class="line">Explanation: Given that the words are sorted lexicographically by the rules of the alien language, so</span><br><span class="line">from the given words we can conclude the following ordering among its characters:</span><br><span class="line"></span><br><span class="line">1. From &quot;ba&quot; and &quot;bc&quot;, we can conclude that &#39;a&#39; comes before &#39;c&#39;.</span><br><span class="line">2. From &quot;bc&quot; and &quot;ac&quot;, we can conclude that &#39;b&#39; comes before &#39;a&#39;</span><br><span class="line"></span><br><span class="line">From the above two points, we can conclude that the correct character order is: &quot;bac&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Character, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Character, List&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> character : word.toCharArray()) &#123;</span><br><span class="line">            inDegree.put(character, <span class="number">0</span>);</span><br><span class="line">            graph.put(character, <span class="keyword">new</span> ArrayList&lt;Character&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        String w1 = words[i], w2 = words[i + <span class="number">1</span>]; <span class="comment">// find ordering of characters from adjacent words</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Math.min(w1.length(), w2.length()); j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> parent = w1.charAt(j), child = w2.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (parent != child) &#123; <span class="comment">// if the two characters are different</span></span><br><span class="line">                graph.get(parent).add(child); <span class="comment">// put the child into it's parent's list</span></span><br><span class="line">                inDegree.put(child, inDegree.get(child) + <span class="number">1</span>); <span class="comment">// increment child's inDegree</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// only the first different character between the two words will help us find the order</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Character&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">    <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">    StringBuilder sortedOrder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        Character vertex = sources.poll();</span><br><span class="line">        sortedOrder.append(vertex);</span><br><span class="line">        List&lt;Character&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">        <span class="keyword">for</span> (Character child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                sources.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder doesn't contain all characters, there is a cyclic dependency between characters, therefore, we</span></span><br><span class="line">    <span class="comment">// will not be able to find the correct ordering of the characters</span></span><br><span class="line">    <span class="keyword">if</span> (sortedOrder.length() != inDegree.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedOrder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-269-Alien-Dictionary🎂✨"><a href="#🌕Unsolved-269-Alien-Dictionary🎂✨" class="headerlink" title="🌕Unsolved 269.Alien Dictionary🎂✨"></a><a href="https://leetcode.com/problems/alien-dictionary/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">🌕Unsolved 269.Alien Dictionary🎂✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 0: Create data structures and find all unique letters.</span></span><br><span class="line">    Map&lt;Character, List&lt;Character&gt;&gt; adjList = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            counts.put(c, <span class="number">0</span>);</span><br><span class="line">            adjList.put(c, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: Find all edges.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        String word1 = words[i];</span><br><span class="line">        String word2 = words[i + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// Check that word2 is not a prefix of word1.</span></span><br><span class="line">        <span class="keyword">if</span> (word1.length() &gt; word2.length() &amp;&amp; word1.startsWith(word2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Find the first non match and insert the corresponding relation.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Math.min(word1.length(), word2.length()); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(j) != word2.charAt(j)) &#123;</span><br><span class="line">                adjList.get(word1.charAt(j)).add(word2.charAt(j));</span><br><span class="line">                counts.put(word2.charAt(j), counts.get(word2.charAt(j)) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Breadth-first search.</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Character c : counts.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counts.get(c).equals(<span class="number">0</span>)) &#123;</span><br><span class="line">            queue.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Character c = queue.remove();</span><br><span class="line">        sb.append(c);</span><br><span class="line">        <span class="keyword">for</span> (Character next : adjList.get(c)) &#123;</span><br><span class="line">            counts.put(next, counts.get(next) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (counts.get(next).equals(<span class="number">0</span>)) &#123;</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sb.length() &lt; counts.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Challenge-1-Reconstructing-a-Sequence-hard"><a href="#🌕Challenge-1-Reconstructing-a-Sequence-hard" class="headerlink" title="🌕Challenge 1 Reconstructing a Sequence (hard)"></a>🌕Challenge 1 Reconstructing a Sequence (hard)</h2><p>The above explanation tells us that we are actually asked to find the topological ordering of all the numbers and also to verify that there is only one topological ordering of the numbers possible from the given array of the sequences.</p>
<p>This makes the current problem similar to <a href="https://www.educative.io/collection/page/5668639101419520/5671464854355968/5066018374287360/" target="_blank" rel="noopener">Tasks Scheduling Order</a> with two differences:</p>
<ol>
<li>We need to build the graph of the numbers by comparing each pair of numbers in the given array of sequences.</li>
<li>We must perform the topological sort for the graph to determine two things:<ul>
<li>Can the topological ordering construct the <code>originalSeq</code>?</li>
<li>That there is only one topological ordering of the numbers possible. This can be confirmed if we do not have more than one source at any time while finding the topological ordering of numbers.</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(<span class="keyword">int</span>[] originalSeq, <span class="keyword">int</span>[][] sequences)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedOrder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (originalSeq.length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] seq : sequences) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seq.length; i++) &#123;</span><br><span class="line">            inDegree.putIfAbsent(seq[i], <span class="number">0</span>);</span><br><span class="line">            graph.putIfAbsent(seq[i], <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] seq : sequences) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; seq.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = seq[i - <span class="number">1</span>], child = seq[i];</span><br><span class="line">            graph.get(parent).add(child);</span><br><span class="line">            inDegree.put(child, inDegree.get(child) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we don't have ordering rules for all the numbers we'll not able to uniquely construct the sequence</span></span><br><span class="line">    <span class="keyword">if</span> (inDegree.size() != originalSeq.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all sources i.e., all vertices with 0 in-degrees</span></span><br><span class="line">    Queue&lt;Integer&gt; sources = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">0</span>)</span><br><span class="line">            sources.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees</span></span><br><span class="line">    <span class="comment">// if a child's in-degree becomes zero, add it to the sources queue</span></span><br><span class="line">    <span class="keyword">while</span> (!sources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sources.size() &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// more than one sources mean, there is more than one way to reconstruct the sequence</span></span><br><span class="line">        <span class="keyword">if</span> (originalSeq[sortedOrder.size()] != sources.peek())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// the next source (or number) is different from the original sequence</span></span><br><span class="line">        <span class="keyword">int</span> vertex = sources.poll();</span><br><span class="line">        sortedOrder.add(vertex);</span><br><span class="line">        List&lt;Integer&gt; children = graph.get(vertex); <span class="comment">// get the node's children to decrement their in-degrees</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">            inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(child) == <span class="number">0</span>)</span><br><span class="line">                sources.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sortedOrder's size is not equal to original sequence's size, there is no unique way to construct  </span></span><br><span class="line">    <span class="keyword">return</span> sortedOrder.size() == originalSeq.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-Challenge-2-Minimum-Height-Trees-hard"><a href="#🌕Unsolved-Challenge-2-Minimum-Height-Trees-hard" class="headerlink" title="🌕Unsolved Challenge 2 Minimum Height Trees (hard)"></a>🌕Unsolved Challenge 2 Minimum Height Trees (hard)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findTrees</span><span class="params">(<span class="keyword">int</span> nodes, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; minHeightTrees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nodes &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> minHeightTrees;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with only one node, since its in-degree will be 0, therefore, we need to handle it separately</span></span><br><span class="line">    <span class="keyword">if</span> (nodes == <span class="number">1</span>) &#123;</span><br><span class="line">        minHeightTrees.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> minHeightTrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. Initialize the graph</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// adjacency list graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes; i++) &#123;</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. Build the graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = edges[i][<span class="number">0</span>], n2 = edges[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// since this is an undirected graph, therefore, add a link for both the nodes</span></span><br><span class="line">        graph.get(n1).add(n2);</span><br><span class="line">        graph.get(n2).add(n1);</span><br><span class="line">        <span class="comment">// increment the in-degrees of both the nodes</span></span><br><span class="line">        inDegree.put(n1, inDegree.get(n1) + <span class="number">1</span>);</span><br><span class="line">        inDegree.put(n2, inDegree.get(n2) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. Find all leaves i.e., all nodes with only 1 in-degree</span></span><br><span class="line">    Queue&lt;Integer&gt; leaves = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : inDegree.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == <span class="number">1</span>)</span><br><span class="line">            leaves.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. Remove leaves level by level and subtract each leave's children's in-degrees.</span></span><br><span class="line">    <span class="comment">// Repeat this until we are left with 1 or 2 nodes, which will be our answer.</span></span><br><span class="line">    <span class="comment">// Any node that has already been a leaf cannot be the root of a minimum height tree, because </span></span><br><span class="line">    <span class="comment">// its adjacent non-leaf node will always be a better candidate.</span></span><br><span class="line">    <span class="keyword">int</span> totalNodes = nodes;</span><br><span class="line">    <span class="keyword">while</span> (totalNodes &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> leavesSize = leaves.size();</span><br><span class="line">        totalNodes -= leavesSize;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leavesSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> vertex = leaves.poll();</span><br><span class="line">            List&lt;Integer&gt; children = graph.get(vertex);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children) &#123;</span><br><span class="line">                inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(child) == <span class="number">1</span>) <span class="comment">// if the child has become a leaf</span></span><br><span class="line">                    leaves.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    minHeightTrees.addAll(leaves);</span><br><span class="line">    <span class="keyword">return</span> minHeightTrees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsolved-310-Minimum-Height-Trees🎂✨"><a href="#Unsolved-310-Minimum-Height-Trees🎂✨" class="headerlink" title="Unsolved 310. Minimum Height Trees🎂✨"></a><a href="https://leetcode.com/problems/minimum-height-trees/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 310. Minimum Height Trees🎂✨</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        ans.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        inDegree.put(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = e[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> j = e[<span class="number">1</span>];</span><br><span class="line">        graph.get(i).add(j);</span><br><span class="line">        graph.get(j).add(i);</span><br><span class="line">        inDegree.put(i, inDegree.get(i) + <span class="number">1</span>);</span><br><span class="line">        inDegree.put(j, inDegree.get(j) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> node : inDegree.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree.get(node) == <span class="number">1</span>) &#123;</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nodeNum = n;</span><br><span class="line">    <span class="keyword">while</span>(nodeNum &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        nodeNum -= size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leaf = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : graph.get(leaf)) &#123;</span><br><span class="line">                inDegree.put(child, inDegree.get(child) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(child) == <span class="number">1</span>) &#123;</span><br><span class="line">                    queue.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Coderust-Hacking-the-Coding-Interview"><a href="#Coderust-Hacking-the-Coding-Interview" class="headerlink" title="Coderust: Hacking the Coding Interview"></a>Coderust: Hacking the Coding Interview</h1><h2 id="Clone-a-Directed-Graph"><a href="#Clone-a-Directed-Graph" class="headerlink" title="Clone a Directed Graph"></a>Clone a Directed Graph</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;data = d;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">clone_rec</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Node root, </span></span></span><br><span class="line"><span class="function"><span class="params">        HashMap&lt;Node, Node&gt; nodes_completed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node pNew = <span class="keyword">new</span> Node(root.data);</span><br><span class="line">        nodes_completed.put(root, pNew);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node p : root.neighbors) &#123;</span><br><span class="line">            Node x = nodes_completed.get(p);</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="keyword">null</span>)&#123;</span><br><span class="line">                pNew.neighbors.add(clone_rec(p, nodes_completed));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pNew.neighbors.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-133-Clone-Graph🎂✨"><a href="#🌕Unsolved-133-Clone-Graph🎂✨" class="headerlink" title="🌕Unsolved 133. Clone Graph🎂✨"></a><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">🌕Unsolved 133. Clone Graph🎂✨</a></h2><p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. OJ’s undirected graph serialization: Nodes are labeled uniquely.</p>
<p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node. As an example, consider the serialized graph {0,1,2#1,2#2,2}. The graph has a total of three nodes, and therefore contains three parts as separated by #. </p>
<ol>
<li>First node is labeled as 0. Connect node 0 to both nodes 1 and 2. </li>
<li>Second node is labeled as 1. Connect node 1 to node 2. </li>
<li>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle. Visually, the graph looks like the following:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span></span><br><span class="line">  / \</span><br><span class="line"> /   \</span><br><span class="line"><span class="number">0</span> --- <span class="number">2</span></span><br><span class="line">    / \</span><br><span class="line">    \_/</span><br><span class="line">Definition <span class="keyword">for</span> a Node.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">        neighbors = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, ArrayList&lt;Node&gt; _neighbors)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>思路 1：BFS，每次把新结点放入将访问队列，通过 Map 记录已访问结点，避免重复访问。</li>
<li>O(nk)，n 结点数， k 邻居数。前提：结点中的值唯一。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node root = <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(node, root);</span><br><span class="line">    queue.add(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (Node neighbor : cur.neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(neighbor)) &#123;</span><br><span class="line">                map.put(neighbor, <span class="keyword">new</span> Node(neighbor.val, <span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">                queue.add(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(cur).neighbors.add(map.get(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>思路 2：DFS，思路同思路 1，只不过深度优先，好处是结点访问次数减少。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> dfs(node, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">dfs</span><span class="params">(Node node, Map&lt;Node, Node&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base line</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Node copyNode = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">    map.put(node, copyNode);</span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : node.neighbors) &#123;</span><br><span class="line">        Node next = map.get(neighbor);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            copyNode.neighbors.add(dfs(neighbor, map));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            copyNode.neighbors.add(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copyNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Minimum-Spanning-Tree"><a href="#🌕Minimum-Spanning-Tree" class="headerlink" title="🌕Minimum Spanning Tree"></a>🌕Minimum Spanning Tree</h2><h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><h2 id="Depth-first-Search-AE"><a href="#Depth-first-Search-AE" class="headerlink" title="Depth first Search(AE)"></a>Depth first Search(AE)</h2><h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>traverse the tree-like graph</li>
<li>V-vertex nodes, E-edges the line between node, call a bunch of stack</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(V+E) T</span></span><br><span class="line"><span class="comment">//O(V) S</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do not edit the class below except</span></span><br><span class="line">    <span class="comment">// for the depthFirstSearch method.</span></span><br><span class="line">    <span class="comment">// Feel free to add new properties</span></span><br><span class="line">    <span class="comment">// and methods to the class.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        List&lt;Node&gt; children = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">depthFirstSearch</span><span class="params">(List&lt;String&gt; array)</span> </span>&#123;</span><br><span class="line">            array.add(<span class="keyword">this</span>.name);  <span class="comment">//add the node to result</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chileren.size(); ++i) &#123;  <span class="comment">//traverse each children node and call DFS function recursively</span></span><br><span class="line">                children.get(i).depthFirstSearch(array);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">addChild</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            Node child = <span class="keyword">new</span> Node(name);</span><br><span class="line">            children.add(child);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="863-All-Nodes-Distance-K-in-Binary-Tree⭐"><a href="#863-All-Nodes-Distance-K-in-Binary-Tree⭐" class="headerlink" title="863. All Nodes Distance K in Binary Tree⭐"></a><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener">863. All Nodes Distance K in Binary Tree⭐</a></h2><p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2018/06/863-ep202.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">7</span>,<span class="number">4</span>], target = <span class="number">5</span>, K = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">The nodes that are a distance <span class="number">2</span> <span class="function">from the target <span class="title">node</span> <span class="params">(with value <span class="number">5</span>)</span></span></span><br><span class="line"><span class="function">have values 7, 4, and 1.</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt=""></p>
<h3 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Build graph, BFS/DFS traverse</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method 1: use HashMap</span></span><br><span class="line"><span class="comment">//1. build a undirected graph using treenodes as vertices, and the parent-child relation as edges</span></span><br><span class="line"><span class="comment">//2. do BFS with source vertice (target) to find all vertices with distance K to it.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//here can also use Map&lt;TreeNode, TreeNode&gt; to only store the child - parent mapping, since parent-child mapping is inherent in the tree structure</span></span><br><span class="line"></span><br><span class="line">Map&lt;TreeNode, List&lt;TreeNode&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//error check</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || K &lt; <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    buildGraph(root, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (!graph.containsKey(target)) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    Set&lt;TreeNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(target);</span><br><span class="line">    visited.add(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="comment">//if distance is K, add this level to the ans list</span></span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                ans.add(queue.poll().val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode neighbor : graph.get(cur)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited.contains(neighbor)) <span class="keyword">continue</span>;</span><br><span class="line">                queue.add(neighbor);</span><br><span class="line">                visited.add(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        K--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(TreeNode root, TreeNode parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!graph.containsKey(root)) &#123;</span><br><span class="line">        graph.put(root, <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;());</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            graph.get(root).add(parent);</span><br><span class="line">            graph.get(parent).add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        buildGraph(root.left, root);</span><br><span class="line">        buildGraph(root.right, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Error check:</span></span><br><span class="line"><span class="comment">1. If root == null</span></span><br><span class="line"><span class="comment">2. K &lt; 0</span></span><br><span class="line"><span class="comment">3. traget inside the tree</span></span><br><span class="line"><span class="comment">return empty list</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Solution1:</span></span><br><span class="line"><span class="comment">BFS,start from target</span></span><br><span class="line"><span class="comment">Step1: Build a graph use adjacency list,</span></span><br><span class="line"><span class="comment">Step2: BFS with a queue</span></span><br><span class="line"><span class="comment">    1.add taregt to queue</span></span><br><span class="line"><span class="comment">    2.level by level, utilize the neighbor list in the graph</span></span><br><span class="line"><span class="comment">    3.in K th level which means K distance from target, add all element in this level to a list and retrun it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2</span></span><br><span class="line"><span class="comment">adjacency list:</span></span><br><span class="line"><span class="comment">3 -&gt; [5,1]</span></span><br><span class="line"><span class="comment">5 -&gt; [6,2,3]</span></span><br><span class="line"><span class="comment">6 -&gt; [5]</span></span><br><span class="line"><span class="comment">2 -&gt; [5,7,4]</span></span><br><span class="line"><span class="comment">7 -&gt; [2]</span></span><br><span class="line"><span class="comment">4 -&gt; [2]</span></span><br><span class="line"><span class="comment">1 -&gt; [3,0,8]</span></span><br><span class="line"><span class="comment">0 -&gt; [1]</span></span><br><span class="line"><span class="comment">8 -&gt; [1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Go through an example:</span></span><br><span class="line"><span class="comment">target:5, K = 2</span></span><br><span class="line"><span class="comment">queue: 7,4,1</span></span><br><span class="line"><span class="comment">level:2</span></span><br><span class="line"><span class="comment">ans: 7,4,1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method 2: No HashMap</span></span><br><span class="line"><span class="comment">//kind of like clone the tree, in the meanwhile add a parent link to the node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GNode targetGNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">GNode</span> </span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        GNode parent, left, right;</span><br><span class="line">        GNode (TreeNode node) &#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;           </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || K &lt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        cloneGraph(root, <span class="keyword">null</span>, target);</span><br><span class="line">        <span class="keyword">if</span> (targetGNode == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Set&lt;GNode&gt; visited = <span class="keyword">new</span> HashSet&lt;GNode&gt;();</span><br><span class="line">        Queue&lt;GNode&gt; q = <span class="keyword">new</span> LinkedList&lt;GNode&gt;();</span><br><span class="line">        q.add(targetGNode);</span><br><span class="line">        visited.add(targetGNode);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size ; i++) res.add(q.poll().node.val);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                GNode gNode = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (gNode.left != <span class="keyword">null</span> &amp;&amp; !visited.contains(gNode.left)) &#123; visited.add(gNode.left); q.add(gNode.left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (gNode.right != <span class="keyword">null</span> &amp;&amp; !visited.contains(gNode.right)) &#123; visited.add(gNode.right); q.add(gNode.right); &#125;</span><br><span class="line">                <span class="keyword">if</span> (gNode.parent != <span class="keyword">null</span> &amp;&amp; !visited.contains(gNode.parent)) &#123; visited.add(gNode.parent); q.add(gNode.parent); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            K--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> GNode <span class="title">cloneGraph</span><span class="params">(TreeNode node, GNode parent, TreeNode target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        GNode gNode = <span class="keyword">new</span> GNode(node);</span><br><span class="line">        <span class="keyword">if</span> (node == target) targetGNode = gNode;</span><br><span class="line">        gNode.parent = parent;</span><br><span class="line">        gNode.left = cloneGraph(node.left, gNode, target);</span><br><span class="line">        gNode.right = cloneGraph(node.right, gNode, target);</span><br><span class="line">        <span class="keyword">return</span> gNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Single-Cycle-Check-AE"><a href="#Single-Cycle-Check-AE" class="headerlink" title="Single Cycle Check(AE)"></a>Single Cycle Check(AE)</h2><ol>
<li>Give a list of Integer, determine whether is there exist a single cycle, a loop visit every element only once</li>
<li>jump</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,-<span class="number">4</span>,-<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,<span class="number">1</span>] visit number</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) time | O(1) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSingleCycle</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numElementsVisits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curIdx = <span class="number">0</span>;  <span class="comment">//keep track the element we at the array, not necessary to be 0</span></span><br><span class="line">    <span class="keyword">while</span> (numElementsVisits &lt; array.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numElementsVisits &gt; <span class="number">0</span> &amp;&amp; curIdx == <span class="number">0</span>) &#123;  <span class="comment">//if we pass the first element before whole loop, the size of cycle not array.length</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        numElementsVisits++;  <span class="comment">//increase the element we have visited</span></span><br><span class="line">        curIdx = getNextIdx(curIdx, array);  <span class="comment">//jump wo next elements</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curIdx == <span class="number">0</span>;  <span class="comment">//aftr one whole loop, if it back to the start pointer, return true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextIdx</span><span class="params">(<span class="keyword">int</span> curIdx, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> jump = array[curIdx];  <span class="comment">//jump distance is the value of element</span></span><br><span class="line">    <span class="keyword">int</span> nextIdx = (curIdx + jump) % array.length;  <span class="comment">//apply mod operation if idx over the bound</span></span><br><span class="line">    <span class="keyword">return</span> nextIdx &gt;= <span class="number">0</span> ? nextIdx : nextIdx + array.length;  <span class="comment">//consider the negetave idx case</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Breadth-First-Search-AE"><a href="#Breadth-First-Search-AE" class="headerlink" title="Breadth First Search(AE)"></a>Breadth First Search(AE)</h2><ol>
<li><p>Target graph is a tree like graph traverse in a BFS way</p>
</li>
<li><p>DFS : branch by branch ; BFS : level by level</p>
</li>
<li><p>use queue (FIFO) will helpful to track the same level node</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">current: A</span><br><span class="line">Final array [A]  when we add A to <span class="keyword">final</span> array add all children BCD to queue</span><br><span class="line">Queue [B, C, D]</span><br><span class="line">    </span><br><span class="line">current: B</span><br><span class="line">Final array [A, B] when we add B to <span class="keyword">final</span> array add all children EF to queue</span><br><span class="line">Queue [C, D, E, F]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Problem</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        List&lt;Node&gt; children = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//O(v + e) time | O(v) space queue may be A have all children BCDEF in queue</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">breadthFirstSearch</span><span class="params">(List&lt;String&gt; array)</span> </span>&#123;</span><br><span class="line">            Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">            queue.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                Node current = queue.poll();</span><br><span class="line">                array.add(current.name);</span><br><span class="line">                queue.addAll(current.children);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">addChild</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            Node child = <span class="keyword">new</span> Node(name);</span><br><span class="line">            children.add(child);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="River-Sizes-AE-Number-of-Island-with-Area-follow-up⭐"><a href="#River-Sizes-AE-Number-of-Island-with-Area-follow-up⭐" class="headerlink" title="River Sizes(AE) || Number of Island with Area follow up⭐"></a>River Sizes(AE) || Number of Island with Area follow up⭐</h2><h3 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>Classical graph traversal question, given a matrix, 0 -&gt; land, 1 -&gt;river. River size is the 1 that are adjacent, right next to each other either horizontally or vertically. Write  function to return an array of all pf the sizes of rivers in the matrix</li>
<li>Treat the matrix element as node, each has neighbor node. Use BFS or DFS to all neighbor node to do so. Technique: keep track of all the node we visited. Traverse all the node in sequence and keep track the size of river and visited</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(wh) time | O(wh) space width and height of matix</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">riverSizes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sizes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  <span class="comment">//initialize the size of rivers</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length][matrix[<span class="number">0</span>].length];  <span class="comment">//declare a boolean matrix that determines if the node has been visited</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; ++i) &#123;  <span class="comment">//row and column may different number</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i][j]) &#123;  <span class="comment">//is this node is already visited</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            traverseNode(i, j, matrix, visited, sizes);  <span class="comment">//call a tarverse helper function</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sizes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseNode</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] matrix, <span class="keyword">boolean</span>[][] visited, List&lt;Integer&gt; sizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentRiverSize = <span class="number">0</span>;  <span class="comment">//declare a polential river size varaible</span></span><br><span class="line">    Stack&lt;Integer[]&gt; nodesToExplore = <span class="keyword">new</span> Stack&lt;Integer[]&gt;();  <span class="comment">//apply DFS iteratively</span></span><br><span class="line">    nodesToExplore.push(<span class="keyword">new</span> Integer[]&#123;i, j&#125;);  <span class="comment">//the first need to explore is [i, j]</span></span><br><span class="line">    <span class="keyword">while</span> (!nodesToExplore.empty()) &#123;  <span class="comment">//pushing th neighbors to stack, and pop one by one, and BFS will use a queue instead of a stack</span></span><br><span class="line">        Integer[] currentNode = nodesToExplore.pop();</span><br><span class="line">        i = currentNode[<span class="number">0</span>];</span><br><span class="line">        j = currentNode[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (visited[i][j]) &#123;  <span class="comment">//when apply DFS if the node has been visited, skip continue</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;  <span class="comment">//else, set it has been visited</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;  <span class="comment">//if it is a piece of land, skip continue</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currentRiverSize++;  <span class="comment">//riversize++</span></span><br><span class="line">        <span class="comment">//we are doing with prevous unvisited one, go throuth the all unvisited neighbors, append them to the stack</span></span><br><span class="line">        List&lt;Integer[]&gt; unvisitedNeighbors = getUnvisitedNeighbors(i, j, matrix, visited);</span><br><span class="line">        <span class="keyword">for</span> (Integer[] neighbor : unvisitedNeighbors) &#123;</span><br><span class="line">            nodesToExplore.add(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentRiverSize &gt; <span class="number">0</span>) &#123;  <span class="comment">//if we have a actual river, add the size</span></span><br><span class="line">        sizes.add(currentRiverSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer[]&gt; getUnvisitedNeighbors(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] matrix, <span class="keyword">boolean</span>[][] visited) &#123;</span><br><span class="line">    List&lt;Integer[]&gt; unvisitedNeighbors = <span class="keyword">new</span> ArrayList&lt;Integer[]&gt;();  <span class="comment">//declare unvisited neighbors to an empty array , check the four neighbors are actually potentially valid neighbors</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !visited[i - <span class="number">1</span>][j]) &#123;  <span class="comment">//if there exist neighbor above us and unvisited, only add unvisited neighbors</span></span><br><span class="line">        unvisitedNeighbors.add(<span class="keyword">new</span> Integer[] &#123;i - <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; matrix.length - <span class="number">1</span> &amp;&amp; !visited[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">        unvisitedNeighbors.add(<span class="keyword">new</span> Integer[] &#123;i + <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; !visited[i][j - <span class="number">1</span>]) &#123;  <span class="comment">//if there left column neighbor and unvisited</span></span><br><span class="line">        unvisitedNeighbors.add(<span class="keyword">new</span> Integer[] &#123;i, j - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; matrix[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; !visited[i][j + <span class="number">1</span>]) &#123;  <span class="comment">//if there right column neighbor and unvisited</span></span><br><span class="line">        unvisitedNeighbors.add(<span class="keyword">new</span> Integer[] &#123;i, j + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unvisitedNeighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Youngest-Common-Ancestor-AE"><a href="#Youngest-Common-Ancestor-AE" class="headerlink" title="Youngest Common Ancestor(AE)"></a>Youngest Common Ancestor(AE)</h2><ol>
<li>Ancestor property, deal with the situation two children in the different level, equalize the two node depth check if they are same, if same return ancestor</li>
<li>else, go back together to find the same ancestor</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(D) time depth of two descendant | O(1) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AncestralTree <span class="title">getYoungestCommonAncestor</span><span class="params">(AncestoralTree topAncestor, AncestoralTree descendantOne, AncestoralTree descendantTwo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depthOne = getDescendantDepth(descendantOne, topAncestor);  <span class="comment">//use helper function to get the depth of both node</span></span><br><span class="line">    <span class="keyword">int</span> depthTwo = getDescendantDepth(descendantTwo, topAncestor);</span><br><span class="line">    <span class="keyword">if</span> (depthOne &gt; depthTwo) &#123;  <span class="comment">//first descendant is lower, bring it up</span></span><br><span class="line">        <span class="keyword">return</span> backtrackAncestralTree(descendantOne, descendantTwo, depthOne - depthTwo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> backtrackAncestralTree(descendantTwo, descendantOne, depthTwo - depthOne);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDescendantDepth</span><span class="params">(AncestralTree descendant, AncestralTree topAncestor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;  <span class="comment">//initialize deoth to 0 and update it</span></span><br><span class="line">    <span class="keyword">while</span> (descendant != topAncestor) &#123;</span><br><span class="line">        depth++;</span><br><span class="line">        descendant = descendant.ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AncestralTree <span class="title">backtrackAncestralTree</span><span class="params">(AncestralTree lowerDescendant, AncestralTree  higherDescendant, <span class="keyword">int</span> diff)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (diff &gt; <span class="number">0</span>) &#123;  <span class="comment">//bring up the lower descendant to the same level with higher descendant</span></span><br><span class="line">        lowerDescendant = lowerDescendant.ancestor;</span><br><span class="line">        diff--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (lowerDescendant != higherDescendant) &#123;  <span class="comment">//backtrack both until find the same ancestor</span></span><br><span class="line">        lowerDescendant = lowerDescendant.ancestor;</span><br><span class="line">        higherDescendant = higherDescendant.ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lowerDescendant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-Rectangle-Mania-AE"><a href="#Unsolved-Rectangle-Mania-AE" class="headerlink" title="Unsolved Rectangle Mania(AE)"></a>Unsolved Rectangle Mania(AE)</h2><h3 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String UP = <span class="string">"up"</span>;</span><br><span class="line">    <span class="keyword">static</span> String DOWN = <span class="string">"down"</span>;</span><br><span class="line">    <span class="keyword">static</span> String LEFT = <span class="string">"left"</span>;</span><br><span class="line">    <span class="keyword">static</span> String RIGHT = <span class="string">"right"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rectangleMania</span><span class="params">(Point[] coords)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, List&lt;Point&gt;&gt;&gt; coordsTable = getCoordsTable(coords);</span><br><span class="line">        <span class="keyword">return</span> getRectangleCount(coords, coordsTable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Map&lt;String, List&lt;Point&gt;&gt;&gt; getCoordsTable(Point[] coords) &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, List&lt;Point&gt;&gt;&gt; coordsTable = <span class="keyword">new</span> HashMap&lt;String, List&lt;Point&gt;&gt;();</span><br><span class="line">        coord1Directions.put(UP, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">        coord1Directions.put(DOWN, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">        coord1Directions.put(LEFT, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">        coord1Directions.put(RIGHT, <span class="keyword">new</span> ArrayList&lt;Point&gt;());</span><br><span class="line">        <span class="keyword">for</span> (Point coord2 : coords) &#123;</span><br><span class="line">            String coords2Direction = getCoordDirection(coord1, coord2);</span><br><span class="line">            <span class="keyword">if</span> (coord1Directions.containsKey(coords2Direction)) &#123;</span><br><span class="line">                coord1Directions.get(coords2Direction).add(coord2);</span><br><span class="line">            &#125;</span><br><span class="line">            String coords1String = coordToString(coord1);</span><br><span class="line">            coordsTable.put(coord1String, coord1Directions);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coordsTable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCoordDirection</span><span class="params">(Point coord1, Point coord2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coord2.y == coord1.y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coord2.x == coord1.x) &#123;</span><br><span class="line">                <span class="keyword">return</span> RIGHT;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coord2.x &lt; coord1.x)&#123;</span><br><span class="line">                <span class="keyword">return</span> LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coord2.x == coord1.x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coord2.y &gt; coord1.y) &#123;</span><br><span class="line">                <span class="keyword">return</span> UP;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coord2.y &lt; coords1.y) &#123;</span><br><span class="line">                <span class="keyword">return</span> DOWN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRectangleCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">clockwiseCountRectangles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNextClockwiseDirection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">coordToString</span><span class="params">(Point coord)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.x = x;</span><br><span class="line">      <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsolved-1042-Flower-Planting-With-No-Adjacent🎂"><a href="#Unsolved-1042-Flower-Planting-With-No-Adjacent🎂" class="headerlink" title="Unsolved 1042.Flower Planting With No Adjacent🎂"></a><a href="https://leetcode.com/problems/flower-planting-with-no-adjacent/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 1042.Flower Planting With No Adjacent🎂</a></h2><h2 id="Unsolved-990-Satisfiability-of-Equality-Equations🎂✨"><a href="#Unsolved-990-Satisfiability-of-Equality-Equations🎂✨" class="headerlink" title="Unsolved 990. Satisfiability of Equality Equations🎂✨"></a><a href="https://leetcode.com/problems/satisfiability-of-equality-equations/?utm_source=AlgoTogether&utm_campaign=ecad82826e-ALGOTOGETHER_2020Q4_PROGRAM_WEEK_5&utm_medium=email&utm_term=0_38d4e2e3e2-ecad82826e-231340480" target="_blank" rel="noopener">Unsolved 990. Satisfiability of Equality Equations🎂✨</a></h2><h1 id="二分图Bipartite"><a href="#二分图Bipartite" class="headerlink" title="二分图Bipartite"></a>二分图Bipartite</h1><p>如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么这个图就是二分图。</p>
<h2 id="🌕Unsolved-785-Is-Graph-Bipartite"><a href="#🌕Unsolved-785-Is-Graph-Bipartite" class="headerlink" title="🌕Unsolved 785.Is Graph Bipartite?"></a><a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener">🌕Unsolved 785.Is Graph Bipartite?</a></h2><p>Given an undirected <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p>
<p>A graph is <em>bipartite</em> if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">Output: <span class="keyword">true</span></span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like <span class="keyword">this</span>:</span><br><span class="line"><span class="number">0</span>----<span class="number">1</span></span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line"><span class="number">3</span>----<span class="number">2</span></span><br><span class="line">We can divide the vertices into two groups: &#123;<span class="number">0</span>, <span class="number">2</span>&#125; and &#123;<span class="number">1</span>, <span class="number">3</span>&#125;.</span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line">Input: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like <span class="keyword">this</span>:</span><br><span class="line"><span class="number">0</span>----<span class="number">1</span></span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line"><span class="number">3</span>----<span class="number">2</span></span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-9"><a href="#Solution1-9" class="headerlink" title="Solution1:"></a>Solution1:</h3><p><code>Our goal</code> is trying to use two colors to color the graph and see if there are any adjacent nodes having the same color.<br>Initialize a color[] array for each node. Here are three states for <code>colors[]</code> array:<br><code>0: Haven&#39;t been colored yet.</code><br><code>1: Blue.</code><br><code>-1: Red.</code><br>For each node,</p>
<ol>
<li>If it hasn’t been colored, use a color to color it. Then use the other color to color all its adjacent nodes (DFS).</li>
<li>If it has been colored, check if the current color is the same as the color that is going to be used to color it. </li>
</ol>
<p>DFS Solution:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    Arrays.fill(colors, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;  <span class="comment">//This graph might be a disconnected graph. So check each unvisited node.</span></span><br><span class="line">        <span class="keyword">if</span> (colors[i] == -<span class="number">1</span> &amp;&amp; !isBipartite(i, <span class="number">0</span>, colors, graph)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span> curNode, <span class="keyword">int</span> curColor, <span class="keyword">int</span>[] colors, <span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (colors[curNode] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> colors[curNode] == curColor;</span><br><span class="line">    &#125;</span><br><span class="line">    colors[curNode] = curColor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nextNode : graph[curNode]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isBipartite(nextNode, <span class="number">1</span> - curColor, colors, graph)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2:"></a>Solution2:</h3><ol>
<li>BFS Solution:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="comment">// 0(not meet), 1(black), 2(white)</span></span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[i].length != <span class="number">0</span> &amp;&amp; visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                q.offer(i);</span><br><span class="line">                <span class="keyword">while</span>(! q.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> current = q.poll();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> c: graph[current]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (visited[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                            visited[c] = (visited[current] == <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">                            q.offer(c);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (visited[c] == visited[current]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;                        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = graph.length;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(i);</span><br><span class="line">        colors[i] = <span class="number">1</span>;   <span class="comment">// Blue: 1; Red: -1.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (colors[next] == <span class="number">0</span>) &#123;          <span class="comment">// If this node hasn't been colored;</span></span><br><span class="line">                    colors[next] = -colors[cur];  <span class="comment">// Color it with a different color;</span></span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colors[next] != -colors[cur]) &#123;   <span class="comment">// If it is colored and its color is different, return false;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。</p>
<h2 id="🌕Unsolved-721-Accounts-Merge"><a href="#🌕Unsolved-721-Accounts-Merge" class="headerlink" title="🌕Unsolved 721. Accounts Merge"></a><a href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener">🌕Unsolved 721. Accounts Merge</a></h2><p><a href="https://leetcode.com/problems/accounts-merge/discuss/109158/Java-Solution-(Build-graph-%2B-DFS-search)" target="_blank" rel="noopener">https://leetcode.com/problems/accounts-merge/discuss/109158/Java-Solution-(Build-graph-%2B-DFS-search)</a></p>
<p><a href="https://leetcode.com/problems/accounts-merge/discuss/109157/JavaC%2B%2B-Union-Find" target="_blank" rel="noopener">https://leetcode.com/problems/accounts-merge/discuss/109157/JavaC%2B%2B-Union-Find</a></p>
<h2 id="🌕128-Longest-Consecutive-Sequence✨"><a href="#🌕128-Longest-Consecutive-Sequence✨" class="headerlink" title="🌕128. Longest Consecutive Sequence✨"></a><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">🌕128. Longest Consecutive Sequence✨</a></h2><h3 id="Solution0"><a href="#Solution0" class="headerlink" title="Solution0:"></a>Solution0:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n^3) S O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">arrayContains</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentNum = num;</span><br><span class="line">            <span class="keyword">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (arrayContains(nums, currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                currentNum += <span class="number">1</span>;</span><br><span class="line">                currentStreak += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longestStreak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Solution1-10"><a href="#Solution1-10" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T O(n) S O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">        set.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.remove(num)) &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> l = num - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = num + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(set.remove(l--)) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(set.remove(r++)) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Minimize-Hamming-Distance-After-Swap-Operations🎃"><a href="#Minimize-Hamming-Distance-After-Swap-Operations🎃" class="headerlink" title="Minimize Hamming Distance After Swap Operations🎃"></a>Minimize Hamming Distance After Swap Operations🎃</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: source = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], target = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>], allowedSwaps = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: source can be transformed the following way:</span><br><span class="line">- Swap indices <span class="number">0</span> and <span class="number">1</span>: source = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">- Swap indices <span class="number">2</span> and <span class="number">3</span>: source = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">The Hamming distance of source and target is <span class="number">1</span> as they differ in <span class="number">1</span> position: index <span class="number">3</span>.</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>[] id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumHammingDistance</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] target, <span class="keyword">int</span>[][] allowedSwaps)</span> </span>&#123;</span><br><span class="line">    n = target.length;</span><br><span class="line">    id = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] a : allowedSwaps) &#123;</span><br><span class="line">        union(a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        map.putIfAbsent(getRoot(i), <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;());</span><br><span class="line">        map.get(getRoot(i)).put(source[i], map.get(getRoot(i)).getOrDefault(map.get(getRoot(i)).get(source[i])));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans= <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.get(getRoot(i)).contains(target[i])) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = getRoot(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = getRoot(q);</span><br><span class="line">    id[rootQ] = rootP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRoot(p) == getRoot(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRoot</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i != id[i]) &#123;</span><br><span class="line">        i = id[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="🌕Unsolved-684-Redundant-Connection✨"><a href="#🌕Unsolved-684-Redundant-Connection✨" class="headerlink" title="🌕Unsolved 684. Redundant Connection✨"></a><a href="https://leetcode.com/problems/redundant-connection/description/" target="_blank" rel="noopener">🌕Unsolved 684. Redundant Connection✨</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">Output: [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Explanation: The given undirected graph will be like <span class="keyword">this</span>:</span><br><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span> - <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>题目描述：有一系列的边连成的图，找出一条边，移除它之后该图能够成为一棵树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="keyword">int</span> N = edges.length;</span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[<span class="number">0</span>], v = e[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (uf.connect(u, v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        uf.union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    UF(<span class="keyword">int</span> N) &#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> uID = find(u);</span><br><span class="line">        <span class="keyword">int</span> vID = find(v);</span><br><span class="line">        <span class="keyword">if</span> (uID == vID) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == uID) &#123;</span><br><span class="line">                id[i] = vID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(u) == find(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Unsolved-685-Redundant-Connection-II"><a href="#🌕Unsolved-685-Redundant-Connection-II" class="headerlink" title="🌕Unsolved 685. Redundant Connection II"></a><a href="https://leetcode.com/problems/redundant-connection-ii/description/" target="_blank" rel="noopener">🌕Unsolved 685. Redundant Connection II</a></h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Graph-Algorithms-One-Place-Dijkstra-Bellman-Ford-Floyd-Warshall-Prims-Kruskals-DSU"><a href="#Graph-Algorithms-One-Place-Dijkstra-Bellman-Ford-Floyd-Warshall-Prims-Kruskals-DSU" class="headerlink" title="Graph Algorithms One Place | Dijkstra | Bellman Ford | Floyd Warshall | Prims | Kruskals | DSU"></a><a href="https://leetcode.com/discuss/general-discussion/969327/graph-algorithms-one-place-dijkstra-bellman-ford-floyd-warshall-prims-kruskals-dsu" target="_blank" rel="noopener">Graph Algorithms One Place | Dijkstra | Bellman Ford | Floyd Warshall | Prims | Kruskals | DSU</a></h2><h1 id="Data-Structures-for-Coding-Interviews-in-Java"><a href="#Data-Structures-for-Coding-Interviews-in-Java" class="headerlink" title="Data Structures for Coding Interviews in Java"></a><a href="https://www.educative.io/courses/data-structures-coding-interviews-java/gxQ283421q9" target="_blank" rel="noopener">Data Structures for Coding Interviews in Java</a></h1><blockquote>
<p>A graph is a set of <strong>vertices</strong> (nodes) that are connected to each other via <strong>edges</strong> in the form of a network.</p>
<p>The structures for storing data in a graph, represented in the form of <em>Nodes</em> (1,3,7…), are also called <strong>Vertices</strong></p>
<p>A <strong>pair(x,y)</strong> is called an <strong>edge</strong>, which indicates that vertex <strong>x</strong> is connected to vertex <strong>y</strong>. An edge may contain weight/cost, showing how much cost is required to traverse from vertex <strong>x</strong> to <strong>y</strong>.</p>
</blockquote>
<h2 id="There-are-two-common-types-of-graphs"><a href="#There-are-two-common-types-of-graphs" class="headerlink" title="There are two common types of graphs:"></a>There are two common types of graphs:</h2><ol>
<li>Undirected</li>
<li>Directed</li>
</ol>
<p><strong>Degree of Vertex</strong>: Total Number of edges connected to a vertex.</p>
<p>The <strong>adjacency matrix</strong> is a two-dimensional matrix where each cell can contain a <strong>0</strong> or <strong>1</strong>. The row and column headings represent the vertices.</p>
<p>If a cell contains <strong>1</strong>, there exists an edge between the corresponding vertices, e.g., Matrix[0][1]=1<em>M<strong>a</strong>t<strong>r</strong>i**x</em>[0][1]=1 shows that an edge exists between vertex <strong>0</strong> and <strong>1</strong>.</p>
<h2 id="Implement-a-Directed-Graph-in-java-using-an-Adjacency-List"><a href="#Implement-a-Directed-Graph-in-java-using-an-Adjacency-List" class="headerlink" title="Implement a Directed Graph in java using an Adjacency List"></a>Implement a <strong>Directed Graph</strong> in java using an Adjacency List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> vertices;</span><br><span class="line">    <span class="keyword">public</span> DoublyLinkedList&lt;Integer&gt; adjacencyList[];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> vertices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertices = vertices;</span><br><span class="line">        <span class="keyword">this</span>.adjacencyList = <span class="keyword">new</span> DoublyLinkedList[vertices];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">            adjacencyList[i] = <span class="keyword">new</span> DoublyLinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source &lt; vertices &amp;&amp; destination &lt; vertices) &#123;</span><br><span class="line">            <span class="keyword">this</span>.adjacencyList[source].insertEnd(destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;Adjacency List of Directed Graph&lt;&lt;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(adjacencyList[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">"|"</span> + i + <span class="string">"| =&gt; "</span>);</span><br><span class="line"></span><br><span class="line">                DoublyLinkedList&lt;Integer&gt;.Node temp = adjacencyList[i].getHeadNode();</span><br><span class="line">                <span class="keyword">while</span> (temp != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print(<span class="string">"["</span> + temp.data + <span class="string">"] -&gt; "</span>);</span><br><span class="line">                    temp = temp.nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"|"</span> + i + <span class="string">"| =&gt; "</span>+ <span class="string">"null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"><strong>Operation</strong></th>
<th align="center"><strong>Adjacency List</strong></th>
<th align="center"><strong>Adjacency Matrix</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Add Vertex</td>
<td align="center">O(1)</td>
<td align="center">O(V^2)</td>
</tr>
<tr>
<td align="center">Remove Vertex</td>
<td align="center">O(V+E)</td>
<td align="center">O(V^2)</td>
</tr>
<tr>
<td align="center">Add Edge</td>
<td align="center">O(1)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">Remove Edge</td>
<td align="center">O(E)</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong><em>A Bipartite Graph</em></strong> is a special kind of Graph, in which the vertices can be divided into two disjoint sets <em>U</em> and <em>V</em> such that no vertex of <em>U</em> is adjacent to any other vertex in <em>U</em> and no vertex of <em>V</em> is adjacent to any other vertex in <em>V</em>. Vertices in <em>U</em> have edges that connect it to vertices in <em>V</em>.</p>
</blockquote>
<h2 id="Types-of-bipartite-graphs"><a href="#Types-of-bipartite-graphs" class="headerlink" title="Types of bipartite graphs"></a>Types of bipartite graphs</h2><p>Some other types of Bipartite graphs are listed below:</p>
<ul>
<li><strong>Complete Bipartite Graphs:</strong> A complete Bipartite graph connects each vertex from set V1 to each vertex from set V2.</li>
<li><strong>Star Graphs:</strong> A star graph is a complete bipartite graph if a single vertex belongs to one set, and all the remaining vertices belong to the other set.</li>
<li><strong>Acyclic Graphs:</strong> A graph with no cycles is called an acyclic graph.</li>
</ul>
<h2 id="Challenge1-Breadth-First-Search-or-BFS-for-a-Graph"><a href="#Challenge1-Breadth-First-Search-or-BFS-for-a-Graph" class="headerlink" title="Challenge1: Breadth First Search or BFS for a Graph"></a>Challenge1: Breadth First Search or BFS for a Graph</h2><h3 id="Solution1-11"><a href="#Solution1-11" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>The <code>bfs()</code> function is a wrapper for the <code>bfsVisit()</code> function which actually performs the traversal on one <code>source</code> vertex at a time and outputs all vertices reachable from the <code>source</code>. The reason for using the wrapper function is to make sure we traverse all vertices even when they are not reachable from any other vertex in the graph.</p>
<p>In the <code>bfs()</code> function, we insert the vertices into the queue, starting from the <code>source</code> vertex. To keep track of the nodes that have been traversed, every node inserted into the queue is marked visited in the <code>visited</code> array.</p>
<p>The <code>result</code> string is our output variable. The value of a node is appended to <code>result</code> when it is dequeued from the queue. For each node that is dequeued, its adjacent nodes are added to the queue if they have not been visited.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckBFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bfs</span><span class="params">(Graph g)</span></span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//Checking if the graph has no vertices</span></span><br><span class="line">        <span class="keyword">if</span> (g.vertices &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertices; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//Checking whether the node is visited or not </span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) </span><br><span class="line">            &#123; </span><br><span class="line">                result = result + bfsVisit(g, i, visited); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bfsVisit</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//Create Queue for Breadth First Traversal and enqueue source in it</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;(g.vertices);</span><br><span class="line">        queue.enqueue(source);</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while queue is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current_node = queue.dequeue();</span><br><span class="line">            result += String.valueOf(current_node);</span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array, and if they are not already visited then enqueue them in the Queue</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    queue.enqueue(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>; <span class="comment">//Visit the current Node</span></span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"Graph1:"</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"BFS traversal of Graph1 : "</span> + bfs(g));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"Graph2:"</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"BFS traversal of Graph2 : "</span> + bfs(g2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-6"><a href="#Solution2-6" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to print BFS traversal from a given source vertex.</span></span><br><span class="line"><span class="comment">// BFS(int s) traverses vertices reachable from s.</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This class represents a directed graph using adjacency list</span></span><br><span class="line"><span class="comment">// representation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// No. of vertices</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">//Adjacency Lists</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    Graph(<span class="keyword">int</span> v)</span><br><span class="line">    &#123;</span><br><span class="line">        V = v;</span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i)</span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function to add an edge into the graph</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prints BFS traversal from a given source s</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Mark all the vertices as not visited(By default</span></span><br><span class="line">        <span class="comment">// set as false)</span></span><br><span class="line">        <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a queue for BFS</span></span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mark the current node as visited and enqueue it</span></span><br><span class="line">        visited[s] = <span class="keyword">true</span>;</span><br><span class="line">        queue.add(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Dequeue a vertex from queue and print it</span></span><br><span class="line">            s = queue.poll();</span><br><span class="line">            System.out.print(s+<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get all adjacent vertices of the dequeued vertex s If a adjacent has not been visited, then mark it visited and enqueue it</span></span><br><span class="line">            Iterator&lt;Integer&gt; i = adj[s].listIterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> n = i.next();</span><br><span class="line">                <span class="keyword">if</span> (!visited[n])</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[n] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method to</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Following is Breadth First Traversal "</span>+</span><br><span class="line">                           <span class="string">"(starting from vertex 2)"</span>);</span><br><span class="line"></span><br><span class="line">        g.BFS(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Challenge2-Iterative-Depth-First-Traversal-of-Graph"><a href="#🌕Challenge2-Iterative-Depth-First-Traversal-of-Graph" class="headerlink" title="🌕Challenge2: Iterative Depth First Traversal of Graph"></a>🌕Challenge2: Iterative Depth First Traversal of Graph</h2><h3 id="Solution1-12"><a href="#Solution1-12" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckDFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dfs</span><span class="params">(Graph g)</span></span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//Checking if the graph has no vertices</span></span><br><span class="line">        <span class="keyword">if</span> (g.vertices &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertices; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//Checking whether the node is visited or not </span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) </span><br><span class="line">            &#123; </span><br><span class="line">                result = result + dfsVisit(g, i, visited); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dfsVisit</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//Create Stack(Implemented in previous lesson) for Depth First Traversal and Push source in it</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;(g.vertices);</span><br><span class="line">        stack.push(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current_node = stack.pop();</span><br><span class="line">            result += String.valueOf(current_node);</span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array, and if they are not already visited then push them in the stack</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] !=<span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    stack.push(temp.data);</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Visit the node</span></span><br><span class="line">            visited[current_node] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"Graph1:"</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"DFS traversal of Graph1 : "</span> + dfs(g));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"Graph2:"</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"DFS traversal of Graph2 : "</span> + dfs(g2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-7"><a href="#Solution2-7" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//An Iterative Java program to do DFS traversal from</span></span><br><span class="line"><span class="comment">//a given source vertex. DFS(int s) traverses vertices</span></span><br><span class="line"><span class="comment">//reachable from s.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GFG</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// This class represents a directed graph using adjacency</span></span><br><span class="line">    <span class="comment">// list representation</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V; <span class="comment">//Number of Vertices</span></span><br><span class="line">        LinkedList&lt;Integer&gt;[] adj; <span class="comment">// adjacency lists</span></span><br><span class="line">        <span class="comment">//Constructor</span></span><br><span class="line">        Graph(<span class="keyword">int</span> V)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.V = V;</span><br><span class="line">            adj = <span class="keyword">new</span> LinkedList[V];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++)</span><br><span class="line">                adj[i] = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//To add an edge to graph</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            adj[v].add(w); <span class="comment">// Add w to v’s list.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prints all not yet visited vertices reachable from s</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// Initially mark all vertices as not visited</span></span><br><span class="line">            Vector&lt;Boolean&gt; visited = <span class="keyword">new</span> Vector&lt;Boolean&gt;(V);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">                visited.add(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a stack for DFS</span></span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            stack.push(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(stack.empty() == <span class="keyword">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s = stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">// Stack may contain same vertex twice. So we need to print the popped item only if it is not visited.</span></span><br><span class="line">                <span class="keyword">if</span>(visited.get(s) == <span class="keyword">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">                    visited.set(s, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Get all adjacent vertices of the popped vertex s If a adjacent has not been visited, then push it to the stack.</span></span><br><span class="line">                Iterator&lt;Integer&gt; itr = adj[s].iterator();</span><br><span class="line">                <span class="keyword">while</span> (itr.hasNext()) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> v = itr.next();</span><br><span class="line">                    <span class="keyword">if</span>(!visited.get(v))</span><br><span class="line">                        stack.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver program to test methods of graph class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Total 5 vertices in graph</span></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Following is the Depth First Traversal"</span>);</span><br><span class="line">        g.DFS(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="⭐Challenge3-Detect-Cycle-in-a-Directed-Graph-Cycle-in-Graph-AE"><a href="#⭐Challenge3-Detect-Cycle-in-a-Directed-Graph-Cycle-in-Graph-AE" class="headerlink" title="⭐Challenge3: Detect Cycle in a Directed Graph || Cycle in Graph(AE)"></a>⭐Challenge3: Detect Cycle in a Directed Graph || Cycle in Graph(AE)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cycleInGraph</span><span class="params">(<span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write your code here.</span></span><br><span class="line">    <span class="keyword">int</span> n = edges.length;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    buildGraph(graph, edges);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">boolean</span>[] stackFlag = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCyclic(i, graph, visited, stackFlag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCyclic</span><span class="params">(<span class="keyword">int</span> node, Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">boolean</span>[] visited, <span class="keyword">boolean</span>[] stackFlag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stackFlag[node]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[node]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    stackFlag[node] = <span class="keyword">true</span>;</span><br><span class="line">    visited[node] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.get(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCyclic(neighbor, graph, visited, stackFlag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stackFlag[node] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] e = edges[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : e) &#123;</span><br><span class="line">            graph.get(i).add(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution1-13"><a href="#Solution1-13" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>The solution might look confusing at first, but the logic behind it is pretty straight forward.</li>
<li>We start by using two boolean arrays, <code>visited</code> and <code>stackFlag</code>. <code>visited</code> keeps a record of all the nodes that have been traversed regardless of the recursive call. <code>stackFlag</code> keeps track of the nodes that have been traversed in the current recursion.</li>
<li>Then we apply a variation of <code>DFS</code> on each node of the graph in a recursive manner. On each call of the method <code>cyclic</code> if we encounter any node which is already in the stack, then we return <code>true</code>. Because this means that we have found a path from that node back to itself!</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckCycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">detectCycle</span><span class="params">(Graph g)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span> [num_of_vertices];</span><br><span class="line">        <span class="comment">//Holds a flag if the node is currently in Stack or not (by default- false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] stackFlag = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_of_vertices; i++)&#123;</span><br><span class="line">            <span class="comment">//Check cyclic on each node</span></span><br><span class="line">            <span class="keyword">if</span> (cyclic(g, i, visited, stackFlag))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cyclic</span><span class="params">(Graph g, <span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited, <span class="keyword">boolean</span>[] stackFlag)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case, if node is currently in stack that means we have found a cycle</span></span><br><span class="line">        <span class="keyword">if</span> (stackFlag[v])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//if it is already visited (and not in Stack) then there is no cycle</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line">        stackFlag[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check adjacency list of the node</span></span><br><span class="line">        DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.adjacencyList[v] != <span class="keyword">null</span>)</span><br><span class="line">            temp = g.adjacencyList[v].headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//run cyclic function recursively on each outgowing path</span></span><br><span class="line">            <span class="keyword">if</span> (cyclic(g, temp.data, visited, stackFlag))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//backtracking, undo the stackFlag for other dfs path</span></span><br><span class="line">        stackFlag[v] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Graph g1 = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g1.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g1.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g1.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g1.addEdge(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">        g1.printGraph();</span><br><span class="line">        System.out.println(detectCycle(g1));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(detectCycle(g2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-Detect-Cycle-in-a-Directed-Graph-using-BFS"><a href="#Solution2-Detect-Cycle-in-a-Directed-Graph-using-BFS" class="headerlink" title="Solution2: Detect Cycle in a Directed Graph using BFS"></a>Solution2: Detect Cycle in a Directed Graph using BFS</h3><p><a href="https://www.geeksforgeeks.org/detect-cycle-in-a-directed-graph-using-bfs/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/detect-cycle-in-a-directed-graph-using-bfs/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to check if there is a cycle in directed graph using BFS.</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFG</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// Class to represent a graph</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V; <span class="comment">// No. of vertices</span></span><br><span class="line">        <span class="comment">//adjacency list</span></span><br><span class="line">        Vector&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Graph(<span class="keyword">int</span> V)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Constructor</span></span><br><span class="line">            <span class="keyword">this</span>.V = V;</span><br><span class="line">            <span class="keyword">this</span>.adj = <span class="keyword">new</span> Vector[V];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">                adj[i] = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// function to add an edge to graph</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            adj[u].add(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This function returns true if there is a cycle in directed graph, else returns false.</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isCycle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a vector to store indegrees of all vertices. Initialize all indegrees as 0.</span></span><br><span class="line">            <span class="keyword">int</span>[] in_degree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.V];</span><br><span class="line">            Arrays.fill(in_degree, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Traverse adjacency lists to fill indegrees of vertices. This step takes O(V+E) time</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v : adj[u])</span><br><span class="line">                    in_degree[v]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create an queue and enqueue all vertices with indegree 0</span></span><br><span class="line">            Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">                <span class="keyword">if</span> (in_degree[i] == <span class="number">0</span>)</span><br><span class="line">                    q.add(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize count of visited vertices</span></span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a vector to store result (A topological ordering of the vertices)</span></span><br><span class="line">            Vector&lt;Integer&gt; top_order = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// One by one dequeue vertices from queue and enqueue adjacents if indegree of adjacent becomes 0</span></span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Extract front of queue (or perform dequeue) and add it to topological order</span></span><br><span class="line">                <span class="keyword">int</span> u = q.poll();</span><br><span class="line">                top_order.add(u);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Iterate through all its neighbouring nodes of dequeued node u and decrease their in-degree by 1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> itr : adj[u])</span><br><span class="line">                    <span class="keyword">if</span> (--in_degree[itr] == <span class="number">0</span>)</span><br><span class="line">                        q.add(itr);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if there was a cycle</span></span><br><span class="line">            <span class="keyword">if</span> (cnt != <span class="keyword">this</span>.V)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test Code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a graph given in the above diagram</span></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.isCycle())</span><br><span class="line">            System.out.println(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cycle-detection-in-an-undirected-graph"><a href="#Cycle-detection-in-an-undirected-graph" class="headerlink" title="Cycle detection in an undirected graph"></a>Cycle detection in an undirected graph</h3><ol>
<li>Run a DFS from every unvisited node.</li>
<li>If visited node, check if it is parent or not.</li>
</ol>
<p><a href="https://www.geeksforgeeks.org/detect-cycle-undirected-graph/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/detect-cycle-undirected-graph/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true if the graph contains a cycle, else false. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">isCyclic</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Mark all the vertices as not visited and not part of recursion stack </span></span><br><span class="line">    Boolean visited[] = <span class="keyword">new</span> Boolean[V]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">        visited[i] = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the recursive helper function to detect cycle in different DFS trees </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Don't recur for u if already visited </span></span><br><span class="line">        <span class="keyword">if</span> (!visited[u]) </span><br><span class="line">            <span class="keyword">if</span> (isCyclicUtil(u, visited, -<span class="number">1</span>)) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//DFS, recursive function that uses visited[] and parent to detect cycle in subgraph reachable from vertex v.</span></span><br><span class="line"><span class="function">Boolean <span class="title">isCyclicUtil</span><span class="params">(<span class="keyword">int</span> v, Boolean visited[], <span class="keyword">int</span> parent)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Mark the current node as visited </span></span><br><span class="line">    visited[v] = <span class="keyword">true</span>; </span><br><span class="line">    Integer i; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recur for all the vertices adjacent to this vertex </span></span><br><span class="line">    Iterator&lt;Integer&gt; it = adj[v].iterator(); </span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) </span><br><span class="line">    &#123; </span><br><span class="line">        i = it.next(); </span><br><span class="line">        <span class="comment">// If an adjacent is not visited, then recur for that adjacent </span></span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (isCyclicUtil(i, visited, v)) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If an adjacent is visited and not parent of current vertex, then there is a cycle. </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != parent) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Challenge4-Find-“Mother-Vertex”-in-a-Directed-Graph"><a href="#🌕Challenge4-Find-“Mother-Vertex”-in-a-Directed-Graph" class="headerlink" title="🌕Challenge4: Find “Mother Vertex” in a Directed Graph"></a>🌕Challenge4: Find “Mother Vertex” in a Directed Graph</h2><p>like find celebrity another version</p>
<h3 id="Mother-Vertex"><a href="#Mother-Vertex" class="headerlink" title="Mother Vertex?"></a>Mother Vertex?</h3><p>A mother vertex in a graph <code>G = (v,e)</code> is a vertex v, such that all other vertices in G can be reached by a path from v.</p>
<h3 id="Solution1-14"><a href="#Solution1-14" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckMotherVertex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMotherVertex</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// visited[] is used for DFS. Initially all are initialized as not visited</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line">        Arrays.fill(visited, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To store last finished vertex (or mother vertex)</span></span><br><span class="line">        <span class="keyword">int</span> lastV = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do a DFS traversal and find the last finished vertex</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertices; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                DFS(g, i, visited);</span><br><span class="line">                lastV = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there exist mother vertex (or vetices) in given</span></span><br><span class="line">        <span class="comment">// graph, then lastV must be one (or one of them)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now check if lastV is actually a mother vertex (or graph</span></span><br><span class="line">        <span class="comment">// has a mother vertex). We basically check if every vertex</span></span><br><span class="line">        <span class="comment">// is reachable from lastV or not.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset all values in visited[] as false and do</span></span><br><span class="line">        <span class="comment">// DFS beginning from lastV to check if all vertices are</span></span><br><span class="line">        <span class="comment">// reachable from it or not.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Double check lastV is a valid mother vertice</span></span><br><span class="line">        Arrays.fill(visited, <span class="keyword">false</span>);</span><br><span class="line">        DFS(g, lastV, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; visited.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A recursive function to print DFS starting from v</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph g, <span class="keyword">int</span> node, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        visited[node] = <span class="keyword">true</span>;</span><br><span class="line">        DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.adjacencyList[node] !=<span class="keyword">null</span>)</span><br><span class="line">            temp = g.adjacencyList[node].headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[temp.data]) &#123;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited[temp.data] = <span class="keyword">true</span>;</span><br><span class="line">                DFS(g, temp.data, visited);</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Mother Vertex is: "</span> + findMotherVertex(g));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-8"><a href="#Solution2-8" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to find a mother vertex in O(V+E) time </span></span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFG</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        adj.get(u).add(v); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// A recursive function to print DFS starting from v </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DFSUtil</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; g, <span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Mark the current node as visited and print it </span></span><br><span class="line">        visited[v] = <span class="keyword">true</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recur for all the vertices adjacent to this vertex </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : g.get(v)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (!visited[x]) </span><br><span class="line">            &#123; </span><br><span class="line">                DFSUtil(g, x, visited); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns a mother vertex if exists. Otherwise returns -1 </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">motherVertex</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt;g, <span class="keyword">int</span> V)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// visited[] is used for DFS. Initially all are initialized as not visited </span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// To store last finished vertex (or mother vertex) </span></span><br><span class="line">        <span class="keyword">int</span> mother = -<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) </span><br><span class="line">            &#123; </span><br><span class="line">                DFSUtil(g, i, visited); </span><br><span class="line">                mother = i; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there exist mother vertex (or vetices) in given graph, then v must be one (or one of them) Now check if v is actually a mother vertex (or graph has a mother vertex). </span></span><br><span class="line">        <span class="comment">// We basically check if every vertex is reachable from v or not. Reset all values in visited[] as false and do DFS beginning from v to check </span></span><br><span class="line">        <span class="comment">// if all vertices are reachable from it or not. </span></span><br><span class="line">        <span class="keyword">boolean</span>[] check = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; </span><br><span class="line">        DFSUtil(g, mother, check); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">boolean</span> val : check) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (!val) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> mother; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test code </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> V = <span class="number">7</span>; </span><br><span class="line">        <span class="keyword">int</span> E = <span class="number">8</span>; </span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            adj.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;()); </span><br><span class="line">        &#125; </span><br><span class="line">        addEdge(<span class="number">0</span>, <span class="number">1</span>,adj); </span><br><span class="line">        addEdge(<span class="number">0</span>, <span class="number">2</span>,adj); </span><br><span class="line">        addEdge(<span class="number">1</span>, <span class="number">3</span>,adj); </span><br><span class="line">        addEdge(<span class="number">4</span>, <span class="number">1</span>,adj); </span><br><span class="line">        addEdge(<span class="number">6</span>, <span class="number">4</span>,adj); </span><br><span class="line">        addEdge(<span class="number">5</span>, <span class="number">6</span>,adj); </span><br><span class="line">        addEdge(<span class="number">5</span>, <span class="number">2</span>,adj); </span><br><span class="line">        addEdge(<span class="number">6</span>, <span class="number">0</span>,adj); </span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"The mother vertex is "</span> + motherVertex(adj, V)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge5-Count-number-of-edges-in-an-undirected-graph"><a href="#Challenge5-Count-number-of-edges-in-an-undirected-graph" class="headerlink" title="Challenge5: Count number of edges in an undirected graph"></a>Challenge5: Count number of edges in an undirected graph</h2><p>Given an adjacency list representation undirected graph. Write a function to count the number of edges in the undirected graph.</p>
<p>Expected time complexity : O(V)</p>
<h3 id="Solution1-15"><a href="#Solution1-15" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckNumEdges</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numEdges</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// For undirected graph, just sum up the size of</span></span><br><span class="line">        <span class="comment">// all the adjacency lists for each vertex and then divide it by 2.</span></span><br><span class="line">        <span class="comment">// It will give us total number of edges in the graph.</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.vertices; i++) &#123;</span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[i] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[i].headNode;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">9</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">        g.addEdge(<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">        g.addEdge(<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line">        g.addEdge(<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">        g.addEdge(<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Number of edges: "</span> + numEdges(g));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">7</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        g2.addEdge(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        g2.addEdge(<span class="number">6</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Number of edges: "</span> + numEdges(g2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-9"><a href="#Solution2-9" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to count number of edge in undirected graph </span></span><br><span class="line"><span class="keyword">import</span> java.io.*; </span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Adjacency list representation of graph </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> V; </span><br><span class="line">    Vector&lt;Integer&gt;[] adj; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//@SuppressWarnings("unchecked") </span></span><br><span class="line">    Graph(<span class="keyword">int</span> V) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">this</span>.V = V; </span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> Vector[V]; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">            adj[i] = <span class="keyword">new</span> Vector&lt;Integer&gt;(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// add edge to graph </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        adj[u].add(v); </span><br><span class="line">        adj[v].add(u); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns count of edge in undirected graph </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countEdges</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// traverse all vertex </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line"></span><br><span class="line">            <span class="comment">// add all edge that are linked to the current vertex </span></span><br><span class="line">            sum += adj[i].size(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// The count of edge is always even because in undirected graph every edge is connected twice between two vertices </span></span><br><span class="line">        <span class="keyword">return</span> sum / <span class="number">2</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFG</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// Test Code </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> V = <span class="number">9</span>; </span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(V); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// making above uhown graph </span></span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">7</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">7</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">8</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">5</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">5</span>); </span><br><span class="line">        g.addEdge(<span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line">        g.addEdge(<span class="number">5</span>, <span class="number">6</span>); </span><br><span class="line">        g.addEdge(<span class="number">6</span>, <span class="number">7</span>); </span><br><span class="line">        g.addEdge(<span class="number">6</span>, <span class="number">8</span>); </span><br><span class="line">        g.addEdge(<span class="number">7</span>, <span class="number">8</span>); </span><br><span class="line"></span><br><span class="line">        System.out.println(g.countEdges()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge6-Find-if-there-is-a-path-between-two-vertices-in-a-directed-graph"><a href="#Challenge6-Find-if-there-is-a-path-between-two-vertices-in-a-directed-graph" class="headerlink" title="Challenge6:  Find if there is a path between two vertices in a directed graph"></a>Challenge6:  Find if there is a path between two vertices in a directed graph</h2><h3 id="Solution1-16"><a href="#Solution1-16" class="headerlink" title="Solution1:"></a>Solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckPaths</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkPath</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (source == destination)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(g.vertices);</span><br><span class="line">        stack.push(source);</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while stack is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//Pop a vertex/node from stack</span></span><br><span class="line">            <span class="keyword">int</span> current_node = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array,</span></span><br><span class="line">            <span class="comment">//and if only push unvisited adjacent vertices into stack</span></span><br><span class="line">            <span class="comment">//Before pushing into stack, check if it's the destination.</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (temp.data == destination) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g1 = <span class="keyword">new</span> Graph(<span class="number">9</span>);</span><br><span class="line">        g1.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g1.addEdge(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        g1.addEdge(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        g1.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        g1.addEdge(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">        g1.addEdge(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        g1.addEdge(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">        g1.addEdge(<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">        g1.addEdge(<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line">        g1.addEdge(<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">        g1.addEdge(<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">        g1.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Path exists: "</span> + checkPath(g1, <span class="number">0</span>, <span class="number">7</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"Path exists: "</span> + checkPath(g2, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-10"><a href="#Solution2-10" class="headerlink" title="Solution2:"></a>Solution2:</h3><p><a href="https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-a-given-graph/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-a-given-graph/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to check if there is exist a path between two vertices of a graph. </span></span><br><span class="line"><span class="keyword">import</span> java.io.*; </span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList; </span><br><span class="line"></span><br><span class="line"><span class="comment">// This class represents a directed graph using adjacency list representation </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// No. of vertices </span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">//Adjacency List </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Constructor </span></span><br><span class="line">    Graph(<span class="keyword">int</span> v) </span><br><span class="line">    &#123; </span><br><span class="line">        V = v; </span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[v]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) </span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//Function to add an edge into the graph </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123; adj[v].add(w); &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//prints BFS traversal from a given source s </span></span><br><span class="line">    <span class="function">Boolean <span class="title">isReachable</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        LinkedList&lt;Integer&gt; temp; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mark all the vertices as not visited(By default set </span></span><br><span class="line">        <span class="comment">// as false) </span></span><br><span class="line">        <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a queue for BFS </span></span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(); </span><br><span class="line">        visited[s] = <span class="keyword">true</span>; </span><br><span class="line">        queue.add(s); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 'i' will be used to get all adjacent vertices of a vertex </span></span><br><span class="line">        Iterator&lt;Integer&gt; i; </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// Dequeue a vertex from queue and print it </span></span><br><span class="line">            s = queue.poll(); </span><br><span class="line">            <span class="keyword">int</span> n; </span><br><span class="line">            i = adj[s].listIterator(); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get all adjacent vertices of the dequeued vertex s If a adjacent has not been visited, then mark it visited and enqueue it </span></span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) </span><br><span class="line">            &#123; </span><br><span class="line">                n = i.next(); </span><br><span class="line"></span><br><span class="line">                <span class="comment">// If this adjacent node is the destination node, </span></span><br><span class="line">                <span class="comment">// then return true </span></span><br><span class="line">                <span class="keyword">if</span> (n == d) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// Else, continue to do BFS </span></span><br><span class="line">                <span class="keyword">if</span> (!visited[n]) </span><br><span class="line">                &#123; </span><br><span class="line">                    visited[n] = <span class="keyword">true</span>; </span><br><span class="line">                    queue.add(n); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// If BFS is complete without visited d </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test code </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Create a graph given in the above diagram </span></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">4</span>); </span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">        g.addEdge(<span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">0</span>); </span><br><span class="line">        g.addEdge(<span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>, <span class="number">3</span>); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">3</span>; </span><br><span class="line">        <span class="keyword">if</span> (g.isReachable(u, v)) </span><br><span class="line">            System.out.println(<span class="string">"There is a path from "</span> + u +<span class="string">" to "</span> + v); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"There is no path from "</span> + u +<span class="string">" to "</span> + v);; </span><br><span class="line"></span><br><span class="line">        u = <span class="number">3</span>; </span><br><span class="line">        v = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (g.isReachable(u, v)) </span><br><span class="line">            System.out.println(<span class="string">"There is a path from "</span> + u +<span class="string">" to "</span> + v); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"There is no path from "</span> + u +<span class="string">" to "</span> + v);; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph"><a href="#Find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph" class="headerlink" title="Find if there is a path between two vertices in an undirected graph"></a>Find if there is a path between two vertices in an undirected graph</h3><p><a href="https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ program to check if there is exist a path between</span></span><br><span class="line"><span class="comment">// two vertices of an undirected graph.</span></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This class represents an undirected graph using adjacency list representation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> V; <span class="comment">// No. of vertices</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pointer to an array containing adjacency lists</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; adj; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Graph(<span class="keyword">int</span> V); <span class="comment">// Constructor</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// function to add an edge to graph</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>; </span><br><span class="line">	<span class="function">bool <span class="title">isReachable</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Graph::Graph(<span class="keyword">int</span> V)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">	adj = <span class="keyword">new</span> list&lt;<span class="keyword">int</span>&gt;[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Graph::addEdge(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">	adj[v].push_back(w);</span><br><span class="line">	adj[w].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A BFS based function to check whether d is reachable from s.</span></span><br><span class="line">bool Graph::isReachable(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Base case</span></span><br><span class="line">	<span class="keyword">if</span> (s == d)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark all the vertices as not visited</span></span><br><span class="line">	bool* visited = <span class="keyword">new</span> bool[V];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">		visited[i] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a queue for BFS</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; queue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark the current node as visited and enqueue it</span></span><br><span class="line">	visited[s] = <span class="keyword">true</span>;</span><br><span class="line">	queue.push_back(s);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// it will be used to get all adjacent vertices of a vertex</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!queue.empty()) &#123;</span><br><span class="line">		<span class="comment">// Dequeue a vertex from queue and print it</span></span><br><span class="line">		s = queue.front();</span><br><span class="line">		queue.pop_front();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get all adjacent vertices of the dequeued vertex s</span></span><br><span class="line">		<span class="comment">// If a adjacent has not been visited, then mark it</span></span><br><span class="line">		<span class="comment">// visited and enqueue it</span></span><br><span class="line">		<span class="keyword">for</span> (i = adj[s].begin(); i != adj[s].end(); ++i) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// If this adjacent node is the destination node, </span></span><br><span class="line">			<span class="comment">// then return true</span></span><br><span class="line">			<span class="keyword">if</span> (*i == d)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Else, continue to do BFS</span></span><br><span class="line">			<span class="keyword">if</span> (!visited[*i]) &#123;</span><br><span class="line">				visited[*i] = <span class="keyword">true</span>;</span><br><span class="line">				queue.push_back(*i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If BFS is complete without visiting d</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver program to test methods of graph class</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Create a graph given in the above diagram</span></span><br><span class="line">	<span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">1</span>, v = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (g.isReachable(u, v))</span><br><span class="line">		cout &lt;&lt; <span class="string">"\n There is a path from "</span> &lt;&lt; u &lt;&lt; <span class="string">" to "</span> &lt;&lt; v;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">"\n There is no path from "</span> &lt;&lt; u &lt;&lt; <span class="string">" to "</span> &lt;&lt; v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕⭐Challenge7-Check-if-a-Directed-graph-is-Tree-or-not"><a href="#🌕⭐Challenge7-Check-if-a-Directed-graph-is-Tree-or-not" class="headerlink" title="🌕⭐Challenge7: Check if a Directed graph is Tree or not"></a>🌕⭐Challenge7: Check if a Directed graph is Tree or not</h2><h3 id="Unsolved-261-Graph-Valid-Tree⭐"><a href="#Unsolved-261-Graph-Valid-Tree⭐" class="headerlink" title="Unsolved 261. Graph Valid Tree⭐"></a><a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="noopener">Unsolved 261. Graph Valid Tree⭐</a></h3><p>“Given <em><code>n</code></em> nodes labeled from <em><code>0</code></em> to <em><code>n-1</code></em> and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.” </p>
<p><a href="https://leetcode.com/problems/graph-valid-tree/discuss/69018/AC-Java-Union-Find-solution" target="_blank" rel="noopener">https://leetcode.com/problems/graph-valid-tree/discuss/69018/AC-Java-Union-Find-solution</a></p>
<h3 id="Solution0-1"><a href="#Solution0-1" class="headerlink" title="Solution0:"></a>Solution0:</h3><ol>
<li><p>Using Cycle Detection</p>
</li>
<li><p>To check whether a directed graph is a tree or not, we’ll check the following :</p>
<ol>
<li>Each node (except root) has exactly one parent</li>
<li>There is no cycle in the graph.</li>
<li>The graph is connected.</li>
</ol>
</li>
<li><p>We check the first condition in <code>checkOneParent</code> method by traversing the adjacency list of the graph. If the first condition is not satisfied, we return <code>false</code> and don’t check further.</p>
<p>For a directed graph, We can use DFS to detect the next two conditions.</p>
<p>To check for cycles, we use the same <code>detectCycle</code> function that was used in <a href="https://www.educative.io/collection/page/5642554087309312/5724822843686912/5748660113506304/" target="_blank" rel="noopener">challenge <strong>3</strong></a>. If we come across any vertex that has already been visited then there is a cycle. If we do not find such an adjacent for any vertex, we say that there is no cycle.</p>
<p>Then we check for connectivity in the <code>checkConnected</code> method and traverse all the vertices on the graph to check if they have been visited from the source. If we find any vertex that is not visited, we conclude that vertex is not reachable from the source. Therefore, the graph is not connected and hence, is not a tree.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTree</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. Check for Cycle</span></span><br><span class="line">        <span class="keyword">if</span> (detectCycle(g))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. Check each node other than root has exactly one parent.</span></span><br><span class="line">        <span class="keyword">if</span> (!checkOneParent(g))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. Check for connectivity</span></span><br><span class="line">        <span class="keyword">if</span> (!checkConnected(g, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. DFS check for Cycle</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">detectCycle</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line">        <span class="comment">//Holds a flag if the node is currently in Stack or not (by default- false)</span></span><br><span class="line">        <span class="keyword">boolean</span>[] stackFlag = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_of_vertices; i++) &#123;</span><br><span class="line">            <span class="comment">//Check cyclic on each node</span></span><br><span class="line">            <span class="keyword">if</span> (cyclic(g, i, visited, stackFlag)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cyclic</span><span class="params">(Graph g, <span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited, <span class="keyword">boolean</span>[] stackFlag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if node is currently in stack that means we have found a cycle</span></span><br><span class="line">        <span class="keyword">if</span> (stackFlag[v])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if it is already visited (and not in Stack) then there is no cycle</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line">        stackFlag[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check adjacency list of the node</span></span><br><span class="line">        DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.adjacencyList[v] != <span class="keyword">null</span>)</span><br><span class="line">            temp = g.adjacencyList[v].headNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//run cyclic function recursively on each outgowing path</span></span><br><span class="line">            <span class="keyword">if</span> (cyclic(g, temp.data, visited, stackFlag)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        stackFlag[v] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. Check each node other than root has exactly one parent.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkOneParent</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line">        <span class="keyword">boolean</span>[] hasOneParent = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//traverse adjacency list and mark the nodes which have a parent</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_of_vertices; i++) &#123;</span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node tmp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tmp = g.adjacencyList[i].headNode;</span><br><span class="line">                <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hasOneParent[tmp.data]) <span class="comment">//if a node has more than one parent</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;            <span class="comment">//then return false</span></span><br><span class="line">                    hasOneParent[tmp.data] = <span class="keyword">true</span>;</span><br><span class="line">                    tmp = tmp.nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//double check the root and not children node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_of_vertices; i++) &#123;</span><br><span class="line">            <span class="comment">//System.out.print(hasOneParent[i]);</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; hasOneParent[i] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// root should not have parent</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; hasOneParent[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="comment">//will be false if the node had no parent.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. Check for connectivity</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkConnected</span><span class="params">(Graph g, <span class="keyword">int</span> source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line">        <span class="keyword">int</span> vertices_reached = <span class="number">0</span>; <span class="comment">//Store vertices reachable through source</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="comment">//Make a node visited whenever you push it into stack</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create Stack(Implemented in previous section) for Depth First Traversal and Push source in it</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(num_of_vertices);</span><br><span class="line"></span><br><span class="line">        stack.push(source);</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while stack is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Pop a vertex/node from stack</span></span><br><span class="line">            <span class="keyword">int</span> current_node = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array,</span></span><br><span class="line">            <span class="comment">//and push unvisited vertices in stack and also increment vertices_reached</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    stack.push(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>;</span><br><span class="line">                    vertices_reached++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//+1 for source, and if number of vertices reachable from source are equal</span></span><br><span class="line">        <span class="comment">//to the total number of vertices in graph then return true else false.</span></span><br><span class="line">        <span class="keyword">return</span> (vertices_reached + <span class="number">1</span>) == g.vertices;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g));</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g2));</span><br><span class="line"></span><br><span class="line">        Graph g3 = <span class="keyword">new</span> Graph(<span class="number">6</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g3.addEdge(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        g3.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-1-Using-BFS-Traversal"><a href="#Solution-1-Using-BFS-Traversal" class="headerlink" title="Solution 1: Using BFS Traversal"></a>Solution 1: Using BFS Traversal</h3><ol>
<li>We maintain a count of the visited nodes in the variable <code>numberOfVisited</code>. During traversal, if an already visited vertex is encountered, we return <code>false</code> as it means that the graph fails the <strong>tree</strong> conditions. In fact, this condition also encompasses the <strong>check cyclic</strong> condition and <strong>check one parent</strong> condition from the solution given above. Hence, it removes redundancy. Finally, when the <strong>BFS</strong> loop ends, we check the <code>numberOfVisited</code> variable to see if all vertices were visited. This condition takes care of the <strong>graph is connected</strong> check that we performed previously. If the condition fails, <code>false</code> is returned. Otherwise, the function <code>isTree</code> returns <code>true</code>.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTree</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="comment">//Make a node visited whenever you enqueue it into queue</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create Queue for Breadth First Traversal and enqueue root in it</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;(g.vertices);</span><br><span class="line">        queue.enqueue(root);</span><br><span class="line">        visited[root] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Store the number of visited nodes to check at end if all are visited</span></span><br><span class="line">        <span class="keyword">int</span> numberOfVisited = <span class="number">1</span>; <span class="comment">//root is already visited</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while queue is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current_node = queue.dequeue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array,</span></span><br><span class="line">            <span class="comment">//and if they are not already visited then enqueue them in the Queue</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    queue.enqueue(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>; <span class="comment">//Visit the current Node</span></span><br><span class="line">                    numberOfVisited++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//If all vertices are visited then return true</span></span><br><span class="line">        <span class="keyword">if</span> (numberOfVisited == g.vertices)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g));</span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g2.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g2.addEdge(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">        g2.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g2));</span><br><span class="line"></span><br><span class="line">        Graph g3 = <span class="keyword">new</span> Graph(<span class="number">6</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g3.addEdge(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        g3.addEdge(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        g3.printGraph();</span><br><span class="line">        System.out.println(<span class="string">"isTree : "</span> + isTree(g3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution2-11"><a href="#Solution2-11" class="headerlink" title="Solution2:"></a>Solution2:</h3><p><a href="https://codereview.stackexchange.com/questions/120165/check-directed-graph-is-tree-or-not" target="_blank" rel="noopener">https://codereview.stackexchange.com/questions/120165/check-directed-graph-is-tree-or-not</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTree</span><span class="params">(<span class="keyword">int</span>[][] adjMat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numVertex = adjMat.length;</span><br><span class="line">    State[] isVisited = <span class="keyword">new</span> State[numVertex];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;</span><br><span class="line">        isVisited[i] = State.UNVISITED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use BFS</span></span><br><span class="line">    Queue q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(<span class="number">0</span>);</span><br><span class="line">    isVisited[<span class="number">0</span>] = State.VISITING;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = (<span class="keyword">int</span>) q.poll();</span><br><span class="line">        <span class="keyword">if</span> (isVisited[current] == State.VISITED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isVisited[current] = State.VISITING;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adjMat[current][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isVisited[current] = State.VISITED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isVisited[i] == State.UNVISITED)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    UNVISITED, VISITING, VISITED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Check if a given undirected graph is tree or not</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Java Program to check whether a graph is tree or not </span></span><br><span class="line"><span class="keyword">import</span> java.io.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="comment">// This class represents a directed graph using adjacency list representation </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// No. of vertices </span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">//Adjacency List </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor </span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) </span><br><span class="line">    Graph(<span class="keyword">int</span> v) </span><br><span class="line">    &#123; </span><br><span class="line">        V = v; </span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[V]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) </span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function to add an edge into the graph </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        adj[v].add(w); </span><br><span class="line">        adj[w].add(v); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// A recursive function that uses visited[] and parent to detect cycle in subgraph reachable from vertex v. </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCyclicUtil</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">boolean</span> visited[], <span class="keyword">int</span> parent)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Mark the current node as visited </span></span><br><span class="line">        visited[v] = <span class="keyword">true</span>; </span><br><span class="line">        Integer i; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recur for all the vertices adjacent to this vertex </span></span><br><span class="line">        Iterator&lt;Integer&gt; it = adj[v].iterator(); </span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) </span><br><span class="line">        &#123; </span><br><span class="line">            i = it.next(); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// If an adjacent is not visited, then recur for </span></span><br><span class="line">            <span class="comment">// that adjacent </span></span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (isCyclicUtil(i, visited, v)) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// If an adjacent is visited and not parent of </span></span><br><span class="line">            <span class="comment">// current vertex, then there is a cycle. </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i != parent) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true if the graph is a tree, else false. </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTree</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Mark all the vertices as not visited and not part </span></span><br><span class="line">        <span class="comment">// of recursion stack </span></span><br><span class="line">        <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">            visited[i] = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// The call to isCyclicUtil serves multiple purposes </span></span><br><span class="line">        <span class="comment">// It returns true if graph reachable from vertex 0 </span></span><br><span class="line">        <span class="comment">// is cyclcic. It also marks all vertices reachable </span></span><br><span class="line">        <span class="comment">// from 0. </span></span><br><span class="line">        <span class="keyword">if</span> (isCyclicUtil(<span class="number">0</span>, visited, -<span class="number">1</span>)) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find a vertex which is not reachable from 0 </span></span><br><span class="line">        <span class="comment">// (not marked by isCyclicUtil(), then we return false </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) </span><br><span class="line">            <span class="keyword">if</span> (!visited[u]) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test code </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// Create a graph given in the above diagram </span></span><br><span class="line">        Graph g1 = <span class="keyword">new</span> Graph(<span class="number">5</span>); </span><br><span class="line">        g1.addEdge(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">        g1.addEdge(<span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">        g1.addEdge(<span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line">        g1.addEdge(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">        <span class="keyword">if</span> (g1.isTree()) </span><br><span class="line">            System.out.println(<span class="string">"Graph is Tree"</span>); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Graph is not Tree"</span>); </span><br><span class="line"></span><br><span class="line">        Graph g2 = <span class="keyword">new</span> Graph(<span class="number">5</span>); </span><br><span class="line">        g2.addEdge(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">        g2.addEdge(<span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">        g2.addEdge(<span class="number">2</span>, <span class="number">1</span>); </span><br><span class="line">        g2.addEdge(<span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line">        g2.addEdge(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g2.isTree()) </span><br><span class="line">            System.out.println(<span class="string">"Graph is Tree"</span>); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Graph is not Tree"</span>); </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🌕Challenge-8-Find-Length-of-Shortest-Path-between-Two-Vertices"><a href="#🌕Challenge-8-Find-Length-of-Shortest-Path-between-Two-Vertices" class="headerlink" title="🌕Challenge 8: Find Length of Shortest Path between Two Vertices"></a>🌕Challenge 8: Find Length of Shortest Path between Two Vertices</h2><h3 id="Solution1-17"><a href="#Solution1-17" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li><p>BFS Queue</p>
</li>
<li><p>Once again, Breadth First Search comes to the rescue. The <code>visited</code> list must be familiar to you by now. The crux of this algorithm, however, lies in the <code>distance</code> list. For each node, the indexed value in the <code>distance</code> shows the node’s distance from the <code>source</code> in terms of the number of edges.</p>
<p>The rest is a simple BFS traversal, where the <code>distance</code> is incremented by 1 each time.</p>
<p>We are guaranteed to find the shortest distance to <code>destination</code>, once it has already been visited through the longer path and consequently marked because it won’t be visited the same way again.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckMin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source == destination)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num_of_vertices = g.vertices;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean Array to hold the history of visited nodes (by default-false)</span></span><br><span class="line">        <span class="comment">//Make a node visited whenever you enqueue it into queue</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//For keeping track of distance of current_node from source</span></span><br><span class="line">        <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[num_of_vertices];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create Queue for Breadth First Traversal and enqueue source in it</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;Integer&gt;(num_of_vertices);</span><br><span class="line"></span><br><span class="line">        queue.enqueue(source);</span><br><span class="line">        distance[source] = <span class="number">0</span>;</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Traverse while queue is not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current_node = queue.dequeue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get adjacent vertices to the current_node from the array,</span></span><br><span class="line">            <span class="comment">//and if they are not already visited then enqueue them in the Queue</span></span><br><span class="line">            <span class="comment">//and also update their distance from source by adding 1 in current_nodes's distance</span></span><br><span class="line">            DoublyLinkedList&lt;Integer&gt;.Node temp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.adjacencyList[current_node] != <span class="keyword">null</span>)</span><br><span class="line">                temp = g.adjacencyList[current_node].headNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[temp.data]) &#123;</span><br><span class="line">                    queue.enqueue(temp.data);</span><br><span class="line">                    visited[temp.data] = <span class="keyword">true</span>;</span><br><span class="line">                    distance[temp.data] = distance[current_node] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.data == destination) &#123;</span><br><span class="line">                    <span class="keyword">return</span> distance[destination];</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Graph g=<span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">3</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">4</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(findMin(g, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Challenge-9-Remove-Edge-from-a-Directed-Graph"><a href="#Challenge-9-Remove-Edge-from-a-Directed-Graph" class="headerlink" title="Challenge 9: Remove Edge from a Directed Graph"></a>Challenge 9: Remove Edge from a Directed Graph</h2><h3 id="Solution1-18"><a href="#Solution1-18" class="headerlink" title="Solution1:"></a>Solution1:</h3><ol>
<li>This is a fairly simple challenge. Since our vertices are stored in the <code>adjacencyList</code>, we access the linked list at <code>source</code> index. Then we call the <code>deleteByValue</code> function and pass the value of <code>destination</code> vertex.</li>
<li>O(E)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveEdgeSolution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(Graph g, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        g.adjacencyList[source].deleteByValue(destination);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Graph g = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">3</span>); </span><br><span class="line">        g.addEdge(<span class="number">3</span>,<span class="number">4</span>); </span><br><span class="line">        g.addEdge(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Before:"</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line"></span><br><span class="line">        removeEdge(g, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"After:"</span>);</span><br><span class="line">        g.printGraph();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AlgoTogether"><a href="#AlgoTogether" class="headerlink" title="AlgoTogether"></a>AlgoTogether</h1><h2 id="Problems-Required"><a href="#Problems-Required" class="headerlink" title="Problems (Required)"></a>Problems (Required)</h2><ol>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=4657dca274&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=a3bc7942d1&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=7d721a5def&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=8e656496df&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/pacific-atlantic-water-flow/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=f619dc7a12&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-ii/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=af9df8fef6&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/reconstruct-itinerary/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=1a339efa75&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/shortest-path-in-binary-matrix/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=d6489d091c&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/sliding-puzzle/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=4577b2098f&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/snakes-and-ladders/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=77c3194d5c&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/surrounded-regions/</a></li>
</ol>
<h2 id="Problems-Options"><a href="#Problems-Options" class="headerlink" title="Problems (Options)"></a>Problems (Options)</h2><ol>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=75f57ca10c&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/cat-and-mouse/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=22fcaca910&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/clone-graph/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=45fe4f3478&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game-iv/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=e54e525e1e&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/</a></li>
<li><a href="https://techcareer.us18.list-manage.com/track/click?u=a7af3978c0ebeaff2b102af2f&id=b20bb72cb8&e=adc0b12ae9" target="_blank" rel="noopener">https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/</a></li>
</ol>
<h1 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Given an array of n distinct elements. Find the minimum number of swaps required to sort the array in strictly increasing order.</span><br><span class="line"> </span><br><span class="line"> Problem: n different ele, targte -&gt; minimum number of swaps to make it strictly increasing order.</span><br><span class="line">   </span><br><span class="line"> nums &#x3D; &#123;2, 8, 5, 4&#125;</span><br><span class="line">Output: 1</span><br><span class="line"> &#123;2, 8, 5, 4&#125;</span><br><span class="line"></span><br><span class="line">  2-0</span><br><span class="line">  8-1</span><br><span class="line">  5-2</span><br><span class="line">  4-3</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">&#123;2, 8, 5, 4, 9&#125;</span><br><span class="line"></span><br><span class="line">2,4,5,8,9</span><br><span class="line">   ^   ^  ^</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   ^     </span><br><span class="line">Timecomplexity: O(nlogn)</span><br><span class="line">   </span><br><span class="line">Usually way: sorting algo</span><br><span class="line"></span><br><span class="line">sort array....</span><br><span class="line">  compare this sorted array with current array.........</span><br><span class="line">  </span><br><span class="line">class FindTheMinimumSwaoNum &#123;</span><br><span class="line">  public int findTheNumsOfSwaps(int[] array) &#123;</span><br><span class="line">    &#x2F;&#x2F;create a copy of this array -- unsorted</span><br><span class="line">    &#x2F;&#x2F; sort that copied array --- sorted</span><br><span class="line">    &#x2F;&#x2F;start loop till size of array</span><br><span class="line">    &#x2F;&#x2F;compare sorted array element with unsarted array element</span><br><span class="line">    &#x2F;&#x2F;check for equality -&gt; swap thm</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;minimum-number-swaps-required-sort-array&#x2F;</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;clone-graph&#x2F;</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;must-coding-questions-company-wise&#x2F;#amazon</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;practice.geeksforgeeks.org&#x2F;explore&#x2F;?company%5B%5D&#x3D;Amazon&amp;problemType&#x3D;functional&amp;page&#x3D;1&amp;sortBy&#x3D;submissions&amp;company%5B%5D&#x3D;Amazon</span><br><span class="line">  </span><br><span class="line">  https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;amazon-interview-preparation&#x2F;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dejavu"
      src="/images/v2-f8df7dc974a522b119a385a0fc09311e_xll.jpg">
  <p class="site-author-name" itemprop="name">Dejavu</p>
  <div class="site-description" itemprop="description">Stay gold</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">87</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Dejavu-19" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Dejavu-19" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/liu.kunling19@gmail.com" title="E-Mail → liu.kunling19@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dejavu</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false});</script></body>
</html>
